"use strict";(self.webpackChunkavrtt_blog=self.webpackChunkavrtt_blog||[]).push([[8858],{7631:function(e,t,a){a.r(t),a.d(t,{Head:function(){return z},PostTemplate:function(){return H},default:function(){return C}});var n=a(54506),i=a(28453),r=a(96540),l=a(16886),s=(a(46295),a(96098));function o(e){const t=Object.assign({p:"p",h3:"h3",a:"a",span:"span",ul:"ul",li:"li",strong:"strong",h2:"h2",ol:"ol",h4:"h4"},(0,i.RP)(),e.components),{Image:a}=t;return a||function(e,t){throw new Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Image",!0),r.createElement(r.Fragment,null,"\n",r.createElement("br"),"\n","\n","\n",r.createElement(t.p,null,"Contrastive learning has emerged as one of the most compelling paradigms in self-supervised learning, particularly in the context of computer vision. The motivation behind contrastive learning is to learn representations from unlabeled data by contrasting positive pairs — different views or augmentations of the same example — with negative pairs — different examples altogether. As we progress through this article, I will dive into the foundational ideas behind contrastive learning, its implementation details, its unique advantages, and then conclude with a discussion of extensions and future directions. My goal is to guide you through these concepts in such a way that you gain both theoretical understanding and practical insights."),"\n",r.createElement(t.h3,{id:"defining-self-supervised-learning-ssl-and-its-motivation",style:{position:"relative"}},r.createElement(t.a,{href:"#defining-self-supervised-learning-ssl-and-its-motivation","aria-label":"defining self supervised learning ssl and its motivation permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Defining self-supervised learning (ssl) and its motivation"),"\n",r.createElement(t.p,null,"In traditional supervised learning, we rely heavily on labeled data. We collect images (or other data modalities), then we have human (or automated) annotators provide labels, and finally, we train models to classify or predict the labels for new examples. This approach has been extraordinarily successful — especially in computer vision tasks such as image recognition and object detection — but it also has significant limitations in terms of cost, scalability, and domain adaptation. Humans must produce large, high-quality annotated datasets, which can be time-consuming and expensive."),"\n",r.createElement(t.p,null,'Self-supervised learning (SSL), on the other hand, attempts to leverage massive amounts of unlabeled data by creating tasks (so-called pretext tasks) that allow the model to discover informative features automatically. Contrastive learning is one powerful approach within SSL; it sets up a problem where the model must determine which data samples (or "views") should be close to each other in the representation space versus which should be far apart. This encourages the learning of a representation that captures the high-level semantics of the data, without requiring explicit labels.'),"\n",r.createElement(t.p,null,"Why is this important? Consider an application such as autonomous driving. Thousands (or millions) of hours of driving footage can be collected without any labeled information. By using self-supervised methods, we can pretrain models on this abundant unlabeled data, extracting generalizable features. Later, with relatively few labels, we can fine-tune the representation for a specific task like pedestrian detection. This flexibility is a major driver behind the surge of interest in self-supervised and contrastive methods."),"\n",r.createElement(t.h3,{id:"the-difference-between-supervised-and-self-supervised-unsupervised-learning",style:{position:"relative"}},r.createElement(t.a,{href:"#the-difference-between-supervised-and-self-supervised-unsupervised-learning","aria-label":"the difference between supervised and self supervised unsupervised learning permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"The difference between supervised and self-supervised (unsupervised) learning"),"\n",r.createElement(t.p,null,"To set the stage properly:"),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,"\n",r.createElement(t.p,null,r.createElement(t.strong,null,"Supervised learning:")," We have a labeled dataset ",r.createElement(s.A,{text:"\\(\\(x_i, y_i\\)\\)"}),", and we train a function ",r.createElement(s.A,{text:"\\(f\\)"})," to map input ",r.createElement(s.A,{text:"\\(x_i\\)"})," to the label ",r.createElement(s.A,{text:"\\(y_i\\)"}),". The objective is typically to minimize some loss function (e.g., cross-entropy for classification)."),"\n"),"\n",r.createElement(t.li,null,"\n",r.createElement(t.p,null,r.createElement(t.strong,null,"Self-supervised (unsupervised) learning:")," We have only unlabeled data ",r.createElement(s.A,{text:"\\(\\(x_i\\)\\)"}),", and we construct an auxiliary learning objective — often by forming pairs, corruption tasks, or other forms of pseudo-labels. Through this objective, the model learns representations that capture meaningful information in the data. In contrastive approaches, for example, an instance ",r.createElement(s.A,{text:"\\(x_i\\)"})," is augmented to produce different views, and the model is trained to produce high similarity (or closeness) for those augmented views relative to views from other instances."),"\n"),"\n"),"\n",r.createElement(t.p,null,'Contrastive self-supervised approaches are sometimes considered a subset of unsupervised learning, because we do not rely on external labels. However, the term "self-supervised" is used to highlight that we impose a supervision-like signal from the data itself, such as pairing augmented samples.'),"\n",r.createElement(t.h3,{id:"importance-of-leveraging-unlabeled-data-in-computer-vision",style:{position:"relative"}},r.createElement(t.a,{href:"#importance-of-leveraging-unlabeled-data-in-computer-vision","aria-label":"importance of leveraging unlabeled data in computer vision permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Importance of leveraging unlabeled data in computer vision"),"\n",r.createElement(t.p,null,"Vision tasks are particularly well suited to self-supervised learning because large-scale unlabeled image datasets are easy to collect (e.g., from the web, from cameras, from user-generated data). Models that learn from these huge data repositories tend to generalize better, and pretraining on unlabeled data can reduce the need for huge labeled sets. This is especially crucial in scenarios like medical imaging, autonomous driving, and industrial monitoring, where labeled data can be scarce or time-consuming to acquire."),"\n",r.createElement(t.p,null,"Consider the example of an autonomous vehicle with cameras on all sides. It captures a continuous video stream during each driving session. If you were to label every frame for every new scene or environment, you would quickly face staggering annotation costs. But with a self-supervised method, you can pretrain a network on all these unlabeled frames, shaping robust visual representations. Then, if you need a specialized detection model (say, for pedestrians or traffic signs), you can label a small set of frames and fine-tune the network for that specific detection task, leveraging the representation learned from the broader unlabeled pool."),"\n",r.createElement(t.h3,{id:"high-level-overview-of-contrastive-learning",style:{position:"relative"}},r.createElement(t.a,{href:"#high-level-overview-of-contrastive-learning","aria-label":"high level overview of contrastive learning permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"High-level overview of contrastive learning"),"\n",r.createElement(t.p,null,'At the heart of contrastive learning lies a simple principle: we want to "pull together" different views of the same instance in representation space, while "pushing apart" views of different instances. If you think of each image as a point in a high-dimensional space, we effectively want the features for the same instance to be close together, and the features for distinct instances to be farther apart.'),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Positive pairs:")," Two data augmentations of the same input (image)."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Negative pairs:")," Any data augmentation derived from a different input."),"\n"),"\n",r.createElement(t.p,null,"This idea dates back to early methods like Siamese networks, but modern contrastive learning approaches scale to massive datasets, often with specialized strategies to handle negative pairs and memory constraints. In the next sections, I will elaborate on these strategies, culminating in an in-depth discussion of SimCLR, one of the most influential contrastive learning frameworks."),"\n",r.createElement(t.h2,{id:"core-concepts-of-contrastive-learning",style:{position:"relative"}},r.createElement(t.a,{href:"#core-concepts-of-contrastive-learning","aria-label":"core concepts of contrastive learning permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Core concepts of contrastive learning"),"\n",r.createElement(t.p,null,"To dive deeper, let's examine the main building blocks. We will look at the notion of positive and negative pairs, the popular InfoNCE loss function, the difference between memory bank approaches and large-batch approaches, as well as a brief survey of methods that have propelled contrastive learning research forward."),"\n",r.createElement(t.h3,{id:"the-role-of-positive-pairs-and-negative-pairs",style:{position:"relative"}},r.createElement(t.a,{href:"#the-role-of-positive-pairs-and-negative-pairs","aria-label":"the role of positive pairs and negative pairs permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"The role of positive pairs and negative pairs"),"\n",r.createElement(t.p,null,'In contrastive learning, each sample in a batch (or in a memory bank) is typically augmented twice (or multiple times, depending on the variant). These augmented "views" of the same sample form the ',r.createElement(t.strong,null,"positive pair"),". By augmenting the original sample in different ways (e.g., random cropping, color distortion), the model is encouraged to learn features that are invariant to these perturbations, focusing on semantically relevant aspects of the image."),"\n",r.createElement(t.p,null,"Simultaneously, all other samples in the batch (or from the memory bank) form ",r.createElement(t.strong,null,"negative pairs")," with the current sample. By forcing the representation of the current sample to differ from those of all other samples, the network learns class-separability (or instance-separability) without explicitly being given class labels."),"\n",r.createElement(t.h3,{id:"infonce-loss-and-key-contrastive-objectives",style:{position:"relative"}},r.createElement(t.a,{href:"#infonce-loss-and-key-contrastive-objectives","aria-label":"infonce loss and key contrastive objectives permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"InfoNCE loss and key contrastive objectives"),"\n",r.createElement(t.p,null,"A common choice for the contrastive loss function is the ",r.createElement(t.strong,null,"InfoNCE"),' loss (short for "Info Noise Contrastive Estimation"). In essence, InfoNCE tries to maximize the similarity between a query vector ',r.createElement(s.A,{text:"\\(q\\)"})," (an encoded augmented sample) and a positive key ",r.createElement(s.A,{text:"\\(k^+\\)"})," (the encoded augmented view of the same sample), while minimizing the similarity between ",r.createElement(s.A,{text:"\\(q\\)"})," and a set of negative keys ",r.createElement(s.A,{text:"\\(k^-\\)"})," (encoded views of other samples)."),"\n",r.createElement(t.p,null,"Let ",r.createElement(s.A,{text:"\\(q_i\\)"})," and ",r.createElement(s.A,{text:"\\(k_i^+\\)"})," be the query and positive key for sample ",r.createElement(s.A,{text:"\\(i\\)"}),". Let ",r.createElement(s.A,{text:"\\(k_{j}^-\\)"})," for ",r.createElement(s.A,{text:"\\(j \\in \\{1, \\ldots, K\\}\\)"})," be the negative keys for other samples. The InfoNCE loss is typically expressed as:"),"\n",r.createElement(s.A,{text:"\\[\nL_{\\text{InfoNCE}} = -\\frac{1}{N}\\sum_{i=1}^N \\log \\frac{\\exp(\\text{sim}(q_i, k_i^+)/\\tau)}{\\exp(\\text{sim}(q_i, k_i^+)/\\tau) + \\sum_{j=1}^K \\exp(\\text{sim}(q_i, k_j^-)/\\tau)}\n\\]"}),"\n",r.createElement(t.p,null,"Here:"),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,r.createElement(s.A,{text:"\\(N\\)"})," is the number of samples in a mini-batch (or the number of queries)."),"\n",r.createElement(t.li,null,r.createElement(s.A,{text:"\\(q_i\\)"})," is the representation (query) of sample ",r.createElement(s.A,{text:"\\(i\\)"})," after passing it through the encoder network and possibly a projection head."),"\n",r.createElement(t.li,null,r.createElement(s.A,{text:"\\(k_i^+\\)"})," is the positive key for ",r.createElement(s.A,{text:"\\(i\\)"}),"."),"\n",r.createElement(t.li,null,r.createElement(s.A,{text:"\\(k_j^-\\)"})," represents negative keys for other samples."),"\n",r.createElement(t.li,null,r.createElement(s.A,{text:"\\(\\text{sim}(\\cdot, \\cdot)\\)"})," is often cosine similarity, i.e. ",r.createElement(s.A,{text:"\\(\\text{sim}(a, b) = \\frac{a \\cdot b}{\\|a\\|\\|b\\|}\\)"}),"."),"\n",r.createElement(t.li,null,r.createElement(s.A,{text:"\\(\\tau\\)"})," is a temperature parameter that scales the similarity. It sharpens or flattens the distribution over positives and negatives, thereby controlling how strongly the model focuses on pulling positives together vs. pushing away negatives."),"\n"),"\n",r.createElement(t.p,null,"Intuitively, this loss is minimized when the model learns to make ",r.createElement(s.A,{text:"(\\text{sim}(q_i, k_i^+))"})," large (pulling positives together) and ",r.createElement(s.A,{text:"(\\text{sim}(q_i, k_j^-))"})," small (pushing negatives away)."),"\n",r.createElement(t.h3,{id:"memory-bank-vs-large-batch-strategies-for-retrieving-negative-samples",style:{position:"relative"}},r.createElement(t.a,{href:"#memory-bank-vs-large-batch-strategies-for-retrieving-negative-samples","aria-label":"memory bank vs large batch strategies for retrieving negative samples permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Memory bank vs. large-batch strategies for retrieving negative samples"),"\n",r.createElement(t.p,null,"One of the practical hurdles for contrastive learning is efficiently gathering a large set of negative examples. The InfoNCE loss often requires many negative pairs in each optimization step to provide enough discriminative power. Two broad strategies address this requirement:"),"\n",r.createElement(t.ol,null,"\n",r.createElement(t.li,null,"\n",r.createElement(t.p,null,r.createElement(t.strong,null,"Memory Bank:")," Methods like InstDisc (Wu and gang, 2018) and MoCo (He and gang, 2020) use a memory bank or queue that stores the representations (keys) of a large number of samples from previous mini-batches. Instead of requiring a huge batch size, they maintain a queue of keys that is continuously updated. This mechanism provides the model with a rich pool of negatives while still using modest batch sizes for the queries."),"\n"),"\n",r.createElement(t.li,null,"\n",r.createElement(t.p,null,r.createElement(t.strong,null,"Large-Batch Training:")," SimCLR (Chen and gang, 2020) and related approaches rely on large or distributed training. They directly compute a large batch of queries and keys at each iteration, so that all other samples in the batch serve as negatives. For example, if you have a batch size of 4096, you get thousands of negative examples for each query. However, this is memory-intensive and typically requires specialized hardware setups (e.g., multi-GPU clusters)."),"\n"),"\n"),"\n",r.createElement(t.h3,{id:"brief-survey-of-methods-instdisc-moco-pirl-byol-barlow-twins",style:{position:"relative"}},r.createElement(t.a,{href:"#brief-survey-of-methods-instdisc-moco-pirl-byol-barlow-twins","aria-label":"brief survey of methods instdisc moco pirl byol barlow twins permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Brief survey of methods: InstDisc, MoCo, PIRL, BYOL, barlow twins"),"\n",r.createElement(t.p,null,"Contrastive learning has spawned a variety of methods, each building on the core concept in unique ways:"),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"InstDisc")," (Wu and gang, 2018): An early work that introduced a memory bank for instance discrimination. It showed that instance-level pretext tasks can learn powerful features."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"MoCo")," (He and gang, 2020): Builds a dynamic dictionary (momentum encoder) to maintain consistent keys in a queue. It keeps a moving average of encoder parameters so that the key encoder does not deviate too quickly, stabilizing the negative samples in the queue."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"PIRL")," (Misra & Maaten, 2020): Uses a pretext task of predicting the transformation that has been applied to images. It also uses contrastive learning to ensure that differently transformed images remain close in feature space."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"BYOL"),' (Grill and gang, 2020): Remarkably, it eliminates the explicit need for negative pairs by using a "target network" updated by an exponential moving average of the "online network". BYOL\'s success challenged the assumption that negative examples are necessary for contrastive self-supervision, prompting new lines of investigation.'),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Barlow Twins")," (Zbontar and gang, 2021): A method that aims to reduce redundancy between different feature components and also does not explicitly rely on negative pairs. It tries to equate cross-correlation between augmented views to the identity matrix."),"\n"),"\n",r.createElement(t.p,null,"These variants, while distinct in their design choices, share a broad set of motivations and often incorporate ideas about data augmentation, robust representation learning, and large-scale training to achieve impressive performance on downstream tasks."),"\n",r.createElement(t.h2,{id:"data-augmentation-in-contrastive-learning",style:{position:"relative"}},r.createElement(t.a,{href:"#data-augmentation-in-contrastive-learning","aria-label":"data augmentation in contrastive learning permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Data augmentation in contrastive learning"),"\n",r.createElement(t.p,null,"Data augmentation is crucial for contrastive learning because the method relies heavily on creating distinct views of each input. If the augmentations are too trivial (e.g., simply resizing the image without changing it otherwise), the network might learn superficial shortcuts (such as color histograms) rather than meaningful high-level features. If augmentations are too strong, the network might lose essential information. Striking the right balance is essential."),"\n",r.createElement(t.h3,{id:"why-data-augmentations-are-crucial",style:{position:"relative"}},r.createElement(t.a,{href:"#why-data-augmentations-are-crucial","aria-label":"why data augmentations are crucial permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Why data augmentations are crucial"),"\n",r.createElement(t.p,null,"In standard supervised learning, we also use data augmentation (random crops, flips, etc.) to mitigate overfitting and encourage invariances. However, in contrastive learning, augmentation is central to the definition of positive pairs. Two augmented views of the same image become the anchor-positive pair that the network must pull together. Without sufficiently diverse or challenging augmentations, the model might collapse to trivial solutions, or it might fail to learn robust representations."),"\n",r.createElement(t.p,null,"For instance, if I only do a small random crop on the same image, the two views might still be nearly identical. The network could exploit tiny details — like a particular smudge or corner — to identify them as the same image. Such a solution wouldn't generalize well to new images. By using more intense transformations (random color jitter, random grayscale, random Gaussian blur, etc.), the network is forced to learn invariances to these changes."),"\n",r.createElement(t.h3,{id:"common-transformations",style:{position:"relative"}},r.createElement(t.a,{href:"#common-transformations","aria-label":"common transformations permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Common transformations"),"\n",r.createElement(t.p,null,"Common transformations used in contrastive learning for images include:"),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Random Resized Crop"),": Selecting a random portion of the image and resizing it back to the original input size. Forces the model to learn spatial invariance."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Color Jitter"),": Randomly perturbing brightness, contrast, saturation, and hue. Encourages color invariance, so the model cannot rely on color distribution alone."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Random Grayscale"),": Converting color images to grayscale with a certain probability, pushing the model to learn shape or texture cues over color cues."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Horizontal Flip"),": Flipping the image horizontally. Encourages left-right invariance in representations."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Gaussian Blur"),": Slightly blurring the image to reduce reliance on high-frequency details."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Solarization"),": In some methods (particularly in newer SSL approaches), you might find solarization to drastically alter pixel intensities in certain ranges."),"\n"),"\n",r.createElement(t.h3,{id:"the-interplay-of-strong-augmentations-with-robust-feature-learning",style:{position:"relative"}},r.createElement(t.a,{href:"#the-interplay-of-strong-augmentations-with-robust-feature-learning","aria-label":"the interplay of strong augmentations with robust feature learning permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"The interplay of strong augmentations with robust feature learning"),"\n",r.createElement(t.p,null,"Modern contrastive methods have discovered that strong augmentations are often beneficial, in part because they ensure that the network must learn higher-level invariances. However, one must be mindful not to destroy crucial semantic content. For example, in tasks where orientation is essential, random rotations might or might not be appropriate."),"\n",r.createElement(t.p,null,"An illustration of the common pipeline might look like this:"),"\n",r.createElement(a,{alt:"Contrastive data augmentation pipeline diagram",path:"",caption:"A schematic of random augmentations used for contrastive pairs, e.g., random resized crop, color jitter, random flip, blur, etc.",zoom:"false"}),"\n",r.createElement(t.p,null,"Each original image is transformed twice. These transformations define the positive pair for that image, in contrast with other images in the batch (or memory bank) that form negative samples."),"\n",r.createElement(t.h3,{id:"examples-and-best-practices",style:{position:"relative"}},r.createElement(t.a,{href:"#examples-and-best-practices","aria-label":"examples and best practices permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Examples and best practices"),"\n",r.createElement(t.p,null,"Researchers have found that an augmentation pipeline combining ",r.createElement(t.strong,null,"random resized crops"),", ",r.createElement(t.strong,null,"strong color jitter"),", and ",r.createElement(t.strong,null,"random grayscale")," is very effective. The key insight is that each transformation complements the others, ensuring the model must learn robust semantic features rather than simple pixel-level or color-based tricks. In typical frameworks like SimCLR, you will often see something along these lines in a PyTorch data augmentation code snippet. Here is a minimal example:"),"\n",r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">&lt;Code text={`\nimport torchvision.transforms as T\n\n# This is a typical set of augmentations for contrastive learning\ncontrastive_transforms = T.Compose([\n    T.RandomResizedCrop(224, scale=(0.08, 1.0)),\n    T.RandomHorizontalFlip(),\n    T.ColorJitter(brightness=0.4, contrast=0.4, \n                  saturation=0.4, hue=0.1),\n    T.RandomGrayscale(p=0.2),\n    T.GaussianBlur(kernel_size=3),\n    T.ToTensor()\n])\n\n# You can then create two augmented views for each sample in your dataset:\ndef get_contrastive_views(img):\n    view1 = contrastive_transforms(img)\n    view2 = contrastive_transforms(img)\n    return view1, view2\n`}/></code></pre></div>'}}),"\n",r.createElement(t.p,null,"These augmentations can be tuned or replaced by domain-specific transformations if, for instance, you are working with medical images or satellite imagery where certain flips or color changes might not make sense. In the standard ImageNet or CIFAR settings, these strong augmentations have been widely adopted, as recommended in works such as SimCLR (Chen and gang, 2020)."),"\n",r.createElement(t.h2,{id:"the-simclr-framework",style:{position:"relative"}},r.createElement(t.a,{href:"#the-simclr-framework","aria-label":"the simclr framework permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"The simclr framework"),"\n",r.createElement(t.p,null,"SimCLR, introduced by Chen and gang (2020), is a foundational method that demonstrated how contrastive learning at large scale could achieve impressive results on ImageNet and other tasks. SimCLR dispensed with memory banks, opting instead for massive batch sizes so that each sample in the batch could treat all others as negatives."),"\n",r.createElement(t.h3,{id:"key-architecture-components",style:{position:"relative"}},r.createElement(t.a,{href:"#key-architecture-components","aria-label":"key architecture components permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Key architecture components"),"\n",r.createElement(t.p,null,"SimCLR includes two main modules:"),"\n",r.createElement(t.ol,null,"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Base encoder network")," ",r.createElement(s.A,{text:"\\(f(\\cdot)\\)"}),": Often a ResNet (e.g., ResNet-50), which maps an image ",r.createElement(s.A,{text:"\\(x\\)"})," to a representation (often called ",r.createElement(s.A,{text:"\\(h\\)"}),"). That is, ",r.createElement(s.A,{text:"\\(h = f(x)\\)"}),"."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Projection head")," ",r.createElement(s.A,{text:"\\(g(\\cdot)\\)"}),": A small multi-layer perceptron (MLP) that projects ",r.createElement(s.A,{text:"\\(h\\)"})," to a latent space ",r.createElement(s.A,{text:"\\(z\\)"})," used in the contrastive loss. That is, ",r.createElement(s.A,{text:"\\(z = g(h)\\)"}),". Typically, ",r.createElement(s.A,{text:"\\(g\\)"})," is a two-layer MLP with a hidden dimension and a ReLU activation."),"\n"),"\n",r.createElement(t.h4,{id:"why-a-projection-head",style:{position:"relative"}},r.createElement(t.a,{href:"#why-a-projection-head","aria-label":"why a projection head permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Why a projection head?"),"\n",r.createElement(t.p,null,"Intuition and empirical experiments show that learning a separate projection space for the contrastive loss can improve the quality of ",r.createElement(s.A,{text:"\\(h\\)"})," itself. The idea is that the final layer of ",r.createElement(s.A,{text:"\\(f\\)"})," (the base encoder) can focus on learning semantic representations, while the projection head ",r.createElement(s.A,{text:"\\(g\\)"})," transforms that representation into a space optimized for the contrastive objective. When you do downstream tasks, you typically discard ",r.createElement(s.A,{text:"\\(g\\)"})," and only use ",r.createElement(s.A,{text:"\\(f\\)"}),"."),"\n",r.createElement(t.h3,{id:"infonce-with-large-batch-sizes-removing-the-need-for-a-memory-bank",style:{position:"relative"}},r.createElement(t.a,{href:"#infonce-with-large-batch-sizes-removing-the-need-for-a-memory-bank","aria-label":"infonce with large batch sizes removing the need for a memory bank permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"InfoNCE with large batch sizes (removing the need for a memory bank)"),"\n",r.createElement(t.p,null,"SimCLR's approach is straightforward: for a given mini-batch of size ",r.createElement(s.A,{text:"\\(N\\)"}),", you take each sample and augment it twice, resulting in ",r.createElement(s.A,{text:"\\(2N\\)"})," augmented samples in total. For each augmented sample, you consider the matching augmented view as the positive and the remaining ",r.createElement(s.A,{text:"\\(2N - 2\\)"})," samples as negatives. Hence, large ",r.createElement(s.A,{text:"\\(N\\)"})," is beneficial because it provides many negative examples. The corresponding InfoNCE loss is computed across these pairs:"),"\n",r.createElement(s.A,{text:"\\[\nL_{\\text{SimCLR}} = -\\frac{1}{2N}\\sum_{i=1}^{2N} \\log \\frac{\\exp(\\text{sim}(z_i, z_i^+)/\\tau)}\n{\\sum_{j=1}^{2N} \\mathbf{1}_{[j\\neq i]} \\exp(\\text{sim}(z_i, z_j)/\\tau)}\n\\]"}),"\n",r.createElement(t.p,null,"Where:"),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,r.createElement(s.A,{text:"\\(z_i\\)"})," is the projection head output for the ",r.createElement(s.A,{text:"\\(i\\)"}),"-th augmented sample."),"\n",r.createElement(t.li,null,r.createElement(s.A,{text:"\\(z_i^+\\)"})," is the corresponding positive sample (the other augmentation of the same original image)."),"\n",r.createElement(t.li,null,"The term ",r.createElement(s.A,{text:"\\(\\mathbf{1}_{[j\\neq i]}\\)"})," is an indicator function that ensures we exclude the term where ",r.createElement(s.A,{text:"\\(j = i\\)"}),"."),"\n"),"\n",r.createElement(t.p,null,"This large-batch approach means that at each step, we have a very large set of negatives. The major drawback, of course, is memory consumption. Training SimCLR on large-scale data typically requires powerful distributed GPU clusters or specialized hardware. Nonetheless, it remains straightforward to implement if you have the computational resources."),"\n",r.createElement(t.h3,{id:"importance-of-temperature-parameter--for-controlling-similarity-gradients",style:{position:"relative"}},r.createElement(t.a,{href:"#importance-of-temperature-parameter--for-controlling-similarity-gradients","aria-label":"importance of temperature parameter  for controlling similarity gradients permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Importance of temperature parameter (",r.createElement(s.A,{text:"\\(\\tau\\)"}),") for controlling similarity gradients"),"\n",r.createElement(t.p,null,"In the InfoNCE formulation, the similarity ",r.createElement(s.A,{text:"(\\text{sim}(z_i, z_j))"})," is often scaled by a temperature parameter ",r.createElement(s.A,{text:"\\(\\tau\\)"}),". This parameter controls how peaked or diffuse the distribution over positives and negatives becomes. A low ",r.createElement(s.A,{text:"\\(\\tau\\)"})," places more emphasis on the highest-similarity pairs, forcing stronger separation between positives and negatives. A higher ",r.createElement(s.A,{text:"\\(\\tau\\)"})," yields a smoother distribution. Empirical tuning of ",r.createElement(s.A,{text:"\\(\\tau\\)"})," can significantly affect performance."),"\n",r.createElement(t.h3,{id:"insights-from-simclr-v1-and-v2",style:{position:"relative"}},r.createElement(t.a,{href:"#insights-from-simclr-v1-and-v2","aria-label":"insights from simclr v1 and v2 permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Insights from simclr v1 and v2"),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,"\n",r.createElement(t.p,null,r.createElement(t.strong,null,"SimCLR v1 (Chen and gang, 2020)"),": Highlighted the importance of large batch sizes, strong augmentations, a projection head, and a well-chosen temperature parameter. Demonstrated that with enough compute, a self-supervised model can match or exceed fully supervised performance on ImageNet classification after fine-tuning."),"\n"),"\n",r.createElement(t.li,null,"\n",r.createElement(t.p,null,r.createElement(t.strong,null,"SimCLR v2 (Chen and gang, 2020)"),": Built upon v1 by introducing deeper and wider ResNets, more extensive data augmentations, and additional training stages. Showed improved performance across various datasets, emphasizing the benefits of scaling model size and training time in self-supervised frameworks."),"\n"),"\n"),"\n",r.createElement(t.p,null,"SimCLR's success opened doors to further research, including attempts to reduce the reliance on huge batch sizes (e.g., MoCo's memory bank approach), or even remove explicit negatives altogether (BYOL). Nonetheless, SimCLR remains a milestone in large-batch, augmentation-based contrastive learning."),"\n",r.createElement(t.h2,{id:"practical-implementation-details",style:{position:"relative"}},r.createElement(t.a,{href:"#practical-implementation-details","aria-label":"practical implementation details permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Practical implementation details"),"\n",r.createElement(t.p,null,"In this section, I will walk you through the main practical steps for implementing SimCLR (or a similar contrastive learning approach) on a standard dataset. While I will focus primarily on the conceptual aspects, the code snippets will be enough to get you started."),"\n",r.createElement(t.h3,{id:"setting-up-data-loaders-to-generate-two-augmented-views-per-image",style:{position:"relative"}},r.createElement(t.a,{href:"#setting-up-data-loaders-to-generate-two-augmented-views-per-image","aria-label":"setting up data loaders to generate two augmented views per image permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Setting up data loaders to generate two augmented views per image"),"\n",r.createElement(t.p,null,"A critical element is to produce two different augmented views for each image in a mini-batch. One common strategy is to create a custom PyTorch ",r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">Dataset</code>'}})," or ",r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">DataLoader</code>'}})," that, for each sample, applies the same augmentation pipeline twice. For example:"),"\n",r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">&lt;Code text={`\nfrom torch.utils.data import Dataset\n\nclass ContrastiveDataset(Dataset):\n    def __init__(self, base_dataset, transform):\n        self.base_dataset = base_dataset\n        self.transform = transform\n    \n    def __getitem__(self, idx):\n        img, _ = self.base_dataset[idx]  # ignoring the label if there\'s any\n        view1 = self.transform(img)\n        view2 = self.transform(img)\n        return view1, view2\n    \n    def __len__(self):\n        return len(self.base_dataset)\n`}\n/></code></pre></div>'}}),"\n",r.createElement(t.p,null,"Then you would wrap this ",r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">ContrastiveDataset</code>'}})," around something like ",r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">torchvision.datasets.ImageFolder</code>'}})," or ",r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">CIFAR10</code>'}}),", specify the transforms you want (random crops, color jitter, etc.), and feed it to a standard ",r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">DataLoader</code>'}}),"."),"\n",r.createElement(t.h3,{id:"training-loop-outline-and-the-use-of-cosine-similarity-in-the-loss",style:{position:"relative"}},r.createElement(t.a,{href:"#training-loop-outline-and-the-use-of-cosine-similarity-in-the-loss","aria-label":"training loop outline and the use of cosine similarity in the loss permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Training loop outline and the use of cosine similarity in the loss"),"\n",r.createElement(t.p,null,"Once you have your data loader producing pairs ",r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">(view1, view2)</code>'}}),", the typical training loop in PyTorch for a single epoch might look like this:"),"\n",r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">&lt;Code text={`\nimport torch\nimport torch.nn.functional as F\n\ndef train_one_epoch(model, projector, dataloader, optimizer, temperature=0.5):\n    model.train()\n    projector.train()\n\n    total_loss = 0.0\n    for (view1, view2) in dataloader:\n        view1 = view1.cuda()\n        view2 = view2.cuda()\n\n        # Encode both views\n        h1 = model(view1)  # base encoder outputs\n        h2 = model(view2)\n\n        # Project to latent space\n        z1 = projector(h1)\n        z2 = projector(h2)\n\n        # Normalize z1 and z2\n        z1 = F.normalize(z1, dim=1)\n        z2 = F.normalize(z2, dim=1)\n\n        # Construct similarity matrix\n        # sim(i, j) = z_i dot z_j\n        # We\'ll do pairwise similarity for the entire batch\n        batch_size = z1.shape[0]\n        representations = torch.cat([z1, z2], dim=0)\n        sim_matrix = torch.matmul(representations, representations.t())  # (2B, 2B)\n\n        # Create labels for positives\n        # The diagonal elements are similarity of each sample with itself\n        # We want the pairs (i, i+B) to be positive for i in [0..B-1]\n        labels = torch.cat([torch.arange(batch_size) + batch_size,\n                            torch.arange(batch_size)], dim=0).cuda()\n\n        # Scale by temperature\n        sim_matrix = sim_matrix / temperature\n\n        # Mask out self-similarities\n        mask = torch.eye(2*batch_size, dtype=torch.bool).cuda()\n        sim_matrix.masked_fill_(mask, float(\'-inf\'))\n\n        # Cross-entropy loss\n        loss = F.cross_entropy(sim_matrix, labels)\n        \n        optimizer.zero_grad()\n        loss.backward()\n        optimizer.step()\n\n        total_loss += loss.item() * batch_size\n\n    return total_loss / len(dataloader.dataset)\n`}/></code></pre></div>'}}),"\n",r.createElement(t.p,null,"This code snippet is a simplified version of a SimCLR-like training loop:"),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,"We take a batch of pairs ",r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">(view1, view2)</code>'}}),"."),"\n",r.createElement(t.li,null,"We encode them into ",r.createElement(s.A,{text:"\\(h_1, h_2\\)"})," using the base model."),"\n",r.createElement(t.li,null,"We project them into ",r.createElement(s.A,{text:"\\(z_1, z_2\\)"})," using the projection head."),"\n",r.createElement(t.li,null,"We compute a similarity matrix among all ",r.createElement(s.A,{text:"\\(z\\)"})," vectors in that batch (2B in total)."),"\n",r.createElement(t.li,null,"We treat the matching pairs ",r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">(z1[i], z2[i])</code>'}})," as positives, while everything else acts as negatives."),"\n",r.createElement(t.li,null,"We apply a temperature scaling and then compute cross-entropy, forcing each sample to find its true pair among the 2B-1 other vectors in the batch."),"\n"),"\n",r.createElement(t.p,null,"This loop can be scaled up with multiple GPUs or multiple nodes. The core idea remains the same: produce positive pairs, embed them, compute InfoNCE-based loss."),"\n",r.createElement(t.h3,{id:"managing-large-batch-training-or-distributed-setups-if-applicable",style:{position:"relative"}},r.createElement(t.a,{href:"#managing-large-batch-training-or-distributed-setups-if-applicable","aria-label":"managing large batch training or distributed setups if applicable permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Managing large-batch training or distributed setups (if applicable)"),"\n",r.createElement(t.p,null,"If you want to train with very large batch sizes (e.g., 1024, 2048, or even more), you can adopt either:"),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Distributed Data Parallel (DDP)")," across multiple GPUs or multiple machines."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Gradient accumulation")," across multiple mini-batches to effectively simulate a larger batch size."),"\n"),"\n",r.createElement(t.p,null,"SimCLR originally used 4096 or 8192 as the batch size on TPUs (Tensor Processing Units). If you have limited resources, you can experiment with smaller batches, but you might lose some performance or need to incorporate memory bank approaches (like MoCo) to maintain a large pool of negatives."),"\n",r.createElement(t.h3,{id:"tips-on-monitoring-learning-progress",style:{position:"relative"}},r.createElement(t.a,{href:"#tips-on-monitoring-learning-progress","aria-label":"tips on monitoring learning progress permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Tips on monitoring learning progress"),"\n",r.createElement(t.p,null,"Unlike supervised learning, where you can directly measure validation accuracy on each epoch, self-supervised training's progress is less direct. Some potential ways to monitor training include:"),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Loss curve"),": The InfoNCE or cross-entropy loss on the contrastive objective. You typically expect it to go down steadily, but its final value doesn't necessarily translate directly to classification accuracy."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Online linear probe"),": You can attach a small linear classifier on top of the base encoder ",r.createElement(s.A,{text:"\\(f\\)"})," and train it on a small labeled subset in parallel (sometimes called online classification). Monitoring the accuracy of that linear classifier can give a sense of how the representation evolves."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Top-k batch accuracy"),": Within the batch, you might measure how often the positive pair is among the top-k similarities. This is a partial metric, but it can still give insights."),"\n"),"\n",r.createElement(t.h2,{id:"downstream-evaluation-and-finetuning",style:{position:"relative"}},r.createElement(t.a,{href:"#downstream-evaluation-and-finetuning","aria-label":"downstream evaluation and finetuning permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Downstream evaluation and finetuning"),"\n",r.createElement(t.p,null,"One of the hallmarks of self-supervised learning is that you aim to learn a general representation that can be adapted to downstream tasks with minimal additional training or labeled data. Let's look at how you can evaluate the representations learned by SimCLR (or any similar approach)."),"\n",r.createElement(t.h3,{id:"removing-the-projection-head-and-using-the-base-encoder",style:{position:"relative"}},r.createElement(t.a,{href:"#removing-the-projection-head-and-using-the-base-encoder","aria-label":"removing the projection head and using the base encoder permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Removing the projection head and using the base encoder"),"\n",r.createElement(t.p,null,"After the model is trained, you typically discard the projection head ",r.createElement(s.A,{text:"\\(g\\)"})," and use the base encoder ",r.createElement(s.A,{text:"\\(f\\)"})," to extract features. In the case of SimCLR, it's been shown that this intermediate representation (before the projection head) can offer highly discriminative features for classification tasks."),"\n",r.createElement(t.h3,{id:"logistic-regression-on-frozen-features",style:{position:"relative"}},r.createElement(t.a,{href:"#logistic-regression-on-frozen-features","aria-label":"logistic regression on frozen features permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Logistic regression on frozen features"),"\n",r.createElement(t.p,null,'A common evaluation technique is the "linear probe" or a logistic regression training:'),"\n",r.createElement(t.ol,null,"\n",r.createElement(t.li,null,"Freeze the base encoder ",r.createElement(s.A,{text:"\\(f\\)"})," — that is, do not update its parameters."),"\n",r.createElement(t.li,null,"Pass each image (or sample) through ",r.createElement(s.A,{text:"\\(f\\)"})," to obtain a feature vector ",r.createElement(s.A,{text:"\\(h\\)"}),"."),"\n",r.createElement(t.li,null,"Train a linear classifier ",r.createElement(s.A,{text:"\\(W\\)"})," (or logistic regression) on top of ",r.createElement(s.A,{text:"\\(h\\)"})," using the labeled subset of data."),"\n",r.createElement(t.li,null,"Evaluate the accuracy of this linear classifier on a test set."),"\n"),"\n",r.createElement(t.p,null,"If the self-supervised representation is robust, you'll typically see strong performance relative to a fully supervised model trained from scratch with the same (limited) labeled data."),"\n",r.createElement(t.h3,{id:"finetuning-on-a-small-labeled-set",style:{position:"relative"}},r.createElement(t.a,{href:"#finetuning-on-a-small-labeled-set","aria-label":"finetuning on a small labeled set permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Finetuning on a small labeled set"),"\n",r.createElement(t.p,null,"In many scenarios, you might do partial or full finetuning of the base encoder. This means you take ",r.createElement(s.A,{text:"\\(f\\)"}),", initialized with the self-supervised weights, and let it update during training for a specific downstream task. This often yields even better performance, especially if you have enough labeled data to gently nudge the representation in the right direction."),"\n",r.createElement(t.p,null,"Common benchmarks for this type of evaluation include datasets like ",r.createElement(t.strong,null,"STL-10")," or ",r.createElement(t.strong,null,"CIFAR-10"),", where you can train the representation on unlabeled data (or the entire dataset ignoring labels) and then test how effectively it can classify images when only a fraction of the labels are available."),"\n",r.createElement(t.h3,{id:"comparison-with-fully-supervised-baselines",style:{position:"relative"}},r.createElement(t.a,{href:"#comparison-with-fully-supervised-baselines","aria-label":"comparison with fully supervised baselines permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Comparison with fully supervised baselines"),"\n",r.createElement(t.p,null,"For an apples-to-apples comparison, researchers often compare:"),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Self-supervised pretrained + linear probe")," vs."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Supervised pretrained + linear probe")," vs."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Supervised from scratch"),"."),"\n"),"\n",r.createElement(t.p,null,"SimCLR and related methods often demonstrate that self-supervised pretraining can match or exceed the performance of supervised baselines when labeled data is scarce."),"\n",r.createElement(t.h3,{id:"highlighting-improvements-in-low-label-or-few-shot-scenarios",style:{position:"relative"}},r.createElement(t.a,{href:"#highlighting-improvements-in-low-label-or-few-shot-scenarios","aria-label":"highlighting improvements in low label or few shot scenarios permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Highlighting improvements in low-label or few-shot scenarios"),"\n",r.createElement(t.p,null,"The difference really shows in low-label regimes, where you might have only 1% or 10% of the data labeled. Self-supervised methods typically maintain strong performance, whereas training from scratch with only 1% of the labeled data might lead to severe overfitting and poor generalization. This advantage is a primary driver of interest in methods like SimCLR."),"\n",r.createElement(t.h2,{id:"extensions-and-other-considerations",style:{position:"relative"}},r.createElement(t.a,{href:"#extensions-and-other-considerations","aria-label":"extensions and other considerations permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Extensions and other considerations"),"\n",r.createElement(t.p,null,"Contrastive self-supervised learning has become a foundational technique in modern machine learning, but it's not a panacea. Let's explore some important extensions and considerations to keep in mind."),"\n",r.createElement(t.h3,{id:"variants-combining-supervised-labels-supervised-contrastive-learning-scl",style:{position:"relative"}},r.createElement(t.a,{href:"#variants-combining-supervised-labels-supervised-contrastive-learning-scl","aria-label":"variants combining supervised labels supervised contrastive learning scl permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Variants combining supervised labels (supervised contrastive learning, scl)"),"\n",r.createElement(t.p,null,"Sometimes you do have labels for a dataset, but you still want the benefits of contrastive representation learning. ",r.createElement(l.A,null,"Supervised contrastive learning")," proposes using label information to define positive pairs not just as two views of the same instance, but also as two instances sharing the same label. Negatives come from instances with different labels. This can be particularly effective in multi-class classification settings."),"\n",r.createElement(t.h3,{id:"semi-supervised-pipelines-using-small-labeled-sets-and-large-unlabeled-sets",style:{position:"relative"}},r.createElement(t.a,{href:"#semi-supervised-pipelines-using-small-labeled-sets-and-large-unlabeled-sets","aria-label":"semi supervised pipelines using small labeled sets and large unlabeled sets permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Semi-supervised pipelines using small labeled sets and large unlabeled sets"),"\n",r.createElement(t.p,null,"In a realistic scenario, you may have a small labeled dataset and a large unlabeled dataset. A pipeline might:"),"\n",r.createElement(t.ol,null,"\n",r.createElement(t.li,null,"Pretrain the model on the entire unlabeled dataset using contrastive self-supervision."),"\n",r.createElement(t.li,null,"Finetune or use a linear probe on the small labeled set."),"\n",r.createElement(t.li,null,"Optionally incorporate the labeled set to refine the contrastive objective or design a hybrid approach."),"\n"),"\n",r.createElement(t.p,null,"This synergy leverages the best of both worlds — abundant unlabeled data and minimal labeled data — to reach high accuracy."),"\n",r.createElement(t.h3,{id:"integration-with-other-ssl-paradigms-eg-distillation-based-byol-or-redundancy-reduction-in-barlow-twins",style:{position:"relative"}},r.createElement(t.a,{href:"#integration-with-other-ssl-paradigms-eg-distillation-based-byol-or-redundancy-reduction-in-barlow-twins","aria-label":"integration with other ssl paradigms eg distillation based byol or redundancy reduction in barlow twins permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Integration with other ssl paradigms (e.g., distillation-based byol or redundancy reduction in barlow twins)"),"\n",r.createElement(t.p,null,"SimCLR isn't alone in the self-supervised universe. We've already mentioned ",r.createElement(t.strong,null,"BYOL"),", ",r.createElement(t.strong,null,"Barlow Twins"),", and more. BYOL elegantly bypasses negative samples, while Barlow Twins focuses on decorrelating feature components across augmented views. These approaches can sometimes reduce the hardware requirement or improve stability. It's worth experimenting with these methods if your application or resources differ from the assumptions behind SimCLR."),"\n",r.createElement(t.h3,{id:"the-trend-toward-larger-models-and-longer-training-in-contrastive-learning",style:{position:"relative"}},r.createElement(t.a,{href:"#the-trend-toward-larger-models-and-longer-training-in-contrastive-learning","aria-label":"the trend toward larger models and longer training in contrastive learning permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"The trend toward larger models and longer training in contrastive learning"),"\n",r.createElement(t.p,null,"A consistent theme in both supervised and self-supervised learning is that bigger models, trained longer, on larger datasets, tend to yield better results — at least up to certain points. Contrastive learning approaches like ",r.createElement(t.strong,null,"SimCLR v2")," highlight that scaling up the architecture (using deeper ResNets, for example) and training for more epochs yields higher performance. Indeed, many subsequent self-supervised methods keep pushing the envelope of scale (e.g., using Vision Transformers with enormous parameters, employing billions of images from the web, etc.)."),"\n",r.createElement(t.h2,{id:"conclusion-and-future-directions",style:{position:"relative"}},r.createElement(t.a,{href:"#conclusion-and-future-directions","aria-label":"conclusion and future directions permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Conclusion and future directions"),"\n",r.createElement(t.p,null,"Contrastive learning — exemplified by SimCLR — has reshaped how we approach representation learning in computer vision and beyond. By leveraging massive unlabeled datasets, we can learn high-quality features that transfer well to downstream tasks, sometimes rivaling or exceeding fully supervised counterparts."),"\n",r.createElement(t.p,null,"SimCLR's impact lies in its ",r.createElement(t.strong,null,"simplicity")," (an encoder, a projection head, and a straightforward InfoNCE loss) and its reliance on ",r.createElement(t.strong,null,"strong augmentations"),", ",r.createElement(t.strong,null,"large batch sizes"),", and an ",r.createElement(t.strong,null,"appropriate temperature parameter"),". Although the original method can be resource-intensive, it has spurred a wave of research into more efficient variants (e.g., MoCo), negative-free approaches (BYOL), and new designs (Barlow Twins, VICReg, and beyond)."),"\n",r.createElement(t.h3,{id:"advantages-of-self-supervised-contrastive-learning-in-real-world-tasks",style:{position:"relative"}},r.createElement(t.a,{href:"#advantages-of-self-supervised-contrastive-learning-in-real-world-tasks","aria-label":"advantages of self supervised contrastive learning in real world tasks permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Advantages of self-supervised contrastive learning in real-world tasks"),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Reduced labeling costs"),": Freed from the tyranny of large-scale annotation efforts, data-hungry tasks in domains like autonomous driving, medical imaging, and remote sensing benefit immensely."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Better low-shot performance"),": Models trained in a self-supervised fashion tend to generalize better with few labels, leading to efficient adaptation for tasks that do not have extensive labeled data."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Domain adaptation"),": If you have a large unlabeled dataset from a new domain (e.g., night-time driving images), you can pretrain a self-supervised model on that domain and then finetune with minimal labeled examples for specialized tasks in that domain."),"\n"),"\n",r.createElement(t.h3,{id:"ongoing-research-reducing-computational-overhead-and-negative-sampling-strategies",style:{position:"relative"}},r.createElement(t.a,{href:"#ongoing-research-reducing-computational-overhead-and-negative-sampling-strategies","aria-label":"ongoing research reducing computational overhead and negative sampling strategies permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Ongoing research: reducing computational overhead and negative sampling strategies"),"\n",r.createElement(t.p,null,"Despite rapid progress, several open questions remain:"),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Resource efficiency"),": Large-batch training is expensive. Methods like MoCo or negative-free approaches attempt to reduce resource requirements. There is ongoing research to further reduce reliance on massive hardware setups."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Task-specific augmentations"),": For specialized tasks, carefully chosen augmentations that reflect domain transformations can be crucial. In scientific imaging or medical contexts, flips or color changes might not always make sense. Researchers are exploring domain-driven augmentations that preserve semantic content."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Negative sampling"),": Even though SimCLR uses all other samples in the batch as negatives, other approaches or specialized sampling strategies might help. Some methods attempt to identify the hardest negatives or maintain diverse negative sets to further enrich the representation."),"\n"),"\n",r.createElement(t.h3,{id:"references-to-foundational-papers-and-suggested-readings",style:{position:"relative"}},r.createElement(t.a,{href:"#references-to-foundational-papers-and-suggested-readings","aria-label":"references to foundational papers and suggested readings permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"References to foundational papers and suggested readings"),"\n",r.createElement(t.p,null,"For anyone looking to study these methods in-depth, I recommend reviewing the original and follow-up papers:"),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"SimCLR"),': Chen and gang, "A Simple Framework for Contrastive Learning of Visual Representations", ICML 2020.'),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"MoCo"),': He and gang, "Momentum Contrast for Unsupervised Visual Representation Learning", CVPR 2020.'),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"BYOL"),': Grill and gang, "Bootstrap Your Own Latent: A New Approach to Self-Supervised Learning", NeurIPS 2020.'),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Barlow Twins"),': Zbontar and gang, "Barlow Twins: Self-Supervised Learning via Redundancy Reduction", ICML 2021.'),"\n"),"\n",r.createElement(t.p,null,"I recommend reading these works for deeper insights into design choices, ablations, and results on benchmark datasets. Each approach builds upon the core principle — learning representations by contrasting positive pairs against negative pairs or other statistical constructs — yet they differ in how they manage or even eliminate the requirement for negative examples."),"\n",r.createElement(t.p,null,"From here, you can continue exploring other self-supervised methods, or experiment with implementing SimCLR on your own data. Contrastive learning remains a vibrant research area, and it is quickly merging with other advanced domains such as ",r.createElement(t.strong,null,"multimodal learning")," (combining vision with text, audio, or other modalities) and ",r.createElement(t.strong,null,"vision-language models"),". The fundamental ideas in contrastive methods — structuring learning around instance-level or class-level similarities/differences — have proven remarkably flexible and influential in broader machine learning research."),"\n",r.createElement(t.p,null,"Overall, I encourage you to experiment with SimCLR or similar frameworks using the augmentation strategies and training loops we've discussed, and then adapt them to your own specialized tasks. The self-supervised revolution in vision is only beginning to unfold, and contrastive learning stands at the forefront of this exciting era."))}var c=function(e){void 0===e&&(e={});const{wrapper:t}=Object.assign({},(0,i.RP)(),e.components);return t?r.createElement(t,e,r.createElement(o,e)):o(e)};var m=a(36710),h=a(58481),d=a.n(h),u=a(36310),g=a(87245),p=a(27042),f=a(59849),v=a(5591),b=a(61122),y=a(9219),E=a(33203),w=a(95751),S=a(94328),x=a(80791),k=a(78137);const _=e=>{let{toc:t}=e;if(!t||!t.items)return null;return r.createElement("nav",{className:x.R},r.createElement("ul",null,t.items.map(((e,t)=>r.createElement("li",{key:t},r.createElement("a",{href:e.url,onClick:t=>((e,t)=>{e.preventDefault();const a=t.replace("#",""),n=document.getElementById(a);n&&n.scrollIntoView({behavior:"smooth",block:"start"})})(t,e.url)},e.title),e.items&&r.createElement(_,{toc:{items:e.items}}))))))};function H(e){let{data:{mdx:t,allMdx:l,allPostImages:s},children:o}=e;const{frontmatter:c,body:m,tableOfContents:h}=t,f=c.index,x=c.slug.split("/")[1],H=l.nodes.filter((e=>e.frontmatter.slug.includes(`/${x}/`))).sort(((e,t)=>e.frontmatter.index-t.frontmatter.index)),C=H.findIndex((e=>e.frontmatter.index===f)),z=H[C+1],T=H[C-1],I=c.slug.replace(/\/$/,""),L=/[^/]*$/.exec(I)[0],M=`posts/${x}/content/${L}/`,{0:A,1:V}=(0,r.useState)(c.flagWideLayoutByDefault),{0:N,1:B}=(0,r.useState)(!1);var R;(0,r.useEffect)((()=>{B(!0);const e=setTimeout((()=>B(!1)),340);return()=>clearTimeout(e)}),[A]),"adventures"===x?R=y.cb:"research"===x?R=y.Qh:"thoughts"===x&&(R=y.T6);const j=d()(m).replace(/import .*? from .*?;/g,"").replace(/<.*?>/g,"").replace(/\{\/\*[\s\S]*?\*\/\}/g,"").trim().split(/\s+/).length,P=function(e){if(e<=10)return"~10 min";if(e<=20)return"~20 min";if(e<=30)return"~30 min";if(e<=40)return"~40 min";if(e<=50)return"~50 min";if(e<=60)return"~1 h";const t=Math.floor(e/60),a=e%60;return a<=30?`~${t}${a>0?".5":""} h`:`~${t+1} h`}(Math.ceil(j/R)+(c.extraReadTimeMin||0)),q=[{flag:c.flagDraft,component:()=>Promise.all([a.e(3231),a.e(8809)]).then(a.bind(a,28809))},{flag:c.flagMindfuckery,component:()=>Promise.all([a.e(3231),a.e(2471)]).then(a.bind(a,67709))},{flag:c.flagRewrite,component:()=>Promise.all([a.e(3231),a.e(6764)]).then(a.bind(a,62002))},{flag:c.flagOffensive,component:()=>Promise.all([a.e(3231),a.e(2443)]).then(a.bind(a,17681))},{flag:c.flagProfane,component:()=>Promise.all([a.e(3231),a.e(8048)]).then(a.bind(a,53286))},{flag:c.flagMultilingual,component:()=>Promise.all([a.e(3231),a.e(4069)]).then(a.bind(a,78831))},{flag:c.flagUnreliably,component:()=>Promise.all([a.e(3231),a.e(3417)]).then(a.bind(a,8179))},{flag:c.flagPolitical,component:()=>Promise.all([a.e(3231),a.e(5195)]).then(a.bind(a,30433))},{flag:c.flagCognitohazard,component:()=>Promise.all([a.e(3231),a.e(3175)]).then(a.bind(a,8413))},{flag:c.flagHidden,component:()=>Promise.all([a.e(3231),a.e(9556)]).then(a.bind(a,14794))}],{0:O,1:W}=(0,r.useState)([]);return(0,r.useEffect)((()=>{q.forEach((e=>{let{flag:t,component:a}=e;t&&a().then((e=>{W((t=>[].concat((0,n.A)(t),[e.default])))}))}))}),[]),r.createElement(p.P.div,{initial:{opacity:0},animate:{opacity:1},exit:{opacity:0},transition:{duration:.15}},r.createElement(v.A,{postNumber:c.index,date:c.date,updated:c.updated,readTime:P,difficulty:c.difficultyLevel,title:c.title,desc:c.desc,banner:c.banner,section:x,postKey:L,isMindfuckery:c.flagMindfuckery,mainTag:c.mainTag}),r.createElement("div",{style:{display:"flex",justifyContent:"flex-end",flexWrap:"wrap",maxWidth:"75%",marginLeft:"auto",paddingRight:"1vw",marginTop:"-6vh",marginBottom:"4vh"}},c.otherTags.map(((e,t)=>r.createElement("span",{key:t,className:`noselect ${k.MW}`,style:{margin:"0 5px 5px 0"}},e)))),r.createElement("div",{class:"postBody"},r.createElement(_,{toc:h})),r.createElement("br"),r.createElement("div",{style:{margin:"0 10% -2vh 30%",textAlign:"right"}},r.createElement(p.P.button,{class:"noselect",className:S.pb,id:S.xG,onClick:()=>{V(!A)},whileTap:{scale:.93}},r.createElement(p.P.div,{className:w.DJ,key:A,initial:{opacity:0},animate:{opacity:1},exit:{opacity:0},transition:{duration:.3,ease:"easeInOut"}},A?"Switch to default layout":"Switch to wide layout"))),r.createElement("br"),r.createElement("div",{class:"postBody",style:{margin:A?"0 -14%":"",maxWidth:A?"200%":"",transition:"margin 1s ease, max-width 1s ease, padding 1s ease"}},r.createElement("div",{className:`${S.P_} ${N?S.Xn:S.qG}`},O.map(((e,t)=>r.createElement(e,{key:t}))),c.indexCourse?r.createElement(E.A,{index:c.indexCourse,category:c.courseCategoryName}):"",r.createElement(u.Z.Provider,{value:{images:s.nodes,basePath:M.replace(/\/$/,"")+"/"}},r.createElement(i.xA,{components:{Image:g.A}},o)))),r.createElement(b.A,{nextPost:z,lastPost:T,keyCurrent:L,section:x}))}function C(e){return r.createElement(H,e,r.createElement(c,e))}function z(e){var t,a,n,i,l;let{data:s}=e;const{frontmatter:o}=s.mdx,c=o.titleSEO||o.title,h=o.titleOG||c,d=o.titleTwitter||c,u=o.descSEO||o.desc,g=o.descOG||u,p=o.descTwitter||u,v=o.schemaType||"BlogPosting",b=o.keywordsSEO,y=o.date,E=o.updated||y,w=o.imageOG||(null===(t=o.banner)||void 0===t||null===(a=t.childImageSharp)||void 0===a||null===(n=a.gatsbyImageData)||void 0===n||null===(i=n.images)||void 0===i||null===(l=i.fallback)||void 0===l?void 0:l.src),S=o.imageAltOG||g,x=o.imageTwitter||w,k=o.imageAltTwitter||p,_=o.canonicalURL,H=o.flagHidden||!1,C=o.mainTag||"Posts",z=o.slug.split("/")[1]||"posts",{siteUrl:T}=(0,m.Q)(),I={"@context":"https://schema.org","@type":"BreadcrumbList",itemListElement:[{"@type":"ListItem",position:1,name:"Home",item:T},{"@type":"ListItem",position:2,name:C,item:`${T}/${o.slug.split("/")[1]}`},{"@type":"ListItem",position:3,name:c,item:`${T}${o.slug}`}]};return r.createElement(f.A,{title:c+" - avrtt.blog",titleOG:h,titleTwitter:d,description:u,descriptionOG:g,descriptionTwitter:p,schemaType:v,keywords:b,datePublished:y,dateModified:E,imageOG:w,imageAltOG:S,imageTwitter:x,imageAltTwitter:k,canonicalUrl:_,flagHidden:H,mainTag:C,section:z,type:"article"},r.createElement("script",{type:"application/ld+json"},JSON.stringify(I)))}},96098:function(e,t,a){var n=a(96540),i=a(7978);t.A=e=>{let{text:t}=e;return n.createElement(i.A,null,t)}}}]);
//# sourceMappingURL=component---src-templates-post-js-content-file-path-src-pages-posts-research-contrastive-learning-and-simclr-mdx-52b4368212138f96b963.js.map