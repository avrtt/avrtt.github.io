"use strict";(self.webpackChunkavrtt_blog=self.webpackChunkavrtt_blog||[]).push([[2717],{2686:function(e,t,n){n.r(t),n.d(t,{Head:function(){return M},PostTemplate:function(){return N},default:function(){return z}});var a=n(54506),i=n(28453),r=n(96540),l=n(66501),o=n(16886),s=n(46295),c=n(96098);function m(e){const t=Object.assign({p:"p",hr:"hr",h2:"h2",a:"a",span:"span",h3:"h3",ul:"ul",li:"li",em:"em",strong:"strong",ol:"ol",br:"br"},(0,i.RP)(),e.components),{Image:n}=t;return n||function(e,t){throw new Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Image",!0),r.createElement(r.Fragment,null,"\n",r.createElement("br"),"\n","\n","\n",r.createElement(t.p,null,'Inpainting is a specialized image processing task in which missing or corrupted regions of an image are filled in with plausible content that preserves global coherence and realism. Although the term "inpainting" might be reminiscent of artistic touch-ups or museum-level restoration of paintings, in the field of computer vision and machine learning, it is usually a much more general operation, involving repairing lost or damaged data within an image. I find this domain fascinating because, in many applications, successful inpainting models can achieve visually seamless results, thereby enabling a wide array of functionalities that were once considered impossible or extremely time-consuming — such as removing unwanted objects, reconstructing damaged photographs, restoring details lost to noise, and even generating entirely new features in a photograph based on contextual cues.'),"\n",r.createElement(t.p,null,"The tradition of image inpainting dates back many decades in computer vision, with many classical methods relying on partial differential equations (",r.createElement(o.A,null,"PDEs"),") and variational calculus to achieve realistic reconstructions. Over time, approaches grew more sophisticated by incorporating ideas from statistics, optimization-based frameworks, and patch-based search or sampling. In recent years, the explosion of deep learning methods — especially generative modeling and convolutional architectures — has taken inpainting performance to new levels of quality, enabling semantically aware solutions that understand which objects, textures, or patterns should be plausibly inferred within missing regions."),"\n",r.createElement(t.p,null,'This article dives into both the traditional concepts of inpainting (rooted in PDEs, variational techniques, and energy minimization) and the modern deep learning approaches that leverage advanced neural architectures such as convolutional neural networks (CNNs), generative adversarial networks (GANs), autoencoders, and more specialized models (e.g. partial convolution, gated convolution, multi-stage or two-stage networks). You will see that the solutions go well beyond mere pixel interpolation — they aim to "understand" the image content so as to produce a faithful fill-in of the occluded areas.'),"\n",r.createElement(t.p,null,"I will also discuss training and implementation details, highlight commonly used inpainting loss functions (including perceptual, style, adversarial, and total variation losses), and explore evaluation metrics such as peak signal-to-noise ratio (PSNR), structural similarity index measure (SSIM), and the more nuanced perceptual evaluations that often guide real-world usage. We will end with a broad look at challenges, limitations, and real-world applications, as well as some advanced references pointing to state-of-the-art research in the field."),"\n",r.createElement(t.hr),"\n",r.createElement(t.h2,{id:"mathematical-foundations",style:{position:"relative"}},r.createElement(t.a,{href:"#mathematical-foundations","aria-label":"mathematical foundations permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Mathematical foundations"),"\n",r.createElement(t.h3,{id:"partial-differential-equations-methods",style:{position:"relative"}},r.createElement(t.a,{href:"#partial-differential-equations-methods","aria-label":"partial differential equations methods permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Partial differential equations methods"),"\n",r.createElement(t.p,null,"Classical image inpainting research is deeply rooted in the idea of leveraging partial differential equations (",r.createElement(l.A,{text:"Differential equations involving functions of several variables and their partial derivatives"}),') to propagate local structural information from known areas to missing regions. One of the earliest groundbreaking works along these lines is often credited to Bertalmio and gang ("Image Inpainting," SIGGRAPH 2000), in which they drew from concepts in fluid dynamics to propose PDE-based image restoration.'),"\n",r.createElement(t.p,null,"A PDE-based method for inpainting typically does the following:"),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,"It defines a small boundary region around the missing (or corrupted) parts of the image."),"\n",r.createElement(t.li,null,"It infers the directions and intensities of the image's isophotes (level lines of equal intensity or color)."),"\n",r.createElement(t.li,null,"It propagates these isophotes continuously into the interior of the unknown region, under constraints that aim to preserve gradient smoothness or color continuity."),"\n"),"\n",r.createElement(t.p,null,"One well-known example is the ",r.createElement(t.em,null,"fast marching method")," (Telea, 2004). This algorithm systematically reconstructs unknown pixels by working inwards from the boundary of the damaged region, determining each new pixel as a weighted combination of the known neighbors. It is relatively straightforward yet surprisingly effective for small, thin, or otherwise uncomplicated missing areas. Another PDE approach involves the ",r.createElement(t.em,null,"Navier–Stokes method"),' (Bertalmio and gang, 2001), named after the famous fluid flow equations. The method enforces that the gradients of color or brightness remain continuous across the boundary, effectively "flowing" the information inside the inpainting domain.'),"\n",r.createElement(t.p,null,"Typically, let ",r.createElement(c.A,{text:"\\( \\Omega \\subset \\mathbb{R}^2 \\)"})," be the domain of the image and ",r.createElement(c.A,{text:"\\( D \\subset \\Omega \\)"})," the region to be inpainted. If ",r.createElement(c.A,{text:"\\( I: \\Omega \\to \\mathbb{R}^3 \\)"})," denotes the RGB image (or grayscale for simplicity), a PDE-based inpainting method might solve:"),"\n",r.createElement(c.A,{text:"\\[\n\\frac{\\partial I(x,y)}{\\partial t} = F\\bigl(I, \\nabla I, \\nabla^2 I, \\dots\\bigr), \\quad (x,y) \\in D,\n\\]"}),"\n",r.createElement(t.p,null,"with boundary conditions such that ",r.createElement(c.A,{text:"\\( I(x,y) \\)"})," is fixed on ",r.createElement(c.A,{text:"\\( \\partial D \\)"}),". The choice of the function ",r.createElement(c.A,{text:"\\( F \\)"})," depends on the PDE approach at hand. Fast marching-based inpainting, for instance, might revolve around extending intensities in the direction normal to the boundary, while Navier–Stokes-based methods incorporate fluid-flow inspired constraints that attempt to preserve edge continuity and gradient direction."),"\n",r.createElement(t.p,null,"In practice, PDE-based solutions work best for small holes or cracks in images where the primary need is to continue lines and textures. Once the missing region becomes large or visually complex, PDE-based approaches often fail to capture the overall semantic structure needed for a truly coherent fill. That's where more sophisticated frameworks come into play."),"\n",r.createElement(t.h3,{id:"variational-and-optimization-based-approaches",style:{position:"relative"}},r.createElement(t.a,{href:"#variational-and-optimization-based-approaches","aria-label":"variational and optimization based approaches permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Variational and optimization-based approaches"),"\n",r.createElement(t.p,null,"Another major class of classical inpainting solutions arises from ",r.createElement(t.strong,null,"variational")," methods, in which one defines an ",r.createElement(t.em,null,"energy functional")," that quantifies how well a reconstructed image agrees with both the known data and some desired smoothness or regularity prior. The inpainting task becomes an optimization problem: minimize the energy with respect to the unknown pixels, given boundary constraints on the known region."),"\n",r.createElement(t.p,null,"A prototypical variational formulation can be expressed as:"),"\n",r.createElement(c.A,{text:"\\[\n\\min_I \\quad E(I) = \\int_{D} \\Phi\\bigl(\\nabla I(x,y)\\bigr) \\, dx \\, dy \n+ \\lambda \\int_{\\Omega \\setminus D} \\|I(x,y) - I_{\\text{obs}}(x,y)\\|^2 \\, dx \\, dy,\n\\]"}),"\n",r.createElement(t.p,null,"where:"),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,r.createElement(c.A,{text:"\\( D \\)"})," is the region of missing or corrupted data,"),"\n",r.createElement(t.li,null,r.createElement(c.A,{text:"\\( I_{\\text{obs}} \\)"})," denotes the observed (known) pixels,"),"\n",r.createElement(t.li,null,r.createElement(c.A,{text:"\\( \\Phi \\)"})," is a functional designed to enforce regularity or penalize large image gradients (thus encouraging smoothness or continuity of edges),"),"\n",r.createElement(t.li,null,r.createElement(c.A,{text:"\\( \\lambda \\)"})," is a weighting parameter controlling the balance between fidelity to known data and regularization."),"\n"),"\n",r.createElement(t.p,null,"Methods based on ",r.createElement(t.em,null,"total variation")," (TV) or higher-order smoothness constraints typically fall in this category. These approaches can produce results that preserve edges relatively well, although they can also introduce oversmoothing in more elaborate or texture-rich scenes."),"\n",r.createElement(t.p,null,"A popular notion is that many classical inpainting energies rely on ",r.createElement(t.em,null,"patch-based approaches"),", which explicitly sample or copy existing patches from known portions of the image into the unknown region to preserve local structures. These methods gained prominence in the mid-2000s due to their effectiveness in reconstructing large regions, provided the same or similar textures/patterns existed elsewhere in the image. The well-known ",r.createElement(t.em,null,"PatchMatch")," algorithm (Barnes and gang, 2009) is an example that computes approximate nearest neighbor correspondences between patches in an image, making it possible to fill in large holes by reusing existing content. While not purely PDE-based or purely variational, patch-based approaches can be seen as a type of optimization-based framework, often with energy functions that measure patch similarity between the unknown region and candidate source patches."),"\n",r.createElement(t.h3,{id:"energy-minimization-principles",style:{position:"relative"}},r.createElement(t.a,{href:"#energy-minimization-principles","aria-label":"energy minimization principles permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Energy minimization principles"),"\n",r.createElement(t.p,null,"In general, energy minimization methods unify PDE-based and variational approaches under a single perspective: the inpainting solution is the image ",r.createElement(c.A,{text:"\\( I \\)"})," that minimizes some carefully chosen energy functional. The PDE viewpoint interprets the Euler–Lagrange equation of that energy functional, leading to a differential equation that can be iteratively solved."),"\n",r.createElement(t.p,null,"These classical approaches, while extremely important historically and still quite relevant for smaller holes or simpler images, have certain limitations:"),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Lack of semantic knowledge"),": Traditional PDEs or patch-based frameworks do not truly \"understand\" the high-level content of a scene (e.g., that it's a person's face, or that it's a car with particular textures). They rely on low-level cues (gradients, intensities, edges, patch similarity)."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Difficulty with large holes"),": As soon as the missing region is large, PDE-based methods often fail to hallucinate realistic content, and patch-based methods can produce repetitive or unnatural patterns if the image does not contain enough relevant source patches."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Computational cost"),": Some classical methods can be quite expensive, especially patch-based ones that rely on repeated nearest neighbor searches within the image."),"\n"),"\n",r.createElement(t.hr),"\n",r.createElement(t.h2,{id:"deep-learning-techniques-for-inpainting",style:{position:"relative"}},r.createElement(t.a,{href:"#deep-learning-techniques-for-inpainting","aria-label":"deep learning techniques for inpainting permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Deep learning techniques for inpainting"),"\n",r.createElement(t.h3,{id:"convolutional-neural-networks",style:{position:"relative"}},r.createElement(t.a,{href:"#convolutional-neural-networks","aria-label":"convolutional neural networks permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Convolutional neural networks"),"\n",r.createElement(t.p,null,"With the rise of deep learning, convolutional neural networks (",r.createElement(o.A,null,"CNNs"),") have become a core workhorse for image analysis and synthesis. Their ability to extract hierarchical features from images and to capture local patterns has made them an attractive tool for inpainting. Instead of using PDEs to propagate local structure, a CNN can learn how to fill missing pixels by seeing millions of examples of incomplete images during training and learning a mapping from masked (partially erased) inputs to plausible completions."),"\n",r.createElement(t.p,null,"The earliest CNN-based inpainting approaches typically used an encoder-decoder structure, similar to an autoencoder, in which:"),"\n",r.createElement(t.ol,null,"\n",r.createElement(t.li,null,"An encoder transforms the input image (with missing patches) into a compact latent representation."),"\n",r.createElement(t.li,null,"A decoder attempts to reconstruct the original image from that latent code."),"\n"),"\n",r.createElement(t.p,null,"During training, the network is fed masked images and asked to produce the ground truth original. By minimizing a reconstruction loss (often ",r.createElement(c.A,{text:"\\( L_1 \\)"})," or ",r.createElement(c.A,{text:"\\( L_2 \\)"})," on pixel differences), the network slowly learns to fill in plausible details, guided by the distribution of training images. However, naive autoencoder-based CNN approaches often lead to blurry or overly smooth completions, especially if the training loss does not incorporate additional structural or perceptual terms."),"\n",r.createElement(t.p,null,"The subsequent wave of innovations introduced many improvements:"),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Dilated (atrous) convolutions"),": to increase the receptive field without increasing the parameter count, enabling networks to incorporate more global context."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Partial or gated convolutions"),": to handle irregular or free-form masks and to incorporate a learned gating mechanism that modulates how much the network relies on valid vs. invalid (erased) pixels."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Multi-scale or coarse-to-fine architectures"),": to first predict a rough fill of the missing region, then refine it with higher-frequency details."),"\n"),"\n",r.createElement(t.h3,{id:"generative-adversarial-networks",style:{position:"relative"}},r.createElement(t.a,{href:"#generative-adversarial-networks","aria-label":"generative adversarial networks permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Generative adversarial networks"),"\n",r.createElement(t.p,null,"A major leap forward in inpainting quality arrived with ",r.createElement(t.strong,null,"generative adversarial networks")," (",r.createElement(o.A,null,"GANs"),"), introduced by Goodfellow and gang (NeurIPS 2014). GAN-based image inpainting typically pairs a generator network (which synthesizes the completed image) with a discriminator network (which tries to distinguish real images from generated ones). By training the generator to fool the discriminator, the generator learns to produce completions that are not just consistent at a pixel level but also appear realistic and natural under the learned distribution of real images."),"\n",r.createElement(t.p,null,"One pioneering approach is the work of Iizuka and gang (SIGGRAPH 2017), who introduced a global and local discriminator:"),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,"The ",r.createElement(t.strong,null,"global")," discriminator sees the entire image, ensuring that the overall composition looks realistic."),"\n",r.createElement(t.li,null,"The ",r.createElement(t.strong,null,"local")," discriminator focuses specifically on the inpainted region, ensuring that the filled-in content is plausible and coherent with its immediate surroundings."),"\n"),"\n",r.createElement(t.p,null,"Many subsequent approaches improved on these ideas by using more advanced generator architectures, better training losses (e.g., ",r.createElement(t.strong,null,"perceptual losses"),", ",r.createElement(t.strong,null,"style losses"),", ",r.createElement(t.strong,null,"feature matching"),"), and new forms of discriminator design (e.g., PatchGAN, SN-PatchGAN). The synergy of CNN-based encoders/decoders and adversarial training provides results that often incorporate meaningful semantic structure and texture details beyond the capabilities of purely classical methods."),"\n",r.createElement(t.h3,{id:"autoencoders-and-other-architectures",style:{position:"relative"}},r.createElement(t.a,{href:"#autoencoders-and-other-architectures","aria-label":"autoencoders and other architectures permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Autoencoders and other architectures"),"\n",r.createElement(t.p,null,"While a basic autoencoder can be used for inpainting, specialized variations often perform better:"),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"U-Net")," style networks (Ronneberger and gang, 2015) incorporate skip-connections between encoder and decoder layers, allowing higher-resolution features (edges, color gradients) to pass forward to the decoding stages. This technique is widely used in segmentation tasks but has also proven valuable for inpainting, especially in multi-stage or coarse-to-fine frameworks."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"VAE (Variational Autoencoders)")," can also be adapted for inpainting, though less commonly so than purely deterministic encoder-decoder or GAN-based models. A VAE would attempt to learn a probabilistic latent space from which to generate possible completions, but many practitioners find that adversarial training better captures high-frequency details."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Flow-based or diffusion-based")," generative models (a more recent development) can also be adapted to inpainting. These methods define an invertible transformation or a gradual noising/denoising process, enabling sampling from learned distributions in a more controlled manner. Though not as common for inpainting as GANs or autoencoders, they represent an exciting frontier for generative modeling."),"\n"),"\n",r.createElement(t.h3,{id:"transfer-learning-for-improved-results",style:{position:"relative"}},r.createElement(t.a,{href:"#transfer-learning-for-improved-results","aria-label":"transfer learning for improved results permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Transfer learning for improved results"),"\n",r.createElement(t.p,null,"In many industrial or research scenarios, training an inpainting model from scratch for each new domain (faces, scenery, medical imaging, etc.) can be expensive. Instead, one can:"),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Pretrain")," a network on a large general-purpose dataset (such as ImageNet, MS-COCO, or other broad image collections)."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Finetune")," that network on a smaller domain-specific dataset, adjusting only the last layers or using mild weight decay to preserve learned features."),"\n"),"\n",r.createElement(t.p,null,"Such transfer learning often leads to faster convergence and better generalization, particularly when data for a specialized domain are scarce. For instance, SC-FEGAN (Jo and Park, SIGGRAPH Asia 2019) and other face inpainting methods might utilize general CNN or GAN backbones pretrained on large face datasets, then adapt them with user sketches or color constraints."),"\n",r.createElement(t.hr),"\n",r.createElement(t.h2,{id:"training-and-implementation-details",style:{position:"relative"}},r.createElement(t.a,{href:"#training-and-implementation-details","aria-label":"training and implementation details permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Training and implementation details"),"\n",r.createElement(t.h3,{id:"data-preparation-and-augmentation",style:{position:"relative"}},r.createElement(t.a,{href:"#data-preparation-and-augmentation","aria-label":"data preparation and augmentation permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Data preparation and augmentation"),"\n",r.createElement(t.p,null,"High-quality data is crucial for inpainting. Typical training data consist of original images ",r.createElement(c.A,{text:"\\(I_{\\text{gt}}\\)"})," and corresponding masks ",r.createElement(c.A,{text:"\\(M\\)"})," that indicate which pixels are missing or corrupted. The simplest approach is to artificially create masks by randomly erasing patches. Many modern papers generate ",r.createElement(t.strong,null,"free-form")," masks with random shapes, lines, or strokes, better reflecting real-world scenarios where the missing region isn't necessarily a simple rectangle."),"\n",r.createElement(t.p,null,"Data augmentation often helps expand the diversity of training pairs. Common augmentations include:"),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,"Random cropping or scaling"),"\n",r.createElement(t.li,null,"Horizontal flips, rotations, or color jitter"),"\n",r.createElement(t.li,null,"Adding random noise or synthetic text overlays to mimic real imperfections"),"\n"),"\n",r.createElement(t.h3,{id:"loss-functions-commonly-used-in-inpainting",style:{position:"relative"}},r.createElement(t.a,{href:"#loss-functions-commonly-used-in-inpainting","aria-label":"loss functions commonly used in inpainting permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Loss functions commonly used in inpainting"),"\n",r.createElement(t.p,null,"Deep inpainting models usually combine multiple losses to ensure both pixel-wise faithfulness and visually pleasing structure. Below are popular components:"),"\n",r.createElement(t.ol,null,"\n",r.createElement(t.li,null,"\n",r.createElement(t.p,null,r.createElement(t.strong,null,"Pixel reconstruction loss (L1 or L2)"),r.createElement(t.br),"\n","Measures direct differences between generated pixels and ground truth. A typical ",r.createElement(c.A,{text:"\\( L_1 \\)"}),"-based formulation might be:"),"\n",r.createElement(c.A,{text:"\\[\nL_{\\text{per-pixel}} = \\frac{1}{N_{I_{\\text{gt}}}} \\bigl\\| M \\odot (I_{\\text{gen}} - I_{\\text{gt}})\\bigr\\|_1 \n+ \\alpha \\, \\frac{1}{N_{I_{\\text{gt}}}} \\bigl\\|(1 - M) \\odot (I_{\\text{gen}} - I_{\\text{gt}})\\bigr\\|_1,\n\\]"}),"\n",r.createElement(t.p,null,"where ",r.createElement(c.A,{text:"\\( I_{\\text{gen}} \\)"})," is the generated image, ",r.createElement(c.A,{text:"\\( I_{\\text{gt}} \\)"})," is the ground truth image, ",r.createElement(c.A,{text:"\\( M \\)"})," is the binary mask, ",r.createElement(c.A,{text:"\\( \\alpha \\)"})," is a hyperparameter adjusting the relative weighting between missing and non-missing regions, and ",r.createElement(c.A,{text:"\\( \\odot \\)"})," denotes elementwise multiplication."),"\n"),"\n",r.createElement(t.li,null,"\n",r.createElement(t.p,null,r.createElement(t.strong,null,"Perceptual loss"),r.createElement(t.br),"\n","Instead of comparing raw pixels, one can compare high-level feature representations extracted by a deep network like VGG-16 (Simonyan and Zisserman, 2015). Formally:"),"\n",r.createElement(c.A,{text:"\\[\nL_{\\text{percept}} = \\sum_{q} \\frac{\\|\\Theta_{q}(I_{\\text{gen}}) - \\Theta_{q}(I_{\\text{gt}})\\|_1}{N_{\\Theta_{q}(I_{\\text{gt}})}} \n+ \\sum_{q} \\frac{\\|\\Theta_{q}(I_{\\text{comp}}) - \\Theta_{q}(I_{\\text{gt}})\\|_1}{N_{\\Theta_{q}(I_{\\text{gt}})}},\n\\]"}),"\n",r.createElement(t.p,null,"where ",r.createElement(c.A,{text:"\\( I_{\\text{comp}} \\)"})," is a composite image that uses generated pixels in the missing region but preserves ground truth in the known region; ",r.createElement(c.A,{text:"\\( \\Theta_{q} \\)"})," denotes feature maps from the ",r.createElement(c.A,{text:"\\( q \\)"}),"-th layer of a pretrained network."),"\n"),"\n",r.createElement(t.li,null,"\n",r.createElement(t.p,null,r.createElement(t.strong,null,"Style loss"),r.createElement(t.br),"\n",'Comparing Gram matrices of deep features to align the textures and color distributions of the generated image with those of the ground truth. This idea is borrowed from neural style transfer, capturing local correlations of feature maps to ensure consistent "style". A simplified version can be written as:'),"\n",r.createElement(c.A,{text:"\\[\nL_{\\text{style}} = \\sum_{q} \\frac{1}{C_q^2} \\Bigl\\| \\frac{G_{q}(I_{\\text{gen}}) - G_{q}(I_{\\text{gt}})}{N_q} \\Bigr\\|,\n\\]"}),"\n",r.createElement(t.p,null,"where ",r.createElement(c.A,{text:"\\( G_{q}(x) = (\\Theta_{q}(x))^\\mathrm{T}\\,\\Theta_{q}(x) \\)"})," is the Gram matrix for the ",r.createElement(c.A,{text:"\\( q \\)"}),"-th layer's feature maps, and ",r.createElement(c.A,{text:"\\( C_q \\)"})," is the dimension of those feature maps."),"\n"),"\n",r.createElement(t.li,null,"\n",r.createElement(t.p,null,r.createElement(t.strong,null,"Total variation (TV) loss"),r.createElement(t.br),"\n","Encourages spatial smoothness and consistency across neighboring pixels:"),"\n",r.createElement(c.A,{text:"\\[\nL_{\\text{tv}} = \\sum_{(i,j)\\in R} \\frac{\\| I_{\\text{comp}}^{i,j+1} - I_{\\text{comp}}^{i,j}\\|}{N_{I_{\\text{comp}}}}\n+ \\sum_{(i,j)\\in R} \\frac{\\| I_{\\text{comp}}^{i+1,j} - I_{\\text{comp}}^{i,j}\\|}{N_{I_{\\text{comp}}}},\n\\]"}),"\n",r.createElement(t.p,null,"where ",r.createElement(c.A,{text:"\\( I_{\\text{comp}} \\)"})," is again the composite image and ",r.createElement(c.A,{text:"\\( R \\)"})," indexes valid pixels within the image boundary."),"\n"),"\n",r.createElement(t.li,null,"\n",r.createElement(t.p,null,r.createElement(t.strong,null,"Adversarial loss"),r.createElement(t.br),"\n","In GAN-based methods, the generator ",r.createElement(c.A,{text:"\\( G \\)"})," tries to fool a discriminator ",r.createElement(c.A,{text:"\\( D \\)"}),":"),"\n",r.createElement(c.A,{text:"\\[\nL_{\\text{adv}} = \\mathbb{E}\\bigl[\\log D(H_{\\text{gt}}, I_{\\text{gray}})\\bigr] + \\mathbb{E}\\bigl[\\log \\bigl(1 - D(H_{\\text{gen}}, I_{\\text{gray}})\\bigr)\\bigr],\n\\]"}),"\n",r.createElement(t.p,null,"where ",r.createElement(c.A,{text:"\\( H_{\\text{gt}} \\)"})," and ",r.createElement(c.A,{text:"\\( H_{\\text{gen}} \\)"})," might be edge or boundary maps of the ground truth and generated images, and ",r.createElement(c.A,{text:"\\( I_{\\text{gray}} \\)"})," some grayscale input image. Different inpainting models adapt the adversarial loss to their own architecture, sometimes focusing on only the inpainted region (local discriminator), or the entire image (global discriminator), or both."),"\n"),"\n",r.createElement(t.li,null,"\n",r.createElement(t.p,null,r.createElement(t.strong,null,"Feature-matching loss"),r.createElement(t.br),"\n","Encourages the intermediate feature representations of the real and generated images, as computed by the discriminator's hidden layers, to be similar:"),"\n",r.createElement(c.A,{text:"\\[\nL_{\\text{FM}} = \\mathbb{E}\\Bigl[\\sum_{i=1}^L \\frac{1}{N_i}\\|D^{(i)}(H_{\\text{gt}}) - D^{(i)}(H_{\\text{gen}})\\|\\Bigr],\n\\]"}),"\n",r.createElement(t.p,null,"where ",r.createElement(c.A,{text:"\\( D^{(i)} \\)"})," is the ",r.createElement(c.A,{text:"\\( i \\)"}),"-th layer's activations of the discriminator, and ",r.createElement(c.A,{text:"\\( N_i \\)"})," is the dimension of that layer."),"\n"),"\n"),"\n",r.createElement(t.p,null,"In practice, many advanced inpainting models combine several of these losses, each weighted by a hyperparameter to balance low-level fidelity, style, and global realism. For instance, a model might have a total loss like:"),"\n",r.createElement(c.A,{text:"\\[\nL = \\lambda_{\\text{rec}} L_{\\text{per-pixel}} + \\lambda_{\\text{perc}} L_{\\text{percept}} \n+ \\lambda_{\\text{style}} L_{\\text{style}} + \\lambda_{\\text{adv}} L_{\\text{adv}} + \\dots\n\\]"}),"\n",r.createElement(t.h3,{id:"model-hyperparameters-and-tuning-strategies",style:{position:"relative"}},r.createElement(t.a,{href:"#model-hyperparameters-and-tuning-strategies","aria-label":"model hyperparameters and tuning strategies permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Model hyperparameters and tuning strategies"),"\n",r.createElement(t.p,null,"Hyperparameter choices in inpainting models vary widely. Some common ones include:"),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Learning rate"),": Typically in the range of ",r.createElement(c.A,{text:"\\(10^{-4}\\)"})," to ",r.createElement(c.A,{text:"\\(10^{-5}\\)"})," for generator networks in adversarial training, with the discriminator often trained at a slightly different rate or using distinct scheduling."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Batch size"),": Larger batches can stabilize training, but memory constraints sometimes limit the maximum size. In inpainting tasks, patch-based or region-based training might reduce the effective image size needed."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Loss weighting"),": The relative weights among the reconstruction loss, perceptual loss, style loss, and adversarial loss can drastically affect the final visual quality. A typical approach is to start with a stronger pixel or perceptual term (for stable content) and gradually increase the adversarial term to add more realistic details once the basic structure is learned."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Mask generation strategy"),": For free-form inpainting, random strokes or shapes can be used. The percentage of removed pixels can also be varied (e.g., from small random holes to very large occlusions)."),"\n"),"\n",r.createElement(t.p,null,"Tuning these parameters is often empirical. Researchers commonly rely on a validation set of masked images and compare metrics such as SSIM or user-based perceptual judgments to decide which hyperparameter setting produces the best results."),"\n",r.createElement(t.h3,{id:"practical-tips-for-faster-convergence",style:{position:"relative"}},r.createElement(t.a,{href:"#practical-tips-for-faster-convergence","aria-label":"practical tips for faster convergence permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Practical tips for faster convergence"),"\n",r.createElement(t.ol,null,"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Progressive or coarse-to-fine training"),": Start with a smaller image resolution or smaller missing region, then gradually increase complexity. This approach can help the model learn global structure first before focusing on fine details."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Use pretrained encoders"),": Employing a backbone (like a pretrained VGG or ResNet) to encode the image can significantly speed up training and improve the quality of the latent features."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Multi-stage architecture"),": Some models do a rough fill, then pass the partially completed image to a second network for refinement. This can yield sharper textures in large missing regions."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Employ advanced normalization"),": Techniques like spectral normalization, instance normalization, or batch normalization with carefully chosen parameters can keep training stable and reduce artifacts."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Prevent mode collapse"),": In adversarial training, periodically check that the discriminator is not overpowering the generator or vice versa. Adjust the learning rates or training frequency of each network accordingly."),"\n"),"\n",r.createElement(t.hr),"\n",r.createElement(t.h2,{id:"evaluation-metrics",style:{position:"relative"}},r.createElement(t.a,{href:"#evaluation-metrics","aria-label":"evaluation metrics permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Evaluation metrics"),"\n",r.createElement(t.p,null,"Evaluating inpainting is tricky because an image can be filled in multiple plausible ways, and purely pixel-wise metrics are not always reflective of perceived visual quality."),"\n",r.createElement(t.h3,{id:"peak-signal-to-noise-ratio-psnr",style:{position:"relative"}},r.createElement(t.a,{href:"#peak-signal-to-noise-ratio-psnr","aria-label":"peak signal to noise ratio psnr permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Peak signal-to-noise ratio (PSNR)"),"\n",r.createElement(t.p,null,r.createElement(c.A,{text:"\\( \\text{PSNR} \\)"})," is a classic metric for image restoration tasks, computed as:"),"\n",r.createElement(c.A,{text:"\\[\n\\text{PSNR}(I_{\\text{gen}}, I_{\\text{gt}}) = 10 \\cdot \\log_{10}\\Bigl(\\frac{ \\max(I_{\\text{gt}})^2 }{ \\text{MSE}(I_{\\text{gen}}, I_{\\text{gt}}) }\\Bigr),\n\\]"}),"\n",r.createElement(t.p,null,"where ",r.createElement(c.A,{text:"\\( \\text{MSE} \\)"})," is the mean squared error between generated and ground truth images. While PSNR can be useful for narrower tasks such as denoising, it often correlates poorly with subjective judgments, especially for larger missing regions."),"\n",r.createElement(t.h3,{id:"structural-similarity-index-measure-ssim",style:{position:"relative"}},r.createElement(t.a,{href:"#structural-similarity-index-measure-ssim","aria-label":"structural similarity index measure ssim permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Structural similarity index measure (SSIM)"),"\n",r.createElement(t.p,null,r.createElement(c.A,{text:"\\( \\text{SSIM} \\)"})," is more perceptually inspired, comparing luminance, contrast, and structural information in a patchwise manner:"),"\n",r.createElement(c.A,{text:"\\[\n\\text{SSIM}(x,y) = \\frac{(2\\mu_x \\mu_y + C_1)(2\\sigma_{xy}+C_2)}{(\\mu_x^2+\\mu_y^2 + C_1)(\\sigma_x^2+\\sigma_y^2 + C_2)},\n\\]"}),"\n",r.createElement(t.p,null,"where ",r.createElement(c.A,{text:"\\( \\mu \\)"})," and ",r.createElement(c.A,{text:"\\( \\sigma \\)"})," denote patch means and standard deviations. SSIM can be more aligned with human perception than PSNR but is still not perfect for evaluating the realism of large-scale inpainting."),"\n",r.createElement(t.h3,{id:"perceptual-metrics-and-human-evaluation",style:{position:"relative"}},r.createElement(t.a,{href:"#perceptual-metrics-and-human-evaluation","aria-label":"perceptual metrics and human evaluation permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Perceptual metrics and human evaluation"),"\n",r.createElement(t.p,null,"An alternative is to measure how well the generated images fool pretrained classifiers or how close their higher-level feature distributions align with real images. Some works use ",r.createElement(t.em,null,"FID (Fréchet Inception Distance)")," or ",r.createElement(t.em,null,"LPIPS (Learned Perceptual Image Patch Similarity)")," to quantify perceptual distances. Ultimately, many studies also rely on ",r.createElement(t.strong,null,"human evaluation")," — asking human annotators to compare real vs. inpainted results or to pick the most realistic fill among multiple candidate completions."),"\n",r.createElement(t.h3,{id:"trade-offs-between-quantitative-and-qualitative-assessments",style:{position:"relative"}},r.createElement(t.a,{href:"#trade-offs-between-quantitative-and-qualitative-assessments","aria-label":"trade offs between quantitative and qualitative assessments permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Trade-offs between quantitative and qualitative assessments"),"\n",r.createElement(t.p,null,"In real-world usage, small differences in PSNR or SSIM may be meaningless if an image subjectively looks better. On the other hand, relying exclusively on subjective metrics can obscure consistent biases or artifacts. Consequently, a combination of metrics — including user studies, reference-based metrics (PSNR, SSIM, etc.), and distribution-based metrics (FID, etc.) — is typically employed to draw robust conclusions about an inpainting model's performance."),"\n",r.createElement(t.hr),"\n",r.createElement(t.h2,{id:"applications",style:{position:"relative"}},r.createElement(t.a,{href:"#applications","aria-label":"applications permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Applications"),"\n",r.createElement(t.p,null,"Inpainting has a variety of practical uses across domains:"),"\n",r.createElement(t.ol,null,"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Photo retouching and object removal"),': Removing unwanted objects (like power lines, blemishes, or photo-bombers) is perhaps the most popular usage. Applications like Adobe Photoshop\'s "Content-Aware Fill" rely on advanced inpainting to produce seamless results.'),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Historical document and artwork restoration"),": Classical PDE-based and patch-based inpainting are widely used to restore old paintings or documents that have cracks, stains, or missing pieces. Deep learning methods are beginning to augment or replace these classical techniques."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Image-based editing"),": With user guidance, advanced models like SC-FEGAN or DeepFillv2 can not only remove objects but also fill them with sketches or custom textures. This is especially popular for face editing — for example, removing or redrawing hair, changing eye color, or adding new accessories."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Medical imaging"),": Inpainting can help remove artifacts in MRI or CT scans or fill in missing slices. Researchers have also used it for data anonymization, e.g. removing identifying features from scans, though caution is needed if the inpainting distorts clinically relevant areas."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Video inpainting"),": An extension of image inpainting to videos must consider temporal coherence. PDE-based approaches have been extended to 3D (2D space + time), and deep networks incorporate recurrent or 3D convolutions to fill missing frames in a temporally consistent manner."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"AR/VR content creation"),": In augmented or virtual reality, inpainting can be leveraged to fill occluded backgrounds when objects or participants are removed, or to create 360° panoramas with no visible seams."),"\n"),"\n",r.createElement(t.hr),"\n",r.createElement(t.h2,{id:"challenges-and-limitations",style:{position:"relative"}},r.createElement(t.a,{href:"#challenges-and-limitations","aria-label":"challenges and limitations permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Challenges and limitations"),"\n",r.createElement(t.p,null,"Despite major advances in generative models, inpainting still faces numerous challenges:"),"\n",r.createElement(t.ol,null,"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Large missing regions"),': As the hole size grows, it becomes increasingly difficult to produce correct global structure. Models must effectively "hallucinate" entire objects or backgrounds.'),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Complex, high-frequency textures"),": Fine textures like fur, hair, or intricate patterns can be tough to synthesize realistically without repetition or obvious artifacts."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Semantic ambiguity"),": There might be multiple plausible ways to fill a missing region. Single-output models often choose a single guess that may or may not align with the user's desired outcome. More recent work (e.g., ",r.createElement(t.em,null,"Pluralistic Image Completion"),") tries to offer multiple completions."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Overfitting and domain specificity"),": An inpainting model trained primarily on certain scenes (e.g., faces) may produce strange completions when confronted with very different data (e.g., outdoor landscapes)."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"User input"),": Some advanced methods allow the user to supply sketches or color hints to guide the fill. While this can produce better results, it also requires a specialized user interface and carefully designed network inputs."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Computational cost"),": Large-scale or high-resolution inpainting networks, especially those with multi-stage refinement or large discriminators, require significant GPU resources. For real-time or embedded applications, this can be prohibitive."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Temporal consistency (video)"),": In videos, the inpainted region should remain consistent across frames, an even harder constraint. Many algorithms that work for single images struggle with flickering or shifting artifacts in the temporal domain."),"\n"),"\n",r.createElement(t.hr),"\n",r.createElement(t.h2,{id:"extended-discussion-of-modern-models-and-references",style:{position:"relative"}},r.createElement(t.a,{href:"#extended-discussion-of-modern-models-and-references","aria-label":"extended discussion of modern models and references permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Extended discussion of modern models and references"),"\n",r.createElement(t.p,null,"Before concluding, let's highlight a few state-of-the-art networks that illustrate the progress and the broad design space of inpainting:"),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,"\n",r.createElement(t.p,null,r.createElement(t.strong,null,"SC-FEGAN")," (Jo and Park, SIGGRAPH Asia 2019): Focuses on face editing with user sketches. A single discriminator takes as input the generated image, mask, and user sketch, enabling flexible modifications such as redrawing parts of a face, changing hair style, etc."),"\n"),"\n",r.createElement(t.li,null,"\n",r.createElement(t.p,null,r.createElement(t.strong,null,"DeepFillv2")," (Yu and gang, ECCV 2018): Introduces ",r.createElement(t.em,null,"gated convolution")," for free-form masks, plus an advanced patch-based discriminator (SN-PatchGAN) that adaptively focuses on different image parts. Combines a coarse network and a refinement network for high-quality results."),"\n"),"\n",r.createElement(t.li,null,"\n",r.createElement(t.p,null,r.createElement(t.strong,null,"Pluralistic Image Completion")," (Zheng and gang, CVPR 2019): Produces multiple plausible completions by modeling the missing region using a learned prior distribution. Users can pick whichever completion best fits their taste, thus addressing the inherent ambiguity in large missing areas."),"\n"),"\n",r.createElement(t.li,null,"\n",r.createElement(t.p,null,r.createElement(t.strong,null,"EdgeConnect")," (Nazeri and gang, BMVC 2019): Splits inpainting into an edge-generation stage and a content-completion stage. The first network is a generator/discriminator that attempts to predict edges of the missing region; the second then inpaints the image guided by these edges. PatchGAN-based training is used to encourage local realism."),"\n"),"\n",r.createElement(t.li,null,"\n",r.createElement(t.p,null,r.createElement(t.strong,null,"Deep Image Prior")," (Ulyanov and gang, CVPR 2018): Intriguingly requires no external dataset. It trains a network from scratch on a single image, leveraging the fact that CNN architecture itself imposes sufficient structure to prioritize meaningful image content over noise. This method can be slow for large images, but it is widely cited as an elegant demonstration that the structure of a CNN can serve as a powerful image prior, even without large-scale training data."),"\n"),"\n"),"\n",r.createElement(t.hr),"\n",r.createElement(t.h2,{id:"example-code-snippet",style:{position:"relative"}},r.createElement(t.a,{href:"#example-code-snippet","aria-label":"example code snippet permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Example code snippet"),"\n",r.createElement(t.p,null,"Below is a simplified example in PyTorch of how one might set up a training loop for an inpainting generator network. It is highly abridged and omits many details — for instance, the creation of the network architecture, the discriminator, or the advanced loss terms. Nevertheless, it offers a glance at the typical flow:"),"\n",r.createElement(s.A,{text:'\nimport torch\nimport torch.nn as nn\nimport torch.optim as optim\n\n# Suppose we have a generator network g_model, \n# a discriminator d_model, and a dataset of (image, mask) pairs.\n\ng_optimizer = optim.Adam(g_model.parameters(), lr=1e-4, betas=(0.5, 0.999))\nd_optimizer = optim.Adam(d_model.parameters(), lr=4e-4, betas=(0.5, 0.999))\n\ncriterion_adv = nn.BCEWithLogitsLoss()\ncriterion_l1 = nn.L1Loss()\n\nfor epoch in range(num_epochs):\n    for images, masks in dataloader:\n        # images: [batch_size, 3, H, W]\n        # masks:  [batch_size, 1, H, W] (1 means masked, 0 means valid)\n        \n        images = images.to(device)\n        masks = masks.to(device)\n        \n        # Create input by combining the masked region.\n        # For instance, we can zero out the masked region in images.\n        input_with_holes = images * (1 - masks)\n        \n        # === Train Generator ===\n        g_optimizer.zero_grad()\n        generated = g_model(input_with_holes, masks)  \n        # Typically, the generator might condition on both the partial image and the mask.\n        \n        # Compute some adversarial loss\n        pred_fake = d_model(generated, masks)\n        adv_loss = criterion_adv(pred_fake, torch.ones_like(pred_fake))\n        \n        # Compute L1 reconstruction loss (only on masked area)\n        l1_loss = criterion_l1(generated * masks, images * masks)\n        \n        g_loss = adv_loss + lambda_l1 * l1_loss\n        g_loss.backward()\n        g_optimizer.step()\n        \n        # === Train Discriminator ===\n        d_optimizer.zero_grad()\n        # Real images\n        pred_real = d_model(images, masks)\n        d_loss_real = criterion_adv(pred_real, torch.ones_like(pred_real))\n        \n        # Fake images\n        pred_fake_d = d_model(generated.detach(), masks)\n        d_loss_fake = criterion_adv(pred_fake_d, torch.zeros_like(pred_fake_d))\n        \n        d_loss = (d_loss_real + d_loss_fake) / 2\n        d_loss.backward()\n        d_optimizer.step()\n        \n    print(f"Epoch [{epoch}/{num_epochs}] -- G_loss: {g_loss.item():.4f}, D_loss: {d_loss.item():.4f}")\n'}),"\n",r.createElement(t.p,null,"Of course, real inpainting code is more sophisticated, typically including perceptual losses, style losses, or partial/gated convolutions. Additionally, it's common to adopt multi-scale discriminators or incorporate advanced normalization layers to stabilize training. Nonetheless, the principle remains: the generator tries to fill the masked regions in a visually realistic manner, and the discriminator tries to discriminate between real and generated images."),"\n",r.createElement(t.hr),"\n",r.createElement(t.h2,{id:"final-thoughts",style:{position:"relative"}},r.createElement(t.a,{href:"#final-thoughts","aria-label":"final thoughts permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Final thoughts"),"\n",r.createElement(t.p,null,"Image inpainting stands at the crossroads between classical computer vision (with PDE-based and variational methods) and modern deep learning (with CNN- or GAN-based generative models). The new wave of deep networks has drastically improved both the speed and quality of inpainting, going from strictly texture-based completions to generating entire plausible objects that respect global context and semantics. Nevertheless, inpainting remains an active research area, with ongoing investigations into:"),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Handling extremely large or irregular holes")),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Modeling multi-modal or uncertain completions")," (where many reconstructions are equally valid)"),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Improving user-guided inpainting")," with better sketches or color hints"),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Reducing reliance on large supervised datasets")," (e.g., self-supervised or single-image methods)"),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Extending to video or 3D inpainting")," with consistent results over time or across different viewpoints"),"\n"),"\n",r.createElement(t.p,null,"From a practical perspective, the future of inpainting will likely see more synergy with interactive user interfaces, letting artists, photographers, or general users precisely control how their images are restored or manipulated. Meanwhile, advanced pipelines in medical imaging, historical restoration, and augmented reality will increasingly rely on inpainting solutions that are robust, domain-aware, and computationally efficient."),"\n",r.createElement(n,{alt:"Inpainting illustration",path:"",caption:"Conceptual illustration showing a large masked area and the predicted reconstruction.",zoom:"false"}),"\n",r.createElement(t.p,null,"The continued refinement of generative methods — including partial convolutions, gated convolutions, attention-based mechanisms, diffusion models, and normalizing flows — promises that the boundary between a missing region and a newly synthesized region will become ever more invisible to the naked eye, pushing us closer to the ultimate goal: truly seamless, semantically accurate image completions."),"\n",r.createElement(t.hr),"\n",r.createElement(t.h3,{id:"references-and-further-reading",style:{position:"relative"}},r.createElement(t.a,{href:"#references-and-further-reading","aria-label":"references and further reading permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"References and further reading"),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,'Bertalmio, M., Bertozzi, A. L., & Sapiro, G. (2001). "Navier–Stokes, Fluid Dynamics, and Image and Video Inpainting". ',r.createElement(t.em,null,"CVPR.")),"\n",r.createElement(t.li,null,'Iizuka, S., Simo-Serra, E., & Ishikawa, H. (2017). "Globally and Locally Consistent Image Completion". ',r.createElement(t.em,null,"ACM Transactions on Graphics (SIGGRAPH).")),"\n",r.createElement(t.li,null,'Jo, Y., & Park, J. (2019). "SC-FEGAN: Face Editing Generative Adversarial Network with User\'s Sketch and Color". ',r.createElement(t.em,null,"SIGGRAPH Asia.")),"\n",r.createElement(t.li,null,'Nazeri, K., Ng, E., Joseph, T., Qureshi, F. Z., & Ebrahimi, M. (2019). "EdgeConnect: Generative Image Inpainting with Adversarial Edge Learning". ',r.createElement(t.em,null,"BMVC.")),"\n",r.createElement(t.li,null,'Ronneberger, O., Fischer, P., & Brox, T. (2015). "U-Net: Convolutional Networks for Biomedical Image Segmentation". ',r.createElement(t.em,null,"MICCAI.")),"\n",r.createElement(t.li,null,'Simonyan, K., & Zisserman, A. (2015). "Very Deep Convolutional Networks for Large-Scale Image Recognition". ',r.createElement(t.em,null,"ICLR.")),"\n",r.createElement(t.li,null,'Telea, A. (2004). "An Image Inpainting Technique Based on the Fast Marching Method". ',r.createElement(t.em,null,"Journal of Graphics Tools.")),"\n",r.createElement(t.li,null,'Ulyanov, D., Vedaldi, A., & Lempitsky, V. (2018). "Deep Image Prior". ',r.createElement(t.em,null,"CVPR.")),"\n",r.createElement(t.li,null,'Yu, J., Lin, Z., Yang, J., Shen, X., Lu, X., & Huang, T. (2018). "Free-Form Image Inpainting with Gated Convolution". ',r.createElement(t.em,null,"ECCV.")),"\n",r.createElement(t.li,null,'Zheng, C., Cham, T.-J., & Cai, J. (2019). "Pluralistic Image Completion". ',r.createElement(t.em,null,"CVPR.")),"\n"),"\n",r.createElement(n,{alt:"EdgeConnect architecture",path:"",caption:"Illustration of the EdgeConnect approach, which splits boundary prediction and content completion.",zoom:"false"}),"\n",r.createElement(t.p,null,"These works, among others presented at top-tier conferences such as NeurIPS, ICCV, CVPR, and ICML, continue to push the frontier of inpainting research. For those looking to dive deeper, I suggest exploring the open-source implementations (many are publicly available on GitHub), experimenting with variations of data augmentation strategies, and testing different combinations of losses to see how each model behaves for your specific domain."),"\n",r.createElement(t.p,null,"By understanding the deeper theoretical underpinnings (PDE-based or energy minimization) and the advanced neural architectures (GAN-based, partial convolution, multi-stage, or otherwise), you will be well-equipped to tackle real-world inpainting challenges and potentially innovate new solutions that blend classical rigor with the powerful generative modeling capabilities of deep learning."))}var d=function(e){void 0===e&&(e={});const{wrapper:t}=Object.assign({},(0,i.RP)(),e.components);return t?r.createElement(t,e,r.createElement(m,e)):m(e)};var h=n(36710),u=n(58481),g=n.n(u),p=n(36310),f=n(87245),v=n(27042),E=n(59849),y=n(5591),b=n(61122),w=n(9219),x=n(33203),k=n(95751),S=n(94328),_=n(80791),I=n(78137);const C=e=>{let{toc:t}=e;if(!t||!t.items)return null;return r.createElement("nav",{className:_.R},r.createElement("ul",null,t.items.map(((e,t)=>r.createElement("li",{key:t},r.createElement("a",{href:e.url,onClick:t=>((e,t)=>{e.preventDefault();const n=t.replace("#",""),a=document.getElementById(n);a&&a.scrollIntoView({behavior:"smooth",block:"start"})})(t,e.url)},e.title),e.items&&r.createElement(C,{toc:{items:e.items}}))))))};function N(e){let{data:{mdx:t,allMdx:l,allPostImages:o},children:s}=e;const{frontmatter:c,body:m,tableOfContents:d}=t,h=c.index,u=c.slug.split("/")[1],E=l.nodes.filter((e=>e.frontmatter.slug.includes(`/${u}/`))).sort(((e,t)=>e.frontmatter.index-t.frontmatter.index)),_=E.findIndex((e=>e.frontmatter.index===h)),N=E[_+1],z=E[_-1],M=c.slug.replace(/\/$/,""),A=/[^/]*$/.exec(M)[0],T=`posts/${u}/content/${A}/`,{0:L,1:H}=(0,r.useState)(c.flagWideLayoutByDefault),{0:P,1:j}=(0,r.useState)(!1);var D;(0,r.useEffect)((()=>{j(!0);const e=setTimeout((()=>j(!1)),340);return()=>clearTimeout(e)}),[L]),"adventures"===u?D=w.cb:"research"===u?D=w.Qh:"thoughts"===u&&(D=w.T6);const V=g()(m).replace(/import .*? from .*?;/g,"").replace(/<.*?>/g,"").replace(/\{\/\*[\s\S]*?\*\/\}/g,"").trim().split(/\s+/).length,G=function(e){if(e<=10)return"~10 min";if(e<=20)return"~20 min";if(e<=30)return"~30 min";if(e<=40)return"~40 min";if(e<=50)return"~50 min";if(e<=60)return"~1 h";const t=Math.floor(e/60),n=e%60;return n<=30?`~${t}${n>0?".5":""} h`:`~${t+1} h`}(Math.ceil(V/D)+(c.extraReadTimeMin||0)),B=[{flag:c.flagDraft,component:()=>Promise.all([n.e(3231),n.e(8809)]).then(n.bind(n,28809))},{flag:c.flagMindfuckery,component:()=>Promise.all([n.e(3231),n.e(2471)]).then(n.bind(n,67709))},{flag:c.flagRewrite,component:()=>Promise.all([n.e(3231),n.e(6764)]).then(n.bind(n,62002))},{flag:c.flagOffensive,component:()=>Promise.all([n.e(3231),n.e(2443)]).then(n.bind(n,17681))},{flag:c.flagProfane,component:()=>Promise.all([n.e(3231),n.e(8048)]).then(n.bind(n,53286))},{flag:c.flagMultilingual,component:()=>Promise.all([n.e(3231),n.e(4069)]).then(n.bind(n,78831))},{flag:c.flagUnreliably,component:()=>Promise.all([n.e(3231),n.e(3417)]).then(n.bind(n,8179))},{flag:c.flagPolitical,component:()=>Promise.all([n.e(3231),n.e(5195)]).then(n.bind(n,30433))},{flag:c.flagCognitohazard,component:()=>Promise.all([n.e(3231),n.e(3175)]).then(n.bind(n,8413))},{flag:c.flagHidden,component:()=>Promise.all([n.e(3231),n.e(9556)]).then(n.bind(n,14794))}],{0:q,1:R}=(0,r.useState)([]);return(0,r.useEffect)((()=>{B.forEach((e=>{let{flag:t,component:n}=e;t&&n().then((e=>{R((t=>[].concat((0,a.A)(t),[e.default])))}))}))}),[]),r.createElement(v.P.div,{initial:{opacity:0},animate:{opacity:1},exit:{opacity:0},transition:{duration:.15}},r.createElement(y.A,{postNumber:c.index,date:c.date,updated:c.updated,readTime:G,difficulty:c.difficultyLevel,title:c.title,desc:c.desc,banner:c.banner,section:u,postKey:A,isMindfuckery:c.flagMindfuckery,mainTag:c.mainTag}),r.createElement("div",{style:{display:"flex",justifyContent:"flex-end",flexWrap:"wrap",maxWidth:"75%",marginLeft:"auto",paddingRight:"1vw",marginTop:"-6vh",marginBottom:"4vh"}},c.otherTags.map(((e,t)=>r.createElement("span",{key:t,className:`noselect ${I.MW}`,style:{margin:"0 5px 5px 0"}},e)))),r.createElement("div",{class:"postBody"},r.createElement(C,{toc:d})),r.createElement("br"),r.createElement("div",{style:{margin:"0 10% -2vh 30%",textAlign:"right"}},r.createElement(v.P.button,{class:"noselect",className:S.pb,id:S.xG,onClick:()=>{H(!L)},whileTap:{scale:.93}},r.createElement(v.P.div,{className:k.DJ,key:L,initial:{opacity:0},animate:{opacity:1},exit:{opacity:0},transition:{duration:.3,ease:"easeInOut"}},L?"Switch to default layout":"Switch to wide layout"))),r.createElement("br"),r.createElement("div",{class:"postBody",style:{margin:L?"0 -14%":"",maxWidth:L?"200%":"",transition:"margin 1s ease, max-width 1s ease, padding 1s ease"}},r.createElement("div",{className:`${S.P_} ${P?S.Xn:S.qG}`},q.map(((e,t)=>r.createElement(e,{key:t}))),c.indexCourse?r.createElement(x.A,{index:c.indexCourse,category:c.courseCategoryName}):"",r.createElement(p.Z.Provider,{value:{images:o.nodes,basePath:T.replace(/\/$/,"")+"/"}},r.createElement(i.xA,{components:{Image:f.A}},s)))),r.createElement(b.A,{nextPost:N,lastPost:z,keyCurrent:A,section:u}))}function z(e){return r.createElement(N,e,r.createElement(d,e))}function M(e){var t,n,a,i,l;let{data:o}=e;const{frontmatter:s}=o.mdx,c=s.titleSEO||s.title,m=s.titleOG||c,d=s.titleTwitter||c,u=s.descSEO||s.desc,g=s.descOG||u,p=s.descTwitter||u,f=s.schemaType||"BlogPosting",v=s.keywordsSEO,y=s.date,b=s.updated||y,w=s.imageOG||(null===(t=s.banner)||void 0===t||null===(n=t.childImageSharp)||void 0===n||null===(a=n.gatsbyImageData)||void 0===a||null===(i=a.images)||void 0===i||null===(l=i.fallback)||void 0===l?void 0:l.src),x=s.imageAltOG||g,k=s.imageTwitter||w,S=s.imageAltTwitter||p,_=s.canonicalURL,I=s.flagHidden||!1,C=s.mainTag||"Posts",N=s.slug.split("/")[1]||"posts",{siteUrl:z}=(0,h.Q)(),M={"@context":"https://schema.org","@type":"BreadcrumbList",itemListElement:[{"@type":"ListItem",position:1,name:"Home",item:z},{"@type":"ListItem",position:2,name:C,item:`${z}/${s.slug.split("/")[1]}`},{"@type":"ListItem",position:3,name:c,item:`${z}${s.slug}`}]};return r.createElement(E.A,{title:c+" - avrtt.blog",titleOG:m,titleTwitter:d,description:u,descriptionOG:g,descriptionTwitter:p,schemaType:f,keywords:v,datePublished:y,dateModified:b,imageOG:w,imageAltOG:x,imageTwitter:k,imageAltTwitter:S,canonicalUrl:_,flagHidden:I,mainTag:C,section:N,type:"article"},r.createElement("script",{type:"application/ld+json"},JSON.stringify(M)))}},3962:function(e,t){t.A="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iaXNvLTg4NTktMSI/Pgo8IS0tIEdlbmVyYXRvcjogQWRvYmUgSWxsdXN0cmF0b3IgMTYuMC4wLCBTVkcgRXhwb3J0IFBsdWctSW4gLiBTVkcgVmVyc2lvbjogNi4wMCBCdWlsZCAwKSAgLS0+CjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+CjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iQ2FwYV8xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4PSIwcHgiIHk9IjBweCIKCSB3aWR0aD0iNDE2Ljk3OXB4IiBoZWlnaHQ9IjQxNi45NzlweCIgdmlld0JveD0iMCAwIDQxNi45NzkgNDE2Ljk3OSIgc3R5bGU9ImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgNDE2Ljk3OSA0MTYuOTc5OyIKCSB4bWw6c3BhY2U9InByZXNlcnZlIj4KPGc+Cgk8cGF0aCBkPSJNMzU2LjAwNCw2MS4xNTZjLTgxLjM3LTgxLjQ3LTIxMy4zNzctODEuNTUxLTI5NC44NDgtMC4xODJjLTgxLjQ3LDgxLjM3MS04MS41NTIsMjEzLjM3OS0wLjE4MSwyOTQuODUKCQljODEuMzY5LDgxLjQ3LDIxMy4zNzgsODEuNTUxLDI5NC44NDksMC4xODFDNDM3LjI5MywyNzQuNjM2LDQzNy4zNzUsMTQyLjYyNiwzNTYuMDA0LDYxLjE1NnogTTIzNy42LDM0MC43ODYKCQljMCwzLjIxNy0yLjYwNyw1LjgyMi01LjgyMiw1LjgyMmgtNDYuNTc2Yy0zLjIxNSwwLTUuODIyLTIuNjA1LTUuODIyLTUuODIyVjE2Ny44ODVjMC0zLjIxNywyLjYwNy01LjgyMiw1LjgyMi01LjgyMmg0Ni41NzYKCQljMy4yMTUsMCw1LjgyMiwyLjYwNCw1LjgyMiw1LjgyMlYzNDAuNzg2eiBNMjA4LjQ5LDEzNy45MDFjLTE4LjYxOCwwLTMzLjc2Ni0xNS4xNDYtMzMuNzY2LTMzLjc2NQoJCWMwLTE4LjYxNywxNS4xNDctMzMuNzY2LDMzLjc2Ni0zMy43NjZjMTguNjE5LDAsMzMuNzY2LDE1LjE0OCwzMy43NjYsMzMuNzY2QzI0Mi4yNTYsMTIyLjc1NSwyMjcuMTA3LDEzNy45MDEsMjA4LjQ5LDEzNy45MDF6Ii8+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPC9zdmc+Cg=="},66501:function(e,t,n){n.d(t,{A:function(){return l}});var a=n(96540),i=n(3962),r="styles-module--tooltiptext--a263b";var l=e=>{let{text:t,isBadge:n=!1}=e;const{0:l,1:o}=(0,a.useState)(!1),s=(0,a.useRef)(null);return(0,a.useEffect)((()=>{function e(e){s.current&&!s.current.contains(e.target)&&o(!1)}return document.addEventListener("click",e),()=>{document.removeEventListener("click",e)}}),[]),a.createElement("span",{className:"styles-module--tooltipWrapper--75ebf",ref:s},a.createElement("img",{id:n?"styles-module--infoBadge--e3d66":"styles-module--info--26c1f",src:i.A,alt:"info",onClick:e=>{e.stopPropagation(),o((e=>!e))}}),a.createElement("span",{className:l?`${r} styles-module--visible--c063c`:r},t))}},96098:function(e,t,n){var a=n(96540),i=n(7978);t.A=e=>{let{text:t}=e;return a.createElement(i.A,null,t)}}}]);
//# sourceMappingURL=component---src-templates-post-js-content-file-path-src-pages-posts-research-inpainting-mdx-2dc2ccb0f4853b43f55c.js.map