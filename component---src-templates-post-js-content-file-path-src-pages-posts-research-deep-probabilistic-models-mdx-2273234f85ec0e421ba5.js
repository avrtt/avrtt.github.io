"use strict";(self.webpackChunkavrtt_blog=self.webpackChunkavrtt_blog||[]).push([[5191],{45614:function(e,t,a){a.r(t),a.d(t,{Head:function(){return M},PostTemplate:function(){return k},default:function(){return A}});var n=a(54506),i=a(28453),r=a(96540),l=a(16886),o=a(46295),s=a(96098);function c(e){const t=Object.assign({p:"p",h3:"h3",a:"a",span:"span",ul:"ul",li:"li",strong:"strong",hr:"hr",h2:"h2",ol:"ol",em:"em"},(0,i.RP)(),e.components);return r.createElement(r.Fragment,null,"\n",r.createElement("br"),"\n","\n","\n",r.createElement(t.p,null,"Deep probabilistic models are machine learning methods that systematically combine the representational power of deep neural networks with principled probabilistic frameworks. On one hand, neural networks excel at modeling complex functions over high-dimensional data; on the other hand, probability theory provides a robust foundation for handling uncertainty and for reasoning under incomplete information. A deep probabilistic model, in essence, leverages both: it includes a deep architecture (e.g., a feed-forward network, convolutional layers, recurrent cells, or more advanced structures) and a probabilistic formulation for latent variables, observed data, or both."),"\n",r.createElement(t.p,null,'In classical machine learning, a neural network typically gives you a single-point estimate (a deterministic mapping from inputs to outputs). Deep probabilistic models generalize this viewpoint. Instead of asking, ""What is the single best output?" we ask, ""What is the probability distribution over possible outputs (or latent states), given the observed data?" This is particularly valuable in scenarios where the data may be noisy, partially observed, or very high dimensional.'),"\n",r.createElement(t.p,null,"Furthermore, many deep probabilistic models adopt latent variable frameworks. A latent variable (often denoted ",r.createElement(s.A,{text:"\\(z\\)"}),") is a hidden random variable that we do not directly observe but believe can explain important regularities in the data ",r.createElement(s.A,{text:"\\(x\\)"}),". By positing a distribution ",r.createElement(s.A,{text:"\\(p(z)\\)"})," and a conditional ",r.createElement(s.A,{text:"\\(p(x \\mid z)\\)"}),", we create flexible and interpretable generative models that can capture complex data distributions without relying solely on direct parameterization in the ",r.createElement(s.A,{text:"\\(x\\)"}),"-space."),"\n",r.createElement(t.p,null,"As we progress through this article, we will encounter many specific examples of deep probabilistic models: from Bayesian neural networks and graphical models to deep latent variable models such as variational autoencoders (VAEs) and deep generative approaches used in large-scale systems. Our focus will be on the underlying probability theory, the algorithmic frameworks for inference (both exact and approximate), and the interplay between deep architectures and uncertainty modeling."),"\n",r.createElement(t.h3,{id:"motivation-and-applications",style:{position:"relative"}},r.createElement(t.a,{href:"#motivation-and-applications","aria-label":"motivation and applications permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"motivation and applications"),"\n",r.createElement(t.p,null,"The motivation for adopting a probabilistic (rather than purely deterministic) perspective in deep learning is rooted in a need for uncertainty quantification and structured representations. Some example domains include:"),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Natural language processing"),": Words and sentences are often ambiguous, and their interpretations can be best captured in a probabilistic sense (e.g., multiple meanings of a phrase)."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Vision"),": An image may have occlusions, multiple objects in uncertain positions, or otherwise incomplete evidence. A probabilistic framework can model the variety of plausible scenes or segmentations."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Reinforcement learning"),": In sequential decision-making, the environment's states and transitions are typically uncertain. A deep probabilistic viewpoint can handle partial observability or belief states."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Time-series"),": Future events in a sequence can be modeled with predictive distributions, capturing the variance and possible future trajectories."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Large-scale web systems"),": For example, in recommendation or question-answering systems (think IBM Watson), we often combine multiple candidate sources of evidence in a probabilistic ensemble. This can help calibrate confidence scores or guide the search among candidate answers."),"\n"),"\n",r.createElement(t.h3,{id:"key-distinctions",style:{position:"relative"}},r.createElement(t.a,{href:"#key-distinctions","aria-label":"key distinctions permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"key distinctions"),"\n",r.createElement(t.p,null,"The main difference between purely deterministic neural networks and deep probabilistic or Bayesian frameworks lies in how they treat parameters and predictions:"),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Deterministic neural networks"),": They learn a single set of network weights. Once trained, they output a single deterministic prediction (though they can appear stochastic if some dropout or random data augmentation is used at inference, that typically is not part of a principled probabilistic mechanism)."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Probabilistic/Bayesian neural networks"),": They treat weights (and/or outputs) as random variables. In a Bayesian approach, you maintain a distribution over weights and integrate over that distribution to make predictions. In many latent variable models, part of the model is a distribution that explains unobserved factors. The prediction is a probability distribution over possible outcomes, not just a single point estimate."),"\n"),"\n",r.createElement(t.hr),"\n",r.createElement(t.h2,{id:"topic-related-probability-refresher",style:{position:"relative"}},r.createElement(t.a,{href:"#topic-related-probability-refresher","aria-label":"topic related probability refresher permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"topic-related probability refresher"),"\n",r.createElement(t.h3,{id:"random-variables",style:{position:"relative"}},r.createElement(t.a,{href:"#random-variables","aria-label":"random variables permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"random variables"),"\n",r.createElement(t.p,null,"A random variable is a variable that can take on different values according to some probability distribution. In the context of deep probabilistic models:"),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Discrete random variables"),": typically used for categorical phenomena (e.g., a class label for classification, or the presence/absence of certain attributes). For instance, in text generation, you might have discrete variables representing tokens."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Continuous random variables"),": typically used for real-valued phenomena (e.g., the location of an object in an image, or a latent code in a variational autoencoder). Gaussian or related distributions often appear in these settings."),"\n"),"\n",r.createElement(t.p,null,"Many deep latent variable models, like VAEs, contain continuous latent variables, while other deep models for text and NLP might incorporate discrete latent structures."),"\n",r.createElement(t.h3,{id:"joint--conditional-distributions",style:{position:"relative"}},r.createElement(t.a,{href:"#joint--conditional-distributions","aria-label":"joint  conditional distributions permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"joint & conditional distributions"),"\n",r.createElement(t.p,null,"For random variables ",r.createElement(s.A,{text:"\\(X\\)"})," and ",r.createElement(s.A,{text:"\\(Y\\)"}),", the joint distribution ",r.createElement(s.A,{text:"\\(p(x, y)\\)"})," encodes the probabilities or densities for pairs of values ",r.createElement(s.A,{text:"(x, y)"}),". Conditional distributions appear when we condition on one variable to get ",r.createElement(s.A,{text:"\\(p(y \\mid x)\\)"}),". In a deep model, we often define a distribution of the form:"),"\n",r.createElement(s.A,{text:"\\[\np_\\theta(x, z) = p_\\theta(z)\\, p_\\theta(x \\mid z),\n\\]"}),"\n",r.createElement(t.p,null,"where ",r.createElement(s.A,{text:"\\(z\\)"})," is a latent variable. This factorization into ",r.createElement(s.A,{text:"\\(p_\\theta(z)\\)"})," (the prior) and ",r.createElement(s.A,{text:"\\(p_\\theta(x \\mid z)\\)"})," (the likelihood or observation model) is central to many generative models."),"\n",r.createElement(t.h3,{id:"marginalization--factorization",style:{position:"relative"}},r.createElement(t.a,{href:"#marginalization--factorization","aria-label":"marginalization  factorization permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"marginalization & factorization"),"\n",r.createElement(t.p,null,"Marginalization is the operation of integrating or summing out hidden variables. For example, to obtain ",r.createElement(s.A,{text:"\\(p_\\theta(x)\\)"}),", we write:"),"\n",r.createElement(s.A,{text:"\\[\np_\\theta(x) = \\sum_{z} p_\\theta(x, z) \\quad \\text{(if \\(z\\) is discrete)}\n\\]"}),"\n",r.createElement(t.p,null,"or"),"\n",r.createElement(s.A,{text:"\\[\np_\\theta(x) = \\int p_\\theta(x, z)\\, dz \\quad \\text{(if \\(z\\) is continuous).}\n\\]"}),"\n",r.createElement(t.p,null,"In large-scale deep probabilistic models, exactly performing this sum or integral is often intractable, which motivates approximate inference strategies like variational methods."),"\n",r.createElement(t.hr),"\n",r.createElement(t.h2,{id:"likelihood-function-again",style:{position:"relative"}},r.createElement(t.a,{href:"#likelihood-function-again","aria-label":"likelihood function again permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"likelihood function, again"),"\n",r.createElement(t.p,null,"The likelihood function ",r.createElement(s.A,{text:"\\(L(\\theta)\\)"})," for observed data ",r.createElement(s.A,{text:"\\(x\\)"})," is simply ",r.createElement(s.A,{text:"\\(p_\\theta(x)\\)"})," viewed as a function of ",r.createElement(s.A,{text:"\\(\\theta\\)"}),". Maximizing ",r.createElement(s.A,{text:"\\(p_\\theta(x)\\)"}),' typically corresponds to "fitting" or "training" the model parameters ',r.createElement(s.A,{text:"\\(\\theta\\)"}),"."),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"MLE (maximum likelihood estimation)"),": we choose ",r.createElement(s.A,{text:"\\(\\theta\\)"})," to maximize ",r.createElement(s.A,{text:"\\(p_\\theta(x)\\)"}),"."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Log-likelihood"),": often used for numerical stability. We prefer ",r.createElement(s.A,{text:"\\(\\log p_\\theta(x)\\)"})," in optimization, which turns products into sums and can help avoid underflow in large-scale data."),"\n"),"\n",r.createElement(t.p,null,"Consider a dataset ",r.createElement(s.A,{text:"\\( \\{x_i\\}_{i=1}^N\\)"}),". Under an i.i.d. assumption, the likelihood is ",r.createElement(s.A,{text:"\\(\\prod_{i=1}^N p_\\theta(x_i)\\)"}),", or in log-form ",r.createElement(s.A,{text:"\\(\\sum_{i=1}^N \\log p_\\theta(x_i)\\)"}),". Almost all modern large-scale approaches in deep probabilistic models rely on gradient-based optimization of this log-likelihood or some suitable proxy objective (like the evidence lower bound, or ELBO)."),"\n",r.createElement(t.hr),"\n",r.createElement(t.h2,{id:"bayesian-networks-and-graphical-models",style:{position:"relative"}},r.createElement(t.a,{href:"#bayesian-networks-and-graphical-models","aria-label":"bayesian networks and graphical models permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"bayesian networks and graphical models"),"\n",r.createElement(t.h3,{id:"directed-graphical-models",style:{position:"relative"}},r.createElement(t.a,{href:"#directed-graphical-models","aria-label":"directed graphical models permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"directed graphical models"),"\n",r.createElement(t.p,null,"A Bayesian network is a directed acyclic graph whose nodes represent random variables, and edges encode direct conditional dependencies. It factorizes a joint distribution as a product of local conditionals:"),"\n",r.createElement(s.A,{text:"\\[\np(x_1, \\ldots, x_n) = \\prod_{i=1}^n p(x_i \\mid \\text{Parents}(x_i)).\n\\]"}),"\n",r.createElement(t.p,null,"In a deep setting, imagine you have hidden layers ",r.createElement(s.A,{text:"\\(\\mathbf{z}_1, \\mathbf{z}_2, \\ldots\\)"})," forming a deep generative chain. A simplified example might be:"),"\n",r.createElement(s.A,{text:"\\[\n\\mathbf{z}_1 \\sim p_\\theta(\\mathbf{z}_1), \\quad\n\\mathbf{z}_2 \\sim p_\\theta(\\mathbf{z}_2 \\mid \\mathbf{z}_1), \\quad\n\\ldots, \\quad\n\\mathbf{x} \\sim p_\\theta(\\mathbf{x} \\mid \\mathbf{z}_k).\n\\]"}),"\n",r.createElement(t.p,null,"Deep Bayesian networks can represent complicated dependencies, but often come at the cost of more complex inference."),"\n",r.createElement(t.h3,{id:"inference-in-bayesian-networks",style:{position:"relative"}},r.createElement(t.a,{href:"#inference-in-bayesian-networks","aria-label":"inference in bayesian networks permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"inference in bayesian networks"),"\n",r.createElement(t.p,null,"Given a Bayesian network ",r.createElement(s.A,{text:"\\(p_\\theta(\\mathbf{x}, \\mathbf{z})\\)"}),", we want ",r.createElement(s.A,{text:"\\(p_\\theta(\\mathbf{z} \\mid \\mathbf{x})\\)"})," or the marginal ",r.createElement(s.A,{text:"\\(p_\\theta(\\mathbf{x})\\)"}),". Exact summation or integration over ",r.createElement(s.A,{text:"\\(\\mathbf{z}\\)"})," can be expensive or entirely intractable, especially as the dimension or structure grows. Instead, approximate methods (message passing, MCMC, variational inference) are used."),"\n",r.createElement(t.h3,{id:"modeling-complex-systems",style:{position:"relative"}},r.createElement(t.a,{href:"#modeling-complex-systems","aria-label":"modeling complex systems permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"modeling complex systems"),"\n",r.createElement(t.p,null,"Graphical models shine when you want to incorporate domain knowledge in conditional structure. For instance, in sensor fusion or medical diagnosis, you might structure your Bayesian network so it captures well-known conditional independencies. Or in large-scale QA systems (like IBM Watson), a Bayesian network can orchestrate how multiple candidate evidence sources combine into a final answer with a model of uncertainty."),"\n",r.createElement(t.hr),"\n",r.createElement(t.h2,{id:"hidden-markov-models-and-deep-probabilistic-models",style:{position:"relative"}},r.createElement(t.a,{href:"#hidden-markov-models-and-deep-probabilistic-models","aria-label":"hidden markov models and deep probabilistic models permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"hidden markov models and deep probabilistic models"),"\n",r.createElement(t.p,null,"A Hidden Markov Model (HMM) is a type of Bayesian network specialized for sequence data, with the structure ",r.createElement(s.A,{text:"\\(z_1 \\rightarrow z_2 \\rightarrow \\cdots \\rightarrow z_T\\)"})," and ",r.createElement(s.A,{text:"\\(x_t \\leftarrow z_t\\)"})," for ",r.createElement(s.A,{text:"\\(t=1,2,\\ldots,T\\)"}),". The latent states ",r.createElement(s.A,{text:"\\(z_t\\)"})," form a Markov chain, and each ",r.createElement(s.A,{text:"\\(x_t\\)"})," depends only on the corresponding ",r.createElement(s.A,{text:"\\(z_t\\)"}),"."),"\n",r.createElement(t.p,null,r.createElement(t.strong,null,"Deep HMMs")," can incorporate deep neural layers in the emission or transition probabilities. For instance, ",r.createElement(s.A,{text:"\\(p_\\theta(x_t \\mid z_t)\\)"})," might be parameterized by a neural network. Alternatively, we can chain multiple layers of hidden states. Although standard HMMs are limited in expressiveness, adding neural architectures can yield significantly richer sequence models."),"\n",r.createElement(t.hr),"\n",r.createElement(t.h2,{id:"viterbi-algorithm-for-sequence-decoding",style:{position:"relative"}},r.createElement(t.a,{href:"#viterbi-algorithm-for-sequence-decoding","aria-label":"viterbi algorithm for sequence decoding permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"viterbi algorithm for sequence decoding"),"\n",r.createElement(t.h3,{id:"viterbi-recurrence",style:{position:"relative"}},r.createElement(t.a,{href:"#viterbi-recurrence","aria-label":"viterbi recurrence permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"viterbi recurrence"),"\n",r.createElement(t.p,null,"The Viterbi algorithm is a dynamic programming method for finding the most likely hidden state sequence ",r.createElement(s.A,{text:"\\(z_{1:T}\\)"})," given an observation sequence ",r.createElement(s.A,{text:"\\(x_{1:T}\\)"})," in an HMM. If ",r.createElement(s.A,{text:"\\(p(\\mathbf{z}, \\mathbf{x})\\)"})," denotes the joint likelihood of states and observations, Viterbi aims to solve:"),"\n",r.createElement(s.A,{text:"\\[\n\\arg \\max_{z_{1:T}} p(z_1)\\prod_{t=2}^T p(z_t \\mid z_{t-1}) \\prod_{t=1}^T p(x_t \\mid z_t).\n\\]"}),"\n",r.createElement(t.p,null,"The recurrence for ",r.createElement(s.A,{text:"\\(\\delta_t(j)\\)"}),", which denotes the highest probability of any state path reaching state ",r.createElement(s.A,{text:"\\(j\\)"})," at time ",r.createElement(s.A,{text:"\\(t\\)"}),", is typically:"),"\n",r.createElement(s.A,{text:"\\[\n\\delta_{t}(j) = \\Bigl[\\max_i \\delta_{t-1}(i) \\, p(z_t = j \\mid z_{t-1} = i)\\Bigr]\\, p(x_t \\mid z_t = j).\n\\]"}),"\n",r.createElement(t.h3,{id:"use-cases",style:{position:"relative"}},r.createElement(t.a,{href:"#use-cases","aria-label":"use cases permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"use cases"),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Part-of-speech tagging"),": Identify the most likely POS sequence ",r.createElement(s.A,{text:"\\(z_{1:T}\\)"})," for the words in a sentence ",r.createElement(s.A,{text:"\\(x_{1:T}\\)"}),"."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Speech recognition"),": Find the best word or phoneme sequence given acoustic frames."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Other sequence prediction tasks"),": Any domain with Markov assumptions over hidden states."),"\n"),"\n",r.createElement(t.h3,{id:"comparison-with-other-decoding-methods",style:{position:"relative"}},r.createElement(t.a,{href:"#comparison-with-other-decoding-methods","aria-label":"comparison with other decoding methods permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"comparison with other decoding methods"),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Greedy"),": picks the locally best state at each step; not guaranteed globally optimal."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Exhaustive"),": enumerates all possible sequences; for large ",r.createElement(s.A,{text:"\\(T\\)"}),", this is exponential in ",r.createElement(s.A,{text:"\\(T\\)"}),"."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Viterbi"),": polynomial complexity ",r.createElement(s.A,{text:"\\(\\mathcal{O}(T \\cdot \\#\\text{states}^2)\\)"})," for standard HMMs."),"\n"),"\n",r.createElement(t.hr),"\n",r.createElement(t.h2,{id:"baum-welch-algorithm-for-hmm-parameter-estimation",style:{position:"relative"}},r.createElement(t.a,{href:"#baum-welch-algorithm-for-hmm-parameter-estimation","aria-label":"baum welch algorithm for hmm parameter estimation permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"baum-welch algorithm for hmm parameter estimation"),"\n",r.createElement(t.p,null,"The Baum-Welch algorithm is an application of Expectation-Maximization (EM) for HMMs:"),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Expectation step (E)"),": Compute posterior probabilities over latent state sequences given the current model parameters ",r.createElement(s.A,{text:"\\(\\theta\\)"}),". This typically uses the forward-backward procedure."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Maximization step (M)"),": Update ",r.createElement(s.A,{text:"\\(\\theta\\)"})," by maximizing the expected complete-data log-likelihood under those posterior probabilities."),"\n"),"\n",r.createElement(t.h3,{id:"em-approach",style:{position:"relative"}},r.createElement(t.a,{href:"#em-approach","aria-label":"em approach permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"em approach"),"\n",r.createElement(s.A,{text:"\\[\n\\text{E-step}: \\; Q(\\theta, \\theta^{(old)}) = \\mathbb{E}_{p_{\\theta^{(old)}}(z \\mid x)}[\\log p_\\theta(x, z)].\n\\]"}),"\n",r.createElement(s.A,{text:"\\[\n\\text{M-step}: \\; \\theta^{(new)} = \\arg \\max_\\theta \\, Q(\\theta, \\theta^{(old)}).\n\\]"}),"\n",r.createElement(t.h3,{id:"implementation-details",style:{position:"relative"}},r.createElement(t.a,{href:"#implementation-details","aria-label":"implementation details permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"implementation details"),"\n",r.createElement(t.p,null,"When ",r.createElement(s.A,{text:"\\(T\\)"})," or the number of states is large, numerical stability issues (underflow) become central. Typically, logs are used throughout forward-backward computations."),"\n",r.createElement(t.h3,{id:"extensions-beyond-hmm",style:{position:"relative"}},r.createElement(t.a,{href:"#extensions-beyond-hmm","aria-label":"extensions beyond hmm permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"extensions beyond hmm"),"\n",r.createElement(t.p,null,"The same iterative refinement idea extends to other latent variable models â€” any model with hidden ",r.createElement(s.A,{text:"\\(z\\)"})," can in principle use EM if exact computations are tractable or can be approximated (leading to variational EM)."),"\n",r.createElement(t.hr),"\n",r.createElement(t.h2,{id:"deep-probabilistic-models-in-time-series-analysis",style:{position:"relative"}},r.createElement(t.a,{href:"#deep-probabilistic-models-in-time-series-analysis","aria-label":"deep probabilistic models in time series analysis permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"deep probabilistic models in time-series analysis"),"\n",r.createElement(t.p,null,"Time-series often combine:"),"\n",r.createElement(t.ol,null,"\n",r.createElement(t.li,null,"A ",r.createElement(t.strong,null,"latent process")," that evolves over time (like ",r.createElement(s.A,{text:"\\(z_t\\)"})," states)."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Deep neural networks")," that model transitions or emissions in a flexible, high-capacity way."),"\n"),"\n",r.createElement(t.p,null,"Examples:"),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Deep Markov Model (DMM)"),": a continuous-state generalization of HMM, but using neural networks for transitions and emissions."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Recurrent VAEs"),": a variational autoencoder that processes sequential data, capturing high-level features in a latent space but also modeling the time evolution in a flexible manner."),"\n"),"\n",r.createElement(t.hr),"\n",r.createElement(t.h2,{id:"text-pre-processing-for-probabilistic-models",style:{position:"relative"}},r.createElement(t.a,{href:"#text-pre-processing-for-probabilistic-models","aria-label":"text pre processing for probabilistic models permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"text pre-processing for probabilistic models"),"\n",r.createElement(t.p,null,"In natural language processing contexts, we often feed text data ",r.createElement(s.A,{text:"\\(x\\)"})," into deep probabilistic models. Typical steps include:"),"\n",r.createElement(t.h3,{id:"tokenization--normalization",style:{position:"relative"}},r.createElement(t.a,{href:"#tokenization--normalization","aria-label":"tokenization  normalization permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"tokenization & normalization"),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Tokenization"),": Splitting text into tokens (e.g., words, subwords, or characters). This yields a discrete sequence ",r.createElement(s.A,{text:"\\(x_1, x_2, \\ldots\\)"}),"."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Normalization"),": Lowercasing, removing punctuation, possibly lemmatizing. This ensures consistent input forms."),"\n"),"\n",r.createElement(t.h3,{id:"handling-unknown-words--out-of-vocabulary",style:{position:"relative"}},r.createElement(t.a,{href:"#handling-unknown-words--out-of-vocabulary","aria-label":"handling unknown words  out of vocabulary permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"handling unknown words / out-of-vocabulary"),"\n",r.createElement(t.p,null,"In a purely discrete model, an out-of-vocabulary (OOV) word leads to immediate mismatch. Approaches:"),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,"Use an ",r.createElement(l.A,null,"UNK token")," to represent unseen words."),"\n",r.createElement(t.li,null,"Use subword or character-based tokenization to drastically reduce OOV frequency."),"\n",r.createElement(t.li,null,"In a probabilistic language model, the system might place a small probability on all unknown tokens."),"\n"),"\n",r.createElement(t.h3,{id:"feature-engineering-vs-learned-representations",style:{position:"relative"}},r.createElement(t.a,{href:"#feature-engineering-vs-learned-representations","aria-label":"feature engineering vs learned representations permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"feature engineering vs. learned representations"),"\n",r.createElement(t.p,null,"Older pipelines might rely on hand-designed text features (e.g., TF-IDF). Modern deep probabilistic text models directly learn embeddings that better preserve semantic or syntactic structure. E.g., a deep Bayesian text classifier might embed text into a latent space and place a prior on those embeddings."),"\n",r.createElement(t.hr),"\n",r.createElement(t.h2,{id:"part-of-speech-tagging-with-probabilistic-methods",style:{position:"relative"}},r.createElement(t.a,{href:"#part-of-speech-tagging-with-probabilistic-methods","aria-label":"part of speech tagging with probabilistic methods permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"part-of-speech tagging with probabilistic methods"),"\n",r.createElement(t.p,null,"POS tagging is a canonical example for introducing hidden variable models in NLP. We can treat POS tags ",r.createElement(s.A,{text:"\\(z_t\\)"})," as hidden states, with each word ",r.createElement(s.A,{text:"\\(x_t\\)"})," conditionally dependent on ",r.createElement(s.A,{text:"\\(z_t\\)"}),"."),"\n",r.createElement(t.h3,{id:"hmm-for-pos-tagging",style:{position:"relative"}},r.createElement(t.a,{href:"#hmm-for-pos-tagging","aria-label":"hmm for pos tagging permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"hmm for pos tagging"),"\n",r.createElement(t.p,null,"The classic approach uses transitions ",r.createElement(s.A,{text:"\\(p(z_t \\mid z_{t-1})\\)"})," and emissions ",r.createElement(s.A,{text:"\\(p(x_t \\mid z_t)\\)"}),". The Viterbi algorithm finds the best ",r.createElement(s.A,{text:"\\(z_{1:T}\\)"}),"."),"\n",r.createElement(t.h3,{id:"viterbi-in-tagging",style:{position:"relative"}},r.createElement(t.a,{href:"#viterbi-in-tagging","aria-label":"viterbi in tagging permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"viterbi in tagging"),"\n",r.createElement(t.p,null,"We compute ",r.createElement(s.A,{text:"\\(\\delta_t(j)\\)"})," for each possible tag ",r.createElement(s.A,{text:"\\(j\\)"})," at position ",r.createElement(s.A,{text:"\\(t\\)"}),". The final result is the path of tags maximizing the product of transitions and emissions."),"\n",r.createElement(t.h3,{id:"deep-extensions",style:{position:"relative"}},r.createElement(t.a,{href:"#deep-extensions","aria-label":"deep extensions permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"deep extensions"),"\n",r.createElement(t.p,null,"State-of-the-art taggers often incorporate deep neural networks (e.g., BiLSTMs or Transformers) for richer feature extraction, with a CRF or HMM-like layer on top. This can be interpreted as a deep probabilistic approach if we keep a well-defined distribution over tags."),"\n",r.createElement(t.hr),"\n",r.createElement(t.h2,{id:"ibm-watson-and-practical-large-scale-inference",style:{position:"relative"}},r.createElement(t.a,{href:"#ibm-watson-and-practical-large-scale-inference","aria-label":"ibm watson and practical large scale inference permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"ibm watson and practical large-scale inference"),"\n",r.createElement(t.p,null,'IBM Watson\'s "DeepQA" system (famous for playing Jeopardy!) illustrates how multiple probabilistic modules can be combined with large corpora:'),"\n",r.createElement(t.h3,{id:"watsons-architecture",style:{position:"relative"}},r.createElement(t.a,{href:"#watsons-architecture","aria-label":"watsons architecture permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"watson's architecture"),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Search-based modules")," identify candidate documents or passages for an input query."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Scoring"),": Each candidate answer is scored with learned models that incorporate textual features, structured knowledge, and confidence metrics."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Probabilistic ensembles"),": The overall confidence in an answer is an aggregate of multiple features, often computed in a log-linear or Bayesian fashion."),"\n"),"\n",r.createElement(t.h3,{id:"ml-pipelines-in-watson",style:{position:"relative"}},r.createElement(t.a,{href:"#ml-pipelines-in-watson","aria-label":"ml pipelines in watson permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"ml pipelines in watson"),"\n",r.createElement(t.p,null,'Text pre-processing, search, candidate generation, scoring, and re-ranking happen in stages. Each stage can be framed probabilistically, e.g., "Given the question ',r.createElement(s.A,{text:"\\(q\\)"}),", what is the probability that snippet ",r.createElement(s.A,{text:"\\(s\\)"}),' is relevant?"'),"\n",r.createElement(t.h3,{id:"lessons-learned",style:{position:"relative"}},r.createElement(t.a,{href:"#lessons-learned","aria-label":"lessons learned permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"lessons learned"),"\n",r.createElement(t.p,null,"In large-scale systems, robust uncertainty estimation can be vital. Overconfident or miscalibrated modules lead to poor overall performance. A well-designed probabilistic ensemble can sometimes offset mistakes from individual modules and lead to better final answers."),"\n",r.createElement(t.hr),"\n",r.createElement(t.h2,{id:"deep-probabilistic-models",style:{position:"relative"}},r.createElement(t.a,{href:"#deep-probabilistic-models","aria-label":"deep probabilistic models permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"deep probabilistic models"),"\n",r.createElement(t.p,null,"Up to now, we have seen or mentioned discrete latent variable models (e.g., HMM) and simpler parametric structures. We now discuss advanced deep probabilistic models more comprehensively:"),"\n",r.createElement(t.h3,{id:"univariate-conditionals",style:{position:"relative"}},r.createElement(t.a,{href:"#univariate-conditionals","aria-label":"univariate conditionals permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"univariate conditionals"),"\n",r.createElement(t.p,null,"A single ",r.createElement(s.A,{text:"\\(y\\)"})," given ",r.createElement(s.A,{text:"\\(x\\)"})," might be discrete (like a classification) or continuous (like a real-valued measurement). A neural network can parameterize a probability distribution in either case. For instance, for regression:"),"\n",r.createElement(s.A,{text:"\\[\ny \\mid x \\sim \\mathcal{N}\\bigl(\\mu_\\theta(x),\\, \\sigma^2_\\theta(x)\\bigr).\n\\]"}),"\n",r.createElement(t.h3,{id:"parameter-estimation-via-maximum-likelihood",style:{position:"relative"}},r.createElement(t.a,{href:"#parameter-estimation-via-maximum-likelihood","aria-label":"parameter estimation via maximum likelihood permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"parameter estimation via maximum likelihood"),"\n",r.createElement(t.p,null,"We define ",r.createElement(s.A,{text:"\\(p_\\theta(y \\mid x)\\)"})," as a distribution from the neural predictor. Then we fit ",r.createElement(s.A,{text:"\\(\\theta\\)"})," to maximize the log-likelihood of observed data ",r.createElement(s.A,{text:"\\((x_i, y_i)\\)"}),":"),"\n",r.createElement(s.A,{text:"\\[\n\\mathcal{L}(\\theta) = \\sum_i \\log p_\\theta(y_i \\mid x_i).\n\\]"}),"\n",r.createElement(t.h3,{id:"decision-rules--bayesian-decision-theory",style:{position:"relative"}},r.createElement(t.a,{href:"#decision-rules--bayesian-decision-theory","aria-label":"decision rules  bayesian decision theory permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"decision rules & bayesian decision theory"),"\n",r.createElement(t.p,null,"Given a predicted distribution ",r.createElement(s.A,{text:"\\(p_\\theta(y \\mid x)\\)"}),", you might want to choose an action ",r.createElement(s.A,{text:"\\(a\\)"})," to maximize expected utility:"),"\n",r.createElement(s.A,{text:"\\[\na^* = \\arg\\max_a \\sum_y u(a, y)\\, p_\\theta(y \\mid x),\n\\]"}),"\n",r.createElement(t.p,null,"where ",r.createElement(s.A,{text:"\\(u(a, y)\\)"})," is the utility of action ",r.createElement(s.A,{text:"\\(a\\)"})," when the true outcome is ",r.createElement(s.A,{text:"\\(y\\)"}),". In many classification tasks with 0-1 utility, we take the mode ",r.createElement(s.A,{text:"\\(\\arg \\max_y p_\\theta(y \\mid x)\\)"}),". In other tasks, we might prefer the mean or median if we measure losses like squared error or absolute deviations."),"\n",r.createElement(t.hr),"\n",r.createElement(t.h2,{id:"advanced-autoregressive-and-structured-models",style:{position:"relative"}},r.createElement(t.a,{href:"#advanced-autoregressive-and-structured-models","aria-label":"advanced autoregressive and structured models permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"advanced autoregressive and structured models"),"\n",r.createElement(t.p,null,"When outputs ",r.createElement(s.A,{text:"\\(y\\)"})," are sequences, trees, or graphs, a factorized approach is possible. For instance, we can express the probability of a sequence ",r.createElement(s.A,{text:"\\(y_{1:T}\\)"})," by the chain rule:"),"\n",r.createElement(s.A,{text:"\\[\np_\\theta(y_{1:T} \\mid x) = \\prod_{t=1}^T p_\\theta(y_t \\mid y_{1:t-1}, x).\n\\]"}),"\n",r.createElement(t.h3,{id:"autoregressive-taggers",style:{position:"relative"}},r.createElement(t.a,{href:"#autoregressive-taggers","aria-label":"autoregressive taggers permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"autoregressive taggers"),"\n",r.createElement(t.p,null,"In POS tagging or other labeling tasks, some advanced taggers approximate:"),"\n",r.createElement(s.A,{text:"\\[\np_\\theta(z_1, \\ldots, z_T \\mid x) = \\prod_{t=1}^T p_\\theta(z_t \\mid z_{1:t-1}, x).\n\\]"}),"\n",r.createElement(t.h3,{id:"exact-vs-approximate-decoding",style:{position:"relative"}},r.createElement(t.a,{href:"#exact-vs-approximate-decoding","aria-label":"exact vs approximate decoding permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"exact vs. approximate decoding"),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,"For purely factorized or conditionally independent structures, you can decode in ",r.createElement(s.A,{text:"\\(\\mathcal{O}(T)\\)"})," by picking each ",r.createElement(s.A,{text:"\\(z_t\\)"}),"."),"\n",r.createElement(t.li,null,"For fully autoregressive or other advanced factorization, searching for the exact mode might be ",r.createElement(s.A,{text:"\\(\\mathsf{NP}\\)"}),"-hard. Instead, we use approximate methods like greedy search or beam search."),"\n"),"\n",r.createElement(t.h3,{id:"beam-search--greedy-approaches",style:{position:"relative"}},r.createElement(t.a,{href:"#beam-search--greedy-approaches","aria-label":"beam search  greedy approaches permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"beam search & greedy approaches"),"\n",r.createElement(t.p,null,"These are heuristics for approximate decoding, used widely in machine translation, text generation, or structured prediction. They strike a trade-off between computational cost and search accuracy."),"\n",r.createElement(t.hr),"\n",r.createElement(t.h2,{id:"variational-inference",style:{position:"relative"}},r.createElement(t.a,{href:"#variational-inference","aria-label":"variational inference permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"variational inference"),"\n",r.createElement(t.p,null,"In many deep probabilistic models, a central challenge is dealing with hidden (latent) variables ",r.createElement(s.A,{text:"\\(z\\)"})," in ",r.createElement(s.A,{text:"\\(p_\\theta(x, z)\\)"}),". The posterior ",r.createElement(s.A,{text:"\\(p_\\theta(z \\mid x)\\)"})," is typically intractable. Variational inference addresses this problem by introducing a simpler distribution ",r.createElement(s.A,{text:"\\(q_\\phi(z \\mid x)\\)"})," (the variational distribution or inference model) to approximate ",r.createElement(s.A,{text:"\\(p_\\theta(z \\mid x)\\)"}),"."),"\n",r.createElement(t.h3,{id:"importance-of-latent-variable-models",style:{position:"relative"}},r.createElement(t.a,{href:"#importance-of-latent-variable-models","aria-label":"importance of latent variable models permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"importance of latent variable models"),"\n",r.createElement(t.p,null,"Latent variables capture hidden structure, making the model more expressive. But the marginal ",r.createElement(s.A,{text:"\\(p_\\theta(x)\\)"})," is ",r.createElement(s.A,{text:"\\(\\int p_\\theta(x, z)\\, dz\\)"})," (for continuous ",r.createElement(s.A,{text:"\\(z\\)"}),") or ",r.createElement(s.A,{text:"\\(\\sum_z p_\\theta(x, z)\\)"})," (discrete). That integral or sum can be huge."),"\n",r.createElement(t.h3,{id:"elbo-formulation",style:{position:"relative"}},r.createElement(t.a,{href:"#elbo-formulation","aria-label":"elbo formulation permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"elbo formulation"),"\n",r.createElement(t.p,null,"The ",r.createElement(t.strong,null,"Evidence Lower BOund (ELBO)")," is given by:"),"\n",r.createElement(s.A,{text:"\\[\n\\log p_\\theta(x) \\ge \\mathbb{E}_{q_\\phi(z \\mid x)}\\bigl[\\log p_\\theta(x \\mid z)\\bigr] - \\mathrm{KL}\\bigl[q_\\phi(z \\mid x) \\;||\\; p_\\theta(z)\\bigr].\n\\]"}),"\n",r.createElement(t.p,null,"Maximizing this lower bound w.r.t. ",r.createElement(s.A,{text:"\\(\\theta\\)"})," and ",r.createElement(s.A,{text:"\\(\\phi\\)"})," is equivalent to performing approximate maximum likelihood on ",r.createElement(s.A,{text:"\\(p_\\theta\\)"})," while also improving ",r.createElement(s.A,{text:"\\(q_\\phi\\)"})," as an approximation to the true posterior."),"\n",r.createElement(t.h3,{id:"gradient-estimation-techniques",style:{position:"relative"}},r.createElement(t.a,{href:"#gradient-estimation-techniques","aria-label":"gradient estimation techniques permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"gradient estimation techniques"),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Score-function (REINFORCE or NVIL)"),": Directly estimates the gradient of the ELBO by seeing the log of ",r.createElement(s.A,{text:"\\(q_\\phi(z \\mid x)\\)"}),' as a "policy." Often exhibits high variance, but can handle discrete or complicated ',r.createElement(s.A,{text:"\\(z\\)"}),"."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Reparameterization trick"),": For continuous reparameterizable distributions (like Gaussians), we write ",r.createElement(s.A,{text:"\\(z = \\mu_\\phi(x) + \\sigma_\\phi(x) \\odot \\epsilon\\)"}),", ",r.createElement(s.A,{text:"\\(\\epsilon \\sim \\mathcal{N}(0, I)\\)"}),". This typically yields lower-variance gradient estimates."),"\n"),"\n",r.createElement(t.hr),"\n",r.createElement(t.h2,{id:"variational-inference-for-deep-discrete-latent-variables",style:{position:"relative"}},r.createElement(t.a,{href:"#variational-inference-for-deep-discrete-latent-variables","aria-label":"variational inference for deep discrete latent variables permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"variational inference for deep discrete latent variables"),"\n",r.createElement(t.p,null,"When ",r.createElement(s.A,{text:"\\(z\\)"})," is discrete, we often rely on score-function or related gradient estimators. For example, in a discrete autoencoder with ",r.createElement(s.A,{text:"\\(z \\in \\{1,\\ldots,K\\}^D\\)"}),", enumerating ",r.createElement(s.A,{text:"\\(K^D\\)"})," possibilities is usually impossible. Instead we define a factorized or structured ",r.createElement(s.A,{text:"\\(q_\\phi(z \\mid x)\\)"})," (like a product of categorical distributions) and do a typical policy-gradient approach."),"\n",r.createElement(t.h3,{id:"discrete-vs-continuous",style:{position:"relative"}},r.createElement(t.a,{href:"#discrete-vs-continuous","aria-label":"discrete vs continuous permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"discrete vs. continuous"),"\n",r.createElement(t.p,null,"Discrete latent spaces cannot typically exploit the reparameterization trick. There are advanced methods (e.g., Gumbel-Softmax, straight-through estimators, or more sophisticated relaxations) that attempt to approximate discrete sampling with continuous surrogates. But a standard fallback is the score-function approach plus variance reduction techniques."),"\n",r.createElement(t.h3,{id:"neural-variational-inference",style:{position:"relative"}},r.createElement(t.a,{href:"#neural-variational-inference","aria-label":"neural variational inference permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"neural variational inference"),"\n",r.createElement(t.p,null,"This phrase often means constructing ",r.createElement(s.A,{text:"\\(q_\\phi(z \\mid x)\\)"})," with a neural network, plus using gradient-based optimization of the ELBO. Many architectures show up in tasks like neural clustering, discrete sequence autoencoders, or generative models for text."),"\n",r.createElement(t.h3,{id:"examples-in-practice",style:{position:"relative"}},r.createElement(t.a,{href:"#examples-in-practice","aria-label":"examples in practice permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"examples in practice"),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Mixture of experts"),": ",r.createElement(s.A,{text:"\\(z\\)"}),' might be an indicator for which "expert" neural network processes the input.'),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Discrete autoencoders"),": ",r.createElement(s.A,{text:"\\(z\\)"})," is a code from a codebook (like VQ-VAE)."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Latent classification variables"),": ",r.createElement(s.A,{text:"\\(z\\)"})," might represent class membership, combined with deeper generative structure for ",r.createElement(s.A,{text:"\\(x\\)"}),"."),"\n"),"\n",r.createElement(t.hr),"\n",r.createElement(t.h2,{id:"continuous-latent-variable-models-vaes",style:{position:"relative"}},r.createElement(t.a,{href:"#continuous-latent-variable-models-vaes","aria-label":"continuous latent variable models vaes permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"continuous latent variable models (vaes)"),"\n",r.createElement(t.p,null,"If ",r.createElement(s.A,{text:"\\(z\\)"})," is continuous, we can often exploit reparameterization-based variational inference. The classical example is the ",r.createElement(t.strong,null,"Variational Autoencoder (VAE)"),"."),"\n",r.createElement(t.h3,{id:"gaussian-prior--posterior",style:{position:"relative"}},r.createElement(t.a,{href:"#gaussian-prior--posterior","aria-label":"gaussian prior  posterior permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"gaussian prior & posterior"),"\n",r.createElement(t.p,null,"A standard approach is:"),"\n",r.createElement(s.A,{text:"\\[\nz \\sim \\mathcal{N}(0, I), \\quad\nx \\mid z \\sim p_\\theta(x \\mid z),\n\\]"}),"\n",r.createElement(t.p,null,"and approximate ",r.createElement(s.A,{text:"\\(p_\\theta(z \\mid x)\\)"})," by a diagonal Gaussian ",r.createElement(s.A,{text:"\\(q_\\phi(z \\mid x)\\)"})," with neural networks for its mean and variance. Then we can sample"),"\n",r.createElement(s.A,{text:"\\[\nz = \\mu_\\phi(x) + \\sigma_\\phi(x)\\odot \\epsilon, \\quad \\epsilon \\sim \\mathcal{N}(0, I).\n\\]"}),"\n",r.createElement(t.h3,{id:"decoder-architectures",style:{position:"relative"}},r.createElement(t.a,{href:"#decoder-architectures","aria-label":"decoder architectures permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"decoder architectures"),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"FFNN"),": simple flattening from the latent code ",r.createElement(s.A,{text:"\\(z\\)"})," to output ",r.createElement(s.A,{text:"\\(x\\)"}),"."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Convolutional decoders"),": useful for image data, building an up-sampling or transposed convolution pipeline from ",r.createElement(s.A,{text:"\\(z\\)"})," to an ",r.createElement(s.A,{text:"\\(H \\times W \\times \\text{channels}\\)"})," image."),"\n"),"\n",r.createElement(t.h3,{id:"extensions-normalizing-flows-hierarchical-vaes",style:{position:"relative"}},r.createElement(t.a,{href:"#extensions-normalizing-flows-hierarchical-vaes","aria-label":"extensions normalizing flows hierarchical vaes permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"extensions: normalizing flows, hierarchical vaes"),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Normalizing flows"),": let you transform a simple distribution (like a diagonal Gaussian) into a more flexible one by applying a series of invertible transformations. This is a powerful method to approximate complicated posteriors."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Hierarchical VAEs"),": stack multiple latent layers ",r.createElement(s.A,{text:"\\(z_1, z_2, \\ldots\\)"})," so each distribution can capture different levels of abstraction."),"\n"),"\n",r.createElement(t.hr),"\n",r.createElement(t.h2,{id:"practical-implementation-tips",style:{position:"relative"}},r.createElement(t.a,{href:"#practical-implementation-tips","aria-label":"practical implementation tips permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"practical implementation tips"),"\n",r.createElement(t.h3,{id:"hardware-considerations",style:{position:"relative"}},r.createElement(t.a,{href:"#hardware-considerations","aria-label":"hardware considerations permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"hardware considerations"),"\n",r.createElement(t.p,null,"Training deep probabilistic models can be GPU intensive. Some tips:"),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Batch sizes"),": Large batches can speed up training, but memory usage might blow up (especially if the model enumerates or stores large distributions)."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Mixed precision"),": If using libraries that support half-precision, watch for potential numerical instabilities in computing log probabilities."),"\n"),"\n",r.createElement(t.h3,{id:"hyperparameters--regularization",style:{position:"relative"}},r.createElement(t.a,{href:"#hyperparameters--regularization","aria-label":"hyperparameters  regularization permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"hyperparameters & regularization"),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"KL-term weighting"),": In VAEs, the ",r.createElement(s.A,{text:"\\(\\mathrm{KL}[q_\\phi(z \\mid x)||p(z)]\\)"})," can be scaled by a factor ",r.createElement(s.A,{text:"\\(\\beta\\)"}),". This is often used to encourage certain properties (e.g., encouraging more or fewer codes to be used)."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Early stopping"),": Evaluate the ELBO on validation data to prevent overfitting."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Learning rates"),": reparameterized models often do well with Adam or other adaptive optimizers. For SFE-based discrete models, RMSProp might handle high variance better."),"\n"),"\n",r.createElement(t.h3,{id:"debugging-convergence",style:{position:"relative"}},r.createElement(t.a,{href:"#debugging-convergence","aria-label":"debugging convergence permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"debugging convergence"),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Posterior collapse"),": sometimes the VAE training leads ",r.createElement(s.A,{text:"\\(q_\\phi(z \\mid x)\\)"})," to ignore ",r.createElement(s.A,{text:"\\(x\\)"}),", collapsing to the prior."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Mode-seeking behavior"),": especially in discrete latent variable models."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Vanishing or exploding gradients"),": as usual in deep learning, watch for numerical stability."),"\n"),"\n",r.createElement(t.hr),"\n",r.createElement(t.h2,{id:"future-directions--conclusion",style:{position:"relative"}},r.createElement(t.a,{href:"#future-directions--conclusion","aria-label":"future directions  conclusion permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"future directions & conclusion"),"\n",r.createElement(t.p,null,"Deep probabilistic models are a rich and rapidly evolving area. Some directions include:"),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"scalable inference"),": Stochastic, distributed, or streaming approaches for extremely large datasets or streaming data."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"structured latent spaces"),": Incorporating domain knowledge (graphs, hierarchies) to achieve interpretability or improved performance."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"advanced expansions"),": bridging symbolic AI with deep probabilistic approaches for logic, reasoning, or knowledge representation."),"\n"),"\n",r.createElement(t.p,null,"In conclusion, deep probabilistic models unite the representational depth of neural networks with the interpretability and rigor of probability theory. Through frameworks like Bayesian networks, HMMs, VAEs, and their numerous extensions, we can capture a wide variety of data modalities and structures while still maintaining a principled handle on uncertainty. The combination of approximate inference strategies â€” variational or otherwise â€” and high-capacity decoders or prior structures continues to open new frontiers in machine learning research and practical enterprise applications alike."),"\n",r.createElement(t.hr),"\n",r.createElement(t.h2,{id:"references-and-further-reading",style:{position:"relative"}},r.createElement(t.a,{href:"#references-and-further-reading","aria-label":"references and further reading permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"references and further reading"),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,'D.P. Kingma, M. Welling. "Auto-Encoding Variational Bayes." ',r.createElement(t.em,null,"ICLR"),", 2014."),"\n",r.createElement(t.li,null,'Rezende, D.J., Mohamed, S. "Variational Inference with Normalizing Flows." ',r.createElement(t.em,null,"ICML"),", 2015."),"\n",r.createElement(t.li,null,'Bishop, C.M. "Pattern Recognition and Machine Learning." ',r.createElement(t.em,null,"Springer"),", 2006."),"\n",r.createElement(t.li,null,'Jordan, M.I., Ghahramani, Z., Jaakkola, T.S., and Saul, L.K. "An Introduction to Variational Methods for Graphical Models." ',r.createElement(t.em,null,"Machine Learning"),", 1999."),"\n",r.createElement(t.li,null,'Neal, R.M. "Bayesian Learning for Neural Networks." ',r.createElement(t.em,null,"Ph.D. Thesis"),", 1995."),"\n",r.createElement(t.li,null,'Blei, D.M., Kucukelbir, A., and McAuliffe, J.D. "Variational Inference: A Review for Statisticians." ',r.createElement(t.em,null,"J. American Statistical Association"),", 2017."),"\n",r.createElement(t.li,null,'J. Ba, R. R. Salakhutdinov, R. Grosse, B. Frey. "Learning Wake-Sleep Recurrent Attention Models." ',r.createElement(t.em,null,"NeurIPS"),", 2015."),"\n",r.createElement(t.li,null,'J. Pearl. "Probabilistic Reasoning in Intelligent Systems: Networks of Plausible Inference." ',r.createElement(t.em,null,"Morgan Kaufmann"),", 1988."),"\n"),"\n",r.createElement(t.hr),"\n",r.createElement(t.h2,{id:"code-snippets-an-illustrative-example",style:{position:"relative"}},r.createElement(t.a,{href:"#code-snippets-an-illustrative-example","aria-label":"code snippets an illustrative example permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"code snippets: an illustrative example"),"\n",r.createElement(t.p,null,"Below is a simplified code demonstration (in Python) that references the core building blocks used in many deep probabilistic modeling workflows. We wrap it in an example of training a variational autoencoder with a Gaussian prior ",r.createElement(s.A,{text:"\\(p_\\theta(z)\\)"})," and a Bernoulli decoder ",r.createElement(s.A,{text:"\\(p_\\theta(x \\mid z)\\)"}),". We then show how to build an inference network ",r.createElement(s.A,{text:"\\(q_\\phi(z \\mid x)\\)"})," that is also Gaussian."),"\n",r.createElement(t.p,null,r.createElement(t.strong,null,"Note"),": This is a self-contained snippet that demonstrates the essential logic. In a real codebase, you would typically separate modules, handle data loaders more carefully, add logging, etc."),"\n",r.createElement(o.A,{text:"\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nimport torch.optim as optim\nfrom torch.utils.data import DataLoader\nimport numpy as np\n\n# Suppose we have a dataset X in shape (N, x_dim).\n# We define a simple VAE with:\n#   - p(z) = N(0, I)\n#   - p(x|z) = Bernoulli( decoder(z) )\n#   - q(z|x) = N(mu(x), diag(sigma^2(x)))\n\nclass Encoder(nn.Module):\n    def __init__(self, x_dim, z_dim, hidden_dim=256):\n        super().__init__()\n        self.net = nn.Sequential(\n            nn.Linear(x_dim, hidden_dim),\n            nn.ReLU(),\n            nn.Linear(hidden_dim, hidden_dim),\n            nn.ReLU(),\n        )\n        # separate heads for mean and log-variance\n        self.mu_head = nn.Linear(hidden_dim, z_dim)\n        self.logvar_head = nn.Linear(hidden_dim, z_dim)\n    \n    def forward(self, x):\n        h = self.net(x)\n        mu = self.mu_head(h)\n        logvar = self.logvar_head(h)\n        return mu, logvar\n\nclass Decoder(nn.Module):\n    def __init__(self, z_dim, x_dim, hidden_dim=256):\n        super().__init__()\n        self.net = nn.Sequential(\n            nn.Linear(z_dim, hidden_dim),\n            nn.ReLU(),\n            nn.Linear(hidden_dim, hidden_dim),\n            nn.ReLU(),\n            nn.Linear(hidden_dim, x_dim),\n        )\n    \n    def forward(self, z):\n        # outputs logits for Bernoulli\n        return self.net(z)\n\nclass VAE(nn.Module):\n    def __init__(self, x_dim, z_dim, hidden_dim=256):\n        super().__init__()\n        self.encoder = Encoder(x_dim, z_dim, hidden_dim)\n        self.decoder = Decoder(z_dim, x_dim, hidden_dim)\n        self.z_dim = z_dim\n    \n    def reparameterize(self, mu, logvar):\n        # z = mu + eps * sigma\n        # logvar is log(sigma^2), so sigma = exp(0.5*logvar)\n        std = torch.exp(0.5 * logvar)\n        eps = torch.randn_like(std)\n        return mu + eps * std\n\n    def forward(self, x):\n        # encode\n        mu, logvar = self.encoder(x)\n        z = self.reparameterize(mu, logvar)\n        # decode\n        logits = self.decoder(z)\n        return logits, mu, logvar\n\ndef vae_loss(x, logits, mu, logvar):\n    # Reconstruction term: Bernoulli negative log-likelihood\n    # We use F.binary_cross_entropy_with_logits in PyTorch\n    recon_loss = F.binary_cross_entropy_with_logits(\n        logits, x, reduction='sum'\n    )\n    # KL term: D_KL( N(mu, diag(sigma^2)) || N(0, I) )\n    # = 0.5 * sum( exp(logvar) + mu^2 - 1 - logvar )\n    kld = 0.5 * torch.sum(torch.exp(logvar) + mu**2 - 1.0 - logvar)\n    return recon_loss + kld\n\n# Example usage\ndef train_vae(model, dataloader, optimizer, device):\n    model.train()\n    total_loss = 0.\n    for batch_x in dataloader:\n        batch_x = batch_x.to(device)\n        optimizer.zero_grad()\n        logits, mu, logvar = model(batch_x)\n        loss = vae_loss(batch_x, logits, mu, logvar)\n        loss.backward()\n        optimizer.step()\n        total_loss += loss.item()\n    return total_loss / len(dataloader.dataset)\n\n# Suppose x_dim=784 (like flattened MNIST), z_dim=20\nx_dim = 784\nz_dim = 20\ndevice = torch.device('cuda' if torch.cuda.is_available() else 'cpu')\n\nvae_model = VAE(x_dim, z_dim).to(device)\noptimizer = optim.Adam(vae_model.parameters(), lr=1e-3)\n\n# Example: a fake dataset\nN = 1000\nfake_data = torch.bernoulli(torch.rand(N, x_dim))  # random Bernoulli\ndloader = DataLoader(fake_data, batch_size=64, shuffle=True)\n\n# training loop\nepochs = 3\nfor ep in range(epochs):\n    loss_val = train_vae(vae_model, dloader, optimizer, device)\n    print(f\"Epoch {ep} Loss = {loss_val:.3f}\")\n\n"}),"\n",r.createElement(t.p,null,r.createElement(t.em,null,"(The above code uses a Bernoulli decoder for demonstration, as would be typical for binarized MNIST. Adjust the reconstruction term for continuous data if needed.)")),"\n",r.createElement(t.hr),"\n",r.createElement(t.p,null,"I hope this long exploration has helped illuminate the wide spectrum of ",r.createElement(t.strong,null,"Deep Probabilistic Models")," â€” from HMMs and Bayesian networks to advanced VAEs and large-scale inference systems. By blending neural architectures with solid probabilistic reasoning, you can open up a world of interpretability, robustness to noise, and capacity to incorporate domain knowledge or uncertainty in a principled way."))}var m=function(e){void 0===e&&(e={});const{wrapper:t}=Object.assign({},(0,i.RP)(),e.components);return t?r.createElement(t,e,r.createElement(c,e)):c(e)},d=a(36710),h=a(58481),p=a.n(h),u=a(36310),g=a(87245),v=a(27042),f=a(59849),b=a(5591),E=a(61122),x=a(9219),y=a(33203),w=a(95751),_=a(94328),S=a(80791),z=a(78137);const H=e=>{let{toc:t}=e;if(!t||!t.items)return null;return r.createElement("nav",{className:S.R},r.createElement("ul",null,t.items.map(((e,t)=>r.createElement("li",{key:t},r.createElement("a",{href:e.url,onClick:t=>((e,t)=>{e.preventDefault();const a=t.replace("#",""),n=document.getElementById(a);n&&n.scrollIntoView({behavior:"smooth",block:"start"})})(t,e.url)},e.title),e.items&&r.createElement(H,{toc:{items:e.items}}))))))};function k(e){let{data:{mdx:t,allMdx:l,allPostImages:o},children:s}=e;const{frontmatter:c,body:m,tableOfContents:d}=t,h=c.index,f=c.slug.split("/")[1],S=l.nodes.filter((e=>e.frontmatter.slug.includes(`/${f}/`))).sort(((e,t)=>e.frontmatter.index-t.frontmatter.index)),k=S.findIndex((e=>e.frontmatter.index===h)),A=S[k+1],M=S[k-1],T=c.slug.replace(/\/$/,""),V=/[^/]*$/.exec(T)[0],C=`posts/${f}/content/${V}/`,{0:I,1:L}=(0,r.useState)(c.flagWideLayoutByDefault),{0:B,1:N}=(0,r.useState)(!1);var q;(0,r.useEffect)((()=>{N(!0);const e=setTimeout((()=>N(!1)),340);return()=>clearTimeout(e)}),[I]),"adventures"===f?q=x.cb:"research"===f?q=x.Qh:"thoughts"===f&&(q=x.T6);const P=p()(m).replace(/import .*? from .*?;/g,"").replace(/<.*?>/g,"").replace(/\{\/\*[\s\S]*?\*\/\}/g,"").trim().split(/\s+/).length,O=function(e){if(e<=10)return"~10 min";if(e<=20)return"~20 min";if(e<=30)return"~30 min";if(e<=40)return"~40 min";if(e<=50)return"~50 min";if(e<=60)return"~1 h";const t=Math.floor(e/60),a=e%60;return a<=30?`~${t}${a>0?".5":""} h`:`~${t+1} h`}(Math.ceil(P/q)+(c.extraReadTimeMin||0)),D=[{flag:c.flagDraft,component:()=>Promise.all([a.e(3231),a.e(8809)]).then(a.bind(a,28809))},{flag:c.flagMindfuckery,component:()=>Promise.all([a.e(3231),a.e(2471)]).then(a.bind(a,67709))},{flag:c.flagRewrite,component:()=>Promise.all([a.e(3231),a.e(6764)]).then(a.bind(a,62002))},{flag:c.flagOffensive,component:()=>Promise.all([a.e(3231),a.e(2443)]).then(a.bind(a,17681))},{flag:c.flagProfane,component:()=>Promise.all([a.e(3231),a.e(8048)]).then(a.bind(a,53286))},{flag:c.flagMultilingual,component:()=>Promise.all([a.e(3231),a.e(4069)]).then(a.bind(a,78831))},{flag:c.flagUnreliably,component:()=>Promise.all([a.e(3231),a.e(3417)]).then(a.bind(a,8179))},{flag:c.flagPolitical,component:()=>Promise.all([a.e(3231),a.e(5195)]).then(a.bind(a,30433))},{flag:c.flagCognitohazard,component:()=>Promise.all([a.e(3231),a.e(3175)]).then(a.bind(a,8413))},{flag:c.flagHidden,component:()=>Promise.all([a.e(3231),a.e(9556)]).then(a.bind(a,14794))}],{0:F,1:R}=(0,r.useState)([]);return(0,r.useEffect)((()=>{D.forEach((e=>{let{flag:t,component:a}=e;t&&a().then((e=>{R((t=>[].concat((0,n.A)(t),[e.default])))}))}))}),[]),r.createElement(v.P.div,{initial:{opacity:0},animate:{opacity:1},exit:{opacity:0},transition:{duration:.15}},r.createElement(b.A,{postNumber:c.index,date:c.date,updated:c.updated,readTime:O,difficulty:c.difficultyLevel,title:c.title,desc:c.desc,banner:c.banner,section:f,postKey:V,isMindfuckery:c.flagMindfuckery,mainTag:c.mainTag}),r.createElement("div",{style:{display:"flex",justifyContent:"flex-end",flexWrap:"wrap",maxWidth:"75%",marginLeft:"auto",paddingRight:"1vw",marginTop:"-6vh",marginBottom:"4vh"}},c.otherTags.map(((e,t)=>r.createElement("span",{key:t,className:`noselect ${z.MW}`,style:{margin:"0 5px 5px 0"}},e)))),r.createElement("div",{class:"postBody"},r.createElement(H,{toc:d})),r.createElement("br"),r.createElement("div",{style:{margin:"0 10% -2vh 30%",textAlign:"right"}},r.createElement(v.P.button,{class:"noselect",className:_.pb,id:_.xG,onClick:()=>{L(!I)},whileTap:{scale:.93}},r.createElement(v.P.div,{className:w.DJ,key:I,initial:{opacity:0},animate:{opacity:1},exit:{opacity:0},transition:{duration:.3,ease:"easeInOut"}},I?"Switch to default layout":"Switch to wide layout"))),r.createElement("br"),r.createElement("div",{class:"postBody",style:{margin:I?"0 -14%":"",maxWidth:I?"200%":"",transition:"margin 1s ease, max-width 1s ease, padding 1s ease"}},r.createElement("div",{className:`${_.P_} ${B?_.Xn:_.qG}`},F.map(((e,t)=>r.createElement(e,{key:t}))),c.indexCourse?r.createElement(y.A,{index:c.indexCourse,category:c.courseCategoryName}):"",r.createElement(u.Z.Provider,{value:{images:o.nodes,basePath:C.replace(/\/$/,"")+"/"}},r.createElement(i.xA,{components:{Image:g.A}},s)))),r.createElement(E.A,{nextPost:A,lastPost:M,keyCurrent:V,section:f}))}function A(e){return r.createElement(k,e,r.createElement(m,e))}function M(e){var t,a,n,i,l;let{data:o}=e;const{frontmatter:s}=o.mdx,c=s.titleSEO||s.title,m=s.titleOG||c,h=s.titleTwitter||c,p=s.descSEO||s.desc,u=s.descOG||p,g=s.descTwitter||p,v=s.schemaType||"BlogPosting",b=s.keywordsSEO,E=s.date,x=s.updated||E,y=s.imageOG||(null===(t=s.banner)||void 0===t||null===(a=t.childImageSharp)||void 0===a||null===(n=a.gatsbyImageData)||void 0===n||null===(i=n.images)||void 0===i||null===(l=i.fallback)||void 0===l?void 0:l.src),w=s.imageAltOG||u,_=s.imageTwitter||y,S=s.imageAltTwitter||g,z=s.canonicalURL,H=s.flagHidden||!1,k=s.mainTag||"Posts",A=s.slug.split("/")[1]||"posts",{siteUrl:M}=(0,d.Q)(),T={"@context":"https://schema.org","@type":"BreadcrumbList",itemListElement:[{"@type":"ListItem",position:1,name:"Home",item:M},{"@type":"ListItem",position:2,name:k,item:`${M}/${s.slug.split("/")[1]}`},{"@type":"ListItem",position:3,name:c,item:`${M}${s.slug}`}]};return r.createElement(f.A,{title:c+" - avrtt.blog",titleOG:m,titleTwitter:h,description:p,descriptionOG:u,descriptionTwitter:g,schemaType:v,keywords:b,datePublished:E,dateModified:x,imageOG:y,imageAltOG:w,imageTwitter:_,imageAltTwitter:S,canonicalUrl:z,flagHidden:H,mainTag:k,section:A,type:"article"},r.createElement("script",{type:"application/ld+json"},JSON.stringify(T)))}},96098:function(e,t,a){var n=a(96540),i=a(7978);t.A=e=>{let{text:t}=e;return n.createElement(i.A,null,t)}}}]);
//# sourceMappingURL=component---src-templates-post-js-content-file-path-src-pages-posts-research-deep-probabilistic-models-mdx-2273234f85ec0e421ba5.js.map