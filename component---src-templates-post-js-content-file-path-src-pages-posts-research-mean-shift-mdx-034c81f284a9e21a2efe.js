"use strict";(self.webpackChunkavrtt_blog=self.webpackChunkavrtt_blog||[]).push([[9668],{18279:function(e,t,n){n.r(t),n.d(t,{Head:function(){return C},PostTemplate:function(){return _},default:function(){return M}});var a=n(54506),i=n(28453),l=n(96540),r=n(96098),s=n(46295);function o(e){const t=Object.assign({h2:"h2",a:"a",span:"span",p:"p",ul:"ul",li:"li",ol:"ol",strong:"strong",h3:"h3",img:"img",h4:"h4",hr:"hr"},(0,i.RP)(),e.components),{Image:n}=t;return n||function(e,t){throw new Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Image",!0),l.createElement(l.Fragment,null,l.createElement("br"),"\n",l.createElement(t.h2,{id:"how-it-looks-like",style:{position:"relative"}},l.createElement(t.a,{href:"#how-it-looks-like","aria-label":"how it looks like permalink",className:"anchor before"},l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"How it looks like"),"\n",l.createElement(t.p,null,"Our goal is to break up the image into similar regions without training data."),"\n",l.createElement(n,{alt:"ALT",path:"1.jpg",caption:"",zoom:"false"}),"\n",l.createElement(t.p,null,"Try to find modes with a non-parametric density:"),"\n",l.createElement(n,{alt:"ALT",path:"2.jpg",caption:"Mean Shift: A Robust Approach toward Feature Space Analysis, D.Comniciu and P.Meer",zoom:"false"}),"\n",l.createElement(t.p,null,"Idea: Estimating the PDF and Finding the Maxima"),"\n",l.createElement(t.ul,null,"\n",l.createElement(t.li,null,'Non-parametric approach to density estimation ("how many data points are in a certain region?")'),"\n",l.createElement(t.li,null,"Find the local modes of this density"),"\n",l.createElement(t.li,null,'All points that "belong" or "lead" to the same mode form a cluster'),"\n"),"\n",l.createElement(n,{alt:"ALT",path:"3.jpg",caption:"Mean Shift: A Robust Approach toward Feature Space Analysis, D.Comniciu and P.Meer",zoom:"false"}),"\n",l.createElement(t.p,null,"But how to estimate a PDF in non-parametric way?"),"\n",l.createElement(n,{alt:"ALT",path:"4.jpg",caption:"",zoom:"false"}),"\n",l.createElement(t.p,null,"Using KDE, of course! The gold standard is Gaussian kernel."),"\n",l.createElement(n,{alt:"ALT",path:"5.jpg",caption:"",zoom:"false"}),"\n",l.createElement(t.p,null,"И так происходит приближение к центру к центру, пока центр региона интереса не совпадает с центром массы:"),"\n",l.createElement(n,{alt:"ALT",path:"6.jpg",caption:"",zoom:"false"}),"\n",l.createElement(t.p,null,"Упрощенно:"),"\n",l.createElement(t.ol,null,"\n",l.createElement(t.li,null,"Compute mean shift vector"),"\n",l.createElement(t.li,null,"Move the kernel window"),"\n"),"\n",l.createElement(n,{alt:"ALT",path:"7.jpg",caption:"",zoom:"false"}),"\n",l.createElement(n,{alt:"ALT",path:"8.jpg",caption:"",zoom:"false"}),"\n",l.createElement(t.h2,{id:"segmentation",style:{position:"relative"}},l.createElement(t.a,{href:"#segmentation","aria-label":"segmentation permalink",className:"anchor before"},l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Segmentation"),"\n",l.createElement(t.ul,null,"\n",l.createElement(t.li,null,"Compute features for each pixel (color, gradients, texture, etc.)"),"\n",l.createElement(t.li,null,"Set kernel size for features Kf and position Ks"),"\n",l.createElement(t.li,null,"Initialize windows at individual pixel locations"),"\n",l.createElement(t.li,null,"Perform mean shift for each window until convergence"),"\n",l.createElement(t.li,null,"Merge windows that are within width of Kf and Ks"),"\n"),"\n",l.createElement(n,{alt:"ALT",path:"9.jpg",caption:"Mean Shift: A Robust Approach toward Feature Space Analysis, D.Comniciu and P.Meer",zoom:"false"}),"\n",l.createElement(t.h2,{id:"understanding-the-mean-shift-algorithm-in-depth",style:{position:"relative"}},l.createElement(t.a,{href:"#understanding-the-mean-shift-algorithm-in-depth","aria-label":"understanding the mean shift algorithm in depth permalink",className:"anchor before"},l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Understanding the Mean Shift Algorithm in Depth"),"\n",l.createElement(t.p,null,"Mean shift is a versatile technique for clustering-based segmentation of image data."),"\n",l.createElement(t.p,null,"The ",l.createElement(t.strong,null,"mean shift algorithm")," is one of those hidden gems in the machine learning toolkit, especially loved for its simplicity and versatility in clustering and feature space analysis. In this blog post, we're going to break down the algorithm, dive deep into the math, look at Python implementations, and highlight its use cases. Expect a detailed discussion filled with LaTeX formulas for a math-centric view!"),"\n",l.createElement(t.h2,{id:"what-is-mean-shift",style:{position:"relative"}},l.createElement(t.a,{href:"#what-is-mean-shift","aria-label":"what is mean shift permalink",className:"anchor before"},l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"What is Mean Shift?"),"\n",l.createElement(t.p,null,"At its core, the ",l.createElement(t.strong,null,"mean shift")," algorithm is a ",l.createElement(t.strong,null,"non-parametric"),' clustering method. It\'s called "mode-seeking" because its goal is to find the mode (or peak) of a density function, without needing to know how many clusters there are beforehand.'),"\n",l.createElement(t.p,null,"Unlike more traditional clustering methods like k-means, where we have to predefine the number of clusters (",l.createElement(r.A,{text:"\\(k\\)"}),"), ",l.createElement(t.strong,null,"mean shift")," adapts to the data's structure. It's useful in situations where we want the data to tell us how many clusters exist."),"\n",l.createElement(t.h3,{id:"mode-seeking-with-mean-shift",style:{position:"relative"}},l.createElement(t.a,{href:"#mode-seeking-with-mean-shift","aria-label":"mode seeking with mean shift permalink",className:"anchor before"},l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Mode Seeking with Mean Shift"),"\n",l.createElement(t.p,null,"Let's start with the simplest question: How does mean shift find the modes of a probability density function (PDF)?"),"\n",l.createElement(t.p,null,"Given a set of data points ",l.createElement(r.A,{text:"\\( x_1, x_2, \\dots, x_n \\)"}),", mean shift estimates the probability density function (PDF) using a kernel density estimation (KDE) approach. A common kernel function ",l.createElement(r.A,{text:"\\( K(x_i - x) \\)"}),", such as a Gaussian, is placed at each point to smooth out the data:"),"\n",l.createElement(r.A,{text:"\\[\nf(x) = \\sum_{i=1}^n K(x - x_i)\n\\]"}),"\n",l.createElement(t.p,null,'Now, for each point in our data, we can calculate a weighted mean of the points in its neighborhood, defined by the kernel. This weighted mean tells us how much we should "shift" our current point to move towards areas of higher density. Mathematically, the mean shift vector ',l.createElement(r.A,{text:"\\(m(x)\\)"})," is given by:"),"\n",l.createElement(r.A,{text:"\\[\nm(x) = \\frac{\\sum_{x_i \\in N(x)} K(x_i - x) x_i}{\\sum_{x_i \\in N(x)} K(x_i - x)}\n\\]"}),"\n",l.createElement(t.p,null,"This gives us the new location after one shift. The algorithm iteratively repeats this shifting process for each data point until it converges to a mode."),"\n",l.createElement(t.h3,{id:"the-mean-shift-vector",style:{position:"relative"}},l.createElement(t.a,{href:"#the-mean-shift-vector","aria-label":"the mean shift vector permalink",className:"anchor before"},l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"The Mean Shift Vector"),"\n",l.createElement(t.p,null,"The mean shift vector ",l.createElement(r.A,{text:"\\( m(x) - x \\)"})," is calculated as the difference between the original point ",l.createElement(r.A,{text:"\\(x\\)"})," and the new estimate of the mean ",l.createElement(r.A,{text:"\\( m(x) \\)"}),'. The idea is that the data points are "pulled" toward the mode by this vector, much like a gravitational field.'),"\n",l.createElement(t.p,null,"In each iteration, we update the current point ",l.createElement(r.A,{text:"\\( x \\)"})," with the new mean estimate ",l.createElement(r.A,{text:"\\( m(x) \\)"}),":"),"\n",l.createElement(r.A,{text:"\\[\nx \\leftarrow m(x)\n\\]"}),"\n",l.createElement(t.p,null,"This continues until the shifts become negligible, and the points converge to their respective cluster centers."),"\n",l.createElement(t.h3,{id:"kernel-choices",style:{position:"relative"}},l.createElement(t.a,{href:"#kernel-choices","aria-label":"kernel choices permalink",className:"anchor before"},l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Kernel Choices"),"\n",l.createElement(t.p,null,"The performance and outcome of mean shift are highly dependent on the choice of the kernel function. The most common kernel used is the ",l.createElement(t.strong,null,"Gaussian kernel"),", given by:"),"\n",l.createElement(r.A,{text:"\\[\nK(x) = e^{-\\frac{\\|x\\|^2}{2\\sigma^2}}\n\\]"}),"\n",l.createElement(t.p,null,"where ",l.createElement(r.A,{text:"\\(\\sigma\\)"})," controls the width or bandwidth of the kernel."),"\n",l.createElement(t.p,null,"Another common kernel is the ",l.createElement(t.strong,null,"flat kernel")," (a.k.a. uniform kernel), which simply assigns equal weights to all points within a fixed distance:"),"\n",l.createElement(r.A,{text:"\\[\nK(x) = \\begin{cases}\n1, & \\|x\\| \\leq h \\\\\n0, & \\|x\\| > h\n\\end{cases}\n\\]"}),"\n",l.createElement(t.p,null,"The choice of kernel and bandwidth ",l.createElement(r.A,{text:"\\(h\\)"})," (or ",l.createElement(r.A,{text:"\\(\\sigma\\)"})," for the Gaussian kernel) is crucial and can greatly affect the clustering outcome."),"\n",l.createElement(t.h2,{id:"mathematical-formulation",style:{position:"relative"}},l.createElement(t.a,{href:"#mathematical-formulation","aria-label":"mathematical formulation permalink",className:"anchor before"},l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Mathematical Formulation"),"\n",l.createElement(t.p,null,"Let's now take a deeper look into the equations involved. Consider a finite set of data points ",l.createElement(r.A,{text:"\\( S = \\{x_1, x_2, \\dots, x_n\\} \\)"})," in an ",l.createElement(r.A,{text:"\\(n\\)"}),"-dimensional Euclidean space ",l.createElement(r.A,{text:"\\( \\mathbb{R}^n \\)"}),"."),"\n",l.createElement(t.ol,null,"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"Kernel Density Estimation")," (KDE):"),"\n"),"\n",l.createElement(t.p,null,"We estimate the density around each point using a kernel ",l.createElement(r.A,{text:"\\( K \\)"}),", which is a non-negative function that integrates to 1:"),"\n",l.createElement(r.A,{text:"\\[\nf(x) = \\frac{1}{nh^n} \\sum_{i=1}^{n} K\\left(\\frac{x - x_i}{h}\\right)\n\\]"}),"\n",l.createElement(t.p,null,"Here, ",l.createElement(r.A,{text:"\\( h \\)"})," is the bandwidth of the kernel, which determines how far-reaching the influence of each data point is."),"\n",l.createElement(t.ol,{start:"2"},"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"Mean Shift Vector"),":"),"\n"),"\n",l.createElement(t.p,null,"We compute the mean shift vector ",l.createElement(r.A,{text:"\\( m(x) \\)"})," as the weighted mean of the data points within the neighborhood defined by the kernel:"),"\n",l.createElement(r.A,{text:"\\[\nm(x) = \\frac{\\sum_{x_i \\in N(x)} K(x_i - x) x_i}{\\sum_{x_i \\in N(x)} K(x_i - x)}\n\\]"}),"\n",l.createElement(t.p,null,"This moves each point towards regions of higher density. The iterative update rule becomes:"),"\n",l.createElement(r.A,{text:"\\[\nx \\leftarrow m(x)\n\\]"}),"\n",l.createElement(t.p,null,"This process repeats until convergence."),"\n",l.createElement(t.ol,{start:"3"},"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"Convergence"),":"),"\n"),"\n",l.createElement(t.p,null,"Mean shift will keep moving points until no significant shift occurs, i.e., when ",l.createElement(r.A,{text:"\\( m(x) - x \\)"})," is below a certain threshold. In practice, this means that the points settle into clusters, with each cluster center representing a mode of the density function."),"\n",l.createElement(t.h2,{id:"python-code-example",style:{position:"relative"}},l.createElement(t.a,{href:"#python-code-example","aria-label":"python code example permalink",className:"anchor before"},l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Python Code Example"),"\n",l.createElement(t.p,null,"Now, let's walk through a Python implementation using ",l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">scikit-learn</code>'}}),"'s built-in mean shift functionality, followed by a custom implementation for a deeper understanding."),"\n",l.createElement(t.p,null,"The mean shift algorithm seeks modes of the given set of points"),"\n",l.createElement(t.ol,null,"\n",l.createElement(t.li,null,"Choose kernel and bandwidth"),"\n",l.createElement(t.li,null,"For each point:\na) Center a window on that point\nb) Compute the mean of the data in the search window\nc) Center the search window at the new mean location\nd) Repeat (b,c) until convergence"),"\n",l.createElement(t.li,null,"Assign points that lead to nearby modes to the same cluster"),"\n"),"\n",l.createElement(t.h3,{id:"scikit-learn-implementation",style:{position:"relative"}},l.createElement(t.a,{href:"#scikit-learn-implementation","aria-label":"scikit learn implementation permalink",className:"anchor before"},l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Scikit-learn Implementation"),"\n",l.createElement(s.A,{text:"\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom sklearn.cluster import MeanShift\n\n## Generating synthetic data\nfrom sklearn.datasets import make_blobs\nX, _ = make_blobs(n_samples=500, centers=3, cluster_std=0.60, random_state=0)\n\n## Applying MeanShift\nms = MeanShift(bandwidth=2)\nms.fit(X)\nlabels = ms.labels_\ncluster_centers = ms.cluster_centers_\n\n## Plotting the results\nplt.scatter(X[:, 0], X[:, 1], c=labels, cmap='viridis')\nplt.scatter(cluster_centers[:, 0], cluster_centers[:, 1], s=300, c='red')\nplt.show()\n"}),"\n",l.createElement(t.h3,{id:"custom-implementation",style:{position:"relative"}},l.createElement(t.a,{href:"#custom-implementation","aria-label":"custom implementation permalink",className:"anchor before"},l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Custom Implementation"),"\n",l.createElement(t.p,null,"Below is a simplified custom mean shift implementation to show the underlying process:"),"\n",l.createElement(s.A,{text:"\nimport numpy as np\n\ndef gaussian_kernel(distance, bandwidth):\n    return np.exp(-0.5 * (distance / bandwidth) ** 2)\n\ndef mean_shift(X, bandwidth, max_iter=300):\n    points = np.copy(X)\n    for it in range(max_iter):\n        for i, point in enumerate(points):\n            distances = np.linalg.norm(X - point, axis=1)\n            weights = gaussian_kernel(distances, bandwidth)\n            weighted_sum = np.sum(X.T * weights, axis=1)\n            points[i] = weighted_sum / np.sum(weights)\n    \n    return points\n\n## Generating synthetic data\nfrom sklearn.datasets import make_blobs\nX, _ = make_blobs(n_samples=300, centers=4, cluster_std=0.70, random_state=0)\n\n## Applying custom mean shift\nshifted_points = mean_shift(X, bandwidth=2)\n\n## Plotting the results\nimport matplotlib.pyplot as plt\nplt.scatter(X[:, 0], X[:, 1], label='Original Points')\nplt.scatter(shifted_points[:, 0], shifted_points[:, 1], label='Shifted Points', c='red')\nplt.legend()\nplt.show()\n"}),"\n",l.createElement(t.h2,{id:"visualization-of-mean-shift-in-action",style:{position:"relative"}},l.createElement(t.a,{href:"#visualization-of-mean-shift-in-action","aria-label":"visualization of mean shift in action permalink",className:"anchor before"},l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Visualization of Mean Shift in Action"),"\n",l.createElement(t.p,null,"Imagine you have a circular kernel (or window) sweeping over your data points. At each iteration, the center of the kernel is moved to the mean of the points within its radius, shifting it toward denser regions of data until it settles at a peak (mode)."),"\n",l.createElement(t.p,null,"Here's an illustrative example of how the process works:"),"\n",l.createElement(t.img,{src:"mean_shift_process.png",alt:"Mean Shift Process"}),"\n",l.createElement(t.ol,null,"\n",l.createElement(t.li,null,"Initially, the kernel is placed at a random point in the feature space."),"\n",l.createElement(t.li,null,"The kernel shifts iteratively towards regions with higher data density (indicated by arrows)."),"\n",l.createElement(t.li,null,"Eventually, it converges to the mode, where no further significant shift occurs."),"\n"),"\n",l.createElement(t.h2,{id:"applications-of-mean-shift",style:{position:"relative"}},l.createElement(t.a,{href:"#applications-of-mean-shift","aria-label":"applications of mean shift permalink",className:"anchor before"},l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Applications of Mean Shift"),"\n",l.createElement(t.h3,{id:"1-clustering",style:{position:"relative"}},l.createElement(t.a,{href:"#1-clustering","aria-label":"1 clustering permalink",className:"anchor before"},l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"1. ",l.createElement(t.strong,null,"Clustering")),"\n",l.createElement(t.p,null,"Mean shift is widely used in clustering tasks. Unlike k-means, which requires the number of clusters to be predefined, mean shift adapts dynamically, making it a great fit for applications where the number of clusters is not known in advance."),"\n",l.createElement(t.h3,{id:"2-image-segmentation-and-smoothing",style:{position:"relative"}},l.createElement(t.a,{href:"#2-image-segmentation-and-smoothing","aria-label":"2 image segmentation and smoothing permalink",className:"anchor before"},l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"2. ",l.createElement(t.strong,null,"Image Segmentation and Smoothing")),"\n",l.createElement(t.p,null,"In image processing, mean shift is used for tasks like image segmentation, where it helps group pixels into distinct regions. It's also employed in ",l.createElement(t.strong,null,"smoothing")," images, particularly using the joint spatial-range domain, to remove noise while preserving edges."),"\n",l.createElement(t.h3,{id:"3-object-tracking",style:{position:"relative"}},l.createElement(t.a,{href:"#3-object-tracking","aria-label":"3 object tracking permalink",className:"anchor before"},l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"3. ",l.createElement(t.strong,null,"Object Tracking")),"\n",l.createElement(t.p,null,"In computer vision, mean shift can be used for object tracking. By creating a probability density function of the object's appearance in consecutive frames, mean shift tracks the object by converging to the peak of the PDF."),"\n",l.createElement(t.h2,{id:"strengths-and-weaknesses",style:{position:"relative"}},l.createElement(t.a,{href:"#strengths-and-weaknesses","aria-label":"strengths and weaknesses permalink",className:"anchor before"},l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Strengths and Weaknesses"),"\n",l.createElement(t.h3,{id:"strengths",style:{position:"relative"}},l.createElement(t.a,{href:"#strengths","aria-label":"strengths permalink",className:"anchor before"},l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Strengths:"),"\n",l.createElement(t.ul,null,"\n",l.createElement(t.li,null,"No need to predefine the number of clusters."),"\n",l.createElement(t.li,null,"Capable of handling non-linearly separable data."),"\n",l.createElement(t.li,null,"Applicable to a wide range of problems, including image processing and feature space analysis."),"\n"),"\n",l.createElement(t.p,null,"§ Good general-practice segmentation\n§ Flexible in number and shape of\nregions\n§ Robust to outliers"),"\n",l.createElement(t.h3,{id:"weaknesses",style:{position:"relative"}},l.createElement(t.a,{href:"#weaknesses","aria-label":"weaknesses permalink",className:"anchor before"},l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Weaknesses:"),"\n",l.createElement(t.ul,null,"\n",l.createElement(t.li,null,"Computationally expensive, especially for large datasets."),"\n",l.createElement(t.li,null,"Highly sensitive to the choice of bandwidth ",l.createElement(r.A,{text:"\\(h\\)"}),"."),"\n",l.createElement(t.li,null,"Convergence is not guaranteed for all kernel functions in high-dimensional spaces."),"\n"),"\n",l.createElement(t.p,null,"Have to choose kernel size in advance\n§ Not well suited for high-dimensional\nfeatures"),"\n",l.createElement(t.h2,{id:"conclusion",style:{position:"relative"}},l.createElement(t.a,{href:"#conclusion","aria-label":"conclusion permalink",className:"anchor before"},l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Conclusion"),"\n",l.createElement(t.p,null,"The ",l.createElement(t.strong,null,"mean shift algorithm")," is a powerful tool for clustering and density estimation, especially in scenarios where you don't want to make assumptions about the number of clusters in advance. By iteratively shifting data points towards higher-density regions, it finds the modes of a probability distribution"),"\n",l.createElement(t.p,null,"in a non-parametric way."),"\n",l.createElement(t.p,null,"Its flexibility makes it a popular choice for various applications, including computer vision and feature space analysis, but its computational complexity can be a drawback for larger datasets."),"\n",l.createElement(t.h3,{id:"next-steps",style:{position:"relative"}},l.createElement(t.a,{href:"#next-steps","aria-label":"next steps permalink",className:"anchor before"},l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Next Steps"),"\n",l.createElement(t.ul,null,"\n",l.createElement(t.li,null,"Experiment with different kernel bandwidths to see how they affect the clustering."),"\n",l.createElement(t.li,null,"Implement mean shift from scratch in Python and apply it to a real-world dataset."),"\n",l.createElement(t.li,null,"Dive deeper into applications like image segmentation or object tracking to see the algorithm's versatility."),"\n"),"\n",l.createElement(t.p,null,"Happy clustering!"),"\n",l.createElement(t.h2,{id:"mean-shift-algorithm-a-gentle-dive-into-mode-seeking",style:{position:"relative"}},l.createElement(t.a,{href:"#mean-shift-algorithm-a-gentle-dive-into-mode-seeking","aria-label":"mean shift algorithm a gentle dive into mode seeking permalink",className:"anchor before"},l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),l.createElement(t.strong,null,"Mean Shift Algorithm: A Gentle Dive Into Mode-Seeking")),"\n",l.createElement(t.p,null,"Alright, so you've probably heard of clustering algorithms like K-Means and DBSCAN, but today, we're talking about ",l.createElement(t.strong,null,"Mean Shift")," — one of the coolest unsupervised learning algorithms that often doesn't get enough attention. It's like K-Means but with fewer constraints, and it's got this great \"mode-seeking\" vibe to it."),"\n",l.createElement(t.h3,{id:"what-is-mean-shift-1",style:{position:"relative"}},l.createElement(t.a,{href:"#what-is-mean-shift-1","aria-label":"what is mean shift 1 permalink",className:"anchor before"},l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),l.createElement(t.strong,null,"What is Mean Shift?")),"\n",l.createElement(t.p,null,"Mean Shift is all about finding ",l.createElement(t.strong,null,"modes")," (aka peaks) in a data distribution. If you imagine your data points as little hills on a landscape, Mean Shift helps us find the tops of those hills. It doesn't need you to specify the number of clusters in advance, which is pretty awesome."),"\n",l.createElement(t.p,null,"The algorithm works by ",l.createElement(t.strong,null,"shifting")," each data point towards the densest part of the dataset — basically moving towards the center of mass of nearby points iteratively. Over time, points converge toward their nearest mode. This is how clusters naturally form."),"\n",l.createElement(t.p,null,"Let's break it down."),"\n",l.createElement(t.h3,{id:"step-by-step-breakdown",style:{position:"relative"}},l.createElement(t.a,{href:"#step-by-step-breakdown","aria-label":"step by step breakdown permalink",className:"anchor before"},l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),l.createElement(t.strong,null,"Step-by-step Breakdown")),"\n",l.createElement(t.h4,{id:"1-initializing-the-centroids-not-explicitly",style:{position:"relative"}},l.createElement(t.a,{href:"#1-initializing-the-centroids-not-explicitly","aria-label":"1 initializing the centroids not explicitly permalink",className:"anchor before"},l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"1. ",l.createElement(t.strong,null,"Initializing the Centroids (not explicitly)")),"\n",l.createElement(t.p,null,"Unlike K-Means, where you initialize specific centroids, here you start by considering every data point as a potential centroid. No need to specify ",l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">k</code>'}})," or anything — nice, right?"),"\n",l.createElement(t.h4,{id:"2-kernel-density-estimation",style:{position:"relative"}},l.createElement(t.a,{href:"#2-kernel-density-estimation","aria-label":"2 kernel density estimation permalink",className:"anchor before"},l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"2. ",l.createElement(t.strong,null,"Kernel Density Estimation")),"\n",l.createElement(t.p,null,"Mean Shift uses something called a ",l.createElement(t.strong,null,"kernel density estimation (KDE)"),' to estimate the density of points around each data point. You can think of it as a smooth curve fitted over your data, where "peaks" correspond to regions of high density.'),"\n",l.createElement(t.p,null,"The KDE formula typically involves a kernel function (often Gaussian), which gives higher weights to points that are closer to the data point of interest."),"\n",l.createElement(r.A,{text:"\\[\nf(x) = \\frac{1}{n h^d} \\sum_{i=1}^{n} K\\left(\\frac{x - x_i}{h}\\right)\n\\]"}),"\n",l.createElement(t.p,null,"Where:"),"\n",l.createElement(t.ul,null,"\n",l.createElement(t.li,null,l.createElement(r.A,{text:"\\( f(x) \\)"})," is the estimated density at point ",l.createElement(r.A,{text:"\\(x\\)"})),"\n",l.createElement(t.li,null,l.createElement(r.A,{text:"\\( x_i \\)"})," are the data points"),"\n",l.createElement(t.li,null,l.createElement(r.A,{text:"\\( h \\)"})," is the bandwidth (think of it as a smoothing parameter)"),"\n",l.createElement(t.li,null,l.createElement(r.A,{text:"\\( K \\)"})," is the kernel function (often a Gaussian function)"),"\n"),"\n",l.createElement(t.p,null,"So, for each point ",l.createElement(r.A,{text:"\\(x_i\\)"}),", we're basically summing up the kernel values of all other points weighted by their distance."),"\n",l.createElement(t.h4,{id:"3-mean-shift-vector",style:{position:"relative"}},l.createElement(t.a,{href:"#3-mean-shift-vector","aria-label":"3 mean shift vector permalink",className:"anchor before"},l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"3. ",l.createElement(t.strong,null,"Mean Shift Vector")),"\n",l.createElement(t.p,null,"Now comes the fun part. For each point, we compute the ",l.createElement(t.strong,null,"mean shift vector"),", which is essentially the difference between the current position and the weighted mean of nearby points (within a certain radius defined by the bandwidth)."),"\n",l.createElement(t.p,null,"Mathematically, the mean shift vector for a point ",l.createElement(r.A,{text:"\\(x_i\\)"})," is given by:"),"\n",l.createElement(r.A,{text:"\\[\nm(x_i) = \\frac{\\sum_{x_j \\in N(x_i)} K(x_j - x_i) x_j}{\\sum_{x_j \\in N(x_i)} K(x_j - x_i)} - x_i\n\\]"}),"\n",l.createElement(t.p,null,"Where ",l.createElement(r.A,{text:"\\(N(x_i)\\)"})," is the neighborhood around ",l.createElement(r.A,{text:"\\(x_i\\)"})," defined by the bandwidth. This vector basically tells us where the data point needs to shift to move closer to a high-density region."),"\n",l.createElement(t.h4,{id:"4-shift-the-points",style:{position:"relative"}},l.createElement(t.a,{href:"#4-shift-the-points","aria-label":"4 shift the points permalink",className:"anchor before"},l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"4. ",l.createElement(t.strong,null,"Shift the Points")),"\n",l.createElement(t.p,null,"Now, simply update the data point's location using the mean shift vector:"),"\n",l.createElement(r.A,{text:"\\[\nx_i^{(t+1)} = x_i^{(t)} + m(x_i)\n\\]"}),"\n",l.createElement(t.p,null,"This process is repeated for all points until convergence, i.e., when the shifts are really small, or points stay in the same place."),"\n",l.createElement(t.h4,{id:"5-convergence-and-clustering",style:{position:"relative"}},l.createElement(t.a,{href:"#5-convergence-and-clustering","aria-label":"5 convergence and clustering permalink",className:"anchor before"},l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"5. ",l.createElement(t.strong,null,"Convergence and Clustering")),"\n",l.createElement(t.p,null,"After enough iterations, each point will converge to a mode (i.e., a high-density region). Once this happens, you can assign points that converge to the same mode to the same cluster. This is super intuitive because points in the same high-density region belong together."),"\n",l.createElement(t.h3,{id:"bandwidth-the-secret-sauce",style:{position:"relative"}},l.createElement(t.a,{href:"#bandwidth-the-secret-sauce","aria-label":"bandwidth the secret sauce permalink",className:"anchor before"},l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),l.createElement(t.strong,null,"Bandwidth: The Secret Sauce")),"\n",l.createElement(t.p,null,"Now, let's talk about the ",l.createElement(t.strong,null,"bandwidth")," ",l.createElement(r.A,{text:"\\(h\\)"}),". This is one of the most important hyperparameters in Mean Shift, and it controls the size of the neighborhood around each point."),"\n",l.createElement(t.ul,null,"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"Small bandwidth"),": You get a lot of clusters (probably too many), because you're focusing on really local regions."),"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"Large bandwidth"),": You might end up merging a bunch of clusters together, even though they're distinct."),"\n"),"\n",l.createElement(t.p,null,"So, bandwidth is a bit like Goldilocks' porridge — find the one that's \"just right\" for your data."),"\n",l.createElement(t.h3,{id:"visualization-time",style:{position:"relative"}},l.createElement(t.a,{href:"#visualization-time","aria-label":"visualization time permalink",className:"anchor before"},l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),l.createElement(t.strong,null,"Visualization Time!")),"\n",l.createElement(t.p,null,"If you were to visualize Mean Shift in action, imagine dropping a bunch of marbles on a bumpy surface. Each marble represents a data point. As the algorithm progresses, the marbles roll upwards, following the slope, until they reach the peaks — those modes of high density. Once there, they stop. Marbles at the same peak belong to the same cluster."),"\n",l.createElement(t.hr),"\n",l.createElement(t.h2,{id:"mathematics-behind-mean-shift",style:{position:"relative"}},l.createElement(t.a,{href:"#mathematics-behind-mean-shift","aria-label":"mathematics behind mean shift permalink",className:"anchor before"},l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),l.createElement(t.strong,null,"Mathematics Behind Mean Shift")),"\n",l.createElement(t.p,null,"Okay, let's get a little math-heavy (because, why not?). If you're into optimization, you'll love this: Mean Shift can be interpreted as a ",l.createElement(t.strong,null,"gradient ascent")," on a density function. Yup, it's a fancy way of climbing a hill."),"\n",l.createElement(t.p,null,"Consider the density function ",l.createElement(r.A,{text:"\\( p(x) \\)"}),". We want to find the modes of this function by following the gradient. The gradient of a kernel density estimator (with a radially symmetric kernel) is proportional to the mean shift vector:"),"\n",l.createElement(r.A,{text:"\\[\n\\nabla p(x) \\propto m(x)\n\\]"}),"\n",l.createElement(t.p,null,'This is why the points move in the direction of the highest density. We\'re climbing the steepest part of the KDE "hill."'),"\n",l.createElement(t.hr),"\n",l.createElement(t.h2,{id:"advantages-of-mean-shift",style:{position:"relative"}},l.createElement(t.a,{href:"#advantages-of-mean-shift","aria-label":"advantages of mean shift permalink",className:"anchor before"},l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),l.createElement(t.strong,null,"Advantages of Mean Shift")),"\n",l.createElement(t.ol,null,"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"No need to predefine the number of clusters"),": Unlike K-Means, you don't need to know the number of clusters in advance. The algorithm just finds them for you."),"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"Versatile"),": It works well in scenarios where clusters don't necessarily have a spherical shape. (K-Means assumes clusters are roughly spherical, which isn't always true.)"),"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"Mode-seeking"),": It directly finds the modes, which is sometimes more intuitive for clustering tasks."),"\n"),"\n",l.createElement(t.hr),"\n",l.createElement(t.h2,{id:"disadvantages-of-mean-shift",style:{position:"relative"}},l.createElement(t.a,{href:"#disadvantages-of-mean-shift","aria-label":"disadvantages of mean shift permalink",className:"anchor before"},l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),l.createElement(t.strong,null,"Disadvantages of Mean Shift")),"\n",l.createElement(t.ol,null,"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"Computationally expensive"),": Mean Shift involves repeatedly shifting all points, which can be slow for large datasets."),"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"Bandwidth selection is tricky"),": Finding the right bandwidth can be a challenge, and there's no universal solution for choosing it."),"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"Sensitive to density estimation"),": The quality of your clusters depends heavily on how well your kernel density estimation represents the data."),"\n"),"\n",l.createElement(t.hr),"\n",l.createElement(t.h2,{id:"when-should-you-use-mean-shift",style:{position:"relative"}},l.createElement(t.a,{href:"#when-should-you-use-mean-shift","aria-label":"when should you use mean shift permalink",className:"anchor before"},l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),l.createElement(t.strong,null,"When Should You Use Mean Shift?")),"\n",l.createElement(t.p,null,"Mean Shift is especially useful when you don't know the number of clusters upfront, and you believe the clusters could be arbitrarily shaped. It works great for image segmentation, object tracking, and scenarios where clusters may be unevenly distributed or even noisy."),"\n",l.createElement(t.p,null,"However, for very large datasets, you might want to look into approximate versions of Mean Shift (such as using KD-trees for faster neighbor searches) or even alternative methods if scalability is a concern."),"\n",l.createElement(t.hr),"\n",l.createElement(t.h2,{id:"conclusion-1",style:{position:"relative"}},l.createElement(t.a,{href:"#conclusion-1","aria-label":"conclusion 1 permalink",className:"anchor before"},l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),l.createElement(t.strong,null,"Conclusion")),"\n",l.createElement(t.p,null,"So there you have it — Mean Shift in all its mode-seeking glory! It's a powerful clustering algorithm that can uncover complex structures in your data without making too many assumptions. While it's not the fastest kid on the block, it's got a unique charm and can handle some pretty tricky clustering scenarios. Now go forth and experiment with Mean Shift!"))}var c=function(e){void 0===e&&(e={});const{wrapper:t}=Object.assign({},(0,i.RP)(),e.components);return t?l.createElement(t,e,l.createElement(o,e)):o(e)};var h=n(36710),m=n(58481),d=n.n(m),u=n(36310),p=n(87245),f=n(27042),g=n(59849),v=n(5591),E=n(61122),y=n(9219),b=n(33203),w=n(95751),S=n(94328),x=n(80791),k=n(78137);const H=e=>{let{toc:t}=e;if(!t||!t.items)return null;return l.createElement("nav",{className:x.R},l.createElement("ul",null,t.items.map(((e,t)=>l.createElement("li",{key:t},l.createElement("a",{href:e.url,onClick:t=>((e,t)=>{e.preventDefault();const n=t.replace("#",""),a=document.getElementById(n);a&&a.scrollIntoView({behavior:"smooth",block:"start"})})(t,e.url)},e.title),e.items&&l.createElement(H,{toc:{items:e.items}}))))))};function _(e){let{data:{mdx:t,allMdx:r,allPostImages:s},children:o}=e;const{frontmatter:c,body:h,tableOfContents:m}=t,g=c.index,x=c.slug.split("/")[1],_=r.nodes.filter((e=>e.frontmatter.slug.includes(`/${x}/`))).sort(((e,t)=>e.frontmatter.index-t.frontmatter.index)),M=_.findIndex((e=>e.frontmatter.index===g)),C=_[M+1],T=_[M-1],z=c.slug.replace(/\/$/,""),A=/[^/]*$/.exec(z)[0],I=`posts/${x}/content/${A}/`,{0:V,1:N}=(0,l.useState)(c.flagWideLayoutByDefault),{0:L,1:B}=(0,l.useState)(!1);var P;(0,l.useEffect)((()=>{B(!0);const e=setTimeout((()=>B(!1)),340);return()=>clearTimeout(e)}),[V]),"adventures"===x?P=y.cb:"research"===x?P=y.Qh:"thoughts"===x&&(P=y.T6);const K=d()(h).replace(/import .*? from .*?;/g,"").replace(/<.*?>/g,"").replace(/\{\/\*[\s\S]*?\*\/\}/g,"").trim().split(/\s+/).length,j=function(e){if(e<=10)return"~10 min";if(e<=20)return"~20 min";if(e<=30)return"~30 min";if(e<=40)return"~40 min";if(e<=50)return"~50 min";if(e<=60)return"~1 h";const t=Math.floor(e/60),n=e%60;return n<=30?`~${t}${n>0?".5":""} h`:`~${t+1} h`}(Math.ceil(K/P)+(c.extraReadTimeMin||0)),D=[{flag:c.flagDraft,component:()=>Promise.all([n.e(3231),n.e(8809)]).then(n.bind(n,28809))},{flag:c.flagMindfuckery,component:()=>Promise.all([n.e(3231),n.e(2471)]).then(n.bind(n,67709))},{flag:c.flagRewrite,component:()=>Promise.all([n.e(3231),n.e(6764)]).then(n.bind(n,62002))},{flag:c.flagOffensive,component:()=>Promise.all([n.e(3231),n.e(2443)]).then(n.bind(n,17681))},{flag:c.flagProfane,component:()=>Promise.all([n.e(3231),n.e(8048)]).then(n.bind(n,53286))},{flag:c.flagMultilingual,component:()=>Promise.all([n.e(3231),n.e(4069)]).then(n.bind(n,78831))},{flag:c.flagUnreliably,component:()=>Promise.all([n.e(3231),n.e(3417)]).then(n.bind(n,8179))},{flag:c.flagPolitical,component:()=>Promise.all([n.e(3231),n.e(5195)]).then(n.bind(n,30433))},{flag:c.flagCognitohazard,component:()=>Promise.all([n.e(3231),n.e(3175)]).then(n.bind(n,8413))},{flag:c.flagHidden,component:()=>Promise.all([n.e(3231),n.e(9556)]).then(n.bind(n,14794))}],{0:O,1:G}=(0,l.useState)([]);return(0,l.useEffect)((()=>{D.forEach((e=>{let{flag:t,component:n}=e;t&&n().then((e=>{G((t=>[].concat((0,a.A)(t),[e.default])))}))}))}),[]),l.createElement(f.P.div,{initial:{opacity:0},animate:{opacity:1},exit:{opacity:0},transition:{duration:.15}},l.createElement(v.A,{postNumber:c.index,date:c.date,updated:c.updated,readTime:j,difficulty:c.difficultyLevel,title:c.title,desc:c.desc,banner:c.banner,section:x,postKey:A,isMindfuckery:c.flagMindfuckery,mainTag:c.mainTag}),l.createElement("div",{style:{display:"flex",justifyContent:"flex-end",flexWrap:"wrap",maxWidth:"75%",marginLeft:"auto",paddingRight:"1vw",marginTop:"-6vh",marginBottom:"4vh"}},c.otherTags.map(((e,t)=>l.createElement("span",{key:t,className:`noselect ${k.MW}`,style:{margin:"0 5px 5px 0"}},e)))),l.createElement("div",{className:"postBody"},l.createElement(H,{toc:m})),l.createElement("br"),l.createElement("div",{style:{margin:"0 10% -2vh 30%",textAlign:"right"}},l.createElement(f.P.button,{className:`noselect ${S.pb}`,id:S.xG,onClick:()=>{N(!V)},whileTap:{scale:.93}},l.createElement(f.P.div,{className:w.DJ,key:V,initial:{opacity:0},animate:{opacity:1},exit:{opacity:0},transition:{duration:.3,ease:"easeInOut"}},V?"Switch to default layout":"Switch to wide layout"))),l.createElement("br"),l.createElement("div",{className:"postBody",style:{margin:V?"0 -14%":"",maxWidth:V?"200%":"",transition:"margin 1s ease, max-width 1s ease, padding 1s ease"}},l.createElement("div",{className:`${S.P_} ${L?S.Xn:S.qG}`},O.map(((e,t)=>l.createElement(e,{key:t}))),c.indexCourse?l.createElement(b.A,{index:c.indexCourse,category:c.courseCategoryName}):"",l.createElement(u.Z.Provider,{value:{images:s.nodes,basePath:I.replace(/\/$/,"")+"/"}},l.createElement(i.xA,{components:{Image:p.A}},o)))),l.createElement(E.A,{nextPost:C,lastPost:T,keyCurrent:A,section:x}))}function M(e){return l.createElement(_,e,l.createElement(c,e))}function C(e){var t,n,a,i,r;let{data:s}=e;const{frontmatter:o}=s.mdx,c=o.titleSEO||o.title,m=o.titleOG||c,d=o.titleTwitter||c,u=o.descSEO||o.desc,p=o.descOG||u,f=o.descTwitter||u,v=o.schemaType||"BlogPosting",E=o.keywordsSEO,y=o.date,b=o.updated||y,w=o.imageOG||(null===(t=o.banner)||void 0===t||null===(n=t.childImageSharp)||void 0===n||null===(a=n.gatsbyImageData)||void 0===a||null===(i=a.images)||void 0===i||null===(r=i.fallback)||void 0===r?void 0:r.src),S=o.imageAltOG||p,x=o.imageTwitter||w,k=o.imageAltTwitter||f,H=o.canonicalURL,_=o.flagHidden||!1,M=o.mainTag||"Posts",C=o.slug.split("/")[1]||"posts",{siteUrl:T}=(0,h.Q)(),z={"@context":"https://schema.org","@type":"BreadcrumbList",itemListElement:[{"@type":"ListItem",position:1,name:"Home",item:T},{"@type":"ListItem",position:2,name:M,item:`${T}/${o.slug.split("/")[1]}`},{"@type":"ListItem",position:3,name:c,item:`${T}${o.slug}`}]};return l.createElement(g.A,{title:c+" - avrtt.blog",titleOG:m,titleTwitter:d,description:u,descriptionOG:p,descriptionTwitter:f,schemaType:v,keywords:E,datePublished:y,dateModified:b,imageOG:w,imageAltOG:S,imageTwitter:x,imageAltTwitter:k,canonicalUrl:H,flagHidden:_,mainTag:M,section:C,type:"article"},l.createElement("script",{type:"application/ld+json"},JSON.stringify(z)))}},96098:function(e,t,n){var a=n(96540),i=n(7978);t.A=e=>{let{text:t}=e;return a.createElement(i.A,null,t)}}}]);
//# sourceMappingURL=component---src-templates-post-js-content-file-path-src-pages-posts-research-mean-shift-mdx-034c81f284a9e21a2efe.js.map