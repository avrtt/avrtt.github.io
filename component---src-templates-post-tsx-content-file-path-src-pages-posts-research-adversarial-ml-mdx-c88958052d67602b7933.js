"use strict";(self.webpackChunkavrtt_blog=self.webpackChunkavrtt_blog||[]).push([[354],{3962:function(e,t){t.A="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iaXNvLTg4NTktMSI/Pgo8IS0tIEdlbmVyYXRvcjogQWRvYmUgSWxsdXN0cmF0b3IgMTYuMC4wLCBTVkcgRXhwb3J0IFBsdWctSW4gLiBTVkcgVmVyc2lvbjogNi4wMCBCdWlsZCAwKSAgLS0+CjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+CjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iQ2FwYV8xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4PSIwcHgiIHk9IjBweCIKCSB3aWR0aD0iNDE2Ljk3OXB4IiBoZWlnaHQ9IjQxNi45NzlweCIgdmlld0JveD0iMCAwIDQxNi45NzkgNDE2Ljk3OSIgc3R5bGU9ImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgNDE2Ljk3OSA0MTYuOTc5OyIKCSB4bWw6c3BhY2U9InByZXNlcnZlIj4KPGc+Cgk8cGF0aCBkPSJNMzU2LjAwNCw2MS4xNTZjLTgxLjM3LTgxLjQ3LTIxMy4zNzctODEuNTUxLTI5NC44NDgtMC4xODJjLTgxLjQ3LDgxLjM3MS04MS41NTIsMjEzLjM3OS0wLjE4MSwyOTQuODUKCQljODEuMzY5LDgxLjQ3LDIxMy4zNzgsODEuNTUxLDI5NC44NDksMC4xODFDNDM3LjI5MywyNzQuNjM2LDQzNy4zNzUsMTQyLjYyNiwzNTYuMDA0LDYxLjE1NnogTTIzNy42LDM0MC43ODYKCQljMCwzLjIxNy0yLjYwNyw1LjgyMi01LjgyMiw1LjgyMmgtNDYuNTc2Yy0zLjIxNSwwLTUuODIyLTIuNjA1LTUuODIyLTUuODIyVjE2Ny44ODVjMC0zLjIxNywyLjYwNy01LjgyMiw1LjgyMi01LjgyMmg0Ni41NzYKCQljMy4yMTUsMCw1LjgyMiwyLjYwNCw1LjgyMiw1LjgyMlYzNDAuNzg2eiBNMjA4LjQ5LDEzNy45MDFjLTE4LjYxOCwwLTMzLjc2Ni0xNS4xNDYtMzMuNzY2LTMzLjc2NQoJCWMwLTE4LjYxNywxNS4xNDctMzMuNzY2LDMzLjc2Ni0zMy43NjZjMTguNjE5LDAsMzMuNzY2LDE1LjE0OCwzMy43NjYsMzMuNzY2QzI0Mi4yNTYsMTIyLjc1NSwyMjcuMTA3LDEzNy45MDEsMjA4LjQ5LDEzNy45MDF6Ii8+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPC9zdmc+Cg=="},9360:function(e,t,a){a.d(t,{A:function(){return l}});var n=a(96540),i=a(3962),r="styles-module--tooltiptext--a263b";var l=e=>{let{text:t,isBadge:a=!1}=e;const{0:l,1:s}=(0,n.useState)(!1),o=(0,n.useRef)(null);return(0,n.useEffect)((()=>{function e(e){o.current&&e.target instanceof Node&&!o.current.contains(e.target)&&s(!1)}return document.addEventListener("click",e),()=>{document.removeEventListener("click",e)}}),[]),n.createElement("span",{className:"styles-module--tooltipWrapper--75ebf",ref:o},n.createElement("img",{id:a?"styles-module--infoBadge--e3d66":"styles-module--info--26c1f",src:i.A,alt:"info",onClick:e=>{e.stopPropagation(),s((e=>!e))}}),n.createElement("span",{className:l?`${r} styles-module--visible--c063c`:r},t))}},83617:function(e,t,a){a.r(t),a.d(t,{Head:function(){return T},PostTemplate:function(){return A},default:function(){return C}});var n=a(28453),i=a(96540),r=a(9360),l=a(61992),s=a(62087),o=a(90548);function c(e){const t=Object.assign({p:"p",hr:"hr",h2:"h2",a:"a",span:"span",blockquote:"blockquote",h3:"h3",ul:"ul",li:"li",em:"em",ol:"ol",strong:"strong",h4:"h4"},(0,n.RP)(),e.components),{Image:a}=t;return a||function(e,t){throw new Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Image",!0),i.createElement(i.Fragment,null,"\n",i.createElement("br"),"\n","\n","\n",i.createElement(t.p,null,"Adversarial machine learning has transformed from a niche concern to a central topic in the machine learning and data science community over the last decade. Although modern deep neural networks, especially convolutional neural networks (CNNs) and other large-scale architectures, boast remarkable accuracy on sophisticated tasks such as image recognition and language understanding, they can still be vulnerable to small and carefully crafted perturbations in their inputs. These tiny changes — typically undetectable or nearly imperceptible to a human observer — are capable of triggering dramatic misclassifications or performance degradation in what would otherwise be reliable models."),"\n",i.createElement(t.p,null,"The implications of these adversarial vulnerabilities are profound. From a security standpoint, a well-crafted adversarial example can subvert neural networks deployed in real-world systems — for instance in autonomous vehicles or facial recognition services — with potentially dire or malicious outcomes. If a self-driving car fails to detect pedestrians, or a face-recognition gate misidentifies unauthorized individuals, it becomes clear that small input perturbations may have severe consequences. The phenomenon underscores deep concerns about model interpretability and reliability, as well as the fundamental nature of how these high-dimensional models learn from data."),"\n",i.createElement(t.p,null,'Yet the scope of adversarial machine learning extends beyond malicious attacks. It also opens doors to interesting opportunities, such as building robust models by embracing adversarial training or using adversarial "patches" to detect and correct distribution shifts. In some cases, adversarial methods are used in data science tasks to detect significant mismatches between training and testing sets (so-called "adversarial validation"). From a theoretical standpoint, adversarial examples challenge longstanding assumptions about smoothness, manifold learning, and the geometry of the decision boundaries that high-capacity models learn to separate classes in high-dimensional space.'),"\n",i.createElement(t.p,null,"Despite extensive research, adversarial vulnerabilities in neural networks are nowhere near resolved. Emerging defense strategies seek to patch these holes, but each new defense often triggers the development of more adaptive or sophisticated attacks. Indeed, the arms race between attackers and defenders in the ML domain serves as a compelling mirror of more classical cybersecurity challenges. In this article, my aim is to dive into the theoretical underpinnings of adversarial machine learning, concretely illustrate common attack methods, demonstrate code-level details using popular frameworks such as PyTorch, and shed light on current defense approaches — all while maintaining an approachable, course-oriented style."),"\n",i.createElement(t.p,null,'We will also integrate relevant insights from the broader data science community, including references to the idea of "adversarial approaches" as they appear in tasks such as distribution mismatch checking and advanced data exploration. This notion overlaps with formal adversarial ML because it leverages the same concept of generating strategic data manipulations to probe potential weaknesses or relationships. By the end of this article, you should have a thorough conceptual and technical understanding of adversarial machine learning, including the motivations, foundational theory, established attacks, and emergent defenses.'),"\n",i.createElement(t.hr),"\n",i.createElement(t.h2,{id:"foundations-of-adversarial-machine-learning",style:{position:"relative"}},i.createElement(t.a,{href:"#foundations-of-adversarial-machine-learning","aria-label":"foundations of adversarial machine learning permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"foundations of adversarial machine learning"),"\n",i.createElement(t.p,null,"Adversarial machine learning generally focuses on creating adversarial perturbations or examples that push a learned model to produce incorrect or unexpected outputs. A simple but powerful way to phrase this is:"),"\n",i.createElement(t.blockquote,null,"\n",i.createElement(t.p,null,"How can we modify an input ",i.createElement(o.A,{text:"\\(x\\)"})," to become ",i.createElement(o.A,{text:"\\(x'\\)"})," so that ",i.createElement(o.A,{text:"\\(x'\\)"}),' is "close" to ',i.createElement(o.A,{text:"\\(x\\)"})," by human standards (or some formal distance metric) but leads the model ",i.createElement(o.A,{text:"\\(f(\\cdot)\\)"})," to produce a drastically different or specifically targeted output?"),"\n"),"\n",i.createElement(t.p,null,"In classification settings, we often want to ensure that ",i.createElement(o.A,{text:"\\(x'\\)"})," is misclassified with high confidence. In other scenarios (e.g., generative modeling), the adversarial objective can be more nuanced."),"\n",i.createElement(t.h3,{id:"definitions-and-notations",style:{position:"relative"}},i.createElement(t.a,{href:"#definitions-and-notations","aria-label":"definitions and notations permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"definitions and notations"),"\n",i.createElement(t.p,null,"Let:"),"\n",i.createElement(t.ul,null,"\n",i.createElement(t.li,null,i.createElement(l.A,null,"f")," be a trained machine learning model, such as a deep neural network parameterized by ",i.createElement(o.A,{text:"\\( \\theta \\)"}),"."),"\n",i.createElement(t.li,null,i.createElement(o.A,{text:"\\( x \\)"})," be an input (for instance, an image) belonging to some data manifold or broader input space ",i.createElement(o.A,{text:"\\( \\mathcal{X} \\)"}),"."),"\n",i.createElement(t.li,null,i.createElement(o.A,{text:"\\( y \\)"})," be the ground truth label (in classification tasks) or ground truth target (in regression tasks)."),"\n",i.createElement(t.li,null,i.createElement(o.A,{text:"\\( x' \\)"})," be the adversarially perturbed version of ",i.createElement(o.A,{text:"\\( x \\)"}),"."),"\n",i.createElement(t.li,null,"A typical requirement is ",i.createElement(o.A,{text:"\\( \\| x' - x \\| \\le \\epsilon \\)"}),", where ",i.createElement(o.A,{text:"\\( \\|\\cdot\\| \\)"})," denotes some norm (e.g., ",i.createElement(o.A,{text:"\\( \\ell_\\infty \\)"})," or ",i.createElement(o.A,{text:"\\( \\ell_2 \\)"}),") and ",i.createElement(o.A,{text:"\\( \\epsilon \\)"})," is a small radius. In words, ",i.createElement(o.A,{text:"\\( x' \\)"})," must remain perceptually close to ",i.createElement(o.A,{text:"\\( x \\)"}),"."),"\n"),"\n",i.createElement(t.p,null,"An attack is frequently framed as an optimization problem. We want to find:"),"\n",i.createElement(s.A,{text:"\n# Pseudocode-like example for an adversarial objective\n# We want to maximize the model's loss w.r.t. x':\n\nmaximize   Loss(f(x'), y)\nsubject to ||x' - x|| <= epsilon\n"}),"\n",i.createElement(t.p,null,"The standard training loop aims to minimize loss with respect to network parameters ",i.createElement(o.A,{text:"\\( \\theta \\)"}),". An adversarial method flips this viewpoint, effectively searching over ",i.createElement(o.A,{text:"\\( x' \\)"})," within an ",i.createElement(o.A,{text:"\\(\\epsilon\\)"}),"-bounded region around the original ",i.createElement(o.A,{text:"\\( x \\)"})," to ",i.createElement(t.em,null,"maximize")," the same loss or to achieve a targeted misclassification."),"\n",i.createElement(t.h3,{id:"threat-models",style:{position:"relative"}},i.createElement(t.a,{href:"#threat-models","aria-label":"threat models permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"threat models"),"\n",i.createElement(t.p,null,'A crucial notion in adversarial machine learning is the "threat model". It defines the attacker\'s knowledge and capabilities. Two canonical threat models are:'),"\n",i.createElement(t.ol,null,"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"White-box attacks"),": The adversary has complete access to the model, its architecture, and parameters. The adversary can thus compute or approximate gradients ",i.createElement(o.A,{text:"\\( \\nabla_x \\)"})," of the loss function with respect to inputs."),"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Black-box attacks"),": The adversary only sees outputs or predictions from the model. They do not know the exact architecture, parameters, or direct gradient values. Instead, they might query the model repeatedly or try to transfer adversarial examples from surrogate models that mimic the behavior of the unknown target."),"\n"),"\n",i.createElement(t.h3,{id:"early-work-and-subsequent-research",style:{position:"relative"}},i.createElement(t.a,{href:"#early-work-and-subsequent-research","aria-label":"early work and subsequent research permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"early work and subsequent research"),"\n",i.createElement(t.p,null,"Initial demonstrations of adversarial instability date back to (Szegedy and gang, 2013) and (Goodfellow and gang, 2015), where they introduced fundamental concepts like the Fast Gradient Sign Method (FGSM). Subsequent efforts (Kurakin and gang, 2016; Carlini & Wagner, 2017; Madry and gang, 2018) systematically improved the quality of adversarial examples and extended them to many settings: from straightforward image classification tasks to more complex segmentation and object detection tasks in computer vision, as well as to natural language processing (NLP) and tabular data."),"\n",i.createElement(t.p,null,"In parallel, defenses advanced. Researchers developed adversarial training methods (Madry and gang, 2018), defensive distillation (Papernot and gang, 2016), input preprocessing strategies (Guo and gang, 2018), detection-based defenses, or even robust optimization frameworks. These solutions often claimed partial success but frequently spurred new and more creative attacks in a cat-and-mouse dynamic."),"\n",i.createElement(t.p,null,"Beyond direct security concerns, adversarial strategies sometimes find use in verifying distribution alignment, searching for data leaks (in so-called adversarial validation in Kaggle or data science competitions), or diagnosing overfitting. The concept is broad and continues to evolve — bridging pure theoretical explorations about high-dimensional geometry to highly practical concerns about safely deploying machine learning in the real world."),"\n",i.createElement(t.hr),"\n",i.createElement(t.h2,{id:"white-box-attacks",style:{position:"relative"}},i.createElement(t.a,{href:"#white-box-attacks","aria-label":"white box attacks permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"white-box attacks"),"\n",i.createElement(t.p,null,"White-box attacks assume the adversary has full visibility into the model's architecture, parameters, and training process. Under this assumption, an attacker can calculate gradients of the loss function with respect to the input features. The strong assumption typically yields some of the most potent adversarial attack methods."),"\n",i.createElement(t.h3,{id:"fast-gradient-sign-method-fgsm",style:{position:"relative"}},i.createElement(t.a,{href:"#fast-gradient-sign-method-fgsm","aria-label":"fast gradient sign method fgsm permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"fast gradient sign method (fgsm)"),"\n",i.createElement(t.h4,{id:"conceptual-overview",style:{position:"relative"}},i.createElement(t.a,{href:"#conceptual-overview","aria-label":"conceptual overview permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"conceptual overview"),"\n",i.createElement(t.p,null,"The Fast Gradient Sign Method (FGSM) stands out as one of the earliest and most direct algorithms to produce adversarial perturbations (Goodfellow and gang, 2015). The rationale is simple: if you want to ",i.createElement(t.em,null,"increase")," the model's loss for a particular input ",i.createElement(o.A,{text:"\\( x \\)"}),", then move ",i.createElement(o.A,{text:"\\( x \\)"})," a small step in the direction of the ",i.createElement(t.em,null,"gradient of the loss with respect to ",i.createElement(o.A,{text:"\\( x \\)"})),". In typical training, we do gradient descent on parameters ",i.createElement(o.A,{text:"\\( \\theta \\)"}),". But in FGSM, we do a single gradient ",i.createElement(t.em,null,"ascent")," step with respect to ",i.createElement(o.A,{text:"\\( x \\)"}),"."),"\n",i.createElement(t.p,null,"Formally, let ",i.createElement(o.A,{text:"\\( J(\\theta, x, y) \\)"})," be the loss function for model parameters ",i.createElement(o.A,{text:"\\( \\theta \\)"}),", input ",i.createElement(o.A,{text:"\\( x \\)"}),", and label ",i.createElement(o.A,{text:"\\( y \\)"}),". FGSM constructs an adversarial example ",i.createElement(o.A,{text:"\\( x' \\)"})," as follows:"),"\n",i.createElement(o.A,{text:"\\[\nx' = x + \\epsilon \\,\\mathrm{sign}\\bigl(\\nabla_x \\, J(\\theta, x, y)\\bigr),\n\\]"}),"\n",i.createElement(t.p,null,"where:"),"\n",i.createElement(t.ul,null,"\n",i.createElement(t.li,null,i.createElement(o.A,{text:"\\( \\epsilon \\)"})," is a small scalar controlling the perturbation strength (often in ",i.createElement(o.A,{text:"\\( \\ell_\\infty \\)"})," norm)."),"\n",i.createElement(t.li,null,i.createElement(o.A,{text:"\\( \\mathrm{sign}(\\cdot) \\)"})," takes the sign of each gradient component, effectively creating a small uniform shift per dimension but aligned with the direction that maximizes the loss."),"\n"),"\n",i.createElement(t.p,null,"Visually, FGSM can be seen as the simplest first-order approximation that pushes ",i.createElement(o.A,{text:"\\( x \\)"})," outward along the cost's gradient. Despite its simplicity, FGSM can be surprisingly effective at fooling a wide variety of neural network architectures, even for modest values of ",i.createElement(o.A,{text:"\\( \\epsilon \\)"})," (e.g., 0.01 or 0.02 in normalized pixel scales)."),"\n",i.createElement(t.h4,{id:"mathematical-formulation",style:{position:"relative"}},i.createElement(t.a,{href:"#mathematical-formulation","aria-label":"mathematical formulation permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"mathematical formulation"),"\n",i.createElement(t.p,null,"Given a model ",i.createElement(o.A,{text:"\\( f_\\theta(\\cdot) \\)"})," that outputs logits or probability estimates, define the standard cross-entropy loss for classification:"),"\n",i.createElement(o.A,{text:"\\[\nJ(\\theta, x, y) = -\\sum_{c=1}^{C} \\mathbb{1}[c = y] \\log \\bigl(\\sigma(f_\\theta(x))_c\\bigr)\n\\]"}),"\n",i.createElement(t.p,null,"where ",i.createElement(o.A,{text:"\\( \\sigma(\\cdot) \\)"})," is the softmax function, and ",i.createElement(o.A,{text:"\\( C \\)"})," is the number of classes. We compute ",i.createElement(o.A,{text:"\\( \\nabla_x J(\\theta, x, y) \\)"}),", the gradient with respect to the input ",i.createElement(o.A,{text:"\\( x \\)"}),". Each component of that gradient indicates how a small change in one pixel (or feature) can increase or decrease the loss. FGSM simply aggregates the sign of those components and multiplies by ",i.createElement(o.A,{text:"\\( \\epsilon \\)"}),":"),"\n",i.createElement(o.A,{text:"\\[\n\\nabla_x J(\\theta, x, y) \\in \\mathbb{R}^d \\quad\\text{(if x is d-dimensional)}\n\\]"}),"\n",i.createElement(o.A,{text:"\\[\n\\mathrm{sign}\\bigl(\\nabla_x J(\\theta, x, y)\\bigr) \\in \\{-1, +1\\}^d.\n\\]"}),"\n",i.createElement(t.p,null,"Hence:"),"\n",i.createElement(o.A,{text:"\\[\nx' = x + \\epsilon \\,\\mathrm{sign}\\bigl(\\nabla_x \\, J(\\theta, x, y)\\bigr).\n\\]"}),"\n",i.createElement(t.p,null,"If ",i.createElement(o.A,{text:"\\( \\epsilon \\)"})," is small enough (in the 0–1 scaled image domain, it might be around 0.01–0.05), ",i.createElement(o.A,{text:"\\( x' \\)"})," typically looks identical or nearly identical to ",i.createElement(o.A,{text:"\\( x \\)"})," from a human perspective, yet ",i.createElement(o.A,{text:"\\( f_\\theta \\)"})," can produce a drastically different or incorrect classification."),"\n",i.createElement(t.h4,{id:"implementation-details",style:{position:"relative"}},i.createElement(t.a,{href:"#implementation-details","aria-label":"implementation details permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"implementation details"),"\n",i.createElement(t.p,null,"Below is a concise illustration of FGSM in PyTorch-like pseudocode. The snippet assumes you already have a pretrained model ",i.createElement(l.A,null,"model"),", an input image batch ",i.createElement(l.A,null,"images"),", and ground-truth labels ",i.createElement(l.A,null,"labels"),". Notice how the only difference from typical training code is that we treat the input ",i.createElement(l.A,null,"images")," as a parameter that we differentiate with respect to:"),"\n",i.createElement(s.A,{text:"\nimport torch\nimport torch.nn.functional as F\n\ndef fgsm_attack(model, images, labels, epsilon):\n    # Ensure gradients wrt 'images' can be computed\n    images.requires_grad = True\n    \n    # Forward pass\n    outputs = model(images)\n    loss = F.cross_entropy(outputs, labels)\n    \n    # Backprop to get gradient wrt input images\n    model.zero_grad()\n    loss.backward()\n    \n    # Collect sign of gradient\n    grad_sign = images.grad.sign()\n    \n    # Create the perturbed image by adjusting each pixel\n    perturbed_images = images + epsilon * grad_sign\n    \n    # Clip to valid image range [0,1] if needed (or other normalization)\n    perturbed_images = torch.clamp(perturbed_images, 0, 1)\n    \n    return perturbed_images\n"}),"\n",i.createElement(t.p,null,"In practice, you might also consider domain-specific transformations or stricter constraints on pixel changes. In some frameworks, images are normalized or scaled differently, so ",i.createElement(o.A,{text:"\\( \\epsilon \\)"})," must be calibrated accordingly."),"\n",i.createElement(t.h4,{id:"visualization-of-adversarial-noise",style:{position:"relative"}},i.createElement(t.a,{href:"#visualization-of-adversarial-noise","aria-label":"visualization of adversarial noise permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"visualization of adversarial noise"),"\n",i.createElement(t.p,null,"Often, to illustrate how subtle (yet devastating) the perturbations are, we can display the raw noise ",i.createElement(o.A,{text:"\\( x' - x \\)"})," on a gray scale or color scale. Even if it looks random, the gradient sign has specifically arranged the directions of each pixel so as to maximize the model's classification error. These perturbations can appear like high-frequency static or faint outlines of shapes that align with a class-specific signature."),"\n",i.createElement(t.h3,{id:"projected-gradient-descent-pgd",style:{position:"relative"}},i.createElement(t.a,{href:"#projected-gradient-descent-pgd","aria-label":"projected gradient descent pgd permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"projected gradient descent (pgd)"),"\n",i.createElement(t.h4,{id:"iterative-refinement-of-adversarial-examples",style:{position:"relative"}},i.createElement(t.a,{href:"#iterative-refinement-of-adversarial-examples","aria-label":"iterative refinement of adversarial examples permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"iterative refinement of adversarial examples"),"\n",i.createElement(t.p,null,"While FGSM operates with a single-step gradient, the Projected Gradient Descent (PGD) method (Madry and gang, 2018) refines this approach through ",i.createElement(t.em,null,"iterative")," gradient steps. PGD is thus sometimes referred to as the iterative version of FGSM. Instead of applying ",i.createElement(o.A,{text:"\\( \\epsilon \\)"})," in a single shot, PGD applies several smaller steps (e.g., each of size ",i.createElement(o.A,{text:"\\( \\alpha \\)"}),") in the direction of the gradient. After each step, it projects the perturbed input back into the ",i.createElement(o.A,{text:"\\( \\ell_p \\)"})," ball of radius ",i.createElement(o.A,{text:"\\( \\epsilon \\)"})," around the original ",i.createElement(o.A,{text:"\\( x \\)"})," to ensure the total distortion remains bounded."),"\n",i.createElement(t.p,null,"In formula form, starting with ",i.createElement(o.A,{text:"\\( x_0 = x \\)"}),":"),"\n",i.createElement(o.A,{text:"\\[\nx_{t+1} = \\prod_{\\|x - x_0\\|\\le \\epsilon} \\Bigl( x_t + \\alpha\\, \\mathrm{sign}\\bigl(\\nabla_{x_t}J(\\theta,x_t,y)\\bigr) \\Bigr)\n\\]"}),"\n",i.createElement(t.p,null,"where ",i.createElement(o.A,{text:"\\( \\prod_{\\|x-x_0\\|\\le \\epsilon}\\bigl(\\cdot\\bigr) \\)"})," denotes the projection operator that enforces ",i.createElement(o.A,{text:"\\( \\|x_t - x\\|\\le \\epsilon \\)"}),"."),"\n",i.createElement(t.p,null,"PGD tends to yield stronger adversarial examples than the single-step FGSM since it systematically searches within the ",i.createElement(o.A,{text:"\\( \\epsilon \\)"}),'-bounded region. Indeed, Madry and gang (ICLR 2018) propose PGD as a "universal first-order adversary," meaning that if a network is robust against PGD across all random restarts, it is robust against a broad class of first-order attacks.'),"\n",i.createElement(t.h4,{id:"comparison-with-fgsm",style:{position:"relative"}},i.createElement(t.a,{href:"#comparison-with-fgsm","aria-label":"comparison with fgsm permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"comparison with fgsm"),"\n",i.createElement(t.ul,null,"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"FGSM")," is fast, requiring only one gradient pass, thus it is sometimes used in real-time or large-scale generation scenarios (or as part of adversarial training for a quick data augmentation step)."),"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"PGD")," is more computationally expensive but typically produces more potent adversarial examples, often resulting in significantly lower accuracy for the victim model."),"\n"),"\n",i.createElement(t.h3,{id:"other-gradient-based-attacks",style:{position:"relative"}},i.createElement(t.a,{href:"#other-gradient-based-attacks","aria-label":"other gradient based attacks permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"other gradient-based attacks"),"\n",i.createElement(t.h4,{id:"carlini--wagner-attacks",style:{position:"relative"}},i.createElement(t.a,{href:"#carlini--wagner-attacks","aria-label":"carlini  wagner attacks permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"carlini & wagner attacks"),"\n",i.createElement(t.p,null,"Carlini & Wagner (C&W) introduced a family of attacks (Carlini & Wagner, 2017) that focus on optimizing a refined objective function that includes:"),"\n",i.createElement(t.ol,null,"\n",i.createElement(t.li,null,"A term encouraging misclassification,"),"\n",i.createElement(t.li,null,"A term penalizing the size of the perturbation."),"\n"),"\n",i.createElement(t.p,null,"In short, the C&W attacks solve a more intricate optimization. They often generate adversarial perturbations that are ",i.createElement(t.em,null,"visually")," imperceptible yet extremely effective at fooling a network. They also handle targeted misclassifications (where you want ",i.createElement(o.A,{text:"\\( x' \\)"})," to appear as class ",i.createElement(o.A,{text:"\\( y_{\\text{target}} \\)"}),")."),"\n",i.createElement(t.p,null,"Though more computationally demanding than FGSM or PGD, C&W attacks historically have proven highly effective at circumventing many proposed defense mechanisms, thereby acting as a strong benchmark in adversarial robustness research."),"\n",i.createElement(t.h4,{id:"deepfool",style:{position:"relative"}},i.createElement(t.a,{href:"#deepfool","aria-label":"deepfool permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"deepfool"),"\n",i.createElement(t.p,null,"DeepFool (Moosavi-Dezfooli and gang, 2016) finds minimal perturbations that move the sample across the nearest decision boundary. It approximates the boundary in a piecewise linear sense and iteratively refines the perturbation. The key idea is that in high-dimensional spaces, a linear approximation can identify the most direct path from ",i.createElement(o.A,{text:"\\( x \\)"})," to a misclassification boundary."),"\n",i.createElement(t.p,null,"DeepFool typically yields smaller perturbation norms (in ",i.createElement(o.A,{text:"\\( \\ell_2 \\)"})," sense) compared to simpler methods, and often reveals vulnerabilities that single-step methods cannot. It is, however, less straightforward to incorporate into adversarial training than FGSM or PGD, primarily because it's more complex to implement at large scale."),"\n",i.createElement(t.hr),"\n",i.createElement(t.h2,{id:"black-box-attacks",style:{position:"relative"}},i.createElement(t.a,{href:"#black-box-attacks","aria-label":"black box attacks permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"black-box attacks"),"\n",i.createElement(t.p,null,"Contrary to white-box settings, in black-box attacks the adversary lacks direct access to the model's gradients or structure. Instead, the attacker must rely on limited knowledge (maybe only input-output queries or even less). Although this restriction complicates the generation of adversarial examples, a variety of black-box attack strategies have proven feasible and potent."),"\n",i.createElement(t.h3,{id:"zero-knowledge-attacks-vs-limited-knowledge-attacks",style:{position:"relative"}},i.createElement(t.a,{href:"#zero-knowledge-attacks-vs-limited-knowledge-attacks","aria-label":"zero knowledge attacks vs limited knowledge attacks permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"zero-knowledge attacks vs. limited-knowledge attacks"),"\n",i.createElement(t.ul,null,"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Zero-knowledge attacks"),": The attacker only knows the final predictions or decisions of the model and cannot make multiple queries to adjust or refine the attack. In extreme cases, the attacker just knows that a classifier ",i.createElement(o.A,{text:"\\( f(\\cdot) \\)"})," exists and is seeking a universal or random approach to degrade its performance."),"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Limited-knowledge attacks"),': The attacker can query the model multiple times and observe outputs (such as the predicted class probabilities, top-1 label, or even confidence scores). Over repeated queries, it is possible to estimate partial gradient signals or build a local "surrogate model."'),"\n"),"\n",i.createElement(t.h3,{id:"query-based-approaches",style:{position:"relative"}},i.createElement(t.a,{href:"#query-based-approaches","aria-label":"query based approaches permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"query-based approaches"),"\n",i.createElement(t.p,null,"In a query-based black-box attack, the idea is to approximate the gradient by measuring how small changes to ",i.createElement(o.A,{text:"\\( x \\)"})," influence the model's output. For instance, one can do finite-difference approximations:"),"\n",i.createElement(o.A,{text:"\\[\n\\frac{\\partial J}{\\partial x_i} \\approx \\frac{J(\\theta, x + \\delta e_i, y) - J(\\theta, x, y)}{\\delta}\n\\]"}),"\n",i.createElement(t.p,null,"where ",i.createElement(o.A,{text:"\\( e_i \\)"})," is a one-hot perturbation to the ",i.createElement(o.A,{text:"\\( i \\)"}),"-th feature. Although straightforward, a naive version of this approach requires a large number of queries (linear in the input dimension). More sophisticated approaches reduce query complexity, for example by using random gradient estimates or evolutionary search."),"\n",i.createElement(t.h3,{id:"surrogate-model-attacks-transferability-in-black-box-settings",style:{position:"relative"}},i.createElement(t.a,{href:"#surrogate-model-attacks-transferability-in-black-box-settings","aria-label":"surrogate model attacks transferability in black box settings permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"surrogate model attacks (transferability in black-box settings)"),"\n",i.createElement(t.p,null,"One of the most remarkable (and troubling) facts about adversarial examples is their ",i.createElement(t.em,null,"transferability"),". If an attacker trains their own surrogate or substitute model ",i.createElement(o.A,{text:"\\( g(\\cdot) \\)"})," on a similar dataset and obtains a set of adversarial examples that fool ",i.createElement(o.A,{text:"\\( g \\)"})," in a white-box manner, there's a surprisingly high chance that these same examples will also fool the ",i.createElement(t.em,null,"target")," model ",i.createElement(o.A,{text:"\\( f \\)"}),"."),"\n",i.createElement(t.p,null,"Transferability arises because different neural networks, especially if they share comparable architectures or have been trained on the same dataset, often learn similar decision boundaries. This phenomenon is a powerful advantage for black-box attackers because they can craft adversarial examples using their local surrogate model and then simply feed these examples to the actual remote or proprietary model."),"\n",i.createElement(t.h3,{id:"evolutionary-and-optimization-based-methods",style:{position:"relative"}},i.createElement(t.a,{href:"#evolutionary-and-optimization-based-methods","aria-label":"evolutionary and optimization based methods permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"evolutionary and optimization-based methods"),"\n",i.createElement(t.p,null,"Where gradient approximations are infeasible or too expensive, attackers can resort to population-based search, genetic algorithms, or more general derivative-free optimization. These black-box search strategies treat the input as a solution vector in a large search space, evolving it in ways that reduce or alter the target model's confidence in the correct label. Although these methods can also be expensive in terms of queries, they have proven effective in scenarios with partial model feedback or unusual data types (e.g. discrete tokens in NLP)."),"\n",i.createElement(t.hr),"\n",i.createElement(t.h2,{id:"adversarial-patches",style:{position:"relative"}},i.createElement(t.a,{href:"#adversarial-patches","aria-label":"adversarial patches permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"adversarial patches"),"\n",i.createElement(t.h3,{id:"concept-of-patch-attacks-and-localized-perturbations",style:{position:"relative"}},i.createElement(t.a,{href:"#concept-of-patch-attacks-and-localized-perturbations","aria-label":"concept of patch attacks and localized perturbations permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"concept of patch attacks and localized perturbations"),"\n",i.createElement(t.p,null,'Adversarial patches (Brown and gang, 2017) expand the notion of adversarial examples beyond subtle pixel-level changes across the entire image. Instead, a patch focuses on a localized region. By simply pasting (digitally or physically) a small square or pattern anywhere on an image, an attacker can force a misclassification. Unlike an "imperceptible noise" approach, an adversarial patch is often quite visible. Yet from a real-world standpoint, it can be placed or printed in a way that does not arouse suspicion.'),"\n",i.createElement(t.h3,{id:"training-adversarial-patches",style:{position:"relative"}},i.createElement(t.a,{href:"#training-adversarial-patches","aria-label":"training adversarial patches permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"training adversarial patches"),"\n",i.createElement(t.p,null,"Instead of solving for a small perturbation ",i.createElement(o.A,{text:"\\( \\delta \\)"})," for each image ",i.createElement(o.A,{text:"\\( x \\)"}),", we now solve for a universal patch ",i.createElement(o.A,{text:"\\( P \\)"})," that, when pasted onto any image, systematically causes misclassification. Typically, we pick a target class ",i.createElement(o.A,{text:"\\( y_{\\mathrm{target}} \\)"})," and want ",i.createElement(o.A,{text:"\\( f_\\theta(x + \\mathrm{PatchOverlay}(P,x)) = y_{\\mathrm{target}} \\)"})," for many or most images ",i.createElement(o.A,{text:"\\( x \\)"}),"."),"\n",i.createElement(t.p,null,"One approach is:"),"\n",i.createElement(t.ol,null,"\n",i.createElement(t.li,null,"Initialize the patch ",i.createElement(o.A,{text:"\\( P \\)"})," randomly (or set it to an image from ",i.createElement(o.A,{text:"\\( y_{\\mathrm{target}} \\)"}),")."),"\n",i.createElement(t.li,null,"In each training iteration:","\n",i.createElement(t.ul,null,"\n",i.createElement(t.li,null,"Sample a minibatch of images."),"\n",i.createElement(t.li,null,"Randomly place the patch ",i.createElement(o.A,{text:"\\( P \\)"})," in each image (optionally with random rotation or scaling)."),"\n",i.createElement(t.li,null,"Compute the loss that encourages the model to predict class ",i.createElement(o.A,{text:"\\( y_{\\mathrm{target}} \\)"})," for these patched images."),"\n",i.createElement(t.li,null,"Update ",i.createElement(o.A,{text:"\\( P \\)"})," in the direction of the gradient that maximizes this objective, typically with standard stochastic gradient ascent."),"\n"),"\n"),"\n"),"\n",i.createElement(t.h3,{id:"objective-function-and-optimization",style:{position:"relative"}},i.createElement(t.a,{href:"#objective-function-and-optimization","aria-label":"objective function and optimization permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"objective function and optimization"),"\n",i.createElement(t.p,null,"For a batch of images ",i.createElement(o.A,{text:"\\( (x_i, y_i) \\)"})," with ",i.createElement(o.A,{text:"\\( i=1,\\ldots,B \\)"}),", we define a patching operation ",i.createElement(o.A,{text:"\\( \\mathrm{PatchOverlay}(P,x_i) \\)"})," that returns the image with the patch applied at some random location. Then let:"),"\n",i.createElement(o.A,{text:"\\[\n\\mathcal{L}(\\theta, P) \\;=\\; \\sum_{i=1}^B J\\Bigl(\\theta,\\; x_i + \\mathrm{PatchOverlay}(P,x_i),\\; y_{\\mathrm{target}}\\Bigr),\n\\]"}),"\n",i.createElement(t.p,null,"where ",i.createElement(o.A,{text:"\\( y_{\\mathrm{target}} \\)"})," is the desired fooling label. Minimizing this with respect to the neural net parameters ",i.createElement(o.A,{text:"\\( \\theta \\)"})," is not our aim; instead, we consider ",i.createElement(o.A,{text:"\\( \\theta \\)"})," as fixed, and we ",i.createElement(t.em,null,"maximize")," with respect to ",i.createElement(o.A,{text:"\\( P \\)"}),":"),"\n",i.createElement(o.A,{text:"\\[\nP^* = \\mathrm{argmax}_P \\;\\mathcal{L}(\\theta, P).\n\\]"}),"\n",i.createElement(t.p,null,"Stochastic gradient ascent steps:"),"\n",i.createElement(o.A,{text:"\\[\nP \\;\\leftarrow\\; P + \\eta\\;\\nabla_P\\,\\mathcal{L}(\\theta, P).\n\\]"}),"\n",i.createElement(t.p,null,"One detail: we typically constrain ",i.createElement(o.A,{text:"\\( P \\)"})," to be a valid image region, e.g., pixel intensities in ",i.createElement(o.A,{text:"\\( [0,1] \\)"}),". This can be enforced by clamping or a ",i.createElement(o.A,{text:"\\( \\tanh(\\cdot) \\)"})," transformation."),"\n",i.createElement(t.h3,{id:"use-of-random-transformations-rotation-scaling",style:{position:"relative"}},i.createElement(t.a,{href:"#use-of-random-transformations-rotation-scaling","aria-label":"use of random transformations rotation scaling permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"use of random transformations (rotation, scaling)"),"\n",i.createElement(t.p,null,"To ensure the patch works even if printed out in the real world or placed at random angles, one can incorporate random transformations during training:"),"\n",i.createElement(t.ul,null,"\n",i.createElement(t.li,null,"Randomly rotate the patch by ",i.createElement(o.A,{text:"\\( \\pm 30^\\circ \\)"})," or more."),"\n",i.createElement(t.li,null,"Randomly scale the patch from, say, 80–120% of its size."),"\n",i.createElement(t.li,null,"Possibly add small random occlusions or color jitter."),"\n"),"\n",i.createElement(t.p,null,"This data augmentation step fosters a more robust universal patch that can reliably break the classifier from multiple vantage points."),"\n",i.createElement(t.h3,{id:"examples-and-visualizations",style:{position:"relative"}},i.createElement(t.a,{href:"#examples-and-visualizations","aria-label":"examples and visualizations permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"examples and visualizations"),"\n",i.createElement(t.p,null,'In the original work by Brown and gang (2017) (NeurIPS), a small toaster-like patch forced the network to see a "toaster" class in nearly any scene, including images of animals or random objects. Visual depictions often show a patch with swirling shapes or odd color patterns that do not necessarily look like a natural object. Yet these patterns are carefully optimized to produce a strong activation for the target class.'),"\n",i.createElement(t.h3,{id:"real-world-applications-of-patch-based-attacks",style:{position:"relative"}},i.createElement(t.a,{href:"#real-world-applications-of-patch-based-attacks","aria-label":"real world applications of patch based attacks permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"real-world applications of patch-based attacks"),"\n",i.createElement(t.p,null,"Patch-based attacks can be physically instantiated: for instance, an attacker could place a small printed sticker on a stop sign or hold up an odd pattern in front of a camera feed. Real-world experiments have confirmed that such patches can fool object detection systems or mislead image classifiers in real, unaltered scenarios."),"\n",i.createElement(t.ul,null,"\n",i.createElement(t.li,null,"In autonomous driving, a patch might trick the system into misreading traffic signs or ignoring pedestrians."),"\n",i.createElement(t.li,null,"In face recognition, a small sticker on the face can cause misidentification."),"\n",i.createElement(t.li,null,"In retail environments, a maliciously placed patch on product packaging might cause an inventory recognition system to mislabel goods."),"\n"),"\n",i.createElement(t.hr),"\n",i.createElement(t.h2,{id:"practical-implementation-and-experiments",style:{position:"relative"}},i.createElement(t.a,{href:"#practical-implementation-and-experiments","aria-label":"practical implementation and experiments permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"practical implementation and experiments"),"\n",i.createElement(t.h3,{id:"pre-trained-models-and-datasets",style:{position:"relative"}},i.createElement(t.a,{href:"#pre-trained-models-and-datasets","aria-label":"pre trained models and datasets permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"pre-trained models and datasets"),"\n",i.createElement(t.p,null,"To explore adversarial attacks in practice, many researchers and practitioners use standard datasets and pre-trained models:"),"\n",i.createElement(t.ul,null,"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"ImageNet")," with pretrained ResNet, DenseNet, or other architectures in PyTorch or TensorFlow."),"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"CIFAR-10")," or ",i.createElement(t.strong,null,"CIFAR-100")," for smaller-scale experiments."),"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"MNIST")," as a starting point for didactic examples, though modern networks achieve near-perfect performance on it."),"\n"),"\n",i.createElement(t.p,null,"Below is an indicative example of code that loads a pretrained PyTorch model (such as ResNet34) and demonstrates a quick adversarial FGSM attack. This snippet is high-level and is for illustration only."),"\n",i.createElement(s.A,{text:"\nimport torch\nimport torch.nn.functional as F\nimport torchvision.transforms as T\nfrom torchvision.models import resnet34\n\n# 1) Load pretrained model\nmodel = resnet34(weights='IMAGENET1K_V1')\nmodel.eval()\n\n# 2) Prepare input image x\ntransform = T.Compose([\n    T.Resize(224),\n    T.CenterCrop(224),\n    T.ToTensor(),\n    # Normalize with ImageNet's mean & std\n    T.Normalize([0.485, 0.456, 0.406],\n                [0.229, 0.224, 0.225])\n])\n# Suppose we have an input PIL image 'orig_img'\nx = transform(orig_img).unsqueeze(0)  # shape: [1, 3, 224, 224]\nx.requires_grad = True\n\n# 3) Forward pass\nlogits = model(x)\nlabel = logits.argmax(dim=1)\n\n# 4) Compute FGSM\nloss = F.cross_entropy(logits, label)\nmodel.zero_grad()\nloss.backward()\nepsilon = 0.02\nperturbation = epsilon * x.grad.sign()\nx_adv = x + perturbation\nx_adv = torch.clamp(x_adv, 0, 1)\n\n# 5) Evaluate\nlogits_adv = model(x_adv)\npred_adv = logits_adv.argmax(dim=1)\nprint(\"Original label:\", label.item())\nprint(\"Adversarial label:\", pred_adv.item())\n"}),"\n",i.createElement(t.h3,{id:"measuring-robustness-accuracy-vs-fooling-rate",style:{position:"relative"}},i.createElement(t.a,{href:"#measuring-robustness-accuracy-vs-fooling-rate","aria-label":"measuring robustness accuracy vs fooling rate permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"measuring robustness (accuracy vs. fooling rate)"),"\n",i.createElement(t.p,null,"When evaluating adversarial robustness, it is helpful to track:"),"\n",i.createElement(t.ol,null,"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Clean accuracy"),": Standard accuracy on the unperturbed test set."),"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Adversarial accuracy")," or fooling rate: The fraction of test samples that remain correctly classified under adversarial perturbations. Some authors define a fooling rate as the fraction of samples that switch from correct to incorrect under attack."),"\n"),"\n",i.createElement(t.p,null,"In the simplest sense:"),"\n",i.createElement(t.ul,null,"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"High adversarial accuracy")," ",i.createElement(r.A,{text:"(the fraction of images still correct under adversarial noise)"})," implies the model is robust."),"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Low adversarial accuracy")," means the model is easily deceived."),"\n"),"\n",i.createElement(t.p,null,"Moreover, we can measure how the adversarial accuracy changes as ",i.createElement(o.A,{text:"\\( \\epsilon \\)"})," grows, or under increasingly sophisticated attacks (FGSM vs. PGD vs. C&W, etc.)."),"\n",i.createElement(t.h3,{id:"common-pitfalls-and-reproducibility-checks",style:{position:"relative"}},i.createElement(t.a,{href:"#common-pitfalls-and-reproducibility-checks","aria-label":"common pitfalls and reproducibility checks permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"common pitfalls and reproducibility checks"),"\n",i.createElement(t.ol,null,"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Normalization"),": Adversarial perturbations must be scaled consistently with input normalization. For instance, if images are normalized by mean and standard deviation, ",i.createElement(o.A,{text:"\\( \\epsilon \\)"})," must be adjusted accordingly in that transformed space."),"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Clamping"),": After you perturb an image, ensure the result is still in a valid pixel range if that is part of your data pipeline."),"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Random seeds and hardware"),": Adversarial training or random restarts can yield slightly different outcomes, so controlling for randomness is crucial to reproducibility."),"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Misreporting"),": Sometimes, reported robust accuracies might reflect an incomplete or suboptimal search by the attacker. If the adversarial method is not thorough, it might overestimate the true robustness."),"\n"),"\n",i.createElement(t.h3,{id:"code-snippets",style:{position:"relative"}},i.createElement(t.a,{href:"#code-snippets","aria-label":"code snippets permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"code snippets"),"\n",i.createElement(t.p,null,"A few lines of (PyTorch) code that illustrate an iterative approach for PGD:"),"\n",i.createElement(s.A,{text:'\ndef pgd_attack(model, images, labels, epsilon=0.03, alpha=0.01, iters=40):\n    """\n    model: neural network\n    images: input batch\n    labels: ground truth labels\n    epsilon: maximum perturbation\n    alpha: step size\n    iters: number of iteration steps\n    """\n    # Clone images for re-usage\n    ori_images = images.clone().detach()\n\n    for i in range(iters):\n        images.requires_grad = True\n        outputs = model(images)\n        loss = F.cross_entropy(outputs, labels)\n        \n        model.zero_grad()\n        loss.backward()\n        adv_grad = images.grad.data\n        \n        # Gradient ascent step\n        images = images + alpha * adv_grad.sign()\n        \n        # Project back into the epsilon-ball\n        # clamp each pixel so that overall dist from ori_images <= epsilon\n        eta = torch.clamp(images - ori_images, min=-epsilon, max=epsilon)\n        images = torch.clamp(ori_images + eta, 0, 1).detach()\n    \n    return images\n'}),"\n",i.createElement(t.hr),"\n",i.createElement(t.h2,{id:"defensive-strategies-challenges-and-lessons-from-adversarial-vulnerabilities",style:{position:"relative"}},i.createElement(t.a,{href:"#defensive-strategies-challenges-and-lessons-from-adversarial-vulnerabilities","aria-label":"defensive strategies challenges and lessons from adversarial vulnerabilities permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"defensive strategies, challenges and lessons from adversarial vulnerabilities"),"\n",i.createElement(t.p,null,"Having explored how easily state-of-the-art models can be tricked, it's natural to look for defenses. While numerous methods have been proposed, none provide a definitive solution for all threat models. Nonetheless, there are a variety of partial or context-specific defenses that can significantly raise the bar for an attacker."),"\n",i.createElement(t.h3,{id:"adversarial-training-data-augmentation",style:{position:"relative"}},i.createElement(t.a,{href:"#adversarial-training-data-augmentation","aria-label":"adversarial training data augmentation permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"adversarial training (data augmentation)"),"\n",i.createElement(t.p,null,"One of the most intuitive and widely studied defenses is ",i.createElement(t.strong,null,"adversarial training"),". It basically expands the training distribution by including adversarial examples:"),"\n",i.createElement(t.ol,null,"\n",i.createElement(t.li,null,"Generate adversarial examples on the current model (e.g., via FGSM or PGD)."),"\n",i.createElement(t.li,null,"Add these examples (labeled with the original ground truth) into the training set."),"\n",i.createElement(t.li,null,"Retrain or continue training so the network learns to classify them correctly."),"\n"),"\n",i.createElement(t.p,null,"Algorithmically, we can write a min-max problem:"),"\n",i.createElement(o.A,{text:"\\[\n\\min_{\\theta} \\;\\; \\mathbb{E}_{(x,y)\\sim \\mathcal{D}} \\Bigl[ \\max_{\\|x'-x\\|\\le \\epsilon} J(\\theta, x', y) \\Bigr].\n\\]"}),"\n",i.createElement(t.p,null,"This is akin to simultaneously training ",i.createElement(o.A,{text:"\\( \\theta \\)"})," and solving the worst-case perturbation ",i.createElement(o.A,{text:"\\( x' \\)"})," for each sample. The inner maximization is an adversarial attack (like PGD)."),"\n",i.createElement(t.p,null,"Adversarial training is conceptually powerful and can, in practice, yield robust models, especially if done with multi-step PGD and large-scale data. However, it entails a significant computational cost because each training step runs a small adversarial optimization. It also might degrade standard (clean) accuracy if not carefully tuned, as the model invests capacity in being robust rather than optimizing purely for clean accuracy."),"\n",i.createElement(t.h3,{id:"defensive-distillation",style:{position:"relative"}},i.createElement(t.a,{href:"#defensive-distillation","aria-label":"defensive distillation permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"defensive distillation"),"\n",i.createElement(t.p,null,'Defensive distillation (Papernot and gang, 2016) tries to smooth the decision surface by training a model to mimic the "soft" outputs of another model. The original steps:'),"\n",i.createElement(t.ol,null,"\n",i.createElement(t.li,null,"Train a network on the training set normally, extracting softmax probabilities as ",i.createElement(o.A,{text:"\\( p(x) \\)"}),"."),"\n",i.createElement(t.li,null,"Train a second network on the same inputs, but use the soft labels from ",i.createElement(o.A,{text:"\\( p(x) \\)"})," rather than the hard ground-truth labels."),"\n"),"\n",i.createElement(t.p,null,"The rationale is that learning from soft labels might flatten or smooth the gradients that attacks exploit. Although some early success was reported, subsequent papers (Carlini & Wagner, 2017) found that more sophisticated or tuned attacks could circumvent the defense. Distillation might still provide partial benefit, but it is not a catch-all solution."),"\n",i.createElement(t.h3,{id:"preprocessing-and-detection-methods",style:{position:"relative"}},i.createElement(t.a,{href:"#preprocessing-and-detection-methods","aria-label":"preprocessing and detection methods permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"preprocessing and detection methods"),"\n",i.createElement(t.p,null,"A wide range of defenses revolve around pre-processing the input before inference:"),"\n",i.createElement(t.ul,null,"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Denoising"),": Use filters or wavelet denoising to remove small perturbations."),"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Pixel defense"),": Add randomization or compression steps (e.g. random resizing, bit-depth reduction)."),"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Feature squeezing"),": Project inputs onto a lower-dimensional manifold to remove fine-grained noise."),"\n"),"\n",i.createElement(t.p,null,"Alternatively, detection-based defenses attempt to identify whether an input is adversarial. For instance, if the input is abnormally far from the training data manifold or triggers suspicious feature activations, a model might label it as suspect. Although these approaches sometimes catch naive attacks, adaptive adversaries often circumvent them by designing perturbations that survive or exploit the preprocessing transformations."),"\n",i.createElement(t.h3,{id:"limitations-and-ongoing-research",style:{position:"relative"}},i.createElement(t.a,{href:"#limitations-and-ongoing-research","aria-label":"limitations and ongoing research permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"limitations and ongoing research"),"\n",i.createElement(t.p,null,"Defenses frequently fail or degrade against new or more adaptive attacks. This pattern is reminiscent of a cat-and-mouse arms race. Some deeper limitations:"),"\n",i.createElement(t.ul,null,"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Computational overhead"),": Many robust training methods require heavy compute resources, restricting their feasibility for very large models or real-time applications."),"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Transferability"),": Even if you robustly defend one model, an attacker might train a surrogate or black-box approach to circumvent your defense."),"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Data constraints"),": Some adversarial training methods require large, diverse training sets to generalize, or else risk overfitting to a specific type of adversarial pattern."),"\n"),"\n",i.createElement(t.h3,{id:"toward-causal-and-uncertainty-aware-models",style:{position:"relative"}},i.createElement(t.a,{href:"#toward-causal-and-uncertainty-aware-models","aria-label":"toward causal and uncertainty aware models permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"toward causal and uncertainty-aware models"),"\n",i.createElement(t.p,null,"One promising path is the pursuit of ",i.createElement(t.em,null,"causal")," approaches that do not rely solely on spurious correlations in the data. By grounding predictions in stable, causal features, models might be less prone to out-of-distribution shifts or trivial perturbations. Meanwhile, ",i.createElement(t.em,null,"uncertainty-aware")," techniques, such as Bayesian neural networks or deep ensembles, attempt to produce well-calibrated confidence estimates, potentially flagging low-confidence predictions when encountering adversarial inputs. Though these ideas are still under development, they represent a deeper shift in how we might approach robust machine learning."),"\n",i.createElement(t.h3,{id:"how-deep-neural-networks-see-images",style:{position:"relative"}},i.createElement(t.a,{href:"#how-deep-neural-networks-see-images","aria-label":"how deep neural networks see images permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),'how deep neural networks "see" images'),"\n",i.createElement(t.p,null,"Many interpretability studies show that CNNs and other deep architectures can exploit high-frequency signals imperceptible to humans. These networks do not necessarily learn exactly the features humans use for classification. ReLU-like activation functions, combined with the high dimensional nature of images, create an environment where subtle changes in each pixel can accumulate, flipping decisions in ways that remain hidden to human vision."),"\n",i.createElement(t.h3,{id:"role-of-activation-functions-eg-relu",style:{position:"relative"}},i.createElement(t.a,{href:"#role-of-activation-functions-eg-relu","aria-label":"role of activation functions eg relu permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"role of activation functions (e.g., relu)"),"\n",i.createElement(t.p,null,"Rectified Linear Units (ReLUs) introduce piecewise linearity, meaning that an adversarial perturbation can abruptly activate or deactivate certain neurons, drastically changing the final output. On one hand, ReLUs are easier to optimize with respect to network parameters than saturating nonlinearities. On the other hand, this piecewise linear surface often contributes to a lack of inherent smoothness in the model's decision boundary with respect to ",i.createElement(o.A,{text:"\\( x \\)"}),"."),"\n",i.createElement(t.h3,{id:"the-manifold-perspective-and-sparsity-in-high-dimensions",style:{position:"relative"}},i.createElement(t.a,{href:"#the-manifold-perspective-and-sparsity-in-high-dimensions","aria-label":"the manifold perspective and sparsity in high dimensions permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"the manifold perspective and sparsity in high dimensions"),"\n",i.createElement(t.p,null,"An overarching intuition is that training data only occupies a low-dimensional manifold within the broad input space. The region of genuine data is relatively sparse. Neural networks can exhibit unpredictable or poorly constrained behavior in the vast regions of space between the manifold clusters. Adversarial noise effectively pushes ",i.createElement(o.A,{text:"\\( x \\)"})," into these uncharted areas. The manifold perspective suggests that if we had perfect generative knowledge of the data manifold, we could project inputs onto it and possibly remove adversarial components. However, learning such a manifold at scale is itself a formidable challenge."),"\n",i.createElement(t.h3,{id:"transfer-learning-and-ensemble-methods",style:{position:"relative"}},i.createElement(t.a,{href:"#transfer-learning-and-ensemble-methods","aria-label":"transfer learning and ensemble methods permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"transfer learning and ensemble methods"),"\n",i.createElement(t.h4,{id:"ensembles-for-defense",style:{position:"relative"}},i.createElement(t.a,{href:"#ensembles-for-defense","aria-label":"ensembles for defense permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"ensembles for defense"),"\n",i.createElement(t.p,null,"Ensembling multiple models can sometimes provide partial robustness gains. The attacker then needs to find a perturbation that fools ",i.createElement(t.em,null,"all")," models simultaneously, which can be more difficult. However, adversarial transferability can still be strong across similarly trained architectures, so naive ensembles might not be enough."),"\n",i.createElement(t.h4,{id:"transfer-learning-vulnerabilities",style:{position:"relative"}},i.createElement(t.a,{href:"#transfer-learning-vulnerabilities","aria-label":"transfer learning vulnerabilities permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"transfer learning vulnerabilities"),"\n",i.createElement(t.p,null,"Transfer learning can inadvertently preserve vulnerabilities from the base model. For instance, if you load a pretrained network on ImageNet and fine-tune only the top layers for a new domain, the underlying features might remain susceptible to the same forms of adversarial attack from the original domain."),"\n",i.createElement(t.h3,{id:"final-remarks-on-adversarial-robustness",style:{position:"relative"}},i.createElement(t.a,{href:"#final-remarks-on-adversarial-robustness","aria-label":"final remarks on adversarial robustness permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"final remarks on adversarial robustness"),"\n",i.createElement(t.p,null,"Despite intense research, there is no universal solution for adversarial attacks, especially in open-ended real-world scenarios. However, a combination of methods — adversarial training with multi-step attacks, input transformations, ensemble strategies, uncertainty estimation, or novel architectural changes — can yield more robust and trustworthy predictions."),"\n",i.createElement(t.hr),"\n",i.createElement(l.A,null,'Below this point, I include an extended discussion to provide additional theoretical context and references, bridging to tasks that sometimes leverage adversarial ideas in data science, such as "adversarial validation." This can help advanced ML practitioners see how the underlying concept of adversarial optimization extends beyond direct security concerns.'),"\n",i.createElement(t.h2,{id:"extra-bridging-adversarial-ml-with-advanced-data-science-techniques",style:{position:"relative"}},i.createElement(t.a,{href:"#extra-bridging-adversarial-ml-with-advanced-data-science-techniques","aria-label":"extra bridging adversarial ml with advanced data science techniques permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"extra: bridging adversarial ml with advanced data science techniques"),"\n",i.createElement(t.p,null,'In broader data science and advanced analytics, the term "adversarial approach" arises in multiple contexts. While the fundamental concept always involves constructing or analyzing a scenario in which some entity is trying to "trick" or probe a model, the objectives may differ from classical adversarial attacks that merely cause misclassification.'),"\n",i.createElement(t.p,null,'One such example is known as "adversarial validation," wherein the data scientist checks for distribution mismatch between training and testing sets (or between subsets of the data). The approach is to build a binary classifier that distinguishes training samples from test samples and then measures how accurately it can do so. If an advanced classifier reliably classifies a point as belonging to the training or test set, that suggests the two distributions differ significantly.'),"\n",i.createElement(t.h3,{id:"distribution-mismatch-detection",style:{position:"relative"}},i.createElement(t.a,{href:"#distribution-mismatch-detection","aria-label":"distribution mismatch detection permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"distribution mismatch detection"),"\n",i.createElement(t.ol,null,"\n",i.createElement(t.li,null,"Label all training data with 0, all test data with 1."),"\n",i.createElement(t.li,null,"Train a binary classifier (which could be a neural network or gradient boosting model) to predict these labels."),"\n",i.createElement(t.li,null,"If the classifier achieves high accuracy or high AUC, it implies the distributions differ so much that a supervised model can separate them."),"\n",i.createElement(t.li,null,"By examining the important features in that classifier, you can glean which input variables drive the distribution mismatch."),"\n"),"\n",i.createElement(t.p,null,"This technique is reminiscent of a black-box adversarial concept: you're effectively trying to see if there is a small set of manipulations or inherent differences that can tell training from test points. Although the objective is not to ",i.createElement(t.em,null,"break")," the system, it uses adversarial logic to probe a mismatch that might lead to poor generalization."),"\n",i.createElement(t.h3,{id:"feature-dependency-and-podmena-zadachi",style:{position:"relative"}},i.createElement(t.a,{href:"#feature-dependency-and-podmena-zadachi","aria-label":"feature dependency and podmena zadachi permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),'feature dependency and "podmena zadachi"'),"\n",i.createElement(t.p,null,'Another interesting data science technique uses the notion of training a model to recover a certain feature from all the other features. This is sometimes framed as "if we can build a strong classifier or regressor for a given feature ',i.createElement(o.A,{text:"\\( F \\)"}),", then ",i.createElement(o.A,{text:"\\( F \\)"}),' is not truly independent from the rest of the data; the information is partly redundant." This method, explained in some data science circles as "подмена задачи" (translated as "task substitution"), helps discover correlated or functionally dependent features, or detect and fill missing values intelligently.'),"\n",i.createElement(t.p,null,"While not always labeled as adversarial, the technique effectively sets up an alternate objective: treat ",i.createElement(o.A,{text:"\\( F \\)"})," as the target label and see how well we can guess it from the remaining data. If we can do so too well, we might suspect data leakage or strong correlation that may or may not help the original predictive task."),"\n",i.createElement(t.p,null,"These advanced data exploration methods connect conceptually to adversarial ML in the sense that both rely on carefully structured manipulations or re-labellings of data to test the boundaries of the model's capabilities."),"\n",i.createElement(t.hr),"\n",i.createElement(t.h2,{id:"images-and-placeholders",style:{position:"relative"}},i.createElement(t.a,{href:"#images-and-placeholders","aria-label":"images and placeholders permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"images and placeholders"),"\n",i.createElement(t.p,null,"Where beneficial, an instructor might include images or diagrams to illustrate specific points. For instance:"),"\n",i.createElement(a,{alt:"adversarial_perturbation_example",path:"",caption:"A subtle perturbation can drastically change the predicted label.",zoom:"false"}),"\n",i.createElement(t.p,null,"You could show two side-by-side images: the original vs. the adversarial one, plus the difference image."),"\n",i.createElement(a,{alt:"adversarial_patch_example",path:"",caption:"A small patch can force the classifier to see a chosen class in nearly any image.",zoom:"false"}),"\n",i.createElement(t.hr),"\n",i.createElement(t.h2,{id:"conclusion-optional-remarks",style:{position:"relative"}},i.createElement(t.a,{href:"#conclusion-optional-remarks","aria-label":"conclusion optional remarks permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"conclusion (optional remarks)"),"\n",i.createElement(t.p,null,"Adversarial machine learning began as a surprising revelation that deep networks — so accurate by standard metrics — could be derailed by almost imperceptible perturbations. Over time, it has become clear that these vulnerabilities stem from broader issues: non-robust features, spurious correlations, the geometry of high-dimensional manifolds, and a possible misalignment between how models and humans perceive data."),"\n",i.createElement(t.p,null,"On the attack side, we have an extensive repertoire: single-step methods like FGSM, iterative approaches like PGD, more specialized attacks like Carlini–Wagner, DeepFool, black-box methods leveraging transferability or query-based gradient approximations, and localized patch attacks that physically realize adversarial threats in real-world scenarios."),"\n",i.createElement(t.p,null,"On the defense side, we have strategies from adversarial training (the gold standard in many settings but computationally expensive) to model distillation, input preprocessing, detection heuristics, and deeper architecture-level changes. None of these alone guarantee absolute robustness. Instead, we have a continuously evolving interplay between attack and defense — a reflection of standard security practices but transplanted into the ML domain, which is complicated by data distribution shifts, model interpretability challenges, and the extremely high-dimensional nature of deep learning."),"\n",i.createElement(t.p,null,'Even outside of strictly malicious contexts, adversarial perspectives offer valuable insights and tools for diagnosing distribution mismatch, investigating data leaks, clarifying feature dependencies, or exploring generalization errors. This synergy of adversarial logic with broader data science tasks (like adversarial validation) underscores the conceptual power of shaping a secondary objective that tries to "break" or "distinguish" something about a dataset or model.'),"\n",i.createElement(t.p,null,"Looking ahead, research in adversarial robustness aims to either achieve stable, provable bounds on a model's sensitivity to input perturbations or to develop flexible methods that gracefully handle the intrinsic uncertainty in real-world data. Current trends include bridging causal models, Bayesian or ensemble-based uncertainty estimates, robust optimization, and new directions like generative manifold projection and certified defenses with formal proofs for small norm-bounded perturbations."),"\n",i.createElement(t.p,null,"I encourage you to experiment with these methods in code, scrutinize your own models' responses to small input perturbations, and consider the bigger picture: robust and reliable ML systems require a holistic approach, from careful data curation and architecture design to ongoing testing against newly developed adversarial techniques."),"\n",i.createElement(t.hr),"\n",i.createElement(t.p,null,i.createElement(t.strong,null,"References and suggested readings")),"\n",i.createElement(t.ul,null,"\n",i.createElement(t.li,null,'Goodfellow, I. J., Shlens, J., and Szegedy, C. "Explaining and harnessing adversarial examples." ICLR 2015.'),"\n",i.createElement(t.li,null,'Szegedy, C. and gang "Intriguing properties of neural networks." ICLR 2014.'),"\n",i.createElement(t.li,null,'Madry, A. and gang "Towards deep learning models resistant to adversarial attacks." ICLR 2018.'),"\n",i.createElement(t.li,null,'Carlini, N. and Wagner, D. "Towards evaluating the robustness of neural networks." IEEE S&P (2017).'),"\n",i.createElement(t.li,null,'Brown, T. B. and gang "Adversarial patch." arXiv:1712.09665 (2017).'),"\n",i.createElement(t.li,null,'Moosavi-Dezfooli, S. M., Fawzi, A., and Frossard, P. "DeepFool: A simple and accurate method to fool deep neural networks." CVPR 2016.'),"\n",i.createElement(t.li,null,'Papernot, N. and gang "Distillation as a defense to adversarial perturbations against deep neural networks." IEEE S&P 2016.'),"\n",i.createElement(t.li,null,'Kurakin, A., Goodfellow, I., and Bengio, S. "Adversarial examples in the physical world." ICLR Workshop 2017.'),"\n",i.createElement(t.li,null,'Tramer, F. and gang "Ensemble adversarial training: Attacks and defenses." ICLR 2018.'),"\n"),"\n",i.createElement(t.hr),"\n",i.createElement(t.p,null,"I hope this comprehensive coverage clarifies not just the mechanics of adversarial machine learning, but also its theoretical foundations and practical nuances. Even as these adversarial phenomena present significant challenges to the ML community, they continue to motivate innovative directions for building safer, more resilient, and ultimately more trustworthy AI systems."))}var d=function(e){void 0===e&&(e={});const{wrapper:t}=Object.assign({},(0,n.RP)(),e.components);return t?i.createElement(t,e,i.createElement(c,e)):c(e)};var m=a(54506),h=a(88864),u=a(58481),p=a.n(u),g=a(5984),f=a(43672),v=a(27042),b=a(72031),y=a(81817),E=a(27105),w=a(17265),x=a(2043),k=a(95751),S=a(94328),z=a(80791),M=a(78137);const H=e=>{let{toc:t}=e;if(!t||!t.items)return null;return i.createElement("nav",{className:z.R},i.createElement("ul",null,t.items.map(((e,t)=>i.createElement("li",{key:t},i.createElement("a",{href:e.url,onClick:t=>((e,t)=>{e.preventDefault();const a=t.replace("#",""),n=document.getElementById(a);n&&n.scrollIntoView({behavior:"smooth",block:"start"})})(t,e.url)},e.title),e.items&&i.createElement(H,{toc:{items:e.items}}))))))};function A(e){let{data:{mdx:t,allMdx:r,allPostImages:l},children:s}=e;const{frontmatter:o,body:c,tableOfContents:d}=t,h=o.index,u=o.slug.split("/")[1],b=r.nodes.filter((e=>e.frontmatter.slug.includes(`/${u}/`))).sort(((e,t)=>e.frontmatter.index-t.frontmatter.index)),z=b.findIndex((e=>e.frontmatter.index===h)),A=b[z+1],C=b[z-1],T=o.slug.replace(/\/$/,""),_=/[^/]*$/.exec(T)[0],I=`posts/${u}/content/${_}/`,{0:L,1:N}=(0,i.useState)(o.flagWideLayoutByDefault),{0:j,1:V}=(0,i.useState)(!1);var P;(0,i.useEffect)((()=>{V(!0);const e=setTimeout((()=>V(!1)),340);return()=>clearTimeout(e)}),[L]),"adventures"===u?P=w.cb:"research"===u?P=w.Qh:"thoughts"===u&&(P=w.T6);const B=p()(c).replace(/import .*? from .*?;/g,"").replace(/<.*?>/g,"").replace(/\{\/\*[\s\S]*?\*\/\}/g,"").trim().split(/\s+/).length,D=function(e){if(e<=10)return"~10 min";if(e<=20)return"~20 min";if(e<=30)return"~30 min";if(e<=40)return"~40 min";if(e<=50)return"~50 min";if(e<=60)return"~1 h";const t=Math.floor(e/60),a=e%60;return a<=30?`~${t}${a>0?".5":""} h`:`~${t+1} h`}(Math.ceil(B/P)+(o.extraReadTimeMin||0)),G=[{flag:o.flagDraft,component:()=>Promise.all([a.e(5850),a.e(9833)]).then(a.bind(a,49833))},{flag:o.flagMindfuckery,component:()=>Promise.all([a.e(5850),a.e(7805)]).then(a.bind(a,27805))},{flag:o.flagRewrite,component:()=>Promise.all([a.e(5850),a.e(8916)]).then(a.bind(a,78916))},{flag:o.flagOffensive,component:()=>Promise.all([a.e(5850),a.e(6731)]).then(a.bind(a,49112))},{flag:o.flagProfane,component:()=>Promise.all([a.e(5850),a.e(3336)]).then(a.bind(a,83336))},{flag:o.flagMultilingual,component:()=>Promise.all([a.e(5850),a.e(2343)]).then(a.bind(a,62343))},{flag:o.flagUnreliably,component:()=>Promise.all([a.e(5850),a.e(6865)]).then(a.bind(a,11627))},{flag:o.flagPolitical,component:()=>Promise.all([a.e(5850),a.e(4417)]).then(a.bind(a,24417))},{flag:o.flagCognitohazard,component:()=>Promise.all([a.e(5850),a.e(8669)]).then(a.bind(a,18669))},{flag:o.flagHidden,component:()=>Promise.all([a.e(5850),a.e(8124)]).then(a.bind(a,48124))}],{0:F,1:O}=(0,i.useState)([]);return(0,i.useEffect)((()=>{G.forEach((e=>{let{flag:t,component:a}=e;t&&a().then((e=>{O((t=>[].concat((0,m.A)(t),[e.default])))}))}))}),[]),i.createElement(v.P.div,{initial:{opacity:0},animate:{opacity:1},exit:{opacity:0},transition:{duration:.15}},i.createElement(y.A,{postNumber:o.index,date:o.date,updated:o.updated,readTime:D,difficulty:o.difficultyLevel,title:o.title,desc:o.desc,banner:o.banner,section:u,postKey:_,isMindfuckery:o.flagMindfuckery,mainTag:o.mainTag}),i.createElement("div",{style:{display:"flex",justifyContent:"flex-end",flexWrap:"wrap",maxWidth:"75%",marginLeft:"auto",paddingRight:"1vw",marginTop:"-6vh",marginBottom:"4vh"}},o.otherTags.map(((e,t)=>i.createElement("span",{key:t,className:`noselect ${M.MW}`,style:{margin:"0 5px 5px 0"}},e)))),i.createElement("div",{className:"postBody"},i.createElement(H,{toc:d})),i.createElement("br",null),i.createElement("div",{style:{margin:"0 10% -2vh 30%",textAlign:"right"}},i.createElement(v.P.button,{className:`noselect ${S.pb}`,id:S.xG,onClick:()=>{N(!L)},whileTap:{scale:.93}},i.createElement(v.P.div,{className:k.DJ,key:L,initial:{opacity:0},animate:{opacity:1},exit:{opacity:0},transition:{duration:.3,ease:"easeInOut"}},L?"Switch to default layout":"Switch to wide layout"))),i.createElement("br",null),i.createElement("div",{className:"postBody",style:{margin:L?"0 -14%":"",maxWidth:L?"200%":"",transition:"margin 1s ease, max-width 1s ease, padding 1s ease"}},i.createElement("div",{className:`${S.P_} ${j?S.Xn:S.qG}`},F.map(((e,t)=>i.createElement(e,{key:t}))),o.indexCourse?i.createElement(x.A,{index:o.indexCourse,category:o.courseCategoryName}):"",i.createElement(g.Z.Provider,{value:{images:l.nodes,basePath:I.replace(/\/$/,"")+"/"}},i.createElement(n.xA,{components:{Image:f.A}},s)))),i.createElement(E.A,{nextPost:A,lastPost:C,keyCurrent:_,section:u}))}function C(e){return i.createElement(A,e,i.createElement(d,e))}function T(e){var t,a,n,r,l;let{data:s}=e;const{frontmatter:o}=s.mdx,c=o.titleSEO||o.title,d=o.titleOG||c,m=o.titleTwitter||c,u=o.descSEO||o.desc,p=o.descOG||u,g=o.descTwitter||u,f=o.schemaType||"BlogPosting",v=o.keywordsSEO,y=o.date,E=o.updated||y,w=o.imageOG||(null===(t=o.banner)||void 0===t||null===(a=t.childImageSharp)||void 0===a||null===(n=a.gatsbyImageData)||void 0===n||null===(r=n.images)||void 0===r||null===(l=r.fallback)||void 0===l?void 0:l.src),x=o.imageAltOG||p,k=o.imageTwitter||w,S=o.imageAltTwitter||g,z=o.canonicalURL,M=o.flagHidden||!1,H=o.mainTag||"Posts",A=o.slug.split("/")[1]||"posts",{siteUrl:C}=(0,h.Q)(),T={"@context":"https://schema.org","@type":"BreadcrumbList",itemListElement:[{"@type":"ListItem",position:1,name:"Home",item:C},{"@type":"ListItem",position:2,name:H,item:`${C}/${o.slug.split("/")[1]}`},{"@type":"ListItem",position:3,name:c,item:`${C}${o.slug}`}]};return i.createElement(b.A,{title:c+" - avrtt.blog",titleOG:d,titleTwitter:m,description:u,descriptionOG:p,descriptionTwitter:g,schemaType:f,keywords:v,datePublished:y,dateModified:E,imageOG:w,imageAltOG:x,imageTwitter:k,imageAltTwitter:S,canonicalUrl:z,flagHidden:M,mainTag:H,section:A,type:"article"},i.createElement("script",{type:"application/ld+json"},JSON.stringify(T)))}},90548:function(e,t,a){var n=a(96540),i=a(7978);t.A=e=>{let{text:t}=e;return n.createElement(i.A,null,t)}}}]);
//# sourceMappingURL=component---src-templates-post-tsx-content-file-path-src-pages-posts-research-adversarial-ml-mdx-c88958052d67602b7933.js.map