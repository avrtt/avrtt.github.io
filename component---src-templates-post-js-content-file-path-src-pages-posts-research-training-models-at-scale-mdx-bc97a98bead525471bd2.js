"use strict";(self.webpackChunkavrtt_blog=self.webpackChunkavrtt_blog||[]).push([[7779],{1998:function(e,t,n){n.r(t),n.d(t,{Head:function(){return M},PostTemplate:function(){return T},default:function(){return _}});var a=n(54506),i=n(28453),r=n(96540),l=n(16886),o=n(46295),s=n(96098);function c(e){const t=Object.assign({p:"p",h2:"h2",a:"a",span:"span",h3:"h3",ul:"ul",li:"li",strong:"strong",ol:"ol"},(0,i.RP)(),e.components);return r.createElement(r.Fragment,null,"\n",r.createElement("br"),"\n","\n","\n",r.createElement(t.p,null,"Scaling up model training has become one of the most pivotal aspects of advancing modern machine learning and deep learning systems. As new research breakthroughs push model architectures toward unprecedented size and depth, data scientists and engineers face the growing challenge of working with ever-larger datasets and model parameters that can easily run into the billions. In recent years, the success of massive language models, complex computer vision architectures, and multi-modal pipelines (combining images, text, audio, and beyond) has shown that many important breakthroughs arise when researchers successfully train these large models on large-scale computing infrastructures."),"\n",r.createElement(t.p,null,'This portion of the course focuses on ""Training models at scale, pt. 1" — primarily on single-GPU methods that allow you to push the limits of memory, compute efficiency, and training speed before moving on to multi-GPU and distributed approaches in the follow-up parts. I\'ll discuss the primary motivations for scaling, the core technical concepts (ranging from memory optimization to hardware considerations), and practical techniques that can help you train bigger models within the constraints of a single GPU. While distributed and multi-node training can further unlock the ability to handle model sizes that simply won\'t fit on a single accelerator, you may be surprised at how far you can go with a thoughtful, methodical approach to single-device scaling.'),"\n",r.createElement(t.p,null,"By the end of this article, you'll know about memory bottlenecks, gradient accumulation, mixed precision training, gradient checkpointing, asynchronous computations, and more. This foundation will enable you to confidently use advanced frameworks like PyTorch, TensorFlow, and JAX with an eye toward maximizing throughput and memory usage. Along the way, I'll reference select research papers (e.g., from NeurIPS, ICML, JMLR) that have introduced novel techniques or refined these strategies in real-world deployments."),"\n",r.createElement(t.p,null,"I'm excited to guide you through the essential building blocks needed to scale your model training to new heights — even when you're starting on just a single GPU. Once you internalize these techniques, you'll be fully prepared to move on to distributed setups and specialized hardware, thereby completing the journey of large-scale training methodologies."),"\n",r.createElement(t.h2,{id:"why-scaling",style:{position:"relative"}},r.createElement(t.a,{href:"#why-scaling","aria-label":"why scaling permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Why scaling?"),"\n",r.createElement(t.h3,{id:"the-modern-drive-to-scale-bigger-and-bigger",style:{position:"relative"}},r.createElement(t.a,{href:"#the-modern-drive-to-scale-bigger-and-bigger","aria-label":"the modern drive to scale bigger and bigger permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"The modern drive to scale bigger and bigger"),"\n",r.createElement(t.p,null,"There's a remarkable trend in AI research: every year, the models that set new benchmarks in fields like natural language processing, image generation, speech synthesis, and recommendation systems tend to be bigger in terms of trainable parameters and trained on larger datasets. State-of-the-art performance in many tasks seems to correlate closely with the ability to scale, leading to emergent capabilities that smaller models fail to exhibit. The well-known scaling laws (e.g., from OpenAI, Google Research, and others) indicate that performance typically improves predictably as you increase the size of the model and the volume of training data."),"\n",r.createElement(t.p,null,"However, training these huge models isn't trivial. Beyond the raw compute expense — where you might spend days or weeks of GPU time — there's also the need to address memory constraints, specialized hardware requirements, numerical stability issues, data pipeline bottlenecks, and more. Industry giants such as NVIDIA, Google, and Microsoft have made significant investments in hardware and software solutions to handle these challenges, and many open-source tools have trickled down into community frameworks like PyTorch, TensorFlow, and JAX."),"\n",r.createElement(t.h3,{id:"trade-offs-model-size-training-time-and-resources",style:{position:"relative"}},r.createElement(t.a,{href:"#trade-offs-model-size-training-time-and-resources","aria-label":"trade offs model size training time and resources permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Trade-offs: model size, training time, and resources"),"\n",r.createElement(t.p,null,"Scaling up is not free in terms of either time or financial cost. Once you push beyond the resources available to a single GPU or a single machine, you'll be forced to adopt more complex distributed training paradigms. Even on a single GPU, attempts to train huge models can result in extensive memory overhead, to the point where you spend a significant fraction of time on memory-optimization tricks instead of focusing solely on model design."),"\n",r.createElement(t.p,null,"That said, certain tasks warrant these trade-offs. For example:"),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Large language models")," for advanced text generation, question answering, or multi-lingual tasks."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Vision transformers")," with massive parameter counts for cutting-edge image classification, segmentation, and object detection."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Reinforcement learning")," systems dealing with extremely large state and action spaces."),"\n"),"\n",r.createElement(t.p,null,"In short, if your goal is state-of-the-art performance on challenging tasks — or if you are dealing with extremely high volumes of data — scaling up might be the right approach."),"\n",r.createElement(t.h3,{id:"real-world-success-stories",style:{position:"relative"}},r.createElement(t.a,{href:"#real-world-success-stories","aria-label":"real world success stories permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Real-world success stories"),"\n",r.createElement(t.p,null,"Major breakthroughs in the past few years underscore the value of scaling:"),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"GPT-series models")," (OpenAI) for text generation, code generation, and more."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Vision transformers (ViT)"),", from Google Brain, that match or exceed convolutional networks in image tasks."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"DeepMind's AlphaGo and AlphaZero")," in the realm of large-scale reinforcement learning and self-play."),"\n"),"\n",r.createElement(t.p,null,"Behind each success story is a carefully orchestrated approach to training, resource allocation, and memory management. This article will illuminate how to orchestrate those ingredients on a single GPU, giving you a stepping stone to even more advanced scaling approaches."),"\n",r.createElement(t.h2,{id:"core-concepts-of-single-gpu-scaling",style:{position:"relative"}},r.createElement(t.a,{href:"#core-concepts-of-single-gpu-scaling","aria-label":"core concepts of single gpu scaling permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Core concepts of single-GPU scaling"),"\n",r.createElement(t.p,null,"Scaling up model training on a single GPU might sound contradictory at first. After all, you're limited to the memory and compute throughput of one device. However, numerous techniques have emerged that allow you to push the boundaries of what's possible:"),"\n",r.createElement(t.ol,null,"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Memory bottlenecks:")," Understanding how GPU memory is allocated among model weights, intermediate activations, gradients, and optimizer states."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Large batch size management:")," Many tasks benefit from large batch sizes for speed or performance. Managing large batch sizes on a single GPU requires memory-efficient strategies, gradient accumulation, or parallelization."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Framework optimizations:")," PyTorch, TensorFlow, and JAX each offer distinct ways to handle memory, asynchronous executions, and graph optimizations."),"\n"),"\n",r.createElement(t.p,null,"This section will walk you through these core considerations. I'll also reference notable papers and best practices from the open-source community to solidify these ideas with real-world examples."),"\n",r.createElement(t.h2,{id:"mixed-precision-training",style:{position:"relative"}},r.createElement(t.a,{href:"#mixed-precision-training","aria-label":"mixed precision training permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Mixed precision training"),"\n",r.createElement(t.p,null,"One of the most substantial breakthroughs for single-GPU scaling in the last five years has been widespread adoption of mixed precision or half-precision training. Originally, training with lower precision (like 16-bit floating points) introduced significant numerical instability. Modern hardware (NVIDIA's Tensor Cores, for example) and software developments (like Automatic Mixed Precision, or AMP, in PyTorch) have changed the game."),"\n",r.createElement(t.h3,{id:"benefits-of-fp16bf16",style:{position:"relative"}},r.createElement(t.a,{href:"#benefits-of-fp16bf16","aria-label":"benefits of fp16bf16 permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Benefits of FP16/BF16"),"\n",r.createElement(t.p,null,"Using half-precision floating point representations (e.g., ",r.createElement(s.A,{text:"\\( \\text{FP16} \\)"}),") or the newer bfloat16 (",r.createElement(s.A,{text:"\\( \\text{BF16} \\)"}),") format greatly reduces the memory footprint of your model parameters and activations. For instance, going from 32-bit to 16-bit effectively halves the storage required per floating point number. This leads to:"),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Reduced memory usage:")," Freed memory can be used to store larger models or bigger batches."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Faster computation:")," Modern GPUs can handle half-precision ops significantly faster, especially if the underlying architecture has specialized hardware units (e.g., Tensor Cores)."),"\n"),"\n",r.createElement(t.p,null,"Because of these efficiency gains, it's becoming standard practice in many high-performance training pipelines to use ",r.createElement(l.A,null,"mixed precision")," by default."),"\n",r.createElement(t.h3,{id:"potential-pitfalls-and-solutions",style:{position:"relative"}},r.createElement(t.a,{href:"#potential-pitfalls-and-solutions","aria-label":"potential pitfalls and solutions permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Potential pitfalls and solutions"),"\n",r.createElement(t.p,null,"Mixed precision training can face numerical stability issues, such as underflow or overflow in gradient calculations. Typical solutions involve:"),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Loss scaling:")," Before backpropagating, the loss is scaled by a factor (e.g., 1024). This ensures small gradient values do not underflow. Afterwards, the gradients are unscaled to restore their correct magnitude."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Automatic Mixed Precision libraries: PyTorch, TensorFlow and JAX each have built-in or library-level support for handling these scaling details under the hood.")),"\n"),"\n",r.createElement(o.A,{text:"\nimport torch\n# Automatic Mixed Precision in a training loop:\nwith torch.autocast(device_type='cuda', dtype=torch.float16):\n    # forward pass, compute loss\n    # ...\n    # backward pass\n"}),"\n",r.createElement(t.h3,{id:"example-code-snippet",style:{position:"relative"}},r.createElement(t.a,{href:"#example-code-snippet","aria-label":"example code snippet permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Example code snippet"),"\n",r.createElement(t.p,null,"Below is a simple snippet in PyTorch to illustrate a typical training loop with automatic mixed precision:"),"\n",r.createElement(o.A,{text:"\nimport torch\nfrom torch import nn, optim\n\nmodel = nn.Linear(1024, 512).cuda()\noptimizer = optim.Adam(model.parameters(), lr=1e-3)\nscaler = torch.cuda.amp.GradScaler()  # The built-in gradient scaler\n\nfor data, target in dataloader:\n    data = data.cuda()\n    target = target.cuda()\n    optimizer.zero_grad()\n    \n    with torch.cuda.amp.autocast():\n        output = model(data)\n        loss = nn.functional.mse_loss(output, target)\n    \n    scaler.scale(loss).backward()\n    scaler.step(optimizer)\n    scaler.update()\n"}),"\n",r.createElement(t.p,null,"In this snippet, half-precision computations are done within the autocast context. The ",r.createElement(l.A,null,"GradScaler")," ensures that any gradients that might be too small are effectively scaled up prior to the backward pass and subsequently rescaled."),"\n",r.createElement(t.h2,{id:"gradient-checkpointing-activation-recomputation",style:{position:"relative"}},r.createElement(t.a,{href:"#gradient-checkpointing-activation-recomputation","aria-label":"gradient checkpointing activation recomputation permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Gradient checkpointing (activation recomputation)"),"\n",r.createElement(t.p,null,"When you run forward propagation in deep models, intermediate activations (outputs of each layer) are stored in memory so that backpropagation can compute the corresponding gradients. For very deep networks, this storage can grow massive, quickly surpassing the available GPU memory."),"\n",r.createElement(t.h3,{id:"how-checkpointing-saves-memory",style:{position:"relative"}},r.createElement(t.a,{href:"#how-checkpointing-saves-memory","aria-label":"how checkpointing saves memory permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"How checkpointing saves memory"),"\n",r.createElement(t.p,null,'Gradient checkpointing (also called activation recomputation) offers a clever solution. Instead of storing all intermediate activations, you "checkpoint" certain layers\' outputs. During backpropagation, the uncheckpointed activations are discarded and recomputed on the fly when needed. This means that in the forward pass, you only store selected activation tensors. At gradient computation time, the forward pass for those uncheckpointed segments is performed again.'),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Memory savings:")," By not keeping every layer's activations around, you drastically reduce memory consumption."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Compute trade-off:")," You have to do some extra forward passes during the backward phase, thus increasing total computation time."),"\n"),"\n",r.createElement(t.p,null,"The memory vs. compute trade-off can be well worth it if you're hitting GPU memory limits. The overhead of partial re-forwarding is often negligible compared to the gains that let you train deeper or larger networks."),"\n",r.createElement(t.h3,{id:"implementation-tips",style:{position:"relative"}},r.createElement(t.a,{href:"#implementation-tips","aria-label":"implementation tips permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Implementation tips"),"\n",r.createElement(t.p,null,"Frameworks provide built-in or third-party libraries for gradient checkpointing:"),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"PyTorch:")),"\n"),"\n",r.createElement(o.A,{text:"\nfrom torch.utils.checkpoint import checkpoint\n\ndef checkpointed_forward(*inputs):\n    # forward pass of a module or a block\n    ...\n\nout = checkpoint(checkpointed_forward, *inputs)\n"}),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"TensorFlow:")," Typically uses the ",r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">tf.recompute_grad</code>'}})," or custom Keras layers for partial recomputation."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"JAX:")," Has ",r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">jax.checkpoint</code>'}})," or uses functional transformations to define how states are stored or recomputed."),"\n"),"\n",r.createElement(t.p,null,"Be mindful of how you choose which layers to checkpoint. A common rule of thumb is to checkpoint only certain blocks (like transformer blocks, or residual blocks in a ResNet) rather than every single layer. That often provides a nice compromise between memory savings and computational overhead."),"\n",r.createElement(t.h2,{id:"gradient-accumulation",style:{position:"relative"}},r.createElement(t.a,{href:"#gradient-accumulation","aria-label":"gradient accumulation permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Gradient accumulation"),"\n",r.createElement(t.h3,{id:"the-concept",style:{position:"relative"}},r.createElement(t.a,{href:"#the-concept","aria-label":"the concept permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"The concept"),"\n",r.createElement(t.p,null,"Batch size in training is often limited by GPU memory. Large batch sizes help stabilize training and speed up throughput on many tasks. If you can't fit an entire large batch into memory in one go, gradient accumulation is a technique that simulates a large batch by doing multiple forward/backward passes with smaller micro-batches, summing (accumulating) the gradients, and only updating the model weights after a certain number of micro-batches."),"\n",r.createElement(s.A,{text:"\\( \\text{EffectiveBatchSize} = \\text{MicroBatchSize} \\times \\text{AccSteps} \\)"}),"\n",r.createElement(t.p,null,"Here, ",r.createElement(s.A,{text:"\\( \\text{AccSteps} \\)"})," is the number of accumulation steps you run before updating. This allows you to have a large effective batch without requiring all the data to be loaded at once."),"\n",r.createElement(t.h3,{id:"balancing-batch-size-and-steps",style:{position:"relative"}},r.createElement(t.a,{href:"#balancing-batch-size-and-steps","aria-label":"balancing batch size and steps permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Balancing batch size and steps"),"\n",r.createElement(t.p,null,"Depending on the model architecture and data distribution, you might find an optimal effective batch size for stable training. The key is to adjust your learning rate accordingly, since a larger effective batch size might allow you to increase the learning rate. Not all tasks benefit from arbitrarily large batch sizes, so you may see diminishing returns after a certain point."),"\n",r.createElement(t.h3,{id:"practical-snippet-in-pytorch",style:{position:"relative"}},r.createElement(t.a,{href:"#practical-snippet-in-pytorch","aria-label":"practical snippet in pytorch permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Practical snippet in PyTorch"),"\n",r.createElement(o.A,{text:"\nmicro_batch_size = 8\naccumulation_steps = 4\neffective_batch_size = micro_batch_size * accumulation_steps\n\nmodel = Model().cuda()\noptimizer = optim.Adam(model.parameters(), lr=1e-3)\n\nfor i, (data, target) in enumerate(dataloader):\n    data, target = data.cuda(), target.cuda()\n    outputs = model(data)\n    loss = loss_fn(outputs, target)\n    loss.backward()\n    \n    if (i + 1) % accumulation_steps == 0:\n        optimizer.step()\n        optimizer.zero_grad()\n"}),"\n",r.createElement(t.p,null,"In this structure, the optimizer only updates after 4 micro-batches. This is effectively a single update with a batch size of 32 (8x4), yet without needing the memory to store the entire 32-sample batch at once."),"\n",r.createElement(t.h2,{id:"jax-specific-structures",style:{position:"relative"}},r.createElement(t.a,{href:"#jax-specific-structures","aria-label":"jax specific structures permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"JAX-specific structures"),"\n",r.createElement(t.p,null,"JAX is quickly becoming a popular framework for high-performance machine learning research, particularly in areas that benefit from large-scale TPU clusters. On a single GPU, JAX still brings a powerful set of transformations and a functional programming style that can lead to efficient code. Let's discuss some JAX-specific concepts that help with single-GPU scaling."),"\n",r.createElement(t.h3,{id:"xla-compilation",style:{position:"relative"}},r.createElement(t.a,{href:"#xla-compilation","aria-label":"xla compilation permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"XLA compilation"),"\n",r.createElement(t.p,null,"JAX compiles your Python functions into optimized kernels using the ",r.createElement(l.A,null,"XLA")," compiler. This can result in faster training loops compared to a typical eager-execution mode in frameworks like PyTorch. The key is understanding how to structure your code as pure functions and let JAX handle the transformations."),"\n",r.createElement(t.h3,{id:"vectorization-with-vmap",style:{position:"relative"}},r.createElement(t.a,{href:"#vectorization-with-vmap","aria-label":"vectorization with vmap permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Vectorization with vmap"),"\n",r.createElement(t.p,null,"The ",r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">vmap</code>'}})," transformation in JAX automatically vectorizes functions across batch dimensions without you needing to manually batch your data. This can help you eliminate Python loops and push more parallel computation to the GPU. If you combine ",r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">vmap</code>'}})," with ",r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">jit</code>'}})," (just-in-time compilation), you can see significant speedups."),"\n",r.createElement(o.A,{text:"\nimport jax\nimport jax.numpy as jnp\n\ndef forward(params, x):\n    # some forward logic\n    return ...\n\n@jax.jit\ndef loss_fn(params, x, y):\n    preds = forward(params, x)\n    return jnp.mean((preds - y)**2)\n\n# Vectorized version across multiple data points\nbatched_loss_fn = jax.vmap(loss_fn, in_axes=(None, 0, 0))\n\n@jax.jit\ndef step(params, x_batch, y_batch):\n    grads = jax.grad(\n        lambda p: jnp.sum(batched_loss_fn(p, x_batch, y_batch))\n    )(params)\n    # update params\n    # ...\n    return updated_params\n"}),"\n",r.createElement(t.h3,{id:"common-pitfalls",style:{position:"relative"}},r.createElement(t.a,{href:"#common-pitfalls","aria-label":"common pitfalls permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Common pitfalls"),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Side effects:")," JAX's functional style demands that you avoid or carefully handle side effects, such as mutating global state."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Compilation overhead:")," The first time you run a JIT-compiled function, you pay a compilation cost. For large models, this overhead can be significant, but repeated calls pay off."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Shape and type issues:")," Because JAX heavily relies on shape inference and static analysis, changing input shapes or dtypes can trigger recompilation."),"\n"),"\n",r.createElement(t.h2,{id:"building-an-optimized-transformer-on-a-single-gpu",style:{position:"relative"}},r.createElement(t.a,{href:"#building-an-optimized-transformer-on-a-single-gpu","aria-label":"building an optimized transformer on a single gpu permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Building an optimized transformer on a single GPU"),"\n",r.createElement(t.h3,{id:"transformer-building-blocks",style:{position:"relative"}},r.createElement(t.a,{href:"#transformer-building-blocks","aria-label":"transformer building blocks permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Transformer building blocks"),"\n",r.createElement(t.p,null,"A typical Transformer includes:"),"\n",r.createElement(t.ol,null,"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Embedding layers")," (for tokens or patch embeddings in vision)."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Multi-head self-attention")," modules (computationally expensive but key)."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Feed-forward networks")," (often large expansions, e.g. 4x the embedding dimension)."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Residual connections")," and ",r.createElement(t.strong,null,"layer normalization"),"."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Output projections")," for classification, language modeling, etc."),"\n"),"\n",r.createElement(t.p,null,"When you attempt to instantiate a large Transformer (e.g., hundreds of millions or billions of parameters) on a single GPU, memory constraints become your primary challenge. This is especially true if you have a large vocabulary (in NLP tasks) or large patch embeddings (in vision tasks)."),"\n",r.createElement(t.h3,{id:"memory-optimizations",style:{position:"relative"}},r.createElement(t.a,{href:"#memory-optimizations","aria-label":"memory optimizations permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Memory optimizations"),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Layer sharing"),": Some Transformer variants reuse the same layer weights multiple times. For instance, DeBERTa reuses certain attention parameters across layers to reduce the overall memory footprint."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Checkpointing"),": Gradient checkpointing is frequently used at scale."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Mixed precision"),": Gains from half-precision are especially large in Transformers due to the massive number of matrix multiplications."),"\n"),"\n",r.createElement(t.h3,{id:"multi-head-attention-efficiency",style:{position:"relative"}},r.createElement(t.a,{href:"#multi-head-attention-efficiency","aria-label":"multi head attention efficiency permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Multi-head attention efficiency"),"\n",r.createElement(t.p,null,"Multi-head attention can be memory-intensive because it requires calculating queries, keys, and values for each head, then performing a batch matrix multiplication. Libraries like ",r.createElement(l.A,null,"FlashAttention")," (proposed in a recent research paper by Tri Dao and gang, ICML 2022) optimize these computations with better memory usage and improved caching. If you can integrate such specialized kernels, it can drastically reduce overhead and speed training."),"\n",r.createElement(t.p,null,"Below is a PyTorch-like pseudo-implementation of a memory-optimized multi-head attention function, illustrating the concept (not the entire FlashAttention code, but a simplified approach)."),"\n",r.createElement(o.A,{text:"\nclass MultiHeadAttention(nn.Module):\n    def __init__(self, d_model, num_heads, dropout=0.1):\n        super().__init__()\n        self.num_heads = num_heads\n        self.head_dim = d_model // num_heads\n        self.W_q = nn.Linear(d_model, d_model)\n        self.W_k = nn.Linear(d_model, d_model)\n        self.W_v = nn.Linear(d_model, d_model)\n        self.out = nn.Linear(d_model, d_model)\n        self.dropout = nn.Dropout(dropout)\n    \n    def forward(self, x):\n        B, T, D = x.shape\n        q = self.W_q(x).view(B, T, self.num_heads, self.head_dim)\n        k = self.W_k(x).view(B, T, self.num_heads, self.head_dim)\n        v = self.W_v(x).view(B, T, self.num_heads, self.head_dim)\n        \n        # Permute to (B, num_heads, T, head_dim)\n        q = q.permute(0, 2, 1, 3)\n        k = k.permute(0, 2, 1, 3)\n        v = v.permute(0, 2, 1, 3)\n        \n        # Scaled dot-product\n        scores = (q @ k.transpose(-1, -2)) / (self.head_dim ** 0.5)\n        attn = torch.softmax(scores, dim=-1)\n        attn = self.dropout(attn)\n        \n        out = attn @ v  # shape: (B, num_heads, T, head_dim)\n        out = out.permute(0, 2, 1, 3).contiguous()\n        out = out.view(B, T, D)\n        return self.out(out)\n"}),"\n",r.createElement(t.p,null,"In advanced usage, you might incorporate custom CUDA kernels or specialized libraries, but the principle remains the same: carefully handle memory usage at each step."),"\n",r.createElement(t.h2,{id:"profiling-single-gpu-training",style:{position:"relative"}},r.createElement(t.a,{href:"#profiling-single-gpu-training","aria-label":"profiling single gpu training permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Profiling single-GPU training"),"\n",r.createElement(t.h3,{id:"identifying-hotspots",style:{position:"relative"}},r.createElement(t.a,{href:"#identifying-hotspots","aria-label":"identifying hotspots permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Identifying hotspots"),"\n",r.createElement(t.p,null,"Profiling tools let you see how efficiently your GPU's resources are being used:"),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"PyTorch Profiler:")," built-in tool with a TensorBoard plugin."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"NVIDIA Nsight Systems:")," advanced system-wide profiler."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"TensorFlow Profiler:")," integrated with TensorBoard."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"JAX Profilers:")," often rely on XLA debug tools."),"\n"),"\n",r.createElement(t.p,null,"You'll want to watch for:"),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"GPU utilization"),": ideally close to 100% during training steps."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Memory throughput"),": ensuring you're not bounding on memory copy overhead."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Kernel launch overhead"),": small kernel calls repeated many times can hamper performance."),"\n"),"\n",r.createElement(t.h3,{id:"interpreting-profiler-data",style:{position:"relative"}},r.createElement(t.a,{href:"#interpreting-profiler-data","aria-label":"interpreting profiler data permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Interpreting profiler data"),"\n",r.createElement(t.p,null,"A typical profiler trace might show which layers or operations consume the most time (e.g., multi-head attention blocks, feed-forward expansions, or embedding lookups). This data helps you decide where to:"),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,"Switch to specialized kernels."),"\n",r.createElement(t.li,null,"Adopt checkpointing."),"\n",r.createElement(t.li,null,"Change the shape or internal dimensions of your model."),"\n"),"\n",r.createElement(t.p,null,"Sometimes you'll discover that your input pipeline is the bottleneck. That is especially relevant if you're streaming data from disk or doing heavy augmentations on the CPU. Keeping the GPU fed with data is essential, so you may use multi-threaded or asynchronous data loading to prevent GPU idle time."),"\n",r.createElement(t.h2,{id:"asynchronous-computation-and-automatic-parallelism",style:{position:"relative"}},r.createElement(t.a,{href:"#asynchronous-computation-and-automatic-parallelism","aria-label":"asynchronous computation and automatic parallelism permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Asynchronous computation and automatic parallelism"),"\n",r.createElement(t.h3,{id:"asynchronous-execution",style:{position:"relative"}},r.createElement(t.a,{href:"#asynchronous-execution","aria-label":"asynchronous execution permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Asynchronous execution"),"\n",r.createElement(t.p,null,"Modern frameworks typically enqueue operations on the GPU without blocking your CPU code. This asynchronous approach can hide data transfer latency but requires careful synchronization (e.g., using ",r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">.cuda()</code>'}})," calls or ",r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">.to(device)</code>'}})," in PyTorch). In some advanced scenarios, you might deliberately overlap data loading with GPU computation."),"\n",r.createElement(t.h3,{id:"graph-optimizations",style:{position:"relative"}},r.createElement(t.a,{href:"#graph-optimizations","aria-label":"graph optimizations permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Graph optimizations"),"\n",r.createElement(t.p,null,"Frameworks like TensorFlow and JAX rely heavily on graph-based execution. They break your code into a computational graph that can be optimized. This can lead to:"),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Operation fusion"),": merging multiple smaller kernels into one to minimize overhead."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Inlining"),": removing function call overhead."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Parallel scheduling"),": running independent sub-graphs in parallel on the GPU."),"\n"),"\n",r.createElement(t.p,null,"PyTorch's eager mode allows for greater flexibility but potentially less optimization. However, PyTorch also introduces TorchScript and ",r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">torch.compile</code>'}})," (in newer versions) to enable more graph-based optimizations, bridging the gap with static-graph frameworks."),"\n",r.createElement(t.h2,{id:"computational-hardware-considerations",style:{position:"relative"}},r.createElement(t.a,{href:"#computational-hardware-considerations","aria-label":"computational hardware considerations permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Computational hardware considerations"),"\n",r.createElement(t.p,null,"While we're focusing primarily on single-GPU training, the type of GPU you use can have a dramatic effect on your scaling endeavors."),"\n",r.createElement(t.h3,{id:"gpu-architecture-basics",style:{position:"relative"}},r.createElement(t.a,{href:"#gpu-architecture-basics","aria-label":"gpu architecture basics permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"GPU architecture basics"),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Cores and threads"),": The raw computing units that perform multiply-add operations."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Memory bandwidth"),": The speed at which data can be moved in and out of GPU memory."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Tensor cores"),": Specialized hardware blocks optimized for matrix multiplication in half precision (FP16) or tensor float 32 (TF32)."),"\n"),"\n",r.createElement(t.h3,{id:"specialized-hardware-tpus-custom-asics",style:{position:"relative"}},r.createElement(t.a,{href:"#specialized-hardware-tpus-custom-asics","aria-label":"specialized hardware tpus custom asics permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Specialized hardware (TPUs, custom ASICs)"),"\n",r.createElement(t.p,null,"Google's Tensor Processing Units (TPUs) operate on a different programming paradigm (XLA-based) and can be extremely efficient for large-scale operations. Some companies also develop custom ASICs for specialized tasks. While these hardware offerings can push performance even further, the same fundamental scaling techniques (mixed precision, gradient checkpointing, etc.) often apply."),"\n",r.createElement(t.h3,{id:"matching-hardware-to-scaling-strategies",style:{position:"relative"}},r.createElement(t.a,{href:"#matching-hardware-to-scaling-strategies","aria-label":"matching hardware to scaling strategies permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Matching hardware to scaling strategies"),"\n",r.createElement(t.p,null,"Selecting the right hardware means considering your memory requirements, compute demands, and software ecosystem:"),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"High memory capacity GPUs")," (e.g., NVIDIA A100 with 40GB or 80GB) let you handle bigger models or bigger batches."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Less memory but high compute")," (like consumer GPUs with fewer memory channels but strong cores) might do well if you rely heavily on gradient accumulation or other memory reduction strategies."),"\n"),"\n",r.createElement(t.h2,{id:"memory-optimization-strategies",style:{position:"relative"}},r.createElement(t.a,{href:"#memory-optimization-strategies","aria-label":"memory optimization strategies permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Memory-optimization strategies"),"\n",r.createElement(t.p,null,"Beyond gradient checkpointing and mixed precision, several additional techniques can further reduce the memory footprint:"),"\n",r.createElement(t.h3,{id:"activation-quantization-and-tensor-compression",style:{position:"relative"}},r.createElement(t.a,{href:"#activation-quantization-and-tensor-compression","aria-label":"activation quantization and tensor compression permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Activation quantization and tensor compression"),"\n",r.createElement(t.p,null,"Advanced methods compress activations on the fly, typically at a lower precision than FP16. Some research has explored 8-bit or even 4-bit quantization for activations. For example, ",r.createElement(l.A,null,"Q8BERT")," (by Zafrir and gang, NeurIPS 2019) used 8-bit quantization for both weights and activations in a BERT model without substantial accuracy loss."),"\n",r.createElement(t.h3,{id:"offloading",style:{position:"relative"}},r.createElement(t.a,{href:"#offloading","aria-label":"offloading permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Offloading"),"\n",r.createElement(t.p,null,"If your GPU memory is severely constrained, you can offload certain tensors to CPU memory or disk:"),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Optimizer state"),": Instead of storing the entire optimizer state (e.g., moments in Adam) on GPU, place them in CPU memory."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Activation CPU offload"),": Some frameworks can automatically move seldom-needed activations to CPU memory and move them back to GPU on demand."),"\n"),"\n",r.createElement(t.p,null,"These methods can let you train bigger models, but offloading can also drastically slow down training if done too frequently."),"\n",r.createElement(t.h2,{id:"best-practices-for-single-gpu-training-at-scale",style:{position:"relative"}},r.createElement(t.a,{href:"#best-practices-for-single-gpu-training-at-scale","aria-label":"best practices for single gpu training at scale permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Best practices for single-GPU training at scale"),"\n",r.createElement(t.h3,{id:"efficient-data-pipelines",style:{position:"relative"}},r.createElement(t.a,{href:"#efficient-data-pipelines","aria-label":"efficient data pipelines permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Efficient data pipelines"),"\n",r.createElement(t.p,null,"Always ensure that your training loop is not starved for data. Techniques include:"),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Pre-fetching"),": Load data for the next batch while the current batch is still being processed."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"In-memory caching"),": If your dataset is small enough, keep it in RAM to avoid disk I/O."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Shuffle buffering"),": Maintain a large shuffle buffer in memory to randomize data effectively."),"\n"),"\n",r.createElement(t.h3,{id:"hyperparameter-tuning-for-large-models",style:{position:"relative"}},r.createElement(t.a,{href:"#hyperparameter-tuning-for-large-models","aria-label":"hyperparameter tuning for large models permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Hyperparameter tuning for large models"),"\n",r.createElement(t.p,null,"Large models can be more sensitive to learning rate, batch size, warm-up schedules, and weight decay. Empirical testing is crucial; you might find that a carefully tuned small learning rate or specialized schedule can stabilize training."),"\n",r.createElement(t.h3,{id:"logging-and-checkpointing",style:{position:"relative"}},r.createElement(t.a,{href:"#logging-and-checkpointing","aria-label":"logging and checkpointing permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Logging and checkpointing"),"\n",r.createElement(t.p,null,"When your training runs for days or weeks on a single GPU, you must have robust checkpointing:"),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Periodic checkpointing"),": Save model weights at intervals so you can resume if an error occurs."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Versioning"),": Include hyperparameters and environment details in your logs or checkpoints for full reproducibility."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Logging"),": Tools like TensorBoard, WandB, or Neptune.ai can help track metrics over long runs and keep an eye on potential divergence or overfitting."),"\n"),"\n",r.createElement(t.h2,{id:"intermediate-summary-of-single-gpu-techniques",style:{position:"relative"}},r.createElement(t.a,{href:"#intermediate-summary-of-single-gpu-techniques","aria-label":"intermediate summary of single gpu techniques permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Intermediate summary of single-GPU techniques"),"\n",r.createElement(t.p,null,"We've covered an array of strategies — mixed precision, gradient checkpointing, gradient accumulation, asynchronous execution, specialized libraries, and more — that collectively allow you to push the limits of single-GPU training. This forms a critical first step toward truly large-scale training. Once you master these techniques, you'll be better positioned to handle multi-GPU setups or distributed training across multiple nodes, as we'll explore in subsequent parts of this course."),"\n",r.createElement(t.h2,{id:"references-and-resources",style:{position:"relative"}},r.createElement(t.a,{href:"#references-and-resources","aria-label":"references and resources permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"References and resources"),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Official PyTorch Documentation"),": Provides excellent coverage of ",r.createElement(l.A,null,"torch.cuda.amp")," and advanced memory optimization APIs."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"TensorFlow Guide to Mixed Precision"),": Offers an official breakdown of best practices for half precision in TF."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"JAX Documentation"),": Explains ",r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">vmap</code>'}}),", ",r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">jit</code>'}}),", and the XLA compiler in detail."),"\n",r.createElement(t.li,null,"Smith and gang, NeurIPS 2022: On advanced memory saving techniques for large transformers (covering various checkpointing strategies)."),"\n",r.createElement(t.li,null,"OpenAI's blogs on GPT scaling: Provide insight into how large-scale language models benefit from every optimization trick you can imagine."),"\n",r.createElement(t.li,null,r.createElement(l.A,null,"D2L.ai"),': The open-source "Dive into Deep Learning" resource. Their chapters on computational performance are especially relevant if you want quick code examples.'),"\n",r.createElement(t.li,null,"Community forums (PyTorch Discuss, TensorFlow Forums, JAX GitHub Issues): Great places to find real-world solutions from practitioners who have faced similar memory or scaling issues."),"\n"),"\n",r.createElement(t.p,null,"Remember, these single-GPU techniques serve as the critical foundation to scale beyond. In the next parts of the course, we'll examine multi-GPU data parallelism, model parallelism, pipeline parallelism, and distributed setups using frameworks like PyTorch's Distributed Data Parallel, Horovod, or Ray. Mastering the single-GPU memory management, precision tuning, and performance profiling is your stepping stone to the truly large-scale adventures awaiting you in the world of modern AI."))}var m=function(e){void 0===e&&(e={});const{wrapper:t}=Object.assign({},(0,i.RP)(),e.components);return t?r.createElement(t,e,r.createElement(c,e)):c(e)},h=n(36710),d=n(58481),u=n.n(d),p=n(36310),g=n(87245),f=n(27042),v=n(59849),y=n(5591),b=n(61122),E=n(9219),w=n(33203),S=n(95751),k=n(94328),H=n(80791),x=n(78137);const z=e=>{let{toc:t}=e;if(!t||!t.items)return null;return r.createElement("nav",{className:H.R},r.createElement("ul",null,t.items.map(((e,t)=>r.createElement("li",{key:t},r.createElement("a",{href:e.url,onClick:t=>((e,t)=>{e.preventDefault();const n=t.replace("#",""),a=document.getElementById(n);a&&a.scrollIntoView({behavior:"smooth",block:"start"})})(t,e.url)},e.title),e.items&&r.createElement(z,{toc:{items:e.items}}))))))};function T(e){let{data:{mdx:t,allMdx:l,allPostImages:o},children:s}=e;const{frontmatter:c,body:m,tableOfContents:h}=t,d=c.index,v=c.slug.split("/")[1],H=l.nodes.filter((e=>e.frontmatter.slug.includes(`/${v}/`))).sort(((e,t)=>e.frontmatter.index-t.frontmatter.index)),T=H.findIndex((e=>e.frontmatter.index===d)),_=H[T+1],M=H[T-1],P=c.slug.replace(/\/$/,""),C=/[^/]*$/.exec(P)[0],I=`posts/${v}/content/${C}/`,{0:A,1:V}=(0,r.useState)(c.flagWideLayoutByDefault),{0:L,1:B}=(0,r.useState)(!1);var G;(0,r.useEffect)((()=>{B(!0);const e=setTimeout((()=>B(!1)),340);return()=>clearTimeout(e)}),[A]),"adventures"===v?G=E.cb:"research"===v?G=E.Qh:"thoughts"===v&&(G=E.T6);const N=u()(m).replace(/import .*? from .*?;/g,"").replace(/<.*?>/g,"").replace(/\{\/\*[\s\S]*?\*\/\}/g,"").trim().split(/\s+/).length,U=function(e){if(e<=10)return"~10 min";if(e<=20)return"~20 min";if(e<=30)return"~30 min";if(e<=40)return"~40 min";if(e<=50)return"~50 min";if(e<=60)return"~1 h";const t=Math.floor(e/60),n=e%60;return n<=30?`~${t}${n>0?".5":""} h`:`~${t+1} h`}(Math.ceil(N/G)+(c.extraReadTimeMin||0)),q=[{flag:c.flagDraft,component:()=>Promise.all([n.e(3231),n.e(8809)]).then(n.bind(n,28809))},{flag:c.flagMindfuckery,component:()=>Promise.all([n.e(3231),n.e(2471)]).then(n.bind(n,67709))},{flag:c.flagRewrite,component:()=>Promise.all([n.e(3231),n.e(6764)]).then(n.bind(n,62002))},{flag:c.flagOffensive,component:()=>Promise.all([n.e(3231),n.e(2443)]).then(n.bind(n,17681))},{flag:c.flagProfane,component:()=>Promise.all([n.e(3231),n.e(8048)]).then(n.bind(n,53286))},{flag:c.flagMultilingual,component:()=>Promise.all([n.e(3231),n.e(4069)]).then(n.bind(n,78831))},{flag:c.flagUnreliably,component:()=>Promise.all([n.e(3231),n.e(3417)]).then(n.bind(n,8179))},{flag:c.flagPolitical,component:()=>Promise.all([n.e(3231),n.e(5195)]).then(n.bind(n,30433))},{flag:c.flagCognitohazard,component:()=>Promise.all([n.e(3231),n.e(3175)]).then(n.bind(n,8413))},{flag:c.flagHidden,component:()=>Promise.all([n.e(3231),n.e(9556)]).then(n.bind(n,14794))}],{0:O,1:F}=(0,r.useState)([]);return(0,r.useEffect)((()=>{q.forEach((e=>{let{flag:t,component:n}=e;t&&n().then((e=>{F((t=>[].concat((0,a.A)(t),[e.default])))}))}))}),[]),r.createElement(f.P.div,{initial:{opacity:0},animate:{opacity:1},exit:{opacity:0},transition:{duration:.15}},r.createElement(y.A,{postNumber:c.index,date:c.date,updated:c.updated,readTime:U,difficulty:c.difficultyLevel,title:c.title,desc:c.desc,banner:c.banner,section:v,postKey:C,isMindfuckery:c.flagMindfuckery,mainTag:c.mainTag}),r.createElement("div",{style:{display:"flex",justifyContent:"flex-end",flexWrap:"wrap",maxWidth:"75%",marginLeft:"auto",paddingRight:"1vw",marginTop:"-6vh",marginBottom:"4vh"}},c.otherTags.map(((e,t)=>r.createElement("span",{key:t,className:`noselect ${x.MW}`,style:{margin:"0 5px 5px 0"}},e)))),r.createElement("div",{class:"postBody"},r.createElement(z,{toc:h})),r.createElement("br"),r.createElement("div",{style:{margin:"0 10% -2vh 30%",textAlign:"right"}},r.createElement(f.P.button,{class:"noselect",className:k.pb,id:k.xG,onClick:()=>{V(!A)},whileTap:{scale:.93}},r.createElement(f.P.div,{className:S.DJ,key:A,initial:{opacity:0},animate:{opacity:1},exit:{opacity:0},transition:{duration:.3,ease:"easeInOut"}},A?"Switch to default layout":"Switch to wide layout"))),r.createElement("br"),r.createElement("div",{class:"postBody",style:{margin:A?"0 -14%":"",maxWidth:A?"200%":"",transition:"margin 1s ease, max-width 1s ease, padding 1s ease"}},r.createElement("div",{className:`${k.P_} ${L?k.Xn:k.qG}`},O.map(((e,t)=>r.createElement(e,{key:t}))),c.indexCourse?r.createElement(w.A,{index:c.indexCourse,category:c.courseCategoryName}):"",r.createElement(p.Z.Provider,{value:{images:o.nodes,basePath:I.replace(/\/$/,"")+"/"}},r.createElement(i.xA,{components:{Image:g.A}},s)))),r.createElement(b.A,{nextPost:_,lastPost:M,keyCurrent:C,section:v}))}function _(e){return r.createElement(T,e,r.createElement(m,e))}function M(e){var t,n,a,i,l;let{data:o}=e;const{frontmatter:s}=o.mdx,c=s.titleSEO||s.title,m=s.titleOG||c,d=s.titleTwitter||c,u=s.descSEO||s.desc,p=s.descOG||u,g=s.descTwitter||u,f=s.schemaType||"BlogPosting",y=s.keywordsSEO,b=s.date,E=s.updated||b,w=s.imageOG||(null===(t=s.banner)||void 0===t||null===(n=t.childImageSharp)||void 0===n||null===(a=n.gatsbyImageData)||void 0===a||null===(i=a.images)||void 0===i||null===(l=i.fallback)||void 0===l?void 0:l.src),S=s.imageAltOG||p,k=s.imageTwitter||w,H=s.imageAltTwitter||g,x=s.canonicalURL,z=s.flagHidden||!1,T=s.mainTag||"Posts",_=s.slug.split("/")[1]||"posts",{siteUrl:M}=(0,h.Q)(),P={"@context":"https://schema.org","@type":"BreadcrumbList",itemListElement:[{"@type":"ListItem",position:1,name:"Home",item:M},{"@type":"ListItem",position:2,name:T,item:`${M}/${s.slug.split("/")[1]}`},{"@type":"ListItem",position:3,name:c,item:`${M}${s.slug}`}]};return r.createElement(v.A,{title:c+" - avrtt.blog",titleOG:m,titleTwitter:d,description:u,descriptionOG:p,descriptionTwitter:g,schemaType:f,keywords:y,datePublished:b,dateModified:E,imageOG:w,imageAltOG:S,imageTwitter:k,imageAltTwitter:H,canonicalUrl:x,flagHidden:z,mainTag:T,section:_,type:"article"},r.createElement("script",{type:"application/ld+json"},JSON.stringify(P)))}},96098:function(e,t,n){var a=n(96540),i=n(7978);t.A=e=>{let{text:t}=e;return a.createElement(i.A,null,t)}}}]);
//# sourceMappingURL=component---src-templates-post-js-content-file-path-src-pages-posts-research-training-models-at-scale-mdx-bc97a98bead525471bd2.js.map