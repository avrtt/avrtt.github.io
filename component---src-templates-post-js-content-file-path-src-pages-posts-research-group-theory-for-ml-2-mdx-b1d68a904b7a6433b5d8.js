"use strict";(self.webpackChunkavrtt_blog=self.webpackChunkavrtt_blog||[]).push([[6930],{19194:function(e,t,n){n.r(t),n.d(t,{Head:function(){return T},PostTemplate:function(){return A},default:function(){return C}});var a=n(54506),r=n(28453),i=n(96540),o=n(16886),l=n(46295),s=n(96098);function c(e){const t=Object.assign({h2:"h2",a:"a",span:"span",p:"p",h3:"h3",ul:"ul",li:"li",strong:"strong",ol:"ol",em:"em",h4:"h4"},(0,r.RP)(),e.components);return i.createElement(i.Fragment,null,"\n",i.createElement("br"),"\n","\n",i.createElement(t.h2,{id:"recap-key-concepts-from-part-1",style:{position:"relative"}},i.createElement(t.a,{href:"#recap-key-concepts-from-part-1","aria-label":"recap key concepts from part 1 permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Recap: key concepts from part 1"),"\n",i.createElement(t.p,null,'In the previous installment of this course\'s exploration of group theory for machine learning — which I referred to informally as "Group theory for ML, pt. 1" — I introduced a wide array of foundational ideas from group theory and how they manifest in machine learning contexts. My plan now is to build on that base by discussing more advanced or extended topics, demonstrating how group-theoretic insights inform the development of new model architectures, and highlighting the bridge from theory to practice.'),"\n",i.createElement(t.p,null,"I will begin with a short recapitulation of the most essential concepts from part 1, which should help anchor your memory and ensure continuity in the flow of ideas. However, if you have not read the previous article, or if you need more background on fundamental group theory (such as the definition of a group, the concept of irreps, and the notion of group actions), I strongly recommend referring to that material first."),"\n",i.createElement(t.h3,{id:"brief-review-of-group-actions-representations-irreps",style:{position:"relative"}},i.createElement(t.a,{href:"#brief-review-of-group-actions-representations-irreps","aria-label":"brief review of group actions representations irreps permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Brief review of group actions, representations, irreps"),"\n",i.createElement(t.p,null,"Let me refresh the core definitions that were central in part 1:"),"\n",i.createElement(t.ul,null,"\n",i.createElement(t.li,null,"\n",i.createElement(t.p,null,"A ",i.createElement(o.A,null,"group"),", in the abstract algebraic sense, is a set ",i.createElement(s.A,{text:"\\(G\\)"})," equipped with a binary operation (often denoted multiplicatively) that satisfies closure, associativity, existence of an identity element, and existence of inverse elements. In machine learning contexts, this group ",i.createElement(s.A,{text:"\\(G\\)"})," often represents a collection of symmetries — e.g., all 2D rotations of an image, or the group of permutations of features."),"\n"),"\n",i.createElement(t.li,null,"\n",i.createElement(t.p,null,"A ",i.createElement(o.A,null,"group representation")," is a way to realize the elements of ",i.createElement(s.A,{text:"\\(G\\)"})," as linear transformations of a vector space (often ",i.createElement(s.A,{text:"\\(\\mathbb{R}^n\\)"})," or ",i.createElement(s.A,{text:"\\(\\mathbb{C}^n\\)"}),"). Concretely, each element ",i.createElement(s.A,{text:"\\(g \\in G\\)"})," is associated with a matrix ",i.createElement(s.A,{text:"\\(\\rho(g)\\)"})," acting on vectors in ",i.createElement(s.A,{text:"\\(\\mathbb{R}^n\\)"}),". The representation ",i.createElement(s.A,{text:"\\(\\rho\\)"})," preserves group structure, meaning ",i.createElement(s.A,{text:"\\(\\rho(g_1g_2) = \\rho(g_1)\\rho(g_2)\\)"}),"."),"\n"),"\n",i.createElement(t.li,null,"\n",i.createElement(t.p,null,"An ",i.createElement(o.A,null,"irreducible representation")," (irrep) is a representation that cannot be decomposed into smaller, non-trivial representations. The famous result from representation theory is that every finite-dimensional representation of a finite group can be expressed uniquely (up to isomorphism) as a direct sum of irreps. This concept is extremely relevant for analyzing how symmetrical transformations can be expressed in a neural network's parameter space or feature maps."),"\n"),"\n",i.createElement(t.li,null,"\n",i.createElement(t.p,null,i.createElement(o.A,null,"Group actions"),' formalize the intuitive notion of a group "acting" on a set or a space. When we say ',i.createElement(s.A,{text:"\\(G\\)"})," acts on a set ",i.createElement(s.A,{text:"\\(X\\)"}),", we have a mapping ",i.createElement(s.A,{text:"\\(G \\times X \\to X\\)"})," (usually denoted ",i.createElement(s.A,{text:"\\((g, x) \\mapsto g \\cdot x\\)"}),") that satisfies certain natural axioms. In ML, the set ",i.createElement(s.A,{text:"\\(X\\)"})," might be an input space (for instance, image pixels), and we want a representation of transformations that's consistent with how the group acts on that input (e.g., rotating an image by 90 degrees)."),"\n"),"\n"),"\n",i.createElement(t.h3,{id:"symmetries-invariance-and-equivariance",style:{position:"relative"}},i.createElement(t.a,{href:"#symmetries-invariance-and-equivariance","aria-label":"symmetries invariance and equivariance permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Symmetries, invariance, and equivariance"),"\n",i.createElement(t.p,null,"We then emphasized:"),"\n",i.createElement(t.ul,null,"\n",i.createElement(t.li,null,"\n",i.createElement(t.p,null,"A function ",i.createElement(s.A,{text:"\\(f\\)"})," is ",i.createElement(o.A,null,"invariant")," under a group action if applying any element ",i.createElement(s.A,{text:"\\(g \\in G\\)"})," to the input does not change the output:"),"\n",i.createElement(s.A,{text:"\\(f(g\\cdot x) = f(x)\\)"}),"\n",i.createElement(t.p,null,"for all ",i.createElement(s.A,{text:"\\(g \\in G\\)"})," and all ",i.createElement(s.A,{text:"\\(x \\in X\\)"}),"."),"\n"),"\n",i.createElement(t.li,null,"\n",i.createElement(t.p,null,"A function ",i.createElement(s.A,{text:"\\(f\\)"})," is ",i.createElement(o.A,null,"equivariant")," under a group action if applying any element ",i.createElement(s.A,{text:"\\(g \\in G\\)"})," to the input is equivalent to applying some corresponding transformation to the output. More formally:"),"\n",i.createElement(s.A,{text:"\\(f(g\\cdot x) = \\rho(g) f(x)\\)"}),"\n",i.createElement(t.p,null,"where ",i.createElement(s.A,{text:"\\(\\rho(g)\\)"})," is often a representation of ",i.createElement(s.A,{text:"\\(g\\)"}),' on the output space. Equivariance can be seen as the output being transformed "in tandem" with the input.'),"\n"),"\n"),"\n",i.createElement(t.p,null,"In part 1, I gave some fundamental reasons why we might care about invariance or equivariance in neural networks. If a dataset exhibits a certain symmetry — for example, the meaning of an image does not change when it is rotated slightly — a network that respects this property can generalize better, use parameters more efficiently, and often reduce the need for large amounts of labeled data (due to built-in constraints or priors)."),"\n",i.createElement(t.h3,{id:"motivation-bridging-theory-to-real-ml-implementations",style:{position:"relative"}},i.createElement(t.a,{href:"#motivation-bridging-theory-to-real-ml-implementations","aria-label":"motivation bridging theory to real ml implementations permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Motivation: bridging theory to real ML implementations"),"\n",i.createElement(t.p,null,"Finally, I closed part 1 by explaining the impetus behind going deeper into group theory for ML: the synergy between advanced abstract algebraic tools and practical, state-of-the-art neural architectures. Indeed, as the field of geometric deep learning (which attempts to unify CNNs, GNNs, and other structured neural networks under a group-theoretic lens) grows, more sophisticated group-based methods are emerging."),"\n",i.createElement(t.p,null,"In this Part 2, I will revisit the context of CNNs specifically, detail the concept of group convolution, show how to construct group-equivariant networks in code, and then explore how these methods can be extended (steerable CNNs, manifold data, etc.). Let's dive right in."),"\n",i.createElement(t.h2,{id:"group-theory-in-the-context-of-machine-learning",style:{position:"relative"}},i.createElement(t.a,{href:"#group-theory-in-the-context-of-machine-learning","aria-label":"group theory in the context of machine learning permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Group theory in the context of machine learning"),"\n",i.createElement(t.p,null,"Let's reframe group theory within the ML domain, focusing on symmetrical transformations and their interplay with data augmentation, network design, and training strategies."),"\n",i.createElement(t.h3,{id:"symmetries-invariances-and-data-augmentation",style:{position:"relative"}},i.createElement(t.a,{href:"#symmetries-invariances-and-data-augmentation","aria-label":"symmetries invariances and data augmentation permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Symmetries, invariances, and data augmentation"),"\n",i.createElement(t.p,null,"I want to highlight again why symmetries and invariances are so relevant in practice. One immediate reason: ",i.createElement(o.A,null,"data augmentation"),". When you augment a dataset by applying transformations to the inputs (e.g., rotating images, flipping them horizontally, etc.), you are implicitly leveraging a group of transformations. If the label or fundamental structure remains the same under these transformations, you are injecting the knowledge that your problem is symmetrical in that manner."),"\n",i.createElement(t.ul,null,"\n",i.createElement(t.li,null,"\n",i.createElement(t.p,null,i.createElement(t.strong,null,"Why symmetries matter for ML"),": If a symmetry is present in your data — say, the classification of a rotated image should be the same as the original image — then building the network to be invariant (or partially equivariant) to that symmetry can significantly improve performance. This approach can also help limit overfitting by effectively expanding the coverage of your training set."),"\n"),"\n",i.createElement(t.li,null,"\n",i.createElement(t.p,null,i.createElement(t.strong,null,"Common transformations in images and signals"),": For 2D images, we commonly see the group of translations (implicitly exploited by standard convolutions), the group of discrete rotations by multiples of 90 degrees, or even continuous rotations ",i.createElement(s.A,{text:"\\(\\mathrm{SO}(2)\\)"}),". Reflections (which form part of dihedral groups) also appear naturally, e.g., flipping an image horizontally or vertically. In one-dimensional signals (audio, time-series), the primary symmetrical transformation is often translations, but some tasks might also involve time-reversal symmetry. In 3D shape analysis or robotics contexts, the relevant groups can involve rigid motions ",i.createElement(s.A,{text:"\\(\\mathrm{SO}(3)\\)"})," or the special Euclidean group ",i.createElement(s.A,{text:"\\(\\mathrm{SE}(3)\\)"}),", i.e. combining rotations and translations in 3D."),"\n"),"\n"),"\n",i.createElement(t.h3,{id:"equivariance-vs-invariance",style:{position:"relative"}},i.createElement(t.a,{href:"#equivariance-vs-invariance","aria-label":"equivariance vs invariance permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Equivariance vs. invariance"),"\n",i.createElement(t.p,null,"To reiterate:"),"\n",i.createElement(t.ul,null,"\n",i.createElement(t.li,null,"\n",i.createElement(t.p,null,i.createElement(t.strong,null,"Equivariance"),": The network's feature maps transform in a predictable, structured way when the input is transformed by an element of the group. Symbolically, ",i.createElement(s.A,{text:"\\(f(g\\cdot x) = \\rho(g)f(x)\\)"}),". If you have a layer (like a standard convolution) that is translation-equivariant, then shifting the input by one pixel shifts the feature map correspondingly."),"\n"),"\n",i.createElement(t.li,null,"\n",i.createElement(t.p,null,i.createElement(t.strong,null,"Invariance"),": The network's output is unaffected by the group transformation: ",i.createElement(s.A,{text:"\\(f(g\\cdot x) = f(x)\\)"}),". In other words, the final result is the same even if the input is changed by a symmetry transformation."),"\n"),"\n"),"\n",i.createElement(t.p,null,"Both properties matter for different reasons. In many classification tasks, we might want the final classification score or label to be invariant (since a rotated image is presumably the same object), while we want the intermediate representation to be equivariant, so that local features in the data move systematically around the feature map. That is precisely why CNNs are so powerful: their convolution layers are equivariant to translation, but the final output is typically a single label that is translation-invariant."),"\n",i.createElement(t.h3,{id:"practical-scenarios",style:{position:"relative"}},i.createElement(t.a,{href:"#practical-scenarios","aria-label":"practical scenarios permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Practical scenarios"),"\n",i.createElement(t.p,null,"Let's outline a few real-world domains where group theory and symmetries come into play:"),"\n",i.createElement(t.ol,null,"\n",i.createElement(t.li,null,"\n",i.createElement(t.p,null,i.createElement(t.strong,null,"2D image classification with rotations/reflections"),": The classical example. Many images are considered the same object or scene even if they are slightly rotated or reflected. That's why building networks with these symmetries built-in can significantly improve performance with fewer training examples."),"\n"),"\n",i.createElement(t.li,null,"\n",i.createElement(t.p,null,i.createElement(t.strong,null,"3D shape analysis, point clouds"),": 3D data is usually subject to rotational and translational symmetries. Rotating a 3D mesh or point cloud of a chair doesn't change the fact that it is a chair. We might want our model to be equivariant or invariant to these transformations."),"\n"),"\n",i.createElement(t.li,null,"\n",i.createElement(t.p,null,i.createElement(t.strong,null,"Time-series and structured data"),": For time-series, translational invariance is often key (temporal shifts). Certain types of pattern recognition tasks can also involve time-reversal invariance. In structured data like molecular graphs, symmetries might be permutations of atoms or rotations in 3D space."),"\n"),"\n"),"\n",i.createElement(t.p,null,"All these scenarios highlight the growing importance of group theory in ML. Next, let me dive into the notion of ",i.createElement(t.em,null,"group convolution")," and group convolutional networks, which generalize the classical idea of convolution by considering transformations from more general groups than translations alone."),"\n",i.createElement(t.h2,{id:"group-convolution-and-group-convolutional-networks",style:{position:"relative"}},i.createElement(t.a,{href:"#group-convolution-and-group-convolutional-networks","aria-label":"group convolution and group convolutional networks permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Group convolution and group convolutional networks"),"\n",i.createElement(t.h3,{id:"revisiting-the-classical-convolution-operator",style:{position:"relative"}},i.createElement(t.a,{href:"#revisiting-the-classical-convolution-operator","aria-label":"revisiting the classical convolution operator permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Revisiting the classical convolution operator"),"\n",i.createElement(t.p,null,"A standard 2D convolutional layer, as used in typical CNN architectures, is translation-equivariant along the spatial dimensions (height and width). If you shift the input image by, say, two pixels to the right, the feature maps produced by the convolution shift correspondingly, no matter which region of the image we're dealing with. Symbolically, the convolution with kernel ",i.createElement(s.A,{text:"\\(k\\)"})," can be written as:"),"\n",i.createElement(s.A,{text:"\\[\n(f * k)(x) = \\sum_{y} f(y) k(x - y).\n\\]"}),"\n",i.createElement(t.p,null,"For continuous signals, you might see an integral instead of a sum. Convolution is intimately tied to translation symmetry — specifically, it is the representation of the group of translations in a suitable function space."),"\n",i.createElement(t.p,null,"One can also interpret the standard convolution operator as computing an inner product of the kernel with each translated patch of the input. This perspective extends naturally to group convolutions, except we consider not just translations, but an entire group ",i.createElement(s.A,{text:"\\(G\\)"})," of transformations."),"\n",i.createElement(t.h3,{id:"extending-convolution-to-group-domains",style:{position:"relative"}},i.createElement(t.a,{href:"#extending-convolution-to-group-domains","aria-label":"extending convolution to group domains permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Extending convolution to group domains"),"\n",i.createElement(t.p,null,"The fundamental insight behind group convolution is that we can consider a function ",i.createElement(s.A,{text:"\\(f\\)"})," defined on some domain (which might be ",i.createElement(s.A,{text:"\\(\\mathbb{R}^n\\)"})," or a discrete grid of pixels), and a kernel defined ",i.createElement(t.em,null,"not only")," as a function of a spatial shift but also of an element in a group ",i.createElement(s.A,{text:"\\(G\\)"}),". For example, in group equivariant CNNs for 2D images with rotational symmetry, the group might be the discrete rotations by multiples of 90 degrees, or even the continuous group ",i.createElement(s.A,{text:"\\(\\mathrm{SO}(2)\\)"}),"."),"\n",i.createElement(t.h4,{id:"lifting-convolution-from--to-",style:{position:"relative"}},i.createElement(t.a,{href:"#lifting-convolution-from--to-","aria-label":"lifting convolution from  to  permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Lifting convolution: from ",i.createElement(s.A,{text:"\\(\\mathbb{R}^n\\)"})," to ",i.createElement(s.A,{text:"\\(\\mathbb{R}^n \\rtimes G\\)"})),"\n",i.createElement(t.p,null,"The first step in building a group-equivariant layer is often referred to as the ",i.createElement(o.A,null,"lifting convolution"),". Instead of mapping a function ",i.createElement(s.A,{text:"\\(f: \\mathbb{R}^n \\to \\mathbb{R}\\)"})," to another function ",i.createElement(s.A,{text:"\\(\\mathbb{R}^n \\to \\mathbb{R}\\)"}),", we map it to a function on the group domain, ",i.createElement(s.A,{text:"\\(F: G \\to \\mathbb{R}\\)"}),"."),"\n",i.createElement(t.p,null,"For a simple example, if the group is rotations of the plane by angles ",i.createElement(s.A,{text:"\\(\\theta\\)"}),", a point in ",i.createElement(s.A,{text:"\\(G\\)"})," can be parameterized by ",i.createElement(s.A,{text:"\\(\\theta\\)"}),". Then, the lifted feature map ",i.createElement(s.A,{text:"\\(F(\\theta)\\)"})," might capture how well the kernel aligns with the input when the kernel is rotated by ",i.createElement(s.A,{text:"\\(\\theta\\)"}),". The concept extends to ",i.createElement(s.A,{text:"\\(\\mathbb{R}^n \\rtimes G\\)"})," (the semidirect product space representing both translations and the group transformation) in more advanced contexts, but to keep things accessible, let's remain with a simpler conceptual explanation. The idea is that we're building a function that is aware of the transformations in ",i.createElement(s.A,{text:"\\(G\\)"}),"."),"\n",i.createElement(t.h4,{id:"regular-group-convolutions-and-kernel-parameterization-over-",style:{position:"relative"}},i.createElement(t.a,{href:"#regular-group-convolutions-and-kernel-parameterization-over-","aria-label":"regular group convolutions and kernel parameterization over  permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Regular group convolutions and kernel parameterization over ",i.createElement(s.A,{text:"\\(G\\)"})),"\n",i.createElement(t.p,null,"Once we have a feature map on the group domain, we can define a convolution that includes summation (or integration) over the group. For a discrete group ",i.createElement(s.A,{text:"\\(G\\)"})," with ",i.createElement(s.A,{text:"\\(|G|\\)"})," elements, we might define:"),"\n",i.createElement(s.A,{text:"\\[\n(F * \\Psi)(g) = \\sum_{h \\in G} F(h) \\, \\Psi(h^{-1}g),\n\\]"}),"\n",i.createElement(t.p,null,"where ",i.createElement(s.A,{text:"\\(\\Psi\\)"})," is a kernel also defined on the group. This is reminiscent of the standard convolution formula, except that the summation runs over ",i.createElement(s.A,{text:"\\(G\\)"})," instead of over the spatial domain. The group element ",i.createElement(s.A,{text:"\\((h^{-1} g)\\)"})," is analogous to the shift ",i.createElement(s.A,{text:"\\((x-y)\\)"})," in the classical formula."),"\n",i.createElement(t.p,null,"In a 2D setting, if ",i.createElement(s.A,{text:"\\(G\\)"})," is the group of rotations by multiples of 90 degrees (i.e., a cyclic group ",i.createElement(s.A,{text:"\\(C_4\\)"}),"), then each group element corresponds to a discrete rotation: ",i.createElement(s.A,{text:"\\(0^\\circ\\)"}),", ",i.createElement(s.A,{text:"\\(90^\\circ\\)"}),", ",i.createElement(s.A,{text:"\\(180^\\circ\\)"}),", ",i.createElement(s.A,{text:"\\(270^\\circ\\)"}),". The kernel ",i.createElement(s.A,{text:"\\(\\Psi\\)"})," would have separate parameters for each possible rotation. Then the group convolution sums over those rotations in a manner consistent with the group structure."),"\n",i.createElement(t.h4,{id:"equivariance-to-larger-transformations",style:{position:"relative"}},i.createElement(t.a,{href:"#equivariance-to-larger-transformations","aria-label":"equivariance to larger transformations permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Equivariance to larger transformations"),"\n",i.createElement(t.p,null,"By expanding the notion of convolution from translations to other groups, we can achieve equivariance to more transformations. For instance, using the dihedral group ",i.createElement(s.A,{text:"\\(D_n\\)"})," gives us both rotations and reflections by discrete angles. Using ",i.createElement(s.A,{text:"\\(\\mathrm{SO}(2)\\)"})," or ",i.createElement(s.A,{text:"\\(\\mathrm{SO}(3)\\)"})," can give us continuous rotational equivariance in 2D or 3D. There are also expansions to scaling, dilation, or affine transformations, each of which can form its own group."),"\n",i.createElement(t.h4,{id:"other-groups-of-interest-scaling-dilation-etc",style:{position:"relative"}},i.createElement(t.a,{href:"#other-groups-of-interest-scaling-dilation-etc","aria-label":"other groups of interest scaling dilation etc permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Other groups of interest (scaling, dilation, etc.)"),"\n",i.createElement(t.p,null,"Beyond rotational groups, scaling transformations also appear in image and signal processing tasks. For instance, if an object's scale is changed, we might want to preserve certain properties. One can also incorporate color transformations if they correspond to group actions in color space. The possibilities are extensive, but always bounded by whether the transformations you're modeling truly form a mathematical group (i.e., closure, identity, inverses, associativity)."),"\n",i.createElement(t.h3,{id:"implementing-group-equivariant-networks",style:{position:"relative"}},i.createElement(t.a,{href:"#implementing-group-equivariant-networks","aria-label":"implementing group equivariant networks permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Implementing group equivariant networks"),"\n",i.createElement(t.p,null,"Implementing group equivariant networks can be done with modern deep learning frameworks (PyTorch, TensorFlow, JAX). The challenge is to handle transformations in a manner consistent with the group, especially for continuous transformations like rotations in 2D or 3D."),"\n",i.createElement(t.ul,null,"\n",i.createElement(t.li,null,"\n",i.createElement(t.p,null,i.createElement(t.strong,null,"PyTorch primitives for group convolution"),': Some specialized libraries (e.g., the "e2cnn" library by Weiler & Cesa, or the "escnn" library) provide group convolution layers out of the box. Otherwise, you might implement them manually by building the transformation grids and performing interpolation (as I will discuss in the next sections).'),"\n"),"\n",i.createElement(t.li,null,"\n",i.createElement(t.p,null,i.createElement(t.strong,null,"Interpolation-based kernels (bilinear, trilinear sampling)"),": When applying transformations (like rotating a kernel in the continuous plane), you often have to sample pixel values in between the discrete grid points. Bilinear, bicubic, or trilinear interpolation can be used. This introduces approximation error but is often necessary if you want your transformation to handle sub-pixel rotations or scaling."),"\n"),"\n",i.createElement(t.li,null,"\n",i.createElement(t.p,null,i.createElement(t.strong,null,"Practical pitfalls"),": Real data is typically discrete, so continuous transformations must be discretized. You must handle boundary conditions (what happens when you rotate an image so that some part is out of the original field-of-view?), and you must decide how large or fine your sampling of the group will be (e.g., how many discrete angles do we approximate ",i.createElement(s.A,{text:"\\(\\mathrm{SO}(2)\\)"})," with?). These choices can affect both performance and computational cost."),"\n"),"\n"),"\n",i.createElement(t.p,null,"With this conceptual scaffold in place, I want to illustrate a more step-by-step approach to building group equivariant modules, from defining a group's representation to constructing group convolution kernels, culminating in a final architecture."),"\n",i.createElement(t.h2,{id:"from-theory-to-code-a-step-by-step-example",style:{position:"relative"}},i.createElement(t.a,{href:"#from-theory-to-code-a-step-by-step-example","aria-label":"from theory to code a step by step example permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"From theory to code: a step-by-step example"),"\n",i.createElement(t.p,null,"I will show a hypothetical scenario where we aim for rotational equivariance to a discrete group of four 2D rotations (i.e., ",i.createElement(s.A,{text:"\\(C_4\\)"}),", the cyclic group of order 4). This means we want the network to handle images so that rotating the input by ",i.createElement(s.A,{text:"\\(0^\\circ\\)"}),", ",i.createElement(s.A,{text:"\\(90^\\circ\\)"}),", ",i.createElement(s.A,{text:"\\(180^\\circ\\)"}),", or ",i.createElement(s.A,{text:"\\(270^\\circ\\)"})," in the pixel plane will lead to correspondingly rotated feature maps."),"\n",i.createElement(t.h3,{id:"defining-the-group-and-its-representation",style:{position:"relative"}},i.createElement(t.a,{href:"#defining-the-group-and-its-representation","aria-label":"defining the group and its representation permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Defining the group and its representation"),"\n",i.createElement(t.p,null,"Let's define a small Python class to represent the group ",i.createElement(s.A,{text:"\\(C_4\\)"}),". Of course, many libraries exist to handle group logic, but let's see how to do it by hand:"),"\n",i.createElement(l.A,{text:"\nimport math\nimport torch\n\nclass Rot90Group:\n    def __init__(self):\n        # We can label the elements of C4 as 0, 1, 2, 3,\n        # representing rotations by 0, 90, 180, 270 degrees\n        self.elements = [0, 1, 2, 3]\n        # Precompute rotation matrices (2x2) or transformations if needed\n        self.matrices = [\n            torch.tensor([[1.0, 0.0], [0.0, 1.0]]),  # 0° rotation\n            torch.tensor([[0.0, -1.0], [1.0,  0.0]]), # 90°\n            torch.tensor([[-1.0,  0.0], [0.0, -1.0]]),# 180°\n            torch.tensor([[0.0,  1.0], [-1.0, 0.0]])  # 270°\n        ]\n    \n    def identity(self):\n        # Identity element is rotation by 0 degrees\n        return 0\n    \n    def inverse(self, g):\n        # For rotation by 90°, the inverse is rotation by 270° and so on\n        return (-g) % 4\n    \n    def product(self, g1, g2):\n        # Summation mod 4\n        return (g1 + g2) % 4\n    \n    def matrix_representation(self, g):\n        # Return the precomputed 2x2 matrix for group element g\n        return self.matrices[g]\n"}),"\n",i.createElement(t.p,null,"Above, I label the four group elements as integers 0, 1, 2, 3, corresponding to rotating the plane by ",i.createElement(s.A,{text:"\\(\\{0^\\circ, 90^\\circ, 180^\\circ, 270^\\circ\\}\\)"}),". The ",i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">matrix_representation()</code>'}})," method is giving me a ",i.createElement(s.A,{text:"\\(2 \\times 2\\)"})," matrix that rotates 2D coordinates accordingly. This is obviously a very small, discrete group, but it exemplifies how I can systematically define group operations (product, inverse, identity) and representations (matrices)."),"\n",i.createElement(t.h3,{id:"building-the-kernel-grids",style:{position:"relative"}},i.createElement(t.a,{href:"#building-the-kernel-grids","aria-label":"building the kernel grids permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Building the kernel grids"),"\n",i.createElement(t.p,null,'To perform group convolution in a typical deep learning framework, you usually need to define how the kernel will be "applied" for each group element. This often involves building sampling grids that transform the kernel or the input feature map. Here is a sketch of how one might create rotation grids to transform the input via bilinear interpolation:'),"\n",i.createElement(l.A,{text:"\nimport torch.nn.functional as F\n\ndef rotate_feature_map(x, angle_index, group: Rot90Group):\n    # x has shape (batch, channels, height, width)\n    # We want to rotate the entire feature map by the group element angle.\n    # For discrete 90° rotations, we can do a special re-indexing or use an affine grid.\n\n    B, C, H, W = x.shape\n    # Convert angle_index to a 2x3 affine matrix for the grid\n    # We know group.matrices[angle_index] is 2x2\n    A = group.matrix_representation(angle_index).clone()\n    \n    # Construct an affine transform matrix (2x3) for use with F.grid_sample\n    affine_matrix = torch.zeros((B, 2, 3), device=x.device)\n    for i in range(B):\n        affine_matrix[i, :2, :2] = A\n    \n    # Create a normalized grid for the desired transform\n    # F.grid_sample expects normalized coordinates in [-1,1]\n    theta = affine_matrix\n    grid = F.affine_grid(theta, [B, C, H, W], align_corners=False)\n\n    # Sample\n    x_rot = F.grid_sample(x, grid, mode='bilinear', padding_mode='zeros', align_corners=False)\n    return x_rot\n"}),"\n",i.createElement(t.p,null,"This snippet (though simplified) demonstrates how you can rotate a feature map in PyTorch using ",i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">F.grid_sample</code>'}}),", constructing the appropriate affine transformation matrix. For a discrete group with small cardinality like ",i.createElement(s.A,{text:"\\(C_4\\)"}),", you might do this in a for-loop, or precompute certain transformations. If your group is continuous (",i.createElement(s.A,{text:"\\(\\mathrm{SO}(2)\\)"}),", for instance), you would do something conceptually similar, but with angles in a continuous range and more complicated sampling logic."),"\n",i.createElement(t.h3,{id:"constructing-group-convolution-layers",style:{position:"relative"}},i.createElement(t.a,{href:"#constructing-group-convolution-layers","aria-label":"constructing group convolution layers permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Constructing group convolution layers"),"\n",i.createElement(t.p,null,"To build a group convolution layer, we typically do something akin to a standard convolution, but we sum over all group elements. Let me illustrate the concept of a ",i.createElement(o.A,null,"lifting convolution")," that takes a standard input image and produces a feature map with an extra dimension for the group:"),"\n",i.createElement(l.A,{text:"\nclass LiftingConv2D(torch.nn.Module):\n    def __init__(self, in_channels, out_channels, group: Rot90Group, kernel_size=3, padding=1):\n        super().__init__()\n        self.in_channels = in_channels\n        self.out_channels = out_channels\n        self.group = group\n        self.kernel_size = kernel_size\n        self.padding = padding\n        # The weight shape: (out_channels, in_channels, kernel_size, kernel_size)\n        # We'll replicate this for each group element or handle group dimension differently\n        # For simplicity, let's define one kernel for each group element\n        # so we have out_channels * |G| sets of parameters\n        self.weights = torch.nn.Parameter(torch.randn(\n            out_channels * len(group.elements), in_channels, kernel_size, kernel_size\n        ))\n        self.bias = torch.nn.Parameter(torch.zeros(out_channels * len(group.elements)))\n        \n    def forward(self, x):\n        # x: (B, in_channels, H, W)\n        B, C, H, W = x.shape\n        # We'll produce a feature map of shape (B, out_channels * |G|, H, W)\n        # Each group element has a corresponding slice of the kernel, convolving with x\n        conv_out = []\n        \n        # Standard 2D convolution for each group element's kernel\n        # but in a real group conv, we might want to rotate x or the kernel\n        # Here, I'll do the naive approach: rotate x, then apply the \"base\" kernel\n        for i, g_elem in enumerate(self.group.elements):\n            # rotate the input by group element\n            x_rot = rotate_feature_map(x, g_elem, self.group)\n            # index the correct slice of the kernel\n            w_g = self.weights[i*self.out_channels:(i+1)*self.out_channels, :, :, :]\n            b_g = self.bias[i*self.out_channels:(i+1)*self.out_channels]\n            # perform a standard conv\n            out_g = torch.nn.functional.conv2d(x_rot, w_g, b_g, padding=self.padding)\n            conv_out.append(out_g)\n        \n        # Stack along the channel dimension\n        return torch.cat(conv_out, dim=1)\n"}),"\n",i.createElement(t.p,null,"While this is a rough, simplified demonstration, it illustrates the principle: for each group element, either rotate the input or rotate the kernel (the two approaches are mathematically equivalent, though some prefer to fix the input and rotate the kernel). Then apply a standard convolution for each transformation, and combine them into a single feature map that now has a dimension for the group (in this example, I appended that dimension to the channels, but you could store it separately)."),"\n",i.createElement(t.p,null,"Once you have the feature map that includes all group elements, you can apply subsequent layers that treat these channels as separate transformations, or you can do further group convolutions that mix these transformations in a structured way."),"\n",i.createElement(t.h3,{id:"projection-for-invariance",style:{position:"relative"}},i.createElement(t.a,{href:"#projection-for-invariance","aria-label":"projection for invariance permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Projection for invariance"),"\n",i.createElement(t.p,null,"In many classification tasks, we eventually want a globally invariant result (e.g., a label that does not change if we rotate the input). To build invariance from an equivariant representation, we often do a ",i.createElement(o.A,null,"projection")," or pooling over the group dimension. Common operations include summation, average pooling, or max pooling across the group dimension:"),"\n",i.createElement(s.A,{text:"\\(F_{\\mathrm{inv}}(x) = \\sum_{g\\in G} F(g, x)\\)"}),"\n",i.createElement(t.p,null,"or"),"\n",i.createElement(t.p,null,i.createElement(s.A,{text:"\\(F_{\\mathrm{inv}}(x) = \\max_{g \\in G} F(g, x)\\)"}),"."),"\n",i.createElement(t.p,null,"This effectively discards the knowledge of which transformation is present, producing an output that is stable (invariant) with respect to that transformation."),"\n",i.createElement(t.h2,{id:"equivariance-invariance-and-projection-layers",style:{position:"relative"}},i.createElement(t.a,{href:"#equivariance-invariance-and-projection-layers","aria-label":"equivariance invariance and projection layers permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Equivariance, invariance, and projection layers"),"\n",i.createElement(t.h3,{id:"key-operations-for-building-invariance",style:{position:"relative"}},i.createElement(t.a,{href:"#key-operations-for-building-invariance","aria-label":"key operations for building invariance permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Key operations for building invariance"),"\n",i.createElement(t.p,null,"The typical pipeline in a group-equivariant architecture is:"),"\n",i.createElement(t.ol,null,"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Lift")," the input to a feature map with a group dimension."),"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Apply group convolutions")," that preserve equivariance."),"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"(Optionally) reduce")," the group dimension by pooling if we want invariance."),"\n"),"\n",i.createElement(t.p,null,"When you do a summation or average over the group dimension, you get a feature map that no longer depends on which element of the group is present in the input, thus achieving invariance. Alternatively, you might keep the group dimension for multiple layers and only project to an invariant feature at the end of the network."),"\n",i.createElement(t.h3,{id:"projection-layer-implementation-details",style:{position:"relative"}},i.createElement(t.a,{href:"#projection-layer-implementation-details","aria-label":"projection layer implementation details permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Projection layer implementation details"),"\n",i.createElement(t.p,null,"In code, a simple projection might look like:"),"\n",i.createElement(l.A,{text:"\ndef group_pool(feature_map, group_size):\n    # feature_map shape: (B, C * group_size, H, W)\n    # we want to pool across the group dimension\n    B, CG, H, W = feature_map.shape\n    C = CG // group_size\n    # reshape and reduce\n    feature_map = feature_map.view(B, C, group_size, H, W)\n    # e.g. take the mean\n    feature_map = feature_map.mean(dim=2)  # average over group dimension\n    return feature_map\n"}),"\n",i.createElement(t.p,null,"This snippet just reshapes the channel dimension (which contains the group dimension in our example) and takes the mean across that group dimension. You could do a sum, a max, or something else that fits your design. If your group dimension is explicitly stored as a separate tensor dimension, you would sum or average over that dimension instead."),"\n",i.createElement(t.h2,{id:"introduction-to-steerable-convolutional-networks",style:{position:"relative"}},i.createElement(t.a,{href:"#introduction-to-steerable-convolutional-networks","aria-label":"introduction to steerable convolutional networks permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Introduction to steerable convolutional networks"),"\n",i.createElement(t.p,null,"Steerable CNNs can be viewed as a continuous generalization or a frequency-based approach to building equivariant architectures. Instead of having separate filters for each discrete group element, one can parameterize filters as linear combinations of basis functions that transform in a predictable (steerable) way under the group action. This approach is especially valuable for continuous groups like ",i.createElement(s.A,{text:"\\(\\mathrm{SO}(2)\\)"})," or ",i.createElement(s.A,{text:"\\(\\mathrm{SO}(3)\\)"})," or for large discrete groups where enumerating all group elements is impractical."),"\n",i.createElement(t.h3,{id:"harmonic-analysis-viewpoint",style:{position:"relative"}},i.createElement(t.a,{href:"#harmonic-analysis-viewpoint","aria-label":"harmonic analysis viewpoint permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Harmonic analysis viewpoint"),"\n",i.createElement(t.p,null,"Steerable CNNs are heavily connected to the theory of non-commutative harmonic analysis. The overarching idea:"),"\n",i.createElement(t.ul,null,"\n",i.createElement(t.li,null,'Decompose signals in terms of irreducible representations or some suitable "basis" that are ',i.createElement(o.A,null,"eigenfunctions")," of the group action."),"\n",i.createElement(t.li,null,"Convolution in the spatial domain corresponds to multiplication in the Fourier (or harmonic) domain."),"\n",i.createElement(t.li,null,"By constraining filters to transform in specific ways under group actions, we get ",i.createElement(o.A,null,"steerability"),"."),"\n"),"\n",i.createElement(t.p,null,"For a continuous group like ",i.createElement(s.A,{text:"\\(\\mathrm{SO}(2)\\)"})," (rotations in the plane), the group is abelian, and the irreps are given by complex exponentials ",i.createElement(s.A,{text:"\\(e^{i m \\theta}\\)"})," for integer ",i.createElement(s.A,{text:"\\(m\\)"}),". This means we can expand a kernel in a Fourier series. Then rotating that kernel in the spatial domain corresponds to multiplying by a phase factor ",i.createElement(s.A,{text:"\\(e^{i m \\alpha}\\)"})," in the Fourier domain."),"\n",i.createElement(t.h3,{id:"steerable-feature-fields",style:{position:"relative"}},i.createElement(t.a,{href:"#steerable-feature-fields","aria-label":"steerable feature fields permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Steerable feature fields"),"\n",i.createElement(t.p,null,"Instead of explicitly representing each angle of rotation, one can store the kernel in terms of a finite number of ",i.createElement(o.A,null,"Fourier modes")," up to some band-limit ",i.createElement(s.A,{text:"\\(M\\)"}),". This is called a band-limited representation. For instance, a filter might look like:"),"\n",i.createElement(s.A,{text:"\\[\nk(r, \\phi) = \\sum_{m=-M}^{M} k_m(r) e^{i m \\phi}\n\\]"}),"\n",i.createElement(t.p,null,"where ",i.createElement(s.A,{text:"\\((r, \\phi)\\)"})," are polar coordinates, and ",i.createElement(s.A,{text:"\\(k_m(r)\\)"})," are radial profiles. Under a rotation by ",i.createElement(s.A,{text:"\\(\\alpha\\)"}),", ",i.createElement(s.A,{text:"\\(\\phi\\mapsto \\phi + \\alpha\\)"}),", which multiplies each mode by ",i.createElement(s.A,{text:"\\(e^{i m \\alpha}\\)"}),'. This means we can easily "steer" the filter by adjusting the phases.'),"\n",i.createElement(t.p,null,"Advantages: for certain tasks, this approach can produce exact or near-exact rotational equivariance, especially if the sampling is done carefully. It can also reduce the number of parameters if the group is large, as you do not need to store a separate filter for each discrete rotation."),"\n",i.createElement(t.h3,{id:"steerable-cnn-architecture",style:{position:"relative"}},i.createElement(t.a,{href:"#steerable-cnn-architecture","aria-label":"steerable cnn architecture permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Steerable CNN architecture"),"\n",i.createElement(t.p,null,"A typical steerable CNN pipeline might:"),"\n",i.createElement(t.ol,null,"\n",i.createElement(t.li,null,'Represent the input or the intermediate feature maps in terms of a "type" — basically specifying how they transform under the group.'),"\n",i.createElement(t.li,null,"Constrain the convolution kernels to respect the group structure, often by enforcing certain relationships among the kernel's Fourier coefficients."),"\n",i.createElement(t.li,null,"Combine these constraints with standard neural network building blocks like ReLUs or batch normalization. Non-linearities in the steerable domain require specialized design, such as complex non-linearities or polynomial expansions that preserve equivariance (since naive ReLU might break equivariance in the Fourier domain)."),"\n"),"\n",i.createElement(t.p,null,'There is an extensive literature on this topic. Key references include "Worrall and gang, CVPR 2017" on "Harmonic Networks" and "Weiler & Cesa, NeurIPS 2019" on "General E(2)-Equivariant Steerable CNNs".'),"\n",i.createElement(t.h2,{id:"real-world-applications-and-experiments",style:{position:"relative"}},i.createElement(t.a,{href:"#real-world-applications-and-experiments","aria-label":"real world applications and experiments permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Real-world applications and experiments"),"\n",i.createElement(t.h3,{id:"rotated-mnist-case-study",style:{position:"relative"}},i.createElement(t.a,{href:"#rotated-mnist-case-study","aria-label":"rotated mnist case study permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Rotated MNIST case study"),"\n",i.createElement(t.p,null,"A classic dataset to illustrate the benefits of group-equivariant networks is ",i.createElement(o.A,null,"Rotated MNIST"),", where each digit image is randomly rotated by some angle. A standard CNN trained on non-rotated MNIST might perform poorly on these images if it has never seen such rotations in training. Even if you augment the data by random rotations, you might still need a large dataset to fully capture the continuum of angles. A group-equivariant CNN, by construction, can significantly outperform a baseline CNN because it inherently encodes the rotational symmetry of the problem."),"\n",i.createElement(t.p,null,"Key metrics often reported are:"),"\n",i.createElement(t.ul,null,"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Accuracy on rotated test sets"),": This indicates how robust the model is to rotations."),"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Equivariance error"),": A specialized metric that measures how well the model's output transforms when the input is transformed, i.e., ",i.createElement(s.A,{text:"\\( \\| f(g \\cdot x) - \\rho(g) f(x) \\|\\)"}),". If the model is perfectly equivariant, that error is zero."),"\n"),"\n",i.createElement(t.h3,{id:"other-benchmark-datasets",style:{position:"relative"}},i.createElement(t.a,{href:"#other-benchmark-datasets","aria-label":"other benchmark datasets permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Other benchmark datasets"),"\n",i.createElement(t.ul,null,"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"CIFAR variants"),": Sometimes people construct artificially rotated or flipped versions of CIFAR-10 or CIFAR-100 to test rotational/ reflectional equivariance."),"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Medical imaging (MRI, CT) with rotational symmetries"),": In certain medical imaging contexts, especially those involving circular cross-sections or radial symmetry, a group-equivariant approach may yield better detection of anomalies."),"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"3D shapes, point-cloud tasks")," (ModelNet, ShapeNet): Particularly relevant for 3D data where orientation might be arbitrary. If your model is not equivariant to 3D rotations, you might require a massive training set to see all possible orientations."),"\n"),"\n",i.createElement(t.h3,{id:"performance-metrics-and-results",style:{position:"relative"}},i.createElement(t.a,{href:"#performance-metrics-and-results","aria-label":"performance metrics and results permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Performance metrics and results"),"\n",i.createElement(t.p,null,"When adopting group-equivariant networks, you typically look at:"),"\n",i.createElement(t.ol,null,"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Equivariance error"),": A direct measure of how well the model enforces the desired symmetry."),"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Accuracy"),": On standard or synthetic test sets."),"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Data efficiency"),": Does the model achieve better results with fewer training examples, due to built-in symmetry constraints?"),"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Computational overhead"),": Expanding the group dimension can inflate the memory usage and the computational cost. Some architectures handle this more efficiently than others, depending on whether the group is discrete, continuous, small, or large."),"\n"),"\n",i.createElement(t.h2,{id:"implementation-insights-and-code-snippets",style:{position:"relative"}},i.createElement(t.a,{href:"#implementation-insights-and-code-snippets","aria-label":"implementation insights and code snippets permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Implementation insights and code snippets"),"\n",i.createElement(t.h3,{id:"practical-considerations",style:{position:"relative"}},i.createElement(t.a,{href:"#practical-considerations","aria-label":"practical considerations permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Practical considerations"),"\n",i.createElement(t.p,null,"Let's underscore some practical details that frequently arise:"),"\n",i.createElement(t.ul,null,"\n",i.createElement(t.li,null,"\n",i.createElement(t.p,null,i.createElement(t.strong,null,"Discrete vs. continuous groups")," (",i.createElement(s.A,{text:"\\(C_n\\)"})," vs. ",i.createElement(s.A,{text:"\\(\\mathrm{SO}(2)\\)"}),"):"),"\n",i.createElement(t.ul,null,"\n",i.createElement(t.li,null,"A small discrete group like ",i.createElement(s.A,{text:"\\(C_4\\)"})," or ",i.createElement(s.A,{text:"\\(D_8\\)"})," is fairly easy to handle by enumerating transformations explicitly."),"\n",i.createElement(t.li,null,"A continuous group means we must approximate it, perhaps by sampling angles at a certain resolution or by using a steerable basis."),"\n"),"\n"),"\n",i.createElement(t.li,null,"\n",i.createElement(t.p,null,i.createElement(t.strong,null,"Interpolation artifacts, aliasing"),": Whenever you rotate or scale an image on a discrete pixel grid, some aliasing is inevitable, especially if the transformations are large. This might degrade equivariance in practice."),"\n"),"\n",i.createElement(t.li,null,"\n",i.createElement(t.p,null,i.createElement(t.strong,null,"Batch normalization vs. group normalization"),": In group convolutional networks, the shape of the feature tensor changes (now we have a group dimension). Sometimes group normalization or specialized normalization layers are used to handle these extra dimensions consistently."),"\n"),"\n",i.createElement(t.li,null,"\n",i.createElement(t.p,null,i.createElement(t.strong,null,"GPU usage and memory costs"),": If you inflate your feature maps with a large group dimension (like 16 or 32 transformations), you might quickly escalate memory usage. This is a key reason to prefer more compact approaches like steerable networks or Fourier-based methods if the group is large."),"\n"),"\n"),"\n",i.createElement(t.h3,{id:"debugging-common-issues",style:{position:"relative"}},i.createElement(t.a,{href:"#debugging-common-issues","aria-label":"debugging common issues permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Debugging common issues"),"\n",i.createElement(t.ol,null,"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Ensuring consistent group action across layers"),": You must check that the same definition of rotation or transformation is used everywhere. A mismatch can break equivariance."),"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Shape mismatches in group convolution"),": Because we add an extra dimension for the group, or we fold it into channels, it's easy to accidentally mismatch shapes."),"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Verifying equivariance numerically"),": A good strategy is to feed a sample input, transform it with a group element, run it through the network, and compare it with the network's output on the untransformed input, transformed appropriately at the output. If the difference is large, your architecture might not be implemented correctly."),"\n"),"\n",i.createElement(t.h2,{id:"broader-directions-and-open-research",style:{position:"relative"}},i.createElement(t.a,{href:"#broader-directions-and-open-research","aria-label":"broader directions and open research permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Broader directions and open research"),"\n",i.createElement(t.h3,{id:"expanding-to-larger-groups",style:{position:"relative"}},i.createElement(t.a,{href:"#expanding-to-larger-groups","aria-label":"expanding to larger groups permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Expanding to larger groups"),"\n",i.createElement(t.p,null,"In many real applications, the relevant group might be more complicated than the small sets of transformations we have been discussing. Examples:"),"\n",i.createElement(t.ul,null,"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Affine groups"),": Combining rotations, translations, and scale changes."),"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Dilation groups"),": Zoom in/out transformations."),"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Lie groups"),": Continuous groups that are not necessarily commutative (e.g., ",i.createElement(s.A,{text:"\\(\\mathrm{SE}(3)\\)"}),", the group of rigid motions in 3D space)."),"\n"),"\n",i.createElement(t.p,null,"Building exact equivariant networks for large or continuous groups can be computationally expensive, so approximate or partial methods are still an active area of research."),"\n",i.createElement(t.h3,{id:"deep-learning-beyond-euclidean-domains",style:{position:"relative"}},i.createElement(t.a,{href:"#deep-learning-beyond-euclidean-domains","aria-label":"deep learning beyond euclidean domains permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Deep learning beyond Euclidean domains"),"\n",i.createElement(t.p,null,"Group theory has strong synergy with:"),"\n",i.createElement(t.ul,null,"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Manifold learning"),": If your data lies on a curved manifold (like a sphere or a more abstract shape), you might want to incorporate the manifold's symmetries."),"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Graph neural networks (GNNs)"),": Permutation invariance or equivariance is essential in GNNs, and certain subgroups of node permutations might be relevant in tasks like chemistry or social network analysis."),"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Geometric deep learning"),": A broader umbrella term that covers the generalization of deep neural network models to non-Euclidean data (graphs, manifolds, point clouds) using group-theoretic principles."),"\n"),"\n",i.createElement(t.h3,{id:"theoretical-considerations-and-challenges",style:{position:"relative"}},i.createElement(t.a,{href:"#theoretical-considerations-and-challenges","aria-label":"theoretical considerations and challenges permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Theoretical considerations and challenges"),"\n",i.createElement(t.ul,null,"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Exact vs. approximate equivariance"),": On a discrete pixel grid, true continuous rotational equivariance can't be perfect. There's always a discretization error."),"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Trade-offs"),": The more transformations you want to be equivariant to, the bigger (and more complex) your network might become."),"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Potential directions"),": Efforts to incorporate ",i.createElement(o.A,null,"E(n)-equivariant networks")," (where ",i.createElement(s.A,{text:"\\(n\\)"})," is the dimension of Euclidean space) have seen success, especially in 3D geometry tasks. Gauge equivariance and other advanced forms of geometric constraints are also being explored."),"\n"),"\n",i.createElement(t.h2,{id:"conclusion-and-future-outlook",style:{position:"relative"}},i.createElement(t.a,{href:"#conclusion-and-future-outlook","aria-label":"conclusion and future outlook permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Conclusion and future outlook"),"\n",i.createElement(t.p,null,"I have now walked through many of the deeper concepts relating group theory to machine learning, specifically focusing on group convolution, the extension of classical convolution to broader transformation sets, and the notion of steerable CNNs that rely on harmonic or Fourier-based expansions of filters. Below is a concise bullet point summary of the big ideas:"),"\n",i.createElement(t.ul,null,"\n",i.createElement(t.li,null,"The classical convolution in CNNs is deeply connected to translational symmetry."),"\n",i.createElement(t.li,null,"We can generalize convolution to other groups (rotations, reflections, scaling, etc.) to build networks that are equivariant to these transformations."),"\n",i.createElement(t.li,null,"This generalization often involves new data structures for feature maps and new parameter-sharing schemes for kernels."),"\n",i.createElement(t.li,null,"By projecting over the group dimension (via summation, average, or max), we can achieve invariance for classification tasks."),"\n",i.createElement(t.li,null,"Steerable CNNs extend group equivariance to continuous transformations, using representation theory and harmonic analysis."),"\n",i.createElement(t.li,null,"Applications of group-equivariant or steerable CNNs are compelling in areas where data transformations are well described by a group, like rotated MNIST, 3D point clouds, or medical imaging with rotational symmetries."),"\n",i.createElement(t.li,null,"There is still much open research on how to scale to large or complicated groups (like ",i.createElement(s.A,{text:"\\(\\mathrm{SE}(3)\\)"}),", ",i.createElement(s.A,{text:"\\(\\mathrm{SE}(n)\\)"}),", and beyond) and how to ensure computational efficiency without losing the benefits of symmetry-based constraints."),"\n"),"\n",i.createElement(t.p,null,"If you are motivated to explore further, I would recommend digging into the following references:"),"\n",i.createElement(t.ul,null,"\n",i.createElement(t.li,null,'"Cohen & Welling, ICML 2016" on "Group Equivariant Convolutional Networks".'),"\n",i.createElement(t.li,null,'"Worrall and gang, CVPR 2017" on "Harmonic Networks".'),"\n",i.createElement(t.li,null,'"Weiler & Cesa, NeurIPS 2019" on "General E(2)-Equivariant Steerable CNNs".'),"\n"),"\n",i.createElement(t.p,null,"All of these dive deeper into the mathematics of representation theory, discrete vs. continuous groups, and how to implement these methods in code. They also provide comprehensive experiments showing how group-equivariant and steerable networks can outperform conventional CNNs on tasks with known symmetries."),"\n",i.createElement(t.p,null,'Where to go next? If you need more group theory background, you can consult our continuing coverage in this advanced course or standard references in representation theory. For immediate practical experimentation, you can try out specialized PyTorch libraries for equivariant neural networks (e.g., "e2cnn"), or attempt your own custom code for small groups like ',i.createElement(s.A,{text:"\\(C_4\\)"}),". I believe that the synergy between group-theoretic insight and modern deep learning architectures will only keep growing, leading to improved generalization and data efficiency in a wide variety of tasks."),"\n",i.createElement(t.p,null,'This concludes "Group theory for ML, pt. 2". The next step might be to experiment with actual group convolution implementations in your own codebase and test them on a dataset like rotated MNIST or your domain-specific data that exhibits known symmetries. Good luck, and keep exploring!'))}var m=function(e){void 0===e&&(e={});const{wrapper:t}=Object.assign({},(0,r.RP)(),e.components);return t?i.createElement(t,e,i.createElement(c,e)):c(e)},h=n(36710),u=n(58481),p=n.n(u),d=n(36310),g=n(87245),f=n(27042),v=n(59849),y=n(5591),E=n(61122),b=n(9219),w=n(33203),x=n(95751),S=n(94328),k=n(80791),_=n(78137);const H=e=>{let{toc:t}=e;if(!t||!t.items)return null;return i.createElement("nav",{className:k.R},i.createElement("ul",null,t.items.map(((e,t)=>i.createElement("li",{key:t},i.createElement("a",{href:e.url,onClick:t=>((e,t)=>{e.preventDefault();const n=t.replace("#",""),a=document.getElementById(n);a&&a.scrollIntoView({behavior:"smooth",block:"start"})})(t,e.url)},e.title),e.items&&i.createElement(H,{toc:{items:e.items}}))))))};function A(e){let{data:{mdx:t,allMdx:o,allPostImages:l},children:s}=e;const{frontmatter:c,body:m,tableOfContents:h}=t,u=c.index,v=c.slug.split("/")[1],k=o.nodes.filter((e=>e.frontmatter.slug.includes(`/${v}/`))).sort(((e,t)=>e.frontmatter.index-t.frontmatter.index)),A=k.findIndex((e=>e.frontmatter.index===u)),C=k[A+1],T=k[A-1],z=c.slug.replace(/\/$/,""),I=/[^/]*$/.exec(z)[0],M=`posts/${v}/content/${I}/`,{0:N,1:V}=(0,i.useState)(c.flagWideLayoutByDefault),{0:q,1:L}=(0,i.useState)(!1);var B;(0,i.useEffect)((()=>{L(!0);const e=setTimeout((()=>L(!1)),340);return()=>clearTimeout(e)}),[N]),"adventures"===v?B=b.cb:"research"===v?B=b.Qh:"thoughts"===v&&(B=b.T6);const G=p()(m).replace(/import .*? from .*?;/g,"").replace(/<.*?>/g,"").replace(/\{\/\*[\s\S]*?\*\/\}/g,"").trim().split(/\s+/).length,P=function(e){if(e<=10)return"~10 min";if(e<=20)return"~20 min";if(e<=30)return"~30 min";if(e<=40)return"~40 min";if(e<=50)return"~50 min";if(e<=60)return"~1 h";const t=Math.floor(e/60),n=e%60;return n<=30?`~${t}${n>0?".5":""} h`:`~${t+1} h`}(Math.ceil(G/B)+(c.extraReadTimeMin||0)),F=[{flag:c.flagDraft,component:()=>Promise.all([n.e(3231),n.e(8809)]).then(n.bind(n,28809))},{flag:c.flagMindfuckery,component:()=>Promise.all([n.e(3231),n.e(2471)]).then(n.bind(n,67709))},{flag:c.flagRewrite,component:()=>Promise.all([n.e(3231),n.e(6764)]).then(n.bind(n,62002))},{flag:c.flagOffensive,component:()=>Promise.all([n.e(3231),n.e(2443)]).then(n.bind(n,17681))},{flag:c.flagProfane,component:()=>Promise.all([n.e(3231),n.e(8048)]).then(n.bind(n,53286))},{flag:c.flagMultilingual,component:()=>Promise.all([n.e(3231),n.e(4069)]).then(n.bind(n,78831))},{flag:c.flagUnreliably,component:()=>Promise.all([n.e(3231),n.e(3417)]).then(n.bind(n,8179))},{flag:c.flagPolitical,component:()=>Promise.all([n.e(3231),n.e(5195)]).then(n.bind(n,30433))},{flag:c.flagCognitohazard,component:()=>Promise.all([n.e(3231),n.e(3175)]).then(n.bind(n,8413))},{flag:c.flagHidden,component:()=>Promise.all([n.e(3231),n.e(9556)]).then(n.bind(n,14794))}],{0:D,1:O}=(0,i.useState)([]);return(0,i.useEffect)((()=>{F.forEach((e=>{let{flag:t,component:n}=e;t&&n().then((e=>{O((t=>[].concat((0,a.A)(t),[e.default])))}))}))}),[]),i.createElement(f.P.div,{initial:{opacity:0},animate:{opacity:1},exit:{opacity:0},transition:{duration:.15}},i.createElement(y.A,{postNumber:c.index,date:c.date,updated:c.updated,readTime:P,difficulty:c.difficultyLevel,title:c.title,desc:c.desc,banner:c.banner,section:v,postKey:I,isMindfuckery:c.flagMindfuckery,mainTag:c.mainTag}),i.createElement("div",{style:{display:"flex",justifyContent:"flex-end",flexWrap:"wrap",maxWidth:"75%",marginLeft:"auto",paddingRight:"1vw",marginTop:"-6vh",marginBottom:"4vh"}},c.otherTags.map(((e,t)=>i.createElement("span",{key:t,className:`noselect ${_.MW}`,style:{margin:"0 5px 5px 0"}},e)))),i.createElement("div",{class:"postBody"},i.createElement(H,{toc:h})),i.createElement("br"),i.createElement("div",{style:{margin:"0 10% -2vh 30%",textAlign:"right"}},i.createElement(f.P.button,{class:"noselect",className:S.pb,id:S.xG,onClick:()=>{V(!N)},whileTap:{scale:.93}},i.createElement(f.P.div,{className:x.DJ,key:N,initial:{opacity:0},animate:{opacity:1},exit:{opacity:0},transition:{duration:.3,ease:"easeInOut"}},N?"Switch to default layout":"Switch to wide layout"))),i.createElement("br"),i.createElement("div",{class:"postBody",style:{margin:N?"0 -14%":"",maxWidth:N?"200%":"",transition:"margin 1s ease, max-width 1s ease, padding 1s ease"}},i.createElement("div",{className:`${S.P_} ${q?S.Xn:S.qG}`},D.map(((e,t)=>i.createElement(e,{key:t}))),c.indexCourse?i.createElement(w.A,{index:c.indexCourse,category:c.courseCategoryName}):"",i.createElement(d.Z.Provider,{value:{images:l.nodes,basePath:M.replace(/\/$/,"")+"/"}},i.createElement(r.xA,{components:{Image:g.A}},s)))),i.createElement(E.A,{nextPost:C,lastPost:T,keyCurrent:I,section:v}))}function C(e){return i.createElement(A,e,i.createElement(m,e))}function T(e){var t,n,a,r,o;let{data:l}=e;const{frontmatter:s}=l.mdx,c=s.titleSEO||s.title,m=s.titleOG||c,u=s.titleTwitter||c,p=s.descSEO||s.desc,d=s.descOG||p,g=s.descTwitter||p,f=s.schemaType||"BlogPosting",y=s.keywordsSEO,E=s.date,b=s.updated||E,w=s.imageOG||(null===(t=s.banner)||void 0===t||null===(n=t.childImageSharp)||void 0===n||null===(a=n.gatsbyImageData)||void 0===a||null===(r=a.images)||void 0===r||null===(o=r.fallback)||void 0===o?void 0:o.src),x=s.imageAltOG||d,S=s.imageTwitter||w,k=s.imageAltTwitter||g,_=s.canonicalURL,H=s.flagHidden||!1,A=s.mainTag||"Posts",C=s.slug.split("/")[1]||"posts",{siteUrl:T}=(0,h.Q)(),z={"@context":"https://schema.org","@type":"BreadcrumbList",itemListElement:[{"@type":"ListItem",position:1,name:"Home",item:T},{"@type":"ListItem",position:2,name:A,item:`${T}/${s.slug.split("/")[1]}`},{"@type":"ListItem",position:3,name:c,item:`${T}${s.slug}`}]};return i.createElement(v.A,{title:c+" - avrtt.blog",titleOG:m,titleTwitter:u,description:p,descriptionOG:d,descriptionTwitter:g,schemaType:f,keywords:y,datePublished:E,dateModified:b,imageOG:w,imageAltOG:x,imageTwitter:S,imageAltTwitter:k,canonicalUrl:_,flagHidden:H,mainTag:A,section:C,type:"article"},i.createElement("script",{type:"application/ld+json"},JSON.stringify(z)))}},96098:function(e,t,n){var a=n(96540),r=n(7978);t.A=e=>{let{text:t}=e;return a.createElement(r.A,null,t)}}}]);
//# sourceMappingURL=component---src-templates-post-js-content-file-path-src-pages-posts-research-group-theory-for-ml-2-mdx-b1d68a904b7a6433b5d8.js.map