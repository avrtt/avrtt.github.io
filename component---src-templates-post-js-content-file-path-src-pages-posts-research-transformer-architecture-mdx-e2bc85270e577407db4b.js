"use strict";(self.webpackChunkavrtt_blog=self.webpackChunkavrtt_blog||[]).push([[1223],{64960:function(e,t,n){n.r(t),n.d(t,{Head:function(){return z},PostTemplate:function(){return T},default:function(){return H}});var a=n(54506),r=n(28453),o=n(96540),i=(n(16886),n(46295)),l=n(96098);function s(e){const t=Object.assign({p:"p",h3:"h3",a:"a",span:"span",ul:"ul",li:"li",strong:"strong",ol:"ol",h2:"h2",hr:"hr"},(0,r.RP)(),e.components);return o.createElement(o.Fragment,null,"\n",o.createElement("br"),"\n","\n","\n",o.createElement(t.p,null,"The world of natural language processing has undergone a dramatic revolution in the last decade or so, evolving from the relatively rigid, rule-based systems of previous generations to the flexible deep learning approaches that dominate modern research and industry use cases. Historically, early computational linguistics involved carefully hand-crafted grammar rules and lexicons. These systems, although groundbreaking for their time, often struggled to handle the complexities and nuances of human language. Ambiguities in syntax, polysemy (the phenomenon of words having multiple meanings), and ever-growing linguistic variation meant that rigid rules frequently broke down in real-world situations."),"\n",o.createElement(t.p,null,"As the field moved forward, the introduction of more data-driven methods — particularly statistical modeling — helped pave the way toward machine learning-based approaches. Recurrent neural networks (RNNs), especially those equipped with gating mechanisms such as LSTM networks (Hochreiter and Schmidhuber, 1997) and GRU networks (Cho and gang, 2014), enabled practitioners to capture contextual dependencies in sequences more effectively than ever before. Soon, these recurrent architectures dominated many NLP tasks, including language modeling, machine translation, speech recognition, and text classification. However, their inherently sequential nature meant that training on long sequences was difficult to parallelize, and capturing extremely long-range dependencies often proved challenging despite gating mechanisms."),"\n",o.createElement(t.p,null,"In parallel, convolutional neural networks (CNNs) — originally designed for image processing tasks — were adapted by some researchers for NLP. Convolutional architectures promised greater parallelization than RNNs and improved gradient flow due to their hierarchical structure (Gehring and gang, 2017). Yet, they often struggled with capturing global dependencies and required carefully chosen kernel sizes or dilations to expand the receptive field."),"\n",o.createElement(t.p,null,'The introduction of attention mechanisms (Bahdanau and gang, 2015; Luong and gang, 2015) was a key milestone that changed the game dramatically. Initially introduced to help RNN-based encoder-decoder systems "focus" on the most relevant parts of an input sequence when generating each output token, attention quickly proved useful beyond just alignment in machine translation. By weighting different components of the input sequence according to their relevance to a particular query, attention mechanisms gave models a way to handle long-range dependencies more directly than purely sequential approaches.'),"\n",o.createElement(t.p,null,"From here, the stage was set for the next big leap: the Transformer model. Introduced by Vaswani and gang (2017), the Transformer architecture demonstrated that recurrence and convolution could be replaced entirely with a structure built around attention, thereby unlocking unprecedented levels of parallelization and performance in sequence-to-sequence tasks. The Transformer quickly became the backbone for breakthroughs in language modeling, machine translation, text summarization, and even tasks beyond NLP, including image classification (Dosovitskiy and gang, 2021) and speech processing. Today, the Transformer stands as arguably the most influential architecture in modern machine learning, underpinning large language models such as GPT, BERT, T5, and numerous domain-specific variants."),"\n",o.createElement(t.h3,{id:"background-and-motivation",style:{position:"relative"}},o.createElement(t.a,{href:"#background-and-motivation","aria-label":"background and motivation permalink",className:"anchor before"},o.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Background and motivation"),"\n",o.createElement(t.p,null,"To fully appreciate the motivation behind the Transformer architecture, one must understand the limitations of prior methods:"),"\n",o.createElement(t.ul,null,"\n",o.createElement(t.li,null,o.createElement(t.strong,null,"Rule-based systems"),": Rigid, hand-crafted logic. Their ability to model language deeply was restricted by the complexity of language itself. Scaling up to new languages, dialects, or domains required extensive human labor."),"\n",o.createElement(t.li,null,o.createElement(t.strong,null,"RNN-based models"),": Although effective at capturing sequential patterns, RNNs process tokens one step at a time, creating computational bottlenecks for long sequences. Training can be slow, and capturing very long-range dependencies becomes progressively more difficult."),"\n",o.createElement(t.li,null,o.createElement(t.strong,null,"CNN-based approaches"),": More parallelizable than RNNs but still not as straightforward to capture non-local dependencies. Additional complexities arise when deciding kernel sizes or dilation schedules to ensure broad context coverage."),"\n"),"\n",o.createElement(t.p,null,'Attention provided a mechanism that addresses these issues by allowing the model to learn where to "look" in the entire input sequence when generating each output element. This idea set the foundation for further exploration that led to the notion of discarding recurrence entirely — and thus emerged the Transformer.'),"\n",o.createElement(t.h3,{id:"importance-in-modern-machine-learning",style:{position:"relative"}},o.createElement(t.a,{href:"#importance-in-modern-machine-learning","aria-label":"importance in modern machine learning permalink",className:"anchor before"},o.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Importance in modern machine learning"),"\n",o.createElement(t.p,null,"Transformers have proven their worth across a wide array of tasks:"),"\n",o.createElement(t.ul,null,"\n",o.createElement(t.li,null,o.createElement(t.strong,null,"Natural language processing"),": State-of-the-art in machine translation, text summarization, question answering, sentiment analysis, and text generation."),"\n",o.createElement(t.li,null,o.createElement(t.strong,null,"Computer vision"),": The Vision Transformer (ViT) treats image patches like tokens, achieving competitive or superior results on image classification tasks."),"\n",o.createElement(t.li,null,o.createElement(t.strong,null,"Speech processing"),": Speech recognition and speech-to-text systems can leverage self-attention for improved context modeling."),"\n",o.createElement(t.li,null,o.createElement(t.strong,null,"Multimodal learning"),": Transformers excel in bridging multiple data modalities (text, images, audio) within a single architecture."),"\n"),"\n",o.createElement(t.p,null,"By removing the need for strict sequential computation, Transformers can train more efficiently on modern hardware accelerators, taking advantage of large parallelizable matrix multiplications. When combined with massive pretraining datasets, Transformers form the basis for large foundation models that can be adapted or fine-tuned for a wide range of specialized tasks."),"\n",o.createElement(t.h3,{id:"scope-of-this-article",style:{position:"relative"}},o.createElement(t.a,{href:"#scope-of-this-article","aria-label":"scope of this article permalink",className:"anchor before"},o.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Scope of this article"),"\n",o.createElement(t.p,null,"This article provides a deep yet accessible introduction to the Transformer architecture. I will discuss:"),"\n",o.createElement(t.ol,null,"\n",o.createElement(t.li,null,"The conceptual underpinnings that distinguish Transformers from previous sequence models."),"\n",o.createElement(t.li,null,"An overview of the architecture's core design, including both the encoder and decoder modules."),"\n",o.createElement(t.li,null,"Practical considerations such as the strengths and limitations of a fully attention-based system."),"\n",o.createElement(t.li,null,"Common variants of the Transformer that use only the encoder or only the decoder."),"\n",o.createElement(t.li,null,"Detailed breakdown of each component (embedding layers, positional encoding, multi-head attention, feed-forward layers, etc.) in both the encoder and decoder."),"\n"),"\n",o.createElement(t.p,null,"While I touch on essential concepts such as the parallelization advantage, memory usage, and how models like BERT and GPT relate to the Transformer blueprint, some of the more intricate mathematical details of the attention mechanism, alternative attention forms, scaling strategies, and advanced training setups will be explored in a follow-up article. By the end of this piece, you should have a firm grasp of the motivation, high-level structure, and internal flow of information within Transformer models."),"\n",o.createElement(t.h3,{id:"historical-context-in-nlp",style:{position:"relative"}},o.createElement(t.a,{href:"#historical-context-in-nlp","aria-label":"historical context in nlp permalink",className:"anchor before"},o.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Historical context in NLP"),"\n",o.createElement(t.p,null,o.createElement(t.strong,null,"Sequence-to-sequence learning"),": The notion of mapping an input sequence to an output sequence using neural networks gained momentum around 2014 (Sutskever and gang, 2014). Encoder-decoder structures employing LSTM or GRU layers became the standard approach for tasks like machine translation."),"\n",o.createElement(t.p,null,o.createElement(t.strong,null,"Introduction of attention"),': In 2015, Bahdanau and gang proposed an attention layer that improved sequence-to-sequence models by enabling the model to "attend" to relevant input tokens at each decoding step. This overcame some of the bottlenecks in purely recurrent models that rely on a single context vector.'),"\n",o.createElement(t.p,null,o.createElement(t.strong,null,"Attention everywhere"),": Subsequent research integrated attention more deeply into the network architecture itself, culminating in the fully attention-based Transformer (Vaswani and gang, 2017). This design drastically reduced the path length between any two tokens in the input or output, yielding better performance and faster training."),"\n",o.createElement(t.p,null,"These historical steps underscore how the field arrived at an architecture that dispenses with recurrence, allowing parallel processing of sequence elements via a global attention mechanism. In modern practice, Transformers define the cutting edge of NLP, forming the underlying blueprint for a diverse array of large-scale models."),"\n",o.createElement(t.h2,{id:"core-concepts",style:{position:"relative"}},o.createElement(t.a,{href:"#core-concepts","aria-label":"core concepts permalink",className:"anchor before"},o.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Core concepts"),"\n",o.createElement(t.h3,{id:"sequence-modeling-vs-transformer-based-modeling",style:{position:"relative"}},o.createElement(t.a,{href:"#sequence-modeling-vs-transformer-based-modeling","aria-label":"sequence modeling vs transformer based modeling permalink",className:"anchor before"},o.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Sequence modeling vs. transformer-based modeling"),"\n",o.createElement(t.p,null,"Traditional sequence modeling techniques (e.g., RNNs) process elements in a strict order: the hidden state at timestep ",o.createElement(l.A,{text:"\\(t\\)"})," depends on the hidden state at timestep ",o.createElement(l.A,{text:"\\(t-1\\)"})," (and so on), creating a chain-like dependency structure. This sequential nature means it can be difficult to parallelize computations across long sequences during training. Although methods like truncated backpropagation through time and specialized architectures (like bidirectional LSTMs) help alleviate some of these issues, the fundamental problem remains."),"\n",o.createElement(t.p,null,"In contrast, a Transformer-based approach processes an entire sequence in parallel by employing self-attention. Given an input sequence of length ",o.createElement(l.A,{text:"\\(n\\)"}),", each token can directly attend to any other token. The notion of positional encoding (discussed later) is introduced to keep track of the sequence order. This parallelism dramatically speeds up training: rather than waiting for hidden states from previous positions, the model updates all token representations at once."),"\n",o.createElement(t.h3,{id:"attention-mechanisms-and-their-role",style:{position:"relative"}},o.createElement(t.a,{href:"#attention-mechanisms-and-their-role","aria-label":"attention mechanisms and their role permalink",className:"anchor before"},o.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Attention mechanisms and their role"),"\n",o.createElement(t.p,null,'Attention mechanisms can be thought of as a strategy to compute weighted averages over a set of "value" vectors, where the weights are determined by how closely a "query" vector matches a set of "key" vectors. Formally, one can define a scaled dot-product attention function as:'),"\n",o.createElement(l.A,{text:"\\[\n\\text{Attention}(Q, K, V) = \\text{softmax}\\Bigl(\\frac{Q K^\\top}{\\sqrt{d_k}}\\Bigr) V,\n\\]"}),"\n",o.createElement(t.p,null,"where ",o.createElement(l.A,{text:"\\(Q\\)"})," (queries), ",o.createElement(l.A,{text:"\\(K\\)"})," (keys), and ",o.createElement(l.A,{text:"\\(V\\)"})," (values) often come from transformations of the same input sequence (self-attention) or from different sequences (encoder-decoder attention). The factor ",o.createElement(l.A,{text:"\\(\\sqrt{d_k}\\)"})," (where ",o.createElement(l.A,{text:"\\(d_k\\)"})," is the dimensionality of the keys) prevents overly large dot-product values that can destabilize gradients."),"\n",o.createElement(t.p,null,"In the Transformer, the self-attention layer allows each position in the sequence to gather information from every other position, effectively modeling relationships across the entire span without relying on potentially distant hidden states."),"\n",o.createElement(t.h3,{id:"key-differences-from-recurrent-and-convolutional-models",style:{position:"relative"}},o.createElement(t.a,{href:"#key-differences-from-recurrent-and-convolutional-models","aria-label":"key differences from recurrent and convolutional models permalink",className:"anchor before"},o.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Key differences from recurrent and convolutional models"),"\n",o.createElement(t.ol,null,"\n",o.createElement(t.li,null,"\n",o.createElement(t.p,null,o.createElement(t.strong,null,"Elimination of recurrence"),": Transformers do not process tokens in a fixed sequential manner. This means the path length between two positions in the sequence is significantly reduced, often resulting in better gradient flow and the ability to capture very long-range dependencies."),"\n"),"\n",o.createElement(t.li,null,"\n",o.createElement(t.p,null,o.createElement(t.strong,null,"No convolutions"),": Instead of applying kernels locally (as in CNNs), Transformers attend to tokens across the entire sequence. Convolution-like behaviors can sometimes emerge in certain attention patterns, but it is not a structural requirement."),"\n"),"\n",o.createElement(t.li,null,"\n",o.createElement(t.p,null,o.createElement(t.strong,null,"Reliance on positional information"),": Since the Transformer processes all tokens in parallel, it needs an explicit way of encoding token positions. This is handled by positional encoding or learned position embeddings."),"\n"),"\n",o.createElement(t.li,null,"\n",o.createElement(t.p,null,o.createElement(t.strong,null,"Multi-head design"),': Each attention layer is split into multiple heads. Each head can "focus" on different parts of the sequence, capturing diverse patterns.'),"\n"),"\n"),"\n",o.createElement(t.h3,{id:"parallelization-advantages",style:{position:"relative"}},o.createElement(t.a,{href:"#parallelization-advantages","aria-label":"parallelization advantages permalink",className:"anchor before"},o.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Parallelization advantages"),"\n",o.createElement(t.p,null,"Because each token can be processed independently (apart from the attention mechanism's matrix multiplications, which themselves are highly parallelizable on GPUs and TPUs), Transformers make much more efficient use of modern hardware. Training times for large datasets can be drastically reduced compared to RNNs, as we are no longer forced to wait on hidden state computations for each position in the input. This is why Transformers have become so central to large-scale language models that require tens or hundreds of billions of parameters."),"\n",o.createElement(t.h2,{id:"transformer-architecture-overview",style:{position:"relative"}},o.createElement(t.a,{href:"#transformer-architecture-overview","aria-label":"transformer architecture overview permalink",className:"anchor before"},o.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Transformer architecture overview"),"\n",o.createElement(t.h3,{id:"encoder-decoder-structure",style:{position:"relative"}},o.createElement(t.a,{href:"#encoder-decoder-structure","aria-label":"encoder decoder structure permalink",className:"anchor before"},o.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Encoder-decoder structure"),"\n",o.createElement(t.p,null,"A standard Transformer (Vaswani and gang, 2017) includes two main blocks:"),"\n",o.createElement(t.ul,null,"\n",o.createElement(t.li,null,o.createElement(t.strong,null,"Encoder"),": Processes the input sequence and produces a sequence of hidden representations (of the same length as the input)."),"\n",o.createElement(t.li,null,o.createElement(t.strong,null,"Decoder"),": Generates output tokens one by one (for sequence generation tasks), attending to both its own previously generated tokens (through masked self-attention) and the encoder outputs (through encoder-decoder attention)."),"\n"),"\n",o.createElement(t.p,null,"Conceptually, this mirrors earlier sequence-to-sequence models that used RNN encoders and decoders. The significant difference is that both the encoder and decoder are built entirely around self-attention (plus feed-forward layers), rather than RNN or CNN cells."),"\n",o.createElement(t.h3,{id:"flow-of-information",style:{position:"relative"}},o.createElement(t.a,{href:"#flow-of-information","aria-label":"flow of information permalink",className:"anchor before"},o.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Flow of information"),"\n",o.createElement(t.p,null,"Consider a machine translation task from a source language to a target language:"),"\n",o.createElement(t.ol,null,"\n",o.createElement(t.li,null,"\n",o.createElement(t.p,null,o.createElement(t.strong,null,"Encoder"),": The input tokens are converted to embeddings and enriched with positional encodings so the model knows the order of words. Then, each encoder layer refines these embeddings by applying self-attention (where every token can attend to every other token in the input) and feed-forward transformations."),"\n"),"\n",o.createElement(t.li,null,"\n",o.createElement(t.p,null,o.createElement(t.strong,null,"Passing to decoder"),": The output of the final encoder layer is a set of contextual embeddings representing each position in the source sentence. These embeddings are fed into the decoder."),"\n"),"\n",o.createElement(t.li,null,"\n",o.createElement(t.p,null,o.createElement(t.strong,null,"Decoder"),': For each token in the target sequence as it\'s being generated, the decoder first applies a masked self-attention mechanism (so the model cannot "peek" at future tokens). It then attends to the encoder outputs, finally passing the result through a feed-forward layer and output logits.'),"\n"),"\n"),"\n",o.createElement(t.p,null,"This pipeline handles sequence-to-sequence transformations comprehensively. In other tasks, like classification, one might use only the encoder portion (e.g., BERT). In language modeling, one might rely only on the decoder (e.g., GPT)."),"\n",o.createElement(t.h3,{id:"advantages-and-limitations",style:{position:"relative"}},o.createElement(t.a,{href:"#advantages-and-limitations","aria-label":"advantages and limitations permalink",className:"anchor before"},o.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Advantages and limitations"),"\n",o.createElement(t.p,null,o.createElement(t.strong,null,"Advantages"),":"),"\n",o.createElement(t.ul,null,"\n",o.createElement(t.li,null,"Massively parallelizable computations lead to faster training."),"\n",o.createElement(t.li,null,"Global attention allows the model to learn relationships between distant tokens more easily than RNN-based methods."),"\n",o.createElement(t.li,null,"Excellent performance on a broad range of tasks, from language modeling to speech recognition to computer vision."),"\n",o.createElement(t.li,null,"Modular design (stacking self-attention layers) makes them relatively simple to scale up."),"\n"),"\n",o.createElement(t.p,null,o.createElement(t.strong,null,"Limitations"),":"),"\n",o.createElement(t.ul,null,"\n",o.createElement(t.li,null,o.createElement(t.strong,null,"Memory usage"),": Storing attention scores for very long sequences ",o.createElement(l.A,{text:"\\((n \\times n)\\)"})," can be prohibitive in terms of memory. This becomes a limiting factor for extremely long inputs."),"\n",o.createElement(t.li,null,o.createElement(t.strong,null,"Computational overhead"),": Although highly parallelizable, the attention mechanism can be expensive for large ",o.createElement(l.A,{text:"\\(n\\)"}),". Researchers have responded with variants like sparse attention or linear attention to mitigate these costs."),"\n",o.createElement(t.li,null,o.createElement(t.strong,null,"Requires large datasets"),": Transformers often demonstrate their full potential when trained on massive corpora. Smaller datasets may lead to overfitting unless carefully regularized or fine-tuned from a pretrained model."),"\n"),"\n",o.createElement(t.h3,{id:"variants-of-encoder-decoder-approaches",style:{position:"relative"}},o.createElement(t.a,{href:"#variants-of-encoder-decoder-approaches","aria-label":"variants of encoder decoder approaches permalink",className:"anchor before"},o.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Variants of encoder-decoder approaches"),"\n",o.createElement(t.ul,null,"\n",o.createElement(t.li,null,o.createElement(t.strong,null,"Encoder-only"),": For tasks like classification or regression on a single sequence (e.g., BERT), you only need an encoder stack. After passing an input sequence through the stack, you might take the final hidden state (or a special token like [CLS]) to perform classification."),"\n",o.createElement(t.li,null,o.createElement(t.strong,null,"Decoder-only"),": For language modeling or generative tasks (e.g., GPT), a decoder stack suffices. It produces one token at a time, conditioning on previously generated tokens."),"\n",o.createElement(t.li,null,o.createElement(t.strong,null,"Full encoder-decoder"),": For sequence-to-sequence tasks like translation, summarization, or question answering, the original Transformer blueprint with both encoder and decoder modules is commonly used."),"\n"),"\n",o.createElement(t.h2,{id:"encoder-module",style:{position:"relative"}},o.createElement(t.a,{href:"#encoder-module","aria-label":"encoder module permalink",className:"anchor before"},o.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Encoder module"),"\n",o.createElement(t.h3,{id:"embedding-layer",style:{position:"relative"}},o.createElement(t.a,{href:"#embedding-layer","aria-label":"embedding layer permalink",className:"anchor before"},o.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Embedding layer"),"\n",o.createElement(t.p,null,"When dealing with textual data, one typically starts with a vocabulary of subword tokens. Each token is assigned an index in an embedding matrix of dimension ",o.createElement(l.A,{text:"\\((\\text{vocab_size} \\times d_\\text{model})\\)"}),". The model dimension ",o.createElement(l.A,{text:"\\(d_\\text{model}\\)"})," (often 512 or 768, though many higher or lower values are used in practice) determines how large each token's representation is. For example, if you have a vocabulary of 30,000 tokens and ",o.createElement(l.A,{text:"\\(d_\\text{model} = 512\\)"}),", your embedding matrix is ",o.createElement(l.A,{text:"\\(30,000 \\times 512\\)"}),". When you feed a batch of token indices into the embedding layer, it returns a 3D tensor: ",o.createElement(l.A,{text:"\\((\\text{batch_size}, \\text{sequence_length}, d_\\text{model})\\)"}),"."),"\n",o.createElement(t.h3,{id:"positional-encoding",style:{position:"relative"}},o.createElement(t.a,{href:"#positional-encoding","aria-label":"positional encoding permalink",className:"anchor before"},o.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Positional encoding"),"\n",o.createElement(t.p,null,"Since Transformers do not inherently track sequence order by processing tokens sequentially, they need a way to inject positional information. The original paper by Vaswani and gang (2017) proposed using sinusoidal position encoding, which can be summarized as follows for each token position ",o.createElement(l.A,{text:"\\(pos\\)"}),":"),"\n",o.createElement(l.A,{text:"\\[\nPE_{(pos, 2i)} = \\sin\\Bigl(\\frac{pos}{10000^{2i / d_{\\text{model}}}}\\Bigr),\n\\]"}),"\n",o.createElement(l.A,{text:"\\[\nPE_{(pos, 2i+1)} = \\cos\\Bigl(\\frac{pos}{10000^{2i / d_{\\text{model}}}}\\Bigr),\n\\]"}),"\n",o.createElement(t.p,null,"where ",o.createElement(l.A,{text:"\\(pos\\)"})," is the token index in the sequence (0, 1, 2, …), and ",o.createElement(l.A,{text:"\\(i\\)"})," is the dimension index within the embedding. These periodic functions allow the model to extrapolate to positions greater than those in the training data, and they encode positions in a way that preserves relative distance information through linear transformations."),"\n",o.createElement(t.p,null,"An alternative is to learn positional embeddings. In that scenario, you simply have another trainable embedding matrix for positions — similar to token embeddings. Some newer models employ more sophisticated strategies, such as ",o.createElement(t.strong,null,"relative position embeddings")," or ",o.createElement(t.strong,null,"rotary embeddings")," (Su and gang, 2021), to better handle long sequences and to model positions in a relative rather than absolute sense."),"\n",o.createElement(t.h3,{id:"multi-head-self-attention-mechanism",style:{position:"relative"}},o.createElement(t.a,{href:"#multi-head-self-attention-mechanism","aria-label":"multi head self attention mechanism permalink",className:"anchor before"},o.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Multi-head self-attention mechanism"),"\n",o.createElement(t.p,null,"A hallmark of the Transformer is ",o.createElement(t.strong,null,"multi-head self-attention"),". Instead of applying a single attention function, the model splits its representation into multiple heads (each of dimension ",o.createElement(l.A,{text:"\\(d_\\text{model}/h\\)"}),", where ",o.createElement(l.A,{text:"\\(h\\)"})," is the number of heads) and applies the attention function in parallel. The outputs of these heads are then concatenated and linearly transformed. For each head ",o.createElement(l.A,{text:"\\(j\\)"}),", the transformations can be expressed as:"),"\n",o.createElement(l.A,{text:"\\[\nQ_j = X W_j^Q, \\quad K_j = X W_j^K, \\quad V_j = X W_j^V,\n\\]"}),"\n",o.createElement(t.p,null,"where ",o.createElement(l.A,{text:"\\(X\\)"})," is the input sequence's representation (dimensions ",o.createElement(l.A,{text:"\\((\\text{batch_size}, \\text{sequence_length}, d_\\text{model})\\)"}),"), and ",o.createElement(l.A,{text:"\\(W_j^Q, W_j^K, W_j^V\\)"})," are parameter matrices specific to that head. Each head then computes its own self-attention:"),"\n",o.createElement(l.A,{text:"\\( \\text{head}_j = \\text{Attention}(Q_j, K_j, V_j) \\)"}),"\n",o.createElement(t.p,null,"Finally, the heads are concatenated and transformed by a matrix ",o.createElement(l.A,{text:"\\(W^O\\)"}),":"),"\n",o.createElement(l.A,{text:"\\( \\text{MultiHead}(X) = [\\text{head}_1, \\ldots, \\text{head}_h] W^O. \\)"}),"\n",o.createElement(t.p,null,"Breaking down the representation into multiple attention heads allows the model to capture a variety of interactions in parallel — perhaps one head focuses on syntactic relationships while another focuses on semantic ones."),"\n",o.createElement(t.h3,{id:"feed-forward-network",style:{position:"relative"}},o.createElement(t.a,{href:"#feed-forward-network","aria-label":"feed forward network permalink",className:"anchor before"},o.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Feed-forward network"),"\n",o.createElement(t.p,null,"Each encoder layer also includes a position-wise feed-forward network that processes each token representation independently. The typical form is:"),"\n",o.createElement(l.A,{text:"\\[\n\\text{FFN}(x) = \\max(0, xW_1 + b_1)W_2 + b_2,\n\\]"}),"\n",o.createElement(t.p,null,"where ",o.createElement(l.A,{text:"\\(W_1\\)"})," and ",o.createElement(l.A,{text:"\\(W_2\\)"})," are learnable parameter matrices (dimensions ",o.createElement(l.A,{text:"\\((d_\\text{model}, d_{ff})\\)"})," and ",o.createElement(l.A,{text:"\\((d_{ff}, d_\\text{model})\\)"}),", respectively), and ",o.createElement(l.A,{text:"\\(b_1, b_2\\)"})," are biases. The intermediate dimension ",o.createElement(l.A,{text:"\\(d_{ff}\\)"})," (often 2,048 in the original Transformer) is larger than ",o.createElement(l.A,{text:"\\(d_\\text{model}\\)"}),", allowing the network to learn more complex transformations. The activation function is typically ReLU or GELU in many modern variants."),"\n",o.createElement(t.h3,{id:"residual-connections-and-layer-normalization",style:{position:"relative"}},o.createElement(t.a,{href:"#residual-connections-and-layer-normalization","aria-label":"residual connections and layer normalization permalink",className:"anchor before"},o.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Residual connections and layer normalization"),"\n",o.createElement(t.p,null,"To facilitate signal propagation and stable gradient flow, Transformers use residual connections around both the multi-head attention sub-layer and the feed-forward sub-layer. After each sub-layer, a layer normalization step (Ba and gang, 2016) is applied. Symbolically:"),"\n",o.createElement(l.A,{text:"\\( y = \\text{LayerNorm}(x + \\text{Sublayer}(x)), \\)"}),"\n",o.createElement(t.p,null,"where ",o.createElement(l.A,{text:"\\(\\text{Sublayer}(x)\\)"})," could be the self-attention block or the feed-forward block. This structure, repeated ",o.createElement(l.A,{text:"\\(N\\)"})," times, forms the encoder stack. The original Transformer used ",o.createElement(l.A,{text:"\\(N=6\\)"})," layers, though many modern architectures use more."),"\n",o.createElement(t.h3,{id:"alternative-positional-encoding-methods",style:{position:"relative"}},o.createElement(t.a,{href:"#alternative-positional-encoding-methods","aria-label":"alternative positional encoding methods permalink",className:"anchor before"},o.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Alternative positional encoding methods"),"\n",o.createElement(t.p,null,"While the original sinusoidal approach and learned position embeddings remain popular, a variety of newer approaches exist:"),"\n",o.createElement(t.ul,null,"\n",o.createElement(t.li,null,o.createElement(t.strong,null,"Relative position embeddings")," (Shaw and gang, 2018): Instead of encoding absolute positions, it encodes the relative distance between tokens, which can be more flexible in certain tasks."),"\n",o.createElement(t.li,null,o.createElement(t.strong,null,"Rotary position embeddings")," (Su and gang, 2021): A method that multiplies token embeddings by a rotation matrix to incorporate positional information directly into the attention score. Known to scale well to longer sequences."),"\n"),"\n",o.createElement(t.h2,{id:"decoder-module",style:{position:"relative"}},o.createElement(t.a,{href:"#decoder-module","aria-label":"decoder module permalink",className:"anchor before"},o.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Decoder module"),"\n",o.createElement(t.h3,{id:"masked-multi-head-self-attention",style:{position:"relative"}},o.createElement(t.a,{href:"#masked-multi-head-self-attention","aria-label":"masked multi head self attention permalink",className:"anchor before"},o.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Masked multi-head self-attention"),"\n",o.createElement(t.p,null,"For tasks like language modeling or machine translation, the decoder must generate the output sequence token-by-token, without peeking at future tokens. A ",o.createElement(t.strong,null,"causal")," or ",o.createElement(t.strong,null,"masked")," self-attention mechanism ensures that the attention for position ",o.createElement(l.A,{text:"\\(t\\)"})," only depends on positions ",o.createElement(l.A,{text:"\\(\\leq t\\)"}),". Concretely, a triangular or future-masking matrix is applied to the attention logits so that no attention weight is computed for positions beyond ",o.createElement(l.A,{text:"\\(t\\)"}),". This is critical for autoregressive text generation, where the model must produce tokens in a left-to-right manner."),"\n",o.createElement(t.h3,{id:"encoder-decoder-attention",style:{position:"relative"}},o.createElement(t.a,{href:"#encoder-decoder-attention","aria-label":"encoder decoder attention permalink",className:"anchor before"},o.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Encoder-decoder attention"),"\n",o.createElement(t.p,null,"In addition to the masked self-attention, the decoder includes a cross-attention sub-layer that attends to the encoder outputs. This is also a multi-head attention mechanism, but here the queries come from the decoder's hidden states, while the keys and values come from the encoder outputs. This structure allows the decoder to reference and distill information from the entire input sequence, which has already been transformed by the encoder."),"\n",o.createElement(t.p,null,"Formally:"),"\n",o.createElement(l.A,{text:"\\( Q = H_{\\text{decoder}}, \\quad K = H_{\\text{encoder}}, \\quad V = H_{\\text{encoder}}. \\)"}),"\n",o.createElement(t.p,null,"Where ",o.createElement(l.A,{text:"\\(H_{\\text{decoder}}\\)"})," and ",o.createElement(l.A,{text:"\\(H_{\\text{encoder}}\\)"})," are the hidden representations (or states) coming from the respective modules."),"\n",o.createElement(t.h3,{id:"feed-forward-network-in-the-decoder",style:{position:"relative"}},o.createElement(t.a,{href:"#feed-forward-network-in-the-decoder","aria-label":"feed forward network in the decoder permalink",className:"anchor before"},o.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Feed-forward network in the decoder"),"\n",o.createElement(t.p,null,"Like the encoder, each decoder layer contains its own position-wise feed-forward network. The structure typically mirrors that of the encoder. Each token's representation is passed through a set of linear transformations and non-linearities. The hyperparameters (like ",o.createElement(l.A,{text:"\\(d_{ff}\\)"}),") often match those in the encoder, though one can modify them as needed."),"\n",o.createElement(t.h3,{id:"residual-connections-and-layer-normalization-1",style:{position:"relative"}},o.createElement(t.a,{href:"#residual-connections-and-layer-normalization-1","aria-label":"residual connections and layer normalization 1 permalink",className:"anchor before"},o.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Residual connections and layer normalization"),"\n",o.createElement(t.p,null,"The decoder also has residual connections around each sub-layer and performs layer normalization in the same manner as the encoder. Specifically:"),"\n",o.createElement(l.A,{text:"\\( y = \\text{LayerNorm}(x + \\text{Sublayer}(x)), \\)"}),"\n",o.createElement(t.p,null,"applies to both the masked self-attention sub-layer, the encoder-decoder attention sub-layer, and the feed-forward sub-layer. This consistency ensures stable training behavior across the entire stack."),"\n",o.createElement(t.h3,{id:"generating-output-tokens",style:{position:"relative"}},o.createElement(t.a,{href:"#generating-output-tokens","aria-label":"generating output tokens permalink",className:"anchor before"},o.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Generating output tokens"),"\n",o.createElement(t.p,null,"Once the decoder has computed its final hidden states, the standard approach is to project those states through a linear transformation that maps each vector of dimension ",o.createElement(l.A,{text:"\\(d_\\text{model}\\)"})," to the vocabulary dimension. A softmax is then applied to produce a probability distribution over possible next tokens:"),"\n",o.createElement(l.A,{text:"\\[\nP(\\text{token}_t = w) = \\text{softmax}(H_{\\text{decoder}} W_{\\text{vocab}}^T)_w.\n\\]"}),"\n",o.createElement(t.p,null,"At inference time, the model can generate text by sampling from this distribution (e.g., greedily taking the most likely token at each step), or using more sophisticated decoding algorithms such as beam search, nucleus sampling, or top-k sampling."),"\n",o.createElement(t.h3,{id:"handling-long-sequences-in-decoding",style:{position:"relative"}},o.createElement(t.a,{href:"#handling-long-sequences-in-decoding","aria-label":"handling long sequences in decoding permalink",className:"anchor before"},o.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Handling long sequences in decoding"),"\n",o.createElement(t.p,null,"While Transformers can handle longer sequences than many RNN-based approaches, memory usage can still balloon if the sequence is very long. Several techniques exist to mitigate this during decoding:"),"\n",o.createElement(t.ul,null,"\n",o.createElement(t.li,null,o.createElement(t.strong,null,"Chunking or blocking"),": Split the input (or the previously generated output) into manageable blocks."),"\n",o.createElement(t.li,null,o.createElement(t.strong,null,"Memory compression"),": Summarize past tokens into fewer representations, so the attention context does not grow unbounded."),"\n",o.createElement(t.li,null,o.createElement(t.strong,null,"Sparse or linear attention variants"),": Reduce the computational overhead and memory usage of full self-attention, often by restricting which tokens can attend to each other or by approximating the attention mechanism."),"\n"),"\n",o.createElement(t.p,null,"Regardless of the method, the essential principle remains that the decoder must not have direct access to future positions, preserving causal consistency."),"\n",o.createElement(t.hr),"\n",o.createElement(t.p,null,"Below, I will embed a brief code snippet that demonstrates a minimal high-level Transformer encoder-decoder forward pass in Python-like pseudocode. This snippet is intended simply as a conceptual illustration of how the data flows, rather than a complete implementation with all details (masking, positional encodings, etc.) spelled out."),"\n",o.createElement(i.A,{text:"\nimport torch\nimport torch.nn as nn\nimport math\n\nclass SimpleTransformer(nn.Module):\n    def __init__(self, \n                 vocab_size, \n                 d_model=512, \n                 n_heads=8, \n                 num_encoder_layers=6,\n                 num_decoder_layers=6):\n        super().__init__()\n        self.embedding_src = nn.Embedding(vocab_size, d_model)\n        self.embedding_tgt = nn.Embedding(vocab_size, d_model)\n\n        # Positional encoding parameters\n        self.pos_encoder = PositionalEncoding(d_model)\n\n        # Transformer module from PyTorch\n        self.transformer = nn.Transformer(d_model=d_model, \n                                          nhead=n_heads,\n                                          num_encoder_layers=num_encoder_layers,\n                                          num_decoder_layers=num_decoder_layers)\n\n        self.fc_out = nn.Linear(d_model, vocab_size)\n    \n    def forward(self, src_tokens, tgt_tokens):\n        # src_tokens, tgt_tokens: shape (seq_len, batch_size)\n        src_emb = self.embedding_src(src_tokens)  # (seq_len, batch_size, d_model)\n        tgt_emb = self.embedding_tgt(tgt_tokens)  # (seq_len, batch_size, d_model)\n\n        src_emb = self.pos_encoder(src_emb)\n        tgt_emb = self.pos_encoder(tgt_emb)\n\n        # The nn.Transformer in PyTorch expects (seq_len, batch_size, d_model)\n        # By default, it implements both the encoder and decoder\n        memory = self.transformer.encoder(src_emb)  # shape: (src_seq_len, batch_size, d_model)\n        outputs = self.transformer.decoder(tgt_emb, memory)  # shape: (tgt_seq_len, batch_size, d_model)\n\n        logits = self.fc_out(outputs)  # (tgt_seq_len, batch_size, vocab_size)\n        return logits\n\nclass PositionalEncoding(nn.Module):\n    def __init__(self, d_model, max_len=5000):\n        super().__init__()\n        pe = torch.zeros(max_len, d_model)\n        position = torch.arange(0, max_len).unsqueeze(1)\n        div_term = torch.exp(torch.arange(0, d_model, 2) * -(math.log(10000.0) / d_model))\n        pe[:, 0::2] = torch.sin(position * div_term)\n        pe[:, 1::2] = torch.cos(position * div_term)\n        pe = pe.unsqueeze(1)  # shape: (max_len, 1, d_model)\n        self.register_buffer('pe', pe)\n\n    def forward(self, x):\n        # x shape: (seq_len, batch_size, d_model)\n        seq_len = x.size(0)\n        x = x + self.pe[:seq_len, :]\n        return x\n"}),"\n",o.createElement(t.p,null,"Even though libraries such as PyTorch provide a high-level ",o.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">nn.Transformer</code>'}})," module, it can be valuable for advanced practitioners to understand the architectural details behind it, especially when debugging or implementing variants like GPT-style decoder-only models, BERT-style encoder-only models, or specialized attention mechanisms."),"\n",o.createElement(t.hr),"\n",o.createElement(t.p,null,"I have thus outlined the core elements of the Transformer architecture: encoder-decoder design, multi-head self-attention, feed-forward networks, and the usage of residual connections and normalization to stabilize training. The final layers of the decoder generate tokens autoregressively, ensuring that the model can effectively produce sequences for tasks like translation or text generation. You should now have a strong conceptual grounding in how Transformers function at a fundamental level."),"\n",o.createElement(t.p,null,"In the subsequent article (part 2), I will dive deeper into the mathematical intricacies of the self-attention mechanism, the roles of queries, keys, and values, and advanced topics such as memory-efficient attention variants and common training techniques. However, even at this stage, it should be evident why Transformers have drastically reshaped the modern ML landscape, offering a scalable, parallelizable, and powerful framework for dealing with sequential data across a variety of modalities."),"\n",o.createElement(t.p,null,"Depending on your application, you may consider exploring both the encoder-only variants (such as BERT or Vision Transformers) and the decoder-only variants (such as GPT) to determine which best meets your needs. If you're working on tasks where a sequence-to-sequence approach is critical — like machine translation or text summarization — the standard encoder-decoder Transformer structure remains a highly effective choice."),"\n",o.createElement(t.p,null,"By understanding these components, you're well on your way to building advanced, attention-driven architectures that stand at the forefront of contemporary machine learning."))}var c=function(e){void 0===e&&(e={});const{wrapper:t}=Object.assign({},(0,r.RP)(),e.components);return t?o.createElement(t,e,o.createElement(s,e)):s(e)},d=n(36710),h=n(58481),m=n.n(h),u=n(36310),p=n(87245),g=n(27042),f=n(59849),v=n(5591),y=n(61122),b=n(9219),E=n(33203),w=n(95751),x=n(94328),k=n(80791),_=n(78137);const S=e=>{let{toc:t}=e;if(!t||!t.items)return null;return o.createElement("nav",{className:k.R},o.createElement("ul",null,t.items.map(((e,t)=>o.createElement("li",{key:t},o.createElement("a",{href:e.url,onClick:t=>((e,t)=>{e.preventDefault();const n=t.replace("#",""),a=document.getElementById(n);a&&a.scrollIntoView({behavior:"smooth",block:"start"})})(t,e.url)},e.title),e.items&&o.createElement(S,{toc:{items:e.items}}))))))};function T(e){let{data:{mdx:t,allMdx:i,allPostImages:l},children:s}=e;const{frontmatter:c,body:d,tableOfContents:h}=t,f=c.index,k=c.slug.split("/")[1],T=i.nodes.filter((e=>e.frontmatter.slug.includes(`/${k}/`))).sort(((e,t)=>e.frontmatter.index-t.frontmatter.index)),H=T.findIndex((e=>e.frontmatter.index===f)),z=T[H+1],q=T[H-1],A=c.slug.replace(/\/$/,""),C=/[^/]*$/.exec(A)[0],M=`posts/${k}/content/${C}/`,{0:N,1:V}=(0,o.useState)(c.flagWideLayoutByDefault),{0:I,1:B}=(0,o.useState)(!1);var L;(0,o.useEffect)((()=>{B(!0);const e=setTimeout((()=>B(!1)),340);return()=>clearTimeout(e)}),[N]),"adventures"===k?L=b.cb:"research"===k?L=b.Qh:"thoughts"===k&&(L=b.T6);const P=m()(d).replace(/import .*? from .*?;/g,"").replace(/<.*?>/g,"").replace(/\{\/\*[\s\S]*?\*\/\}/g,"").trim().split(/\s+/).length,R=function(e){if(e<=10)return"~10 min";if(e<=20)return"~20 min";if(e<=30)return"~30 min";if(e<=40)return"~40 min";if(e<=50)return"~50 min";if(e<=60)return"~1 h";const t=Math.floor(e/60),n=e%60;return n<=30?`~${t}${n>0?".5":""} h`:`~${t+1} h`}(Math.ceil(P/L)+(c.extraReadTimeMin||0)),G=[{flag:c.flagDraft,component:()=>Promise.all([n.e(3231),n.e(8809)]).then(n.bind(n,28809))},{flag:c.flagMindfuckery,component:()=>Promise.all([n.e(3231),n.e(2471)]).then(n.bind(n,67709))},{flag:c.flagRewrite,component:()=>Promise.all([n.e(3231),n.e(6764)]).then(n.bind(n,62002))},{flag:c.flagOffensive,component:()=>Promise.all([n.e(3231),n.e(2443)]).then(n.bind(n,17681))},{flag:c.flagProfane,component:()=>Promise.all([n.e(3231),n.e(8048)]).then(n.bind(n,53286))},{flag:c.flagMultilingual,component:()=>Promise.all([n.e(3231),n.e(4069)]).then(n.bind(n,78831))},{flag:c.flagUnreliably,component:()=>Promise.all([n.e(3231),n.e(3417)]).then(n.bind(n,8179))},{flag:c.flagPolitical,component:()=>Promise.all([n.e(3231),n.e(5195)]).then(n.bind(n,30433))},{flag:c.flagCognitohazard,component:()=>Promise.all([n.e(3231),n.e(3175)]).then(n.bind(n,8413))},{flag:c.flagHidden,component:()=>Promise.all([n.e(3231),n.e(9556)]).then(n.bind(n,14794))}],{0:W,1:j}=(0,o.useState)([]);return(0,o.useEffect)((()=>{G.forEach((e=>{let{flag:t,component:n}=e;t&&n().then((e=>{j((t=>[].concat((0,a.A)(t),[e.default])))}))}))}),[]),o.createElement(g.P.div,{initial:{opacity:0},animate:{opacity:1},exit:{opacity:0},transition:{duration:.15}},o.createElement(v.A,{postNumber:c.index,date:c.date,updated:c.updated,readTime:R,difficulty:c.difficultyLevel,title:c.title,desc:c.desc,banner:c.banner,section:k,postKey:C,isMindfuckery:c.flagMindfuckery,mainTag:c.mainTag}),o.createElement("div",{style:{display:"flex",justifyContent:"flex-end",flexWrap:"wrap",maxWidth:"75%",marginLeft:"auto",paddingRight:"1vw",marginTop:"-6vh",marginBottom:"4vh"}},c.otherTags.map(((e,t)=>o.createElement("span",{key:t,className:`noselect ${_.MW}`,style:{margin:"0 5px 5px 0"}},e)))),o.createElement("div",{className:"postBody"},o.createElement(S,{toc:h})),o.createElement("br"),o.createElement("div",{style:{margin:"0 10% -2vh 30%",textAlign:"right"}},o.createElement(g.P.button,{className:`noselect ${x.pb}`,id:x.xG,onClick:()=>{V(!N)},whileTap:{scale:.93}},o.createElement(g.P.div,{className:w.DJ,key:N,initial:{opacity:0},animate:{opacity:1},exit:{opacity:0},transition:{duration:.3,ease:"easeInOut"}},N?"Switch to default layout":"Switch to wide layout"))),o.createElement("br"),o.createElement("div",{className:"postBody",style:{margin:N?"0 -14%":"",maxWidth:N?"200%":"",transition:"margin 1s ease, max-width 1s ease, padding 1s ease"}},o.createElement("div",{className:`${x.P_} ${I?x.Xn:x.qG}`},W.map(((e,t)=>o.createElement(e,{key:t}))),c.indexCourse?o.createElement(E.A,{index:c.indexCourse,category:c.courseCategoryName}):"",o.createElement(u.Z.Provider,{value:{images:l.nodes,basePath:M.replace(/\/$/,"")+"/"}},o.createElement(r.xA,{components:{Image:p.A}},s)))),o.createElement(y.A,{nextPost:z,lastPost:q,keyCurrent:C,section:k}))}function H(e){return o.createElement(T,e,o.createElement(c,e))}function z(e){var t,n,a,r,i;let{data:l}=e;const{frontmatter:s}=l.mdx,c=s.titleSEO||s.title,h=s.titleOG||c,m=s.titleTwitter||c,u=s.descSEO||s.desc,p=s.descOG||u,g=s.descTwitter||u,v=s.schemaType||"BlogPosting",y=s.keywordsSEO,b=s.date,E=s.updated||b,w=s.imageOG||(null===(t=s.banner)||void 0===t||null===(n=t.childImageSharp)||void 0===n||null===(a=n.gatsbyImageData)||void 0===a||null===(r=a.images)||void 0===r||null===(i=r.fallback)||void 0===i?void 0:i.src),x=s.imageAltOG||p,k=s.imageTwitter||w,_=s.imageAltTwitter||g,S=s.canonicalURL,T=s.flagHidden||!1,H=s.mainTag||"Posts",z=s.slug.split("/")[1]||"posts",{siteUrl:q}=(0,d.Q)(),A={"@context":"https://schema.org","@type":"BreadcrumbList",itemListElement:[{"@type":"ListItem",position:1,name:"Home",item:q},{"@type":"ListItem",position:2,name:H,item:`${q}/${s.slug.split("/")[1]}`},{"@type":"ListItem",position:3,name:c,item:`${q}${s.slug}`}]};return o.createElement(f.A,{title:c+" - avrtt.blog",titleOG:h,titleTwitter:m,description:u,descriptionOG:p,descriptionTwitter:g,schemaType:v,keywords:y,datePublished:b,dateModified:E,imageOG:w,imageAltOG:x,imageTwitter:k,imageAltTwitter:_,canonicalUrl:S,flagHidden:T,mainTag:H,section:z,type:"article"},o.createElement("script",{type:"application/ld+json"},JSON.stringify(A)))}},96098:function(e,t,n){var a=n(96540),r=n(7978);t.A=e=>{let{text:t}=e;return a.createElement(r.A,null,t)}}}]);
//# sourceMappingURL=component---src-templates-post-js-content-file-path-src-pages-posts-research-transformer-architecture-mdx-e2bc85270e577407db4b.js.map