"use strict";(self.webpackChunkavrtt_blog=self.webpackChunkavrtt_blog||[]).push([[7863],{14582:function(e,t,n){n.r(t),n.d(t,{Head:function(){return A},PostTemplate:function(){return H},default:function(){return z}});var a=n(54506),i=n(28453),r=n(96540),l=(n(16886),n(46295)),s=n(96098);function o(e){const t=Object.assign({p:"p",hr:"hr",h2:"h2",a:"a",span:"span",h3:"h3",ol:"ol",li:"li",strong:"strong",ul:"ul",h4:"h4"},(0,i.RP)(),e.components),{Image:n}=t;return n||function(e,t){throw new Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Image",!0),r.createElement(r.Fragment,null,"\n",r.createElement("br"),"\n","\n","\n",r.createElement(t.p,null,'I want to begin this deep dive into learning to rank by highlighting the profound importance of ranking systems in modern data-intensive environments. Every time you open a search engine, scroll through a recommendation feed, or browse for products in an online store, you are engaging with an algorithm that decides — often behind the scenes — how to order information so that the most "useful" or "relevant" items appear first. These tasks may involve ranking web documents, personalizing song recommendations, reordering a user\'s social media feed, or prioritizing product listings. The underlying principle is that not all content is equally relevant to a user\'s query, intent, or preference; learning to rank is the discipline that provides mathematical and computational frameworks to produce, evaluate, and optimize such orderings.'),"\n",r.createElement(t.p,null,"The prominence of ranking in commercial and research applications — from search engine result pages (SERPs) to advanced recommender systems — has led to the emergence of specialized algorithms and models. Early ranking techniques simply used heuristic-based scores or domain-specific rules; modern learning-to-rank methods leverage large datasets, sophisticated loss functions, advanced neural networks (including transformer-based architectures), and large-scale distributed training strategies to provide the best possible ordering under complex and dynamic conditions."),"\n",r.createElement(t.p,null,"Beyond these immediate applications, learning to rank intersects with many other sub-fields of machine learning. Concepts from classification, regression, and clustering appear in pointwise, pairwise, and listwise approaches to ranking. Specialized ranking metrics like NDCG (",r.createElement(s.A,{text:"\\( \\text{normalized discounted cumulative gain} \\)"}),"), MAP (",r.createElement(s.A,{text:"\\( \\text{mean average precision} \\)"}),"), and various others shape the way we design objective functions and measure success. The interplay between partial orders, real-valued scoring functions, and the discrete nature of permutations makes ranking an especially fascinating topic where theory and practice often collide in intriguing ways."),"\n",r.createElement(t.p,null,"This article, intended for a specialized audience of data scientists, researchers, and advanced practitioners, aims to bridge the gap between theory and real-world applications. By the end, I hope to leave you with a thorough, rigorous, and conceptual understanding of learning to rank — from fundamental definitions and classical algorithms to cutting-edge neural approaches and large-scale deployment."),"\n",r.createElement(t.hr),"\n",r.createElement(t.h2,{id:"fundamental-concepts",style:{position:"relative"}},r.createElement(t.a,{href:"#fundamental-concepts","aria-label":"fundamental concepts permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Fundamental concepts"),"\n",r.createElement(t.p,null,"Learning to rank is at its core an approach to supervised machine learning. Instead of predicting a label (as in classification) or a numeric value (as in regression), the objective is to predict the relative ordering among items. Often, these items are grouped by some higher-level context (e.g., items that appear in the same search query, or items recommended to a single user). The training data typically consists of ordered lists (or pairwise preferences) for these groupings, and the goal is to learn a ranking function that generalizes to future data."),"\n",r.createElement(t.h3,{id:"types-of-ranking-problems",style:{position:"relative"}},r.createElement(t.a,{href:"#types-of-ranking-problems","aria-label":"types of ranking problems permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Types of ranking problems"),"\n",r.createElement(t.p,null,"When discussing learning to rank, it is helpful to distinguish between multiple formulations. While the ultimate output is an ordering or sorted list, the approaches used to arrive at that ordering can differ:"),"\n",r.createElement(t.ol,null,"\n",r.createElement(t.li,null,"\n",r.createElement(t.p,null,r.createElement(t.strong,null,"Pointwise ranking"),": Treats each item's relevance score as an independent regression or classification target. The predicted score, ",r.createElement(s.A,{text:"\\( a(x) \\)"}),", for item ",r.createElement(s.A,{text:"\\( x \\)"})," is then used to produce a final rank ordering by sorting these predicted values."),"\n"),"\n",r.createElement(t.li,null,"\n",r.createElement(t.p,null,r.createElement(t.strong,null,"Pairwise ranking"),": Focuses on learning from pairwise preferences: you know that item ",r.createElement(s.A,{text:"\\( x_i \\)"})," is ranked higher than item ",r.createElement(s.A,{text:"\\( x_j \\)"}),'. The objective is to reduce the number of "inversions," i.e., incorrectly ordered pairs.'),"\n"),"\n",r.createElement(t.li,null,"\n",r.createElement(t.p,null,r.createElement(t.strong,null,"Listwise ranking"),": Attempts to model the entire ranked list at once. Typically, the loss function measures how close the predicted order is to the ground truth order, using metrics that reward correct placement at the top of the list or penalize larger mistakes for highly relevant items."),"\n"),"\n"),"\n",r.createElement(t.p,null,"Each formulation has its pros and cons. Pointwise methods are conceptually simpler but may not capture the relative ordering constraints explicitly. Pairwise methods often strike a good balance between practicality and direct modeling of preference relationships. Listwise methods, while theoretically aligning most strongly with ranking metrics, can be more complex to implement and optimize effectively at scale."),"\n",r.createElement(t.h3,{id:"pointwise-ranking",style:{position:"relative"}},r.createElement(t.a,{href:"#pointwise-ranking","aria-label":"pointwise ranking permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Pointwise ranking"),"\n",r.createElement(t.p,null,"Pointwise ranking can be viewed as a regression or classification problem where the target is the relevance label (e.g., a binary indicator of relevance or a multi-level rating). You estimate a function ",r.createElement(s.A,{text:"\\( a(x) \\)"})," that assigns a real-valued score (or probability of relevance) to each item ",r.createElement(s.A,{text:"\\( x \\)"}),". Once trained, you rank items by sorting them in descending order of ",r.createElement(s.A,{text:"\\( a(x) \\)"}),"."),"\n",r.createElement(t.p,null,"An example is using linear regression:"),"\n",r.createElement(s.A,{text:"\\[\n\\min_{w} \\sum_{i=1}^l \\left(a(q_i, d_i; w) \\;-\\; y(q_i, d_i)\\right)^2,\n\\]"}),"\n",r.createElement(t.p,null,"where ",r.createElement(s.A,{text:"\\( y(q_i, d_i) \\)"})," is an expert-provided (or user-generated) relevance score for document ",r.createElement(s.A,{text:"\\( d_i \\)"})," under query ",r.createElement(s.A,{text:"\\( q_i \\)"}),", and ",r.createElement(s.A,{text:"\\( a(q_i, d_i; w) = \\langle w, x_i\\rangle \\)"})," is a linear function of the feature vector ",r.createElement(s.A,{text:"\\( x_i \\)"})," representing that (query, document) pair. Although pointwise ranking is easy to implement, one limitation is that the model does not directly optimize for typical ranking metrics (like NDCG or MAP) which emphasize correct ordering over numeric accuracy of a predicted score."),"\n",r.createElement(t.h3,{id:"pairwise-ranking",style:{position:"relative"}},r.createElement(t.a,{href:"#pairwise-ranking","aria-label":"pairwise ranking permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Pairwise ranking"),"\n",r.createElement(t.p,null,"In pairwise ranking, the focus is on comparing pairs of items. Given a training set of pairs ",r.createElement(s.A,{text:"\\( (x_i, x_j) \\)"})," with ",r.createElement(s.A,{text:"\\( x_i \\prec x_j \\)"})," meaning that item ",r.createElement(s.A,{text:"\\( x_i \\)"})," should be ranked lower than ",r.createElement(s.A,{text:"\\( x_j \\)"})," (or equivalently, ",r.createElement(s.A,{text:"\\( x_j \\)"})," is the more relevant one), the goal is to find ",r.createElement(s.A,{text:"\\( a(\\cdot) \\)"})," such that ",r.createElement(s.A,{text:"\\( a(x_j) > a(x_i) \\)"})," for as many training pairs as possible."),"\n",r.createElement(t.p,null,"A popular approach is to transform these pairs into a classification-like problem: the difference ",r.createElement(s.A,{text:"\\( a(x_j) - a(x_i) \\)"})," is positive if ",r.createElement(s.A,{text:"\\( x_j \\)"})," ranks above ",r.createElement(s.A,{text:"\\( x_i \\)"}),". For instance, a logistic loss might look like:"),"\n",r.createElement(s.A,{text:"\\[\n\\sum_{(i,j) \\in \\text{Pairs}} \\log\\left(1 + \\exp\\left(-\\left(a(x_j) - a(x_i)\\right)\\right)\\right).\n\\]"}),"\n",r.createElement(t.p,null,"Minimizing this sum encourages ",r.createElement(s.A,{text:"\\( a(x_j) \\)"})," to exceed ",r.createElement(s.A,{text:"\\( a(x_i) \\)"})," and penalizes incorrect orderings. This technique underlies methods such as ",r.createElement(t.strong,null,"RankNet"),", which uses a neural network to learn the function ",r.createElement(s.A,{text:"\\( a(\\cdot) \\)"}),"."),"\n",r.createElement(t.h3,{id:"listwise-ranking",style:{position:"relative"}},r.createElement(t.a,{href:"#listwise-ranking","aria-label":"listwise ranking permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Listwise ranking"),"\n",r.createElement(t.p,null,"Unlike pairwise methods that process pairs, listwise methods look at the entire list. The training objective might be designed to directly optimize for a ranking metric like NDCG or MAP. An example is ",r.createElement(t.strong,null,"ListNet"),", which uses a probability model over permutations and attempts to minimize a Kullback–Leibler divergence between the predicted permutation probabilities and the ground truth distribution of permutations. Another notable example is ",r.createElement(t.strong,null,"LambdaRank"),", where the gradient is scaled by how much a particular swap of two items would affect a target metric like NDCG."),"\n",r.createElement(t.p,null,"Listwise approaches can, in principle, align perfectly with how we evaluate ranking systems, since ranking metrics are often list-based. However, building a smooth, differentiable objective that matches these metrics remains a challenge, leading to approximate or surrogate losses."),"\n",r.createElement(t.h3,{id:"loss-functions-and-evaluation-metrics",style:{position:"relative"}},r.createElement(t.a,{href:"#loss-functions-and-evaluation-metrics","aria-label":"loss functions and evaluation metrics permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Loss functions and evaluation metrics"),"\n",r.createElement(t.p,null,"An essential part of learning to rank is choosing an appropriate objective function that correlates well with final performance as measured by real-world ranking metrics. These metrics typically place emphasis on the top of the list, because that is where user attention focuses most. Common metrics include:"),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"MAP")," (",r.createElement(s.A,{text:"\\( \\text{mean average precision} \\)"}),")"),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"NDCG")," (",r.createElement(s.A,{text:"\\( \\text{normalized discounted cumulative gain} \\)"}),")"),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Precision@k and Recall@k")),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"MRR")," (",r.createElement(s.A,{text:"\\( \\text{mean reciprocal rank} \\)"}),")"),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"pFound")," (used by some large search engines)"),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"ERR")," (",r.createElement(s.A,{text:"\\( \\text{expected reciprocal rank} \\)"}),")"),"\n"),"\n",r.createElement(t.p,null,"Below, I will focus on MAP and NDCG as they are particularly popular."),"\n",r.createElement(t.h3,{id:"mean-average-precision-map",style:{position:"relative"}},r.createElement(t.a,{href:"#mean-average-precision-map","aria-label":"mean average precision map permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Mean average precision (MAP)"),"\n",r.createElement(t.p,null,"Mean average precision (MAP) is a metric that measures ranking quality when binary relevance labels ",r.createElement(s.A,{text:"\\( y(q, d) \\in \\{0, 1\\} \\)"})," are available. For a given query ",r.createElement(s.A,{text:"\\( q \\)"}),", define ",r.createElement(s.A,{text:"\\( d_q^{(i)} \\)"})," as the document at rank ",r.createElement(s.A,{text:"\\( i \\)"}),". Precision@",r.createElement(s.A,{text:"\\( i \\)"})," is then the fraction of relevant items among the top ",r.createElement(s.A,{text:"\\( i \\)"})," positions:"),"\n",r.createElement(s.A,{text:"\\[\n\\text{Precision@}i(q) = \\frac{1}{i} \\sum_{r=1}^{i} y\\bigl(q, d_q^{(r)}\\bigr).\n\\]"}),"\n",r.createElement(t.p,null,"Average precision (AP) at rank ",r.createElement(s.A,{text:"\\( k \\)"})," is:"),"\n",r.createElement(s.A,{text:"\\[\n\\text{AP@}k(q) = \\frac{\\sum_{i=1}^{k} y\\bigl(q, d_q^{(i)}\\bigr) \\; \\text{Precision@}i(q)}{\\sum_{i=1}^{k} y\\bigl(q, d_q^{(i)}\\bigr)}.\n\\]"}),"\n",r.createElement(t.p,null,"It increases when relevant documents appear earlier. MAP@",r.createElement(s.A,{text:"\\( k \\)"})," is the mean over all queries:"),"\n",r.createElement(s.A,{text:"\\[\n\\text{MAP@}k = \\frac{1}{|Q|}\\sum_{q \\in Q} \\text{AP@}k(q).\n\\]"}),"\n",r.createElement(t.h3,{id:"normalized-discounted-cumulative-gain-ndcg",style:{position:"relative"}},r.createElement(t.a,{href:"#normalized-discounted-cumulative-gain-ndcg","aria-label":"normalized discounted cumulative gain ndcg permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Normalized discounted cumulative gain (NDCG)"),"\n",r.createElement(t.p,null,"NDCG handles multi-level (graded) relevance, e.g. ",r.createElement(s.A,{text:"\\( \\{0,1,2,3\\} \\)"})," or real numbers. For a ranked list of ",r.createElement(s.A,{text:"\\( k \\)"})," items, ",r.createElement(t.strong,null,"discounted cumulative gain")," is:"),"\n",r.createElement(s.A,{text:"\\[\n\\text{DCG@}k(q) = \\sum_{i=1}^{k} \\frac{2^{\\,y\\bigl(q, d_q^{(i)}\\bigr)} - 1}{\\log_2\\bigl(i+1\\bigr)},\n\\]"}),"\n",r.createElement(t.p,null,"where ",r.createElement(s.A,{text:"\\( y(q, d) \\)"})," is the relevance rating of document ",r.createElement(s.A,{text:"\\( d \\)"}),'. DCG places a heavier penalty on items that are relevant but placed near the bottom of the list, because of the logarithmic "discount" factor.'),"\n",r.createElement(t.p,null,"NDCG normalizes DCG by the best possible (ideal) ordering's DCG:"),"\n",r.createElement(s.A,{text:"\\[\n\\text{nDCG@}k(q) = \\frac{\\text{DCG@}k(q)}{\\text{maxDCG@}k(q)},\n\\]"}),"\n",r.createElement(t.p,null,"so ",r.createElement(s.A,{text:"\\( \\text{nDCG@}k(q) \\in [0,1] \\)"}),". A ranking that exactly matches the ideal ordering achieves ",r.createElement(s.A,{text:"\\( 1 \\)"}),"."),"\n",r.createElement(t.h3,{id:"precisionk-and-recallk",style:{position:"relative"}},r.createElement(t.a,{href:"#precisionk-and-recallk","aria-label":"precisionk and recallk permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Precision@k and recall@k"),"\n",r.createElement(t.p,null,"Precision@k simply checks the fraction of relevant documents among the top ",r.createElement(s.A,{text:"\\( k \\)"})," positions. Recall@k checks the fraction of all relevant documents retrieved within the top ",r.createElement(s.A,{text:"\\( k \\)"})," ranks. While both are easy to interpret, they do not explicitly penalize placing a relevant item at position 10 vs. position 1; they only check whether the relevant item is in the top ",r.createElement(s.A,{text:"\\( k \\)"}),". More refined metrics (like nDCG) care about the exact position of each item."),"\n",r.createElement(t.hr),"\n",r.createElement(t.h2,{id:"algorithms-and-models",style:{position:"relative"}},r.createElement(t.a,{href:"#algorithms-and-models","aria-label":"algorithms and models permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Algorithms and models"),"\n",r.createElement(t.p,null,"Learning-to-rank algorithms span classic machine learning, ensemble methods, large-scale gradient boosting, and advanced neural network models that can incorporate deep architectures or even transformers. Historically, academic conferences like SIGIR, WWW, KDD, and NeurIPS have played host to numerous new ranking algorithms that push state of the art."),"\n",r.createElement(t.h3,{id:"traditional-machine-learning-approaches",style:{position:"relative"}},r.createElement(t.a,{href:"#traditional-machine-learning-approaches","aria-label":"traditional machine learning approaches permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Traditional machine learning approaches"),"\n",r.createElement(t.p,null,"Traditional methods began by applying known supervised learning paradigms (regression, classification) to ranking. For instance, you could simply train a linear regressor (or logistic regressor in the binary relevance setting) to predict a relevance score for each item. Then you sort items by that predicted score. Alternatively, you might adapt a classification approach to minimize pairwise inversions."),"\n",r.createElement(t.h4,{id:"linear-models-for-ranking",style:{position:"relative"}},r.createElement(t.a,{href:"#linear-models-for-ranking","aria-label":"linear models for ranking permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Linear models for ranking"),"\n",r.createElement(t.p,null,"A linear ranker has the form:"),"\n",r.createElement(s.A,{text:"\\[\na(x; w) = \\langle w, x \\rangle,\n\\]"}),"\n",r.createElement(t.p,null,"where ",r.createElement(s.A,{text:"\\( x \\in \\mathbb{R}^n \\)"})," is a feature vector. The training might involve solving:"),"\n",r.createElement(s.A,{text:"\\[\n\\min_{w}\\quad \\sum_{(i, j)} L\\bigl(\\langle w, x_j\\rangle - \\langle w, x_i\\rangle\\bigr),\n\\]"}),"\n",r.createElement(t.p,null,"if using a pairwise approach, or"),"\n",r.createElement(s.A,{text:"\\[\n\\min_{w}\\quad \\sum_{i} \\left(\\langle w, x_i\\rangle - y_i\\right)^2,\n\\]"}),"\n",r.createElement(t.p,null,"in the pointwise scenario. Linear models are fast, interpretable, and remain relevant in many large-scale industrial systems."),"\n",r.createElement(t.h4,{id:"tree-based-methods-including-random-forests",style:{position:"relative"}},r.createElement(t.a,{href:"#tree-based-methods-including-random-forests","aria-label":"tree based methods including random forests permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Tree-based methods (including random forests)"),"\n",r.createElement(t.p,null,"Decision trees and random forests have also been adapted for ranking tasks. A random forest can produce a real-valued relevance prediction for each item. Typically, each tree outputs a score (e.g., the mean label of training samples in the corresponding leaf), and the final prediction is an average over all trees. In pairwise setups, each data point corresponds to a difference of feature vectors (",r.createElement(s.A,{text:"\\( x_j - x_i \\)"}),") or both ",r.createElement(s.A,{text:"\\( x_i \\)"})," and ",r.createElement(s.A,{text:"\\( x_j \\)"})," are fed to the model (though that can get more complicated for trees)."),"\n",r.createElement(t.h4,{id:"gradient-boosting-for-ranking-lambdamart",style:{position:"relative"}},r.createElement(t.a,{href:"#gradient-boosting-for-ranking-lambdamart","aria-label":"gradient boosting for ranking lambdamart permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Gradient boosting for ranking (LambdaMART)"),"\n",r.createElement(t.p,null,"One of the most widely used classes of ranking algorithms in industry — from web search to e-commerce — involves gradient boosting over regression trees, combined with specialized ranking losses. ",r.createElement(t.strong,null,"LambdaMART")," is a prime example: it starts from the principle of ",r.createElement(t.strong,null,"LambdaRank")," (a listwise approach that modifies the gradient by the potential gain in NDCG from pairwise swaps) and applies it in a gradient boosting framework. Each iteration fits a new regression tree to the current pseudo-residuals, which incorporate both the standard pairwise logistic gradient and a factor that captures how a small change in the item scores would affect the final ranking metric (e.g., NDCG)."),"\n",r.createElement(t.p,null,"LambdaMART has been championed by several large-scale search engines (notably Microsoft's Bing in the original research) and remains a go-to method for tabular ranking tasks where features are mostly numeric or categorical in structured form."),"\n",r.createElement(t.h3,{id:"neural-network-approaches",style:{position:"relative"}},r.createElement(t.a,{href:"#neural-network-approaches","aria-label":"neural network approaches permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Neural network approaches"),"\n",r.createElement(t.p,null,"As deep learning rose to prominence, researchers explored neural architectures for ranking. Neural networks can handle raw or high-dimensional input data (like text embeddings, images, or user-event logs) without extensive feature engineering, and they can, in principle, learn sophisticated context-aware representations."),"\n",r.createElement(t.h4,{id:"deep-pairwise-ranking-models",style:{position:"relative"}},r.createElement(t.a,{href:"#deep-pairwise-ranking-models","aria-label":"deep pairwise ranking models permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Deep pairwise ranking models"),"\n",r.createElement(t.p,null,"A neural approach to pairwise ranking, exemplified by ",r.createElement(t.strong,null,"RankNet")," or neural adaptation of ",r.createElement(t.strong,null,"Ranking SVM"),", processes a pair ",r.createElement(s.A,{text:"\\( (x_i, x_j) \\)"})," as two separate forward passes (or a combined architecture with shared parameters). It then produces a difference in predicted scores. The objective might be a logistic or hinge loss. For instance, RankNet uses:"),"\n",r.createElement(s.A,{text:"\\[\nL = \\sum_{i,j} \\log\\Bigl(1 + \\exp\\bigl(-\\bigl(a(x_j) - a(x_i)\\bigr)\\bigr)\\Bigr).\n\\]"}),"\n",r.createElement(t.p,null,"Because neural networks can approximate complex nonlinear mappings, they can capture richer interactions among features than a simple linear approach. This is particularly helpful if items come with textual or image embeddings as part of the feature representation."),"\n",r.createElement(t.h4,{id:"listwise-neural-rankers",style:{position:"relative"}},r.createElement(t.a,{href:"#listwise-neural-rankers","aria-label":"listwise neural rankers permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Listwise neural rankers"),"\n",r.createElement(t.p,null,"Building on pairwise neural methods, listwise neural rankers incorporate an entire list (or a mini-batch that approximates a list) and define a training objective that tries to match the final ordering to ground truth labels in a manner consistent with typical ranking metrics. Examples include ",r.createElement(t.strong,null,"ListNet"),", ",r.createElement(t.strong,null,"ListMLE"),", ",r.createElement(t.strong,null,"AdaRank"),", and neural variations that optimize a smoothed approximation of NDCG. Some approaches draw on the concept of ",r.createElement(t.strong,null,"SoftRank"),", which attempts to make the listwise metric differentiable by modeling the probability of each document's position in the ranked list through a continuous relaxation."),"\n",r.createElement(t.h4,{id:"modern-transformer-based-ranking-models",style:{position:"relative"}},r.createElement(t.a,{href:"#modern-transformer-based-ranking-models","aria-label":"modern transformer based ranking models permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Modern transformer-based ranking models"),"\n",r.createElement(t.p,null,"Transformer architectures have proven immensely powerful for language tasks, and ranking is no exception, especially in the context of search and recommendation. Large pretrained language models, like BERT, can be finetuned to produce high-quality relevance estimates. There is a growing sub-field called ",r.createElement(t.strong,null,"Neural Information Retrieval (Neural IR)")," that focuses on using transformers to re-rank candidate sets of documents or product items. Typically, these models:"),"\n",r.createElement(t.ol,null,"\n",r.createElement(t.li,null,"Encode the query and each candidate item (document, passage, etc.)."),"\n",r.createElement(t.li,null,"Combine or compare these representations, often with cross-attention mechanisms, to predict relevance scores."),"\n",r.createElement(t.li,null,"Sort the candidates according to these scores."),"\n"),"\n",r.createElement(t.p,null,"Recent methods may adopt ",r.createElement(t.strong,null,"listwise")," approaches by feeding multiple items in a single pass and computing specialized losses that account for the entire top-",r.createElement(s.A,{text:"\\( k \\)"})," list. However, compute constraints often necessitate pairwise or pointwise re-ranking, especially if the number of candidates is large."),"\n",r.createElement(t.hr),"\n",r.createElement(t.h2,{id:"training-and-optimization",style:{position:"relative"}},r.createElement(t.a,{href:"#training-and-optimization","aria-label":"training and optimization permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Training and optimization"),"\n",r.createElement(t.p,null,"Designing and training a learning-to-rank model involves carefully balancing computational tractability, the complexity of the ranking objective, and the need to generalize to new data. Below are some recurring considerations:"),"\n",r.createElement(t.h3,{id:"41-pairwise-vs-listwise-training-objectives",style:{position:"relative"}},r.createElement(t.a,{href:"#41-pairwise-vs-listwise-training-objectives","aria-label":"41 pairwise vs listwise training objectives permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"4.1 Pairwise vs. listwise training objectives"),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Pairwise")," objectives can be easier to handle at large scale because the loss function becomes a sum over pairs, and standard stochastic gradient descent or mini-batch approaches can be used. However, pairwise methods may not perfectly align with the ultimate list-based metrics like NDCG."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Listwise")," methods incorporate the entire ranking at once and can directly optimize metrics such as NDCG. But their computational complexity and potential difficulty in building a smooth or differentiable approximation of the metric can be substantial."),"\n"),"\n",r.createElement(t.h3,{id:"42-addressing-overfitting-and-generalization",style:{position:"relative"}},r.createElement(t.a,{href:"#42-addressing-overfitting-and-generalization","aria-label":"42 addressing overfitting and generalization permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"4.2 Addressing overfitting and generalization"),"\n",r.createElement(t.p,null,"Like any supervised method, a learning-to-rank model can overfit — for instance, memorizing training queries without effectively generalizing to unseen queries. Strategies to mitigate overfitting include:"),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Regularization")," (L1, L2, or more advanced forms)"),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Dropout")," and data augmentation (especially for neural approaches)"),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Early stopping")," based on validation metrics like validation NDCG or MAP"),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Cross-validation")," or repeated sampling for robust evaluation"),"\n"),"\n",r.createElement(t.p,null,"A frequent problem is that the training set might have incomplete or noisy judgments (e.g., not all relevant items are labeled), which complicates generalization. Methods like negative sampling or incomplete-label strategies can help address these issues."),"\n",r.createElement(t.h3,{id:"43-hyperparameter-tuning-and-model-selection",style:{position:"relative"}},r.createElement(t.a,{href:"#43-hyperparameter-tuning-and-model-selection","aria-label":"43 hyperparameter tuning and model selection permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"4.3 Hyperparameter tuning and model selection"),"\n",r.createElement(t.p,null,"Hyperparameters (such as learning rate, tree depth in gradient boosting, or network architecture in neural ranking) can be tuned using any standard approach: grid search, random search, or Bayesian optimization. The key difference is that the validation metric for ranking is typically NDCG or MAP. For instance, you might pick the hyperparameters that maximize validation NDCG@10. Tuning can be performed offline if you have a curated dataset with relevance judgments, or in certain contexts, online metrics can be used in live systems."),"\n",r.createElement(t.h3,{id:"44-parallelization-and-distributed-training",style:{position:"relative"}},r.createElement(t.a,{href:"#44-parallelization-and-distributed-training","aria-label":"44 parallelization and distributed training permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"4.4 Parallelization and distributed training"),"\n",r.createElement(t.p,null,"Web-scale ranking tasks can involve billions of training examples. Distributing the workload becomes critical. For tree-based rankers like LambdaMART, frameworks such as XGBoost, LightGBM, or CatBoost offer built-in support for distributed training. For neural rankers, frameworks like TensorFlow or PyTorch can parallelize mini-batch computations across multiple GPUs or across a cluster."),"\n",r.createElement(t.hr),"\n",r.createElement(t.h2,{id:"evaluation-and-validation",style:{position:"relative"}},r.createElement(t.a,{href:"#evaluation-and-validation","aria-label":"evaluation and validation permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Evaluation and validation"),"\n",r.createElement(t.p,null,"Once a model is trained, the next question is: how do I assess its quality and how do I confirm that improvements in offline experiments carry over into actual user experiences?"),"\n",r.createElement(t.h3,{id:"51-offline-vs-online-evaluation",style:{position:"relative"}},r.createElement(t.a,{href:"#51-offline-vs-online-evaluation","aria-label":"51 offline vs online evaluation permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"5.1 Offline vs. online evaluation"),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Offline evaluation")," uses a labeled test set (with known relevance scores, clicks, or pairwise preferences). You compute metrics like nDCG, MAP, or Precision@k. Offline evaluation is relatively cheap and can be repeated at will."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Online evaluation")," measures user-facing impact by deploying the model in a production environment and analyzing metrics such as click-through rate, session length, or direct user feedback. Commonly used is ",r.createElement(t.strong,null,"A/B testing")," (sometimes multi-armed bandits or interleaving methods) to confirm that a new ranker truly outperforms the existing production system."),"\n"),"\n",r.createElement(t.h3,{id:"52-common-pitfalls-in-model-evaluation",style:{position:"relative"}},r.createElement(t.a,{href:"#52-common-pitfalls-in-model-evaluation","aria-label":"52 common pitfalls in model evaluation permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"5.2 Common pitfalls in model evaluation"),"\n",r.createElement(t.p,null,"A classic pitfall is ",r.createElement(t.strong,null,"position bias")," in user feedback: users rarely venture beyond the first few items of a list, so top positions get more clicks simply by virtue of being visible. Another is ",r.createElement(t.strong,null,"presentation bias"),", where the visual arrangement can distort which items get attention. Offline datasets might also have incomplete relevance judgments (missing some relevant items), leading to an underestimation of performance if the model ranks unknown relevant items near the top."),"\n",r.createElement(t.h3,{id:"53-statistical-significance-in-ranking-comparisons",style:{position:"relative"}},r.createElement(t.a,{href:"#53-statistical-significance-in-ranking-comparisons","aria-label":"53 statistical significance in ranking comparisons permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"5.3 Statistical significance in ranking comparisons"),"\n",r.createElement(t.p,null,"When comparing two rankers with slightly different metrics, it is often necessary to conduct significance tests, such as a paired t-test or Wilcoxon signed-rank test, to confirm that performance differences are not due to chance. Observed differences in MAP or nDCG can sometimes be small but still translate to meaningful improvements at scale."),"\n",r.createElement(t.h3,{id:"54-ab-testing-and-experimentation",style:{position:"relative"}},r.createElement(t.a,{href:"#54-ab-testing-and-experimentation","aria-label":"54 ab testing and experimentation permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"5.4 A/B testing and experimentation"),"\n",r.createElement(t.p,null,"A/B testing is the gold standard for measuring how a new ranker performs with real users. Typically, a fraction of users sees the new ranking system while the rest see the control system. By comparing user engagement, click-through rate, or other domain-specific metrics, one can quantitatively determine whether the new system yields a statistically significant improvement. Given the strong potential for confounding factors, controlled experiments are vital for robust conclusions about system performance."),"\n",r.createElement(t.hr),"\n",r.createElement(t.h2,{id:"implementations-and-deployment",style:{position:"relative"}},r.createElement(t.a,{href:"#implementations-and-deployment","aria-label":"implementations and deployment permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Implementations and deployment"),"\n",r.createElement(t.p,null,"Developing a ranker in a research environment is one challenge; deploying it at scale with low latency, continuous data updates, and real-time monitoring is another. Below are some notes on practical implementation and deployment."),"\n",r.createElement(t.h3,{id:"frameworks-and-libraries-for-learning-to-rank",style:{position:"relative"}},r.createElement(t.a,{href:"#frameworks-and-libraries-for-learning-to-rank","aria-label":"frameworks and libraries for learning to rank permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Frameworks and libraries for learning to rank"),"\n",r.createElement(t.p,null,"Many open-source libraries and platforms facilitate learning to rank:"),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"RankLib")," (part of Lemur/Indri) provides implementations for RankNet, ListNet, AdaRank, etc."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"XGBoost"),", ",r.createElement(t.strong,null,"LightGBM"),", and ",r.createElement(t.strong,null,"CatBoost")," implement specialized ranking objectives (pairwise, NDCG-based)."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"TensorFlow Ranking")," has advanced neural-based ranking tools, including listwise objectives and metrics."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"PyTorch")," is used widely for custom neural rankers, with research code for LambdaRank, SoftRank, transformer-based rankers, etc."),"\n"),"\n",r.createElement(t.h3,{id:"systems-design-for-large-scale-ranking",style:{position:"relative"}},r.createElement(t.a,{href:"#systems-design-for-large-scale-ranking","aria-label":"systems design for large scale ranking permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Systems design for large-scale ranking"),"\n",r.createElement(t.p,null,"Real-world ranking systems (e.g., a search engine) might have the following architecture:"),"\n",r.createElement(t.ol,null,"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Candidate generation"),": from a massive corpus, quickly retrieve a candidate set (using approximate nearest neighbor search, inverted indices, or specialized retrieval)."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Feature extraction"),": each candidate item is associated with a feature vector (like textual features, user behavior, or contextual signals)."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Reranking"),": a learning-to-rank model reorders the top candidates."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Post-processing"),": might add constraints or blending, ensuring certain items appear in the top results."),"\n"),"\n",r.createElement(t.p,null,"Often, the ranking model is served in a high-throughput, low-latency environment. This requires specialized infrastructure with fast inference (e.g., GPU inference for deep rankers, optimized CPU inference for tree-based models)."),"\n",r.createElement(t.h3,{id:"continuous-model-monitoring-and-updates",style:{position:"relative"}},r.createElement(t.a,{href:"#continuous-model-monitoring-and-updates","aria-label":"continuous model monitoring and updates permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Continuous model monitoring and updates"),"\n",r.createElement(t.p,null,"Ranking systems typically see non-stationary data distributions: user tastes evolve, new documents appear, old documents become irrelevant. A well-designed system may retrain or fine-tune the ranking model on fresh data every few hours or days. Monitoring pipelines ensure that key metrics (like NDCG@10 on new queries) remain stable, and that sudden distributional shifts trigger anomaly detection or reanalysis of training data."),"\n",r.createElement(t.h3,{id:"code-snippets-for-various-approaches",style:{position:"relative"}},r.createElement(t.a,{href:"#code-snippets-for-various-approaches","aria-label":"code snippets for various approaches permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Code snippets for various approaches"),"\n",r.createElement(t.p,null,"Below is a brief demonstration of how one might implement a pairwise ranking approach in Python using PyTorch. Here, I illustrate a simplified version of RankNet:"),"\n",r.createElement(l.A,{text:'\nimport torch\nimport torch.nn as nn\nimport torch.optim as optim\n\n# Hypothetical neural network ranker\nclass SimpleRankNet(nn.Module):\n    def __init__(self, input_dim, hidden_dim=64):\n        super(SimpleRankNet, self).__init__()\n        self.net = nn.Sequential(\n            nn.Linear(input_dim, hidden_dim),\n            nn.ReLU(),\n            nn.Linear(hidden_dim, 1)\n        )\n        \n    def forward(self, x):\n        # Returns the relevance score for each item\n        return self.net(x).squeeze(-1)\n\n\ndef pairwise_loss(score_i, score_j):\n    # Sigmoid pairwise loss\n    # We want score_j > score_i, so margin = score_j - score_i\n    margin = score_j - score_i\n    return torch.log1p(torch.exp(-margin))\n\n\n# Example usage:\n# Let\'s assume we have pairs of items (features_i, features_j) \n# and a label that indicates i < j in ranking\n\ninput_dim = 128\nmodel = SimpleRankNet(input_dim=input_dim)\noptimizer = optim.Adam(model.parameters(), lr=1e-3)\n\n# A toy training loop\nfor epoch in range(10):  # Just 10 epochs for demonstration\n    # Suppose we have a batch of pairs\n    # features_i, features_j are Tensors of shape [batch_size, input_dim]\n    # we also have a binary label or direct knowledge that i < j for each pair\n    \n    features_i = torch.randn(32, input_dim)  # random toy features\n    features_j = torch.randn(32, input_dim)\n    \n    # Forward pass\n    score_i = model(features_i)\n    score_j = model(features_j)\n    \n    loss = pairwise_loss(score_i, score_j).mean()\n    \n    optimizer.zero_grad()\n    loss.backward()\n    optimizer.step()\n    \n    if epoch % 2 == 0:\n        print(f"Epoch {epoch}, Loss: {loss.item():.4f}")\n'}),"\n",r.createElement(t.p,null,"And here is a brief snippet showing how you might compute a simple version of nDCG@k for a set of predictions:"),"\n",r.createElement(l.A,{text:'\nimport numpy as np\n\ndef ndcg_at_k(scores, labels, k=10):\n    """\n    scores: array of predicted scores\n    labels: array of ground truth relevances\n    both arrays of shape [num_items]\n    """\n    idx = np.argsort(scores)[::-1]  # descending sort\n    sorted_labels = labels[idx]\n    # DCG\n    dcg = 0.0\n    for i in range(min(k, len(labels))):\n        rel = sorted_labels[i]\n        dcg += (2**rel - 1) / np.log2(i + 2)  # i+2 because log2(1+1) for i=0\n    # IDCG\n    ideal_idx = np.argsort(labels)[::-1]\n    ideal_labels = labels[ideal_idx]\n    idcg = 0.0\n    for i in range(min(k, len(labels))):\n        rel = ideal_labels[i]\n        idcg += (2**rel - 1) / np.log2(i + 2)\n    return dcg / idcg if idcg > 0 else 0.0\n'}),"\n",r.createElement(t.p,null,"These examples are purely demonstrative: real-world ranking systems require more elaborate handling, especially for grouping items by query, partial labeling, and large-scale data ingestion."),"\n",r.createElement(t.hr),"\n",r.createElement(n,{alt:"High-level architecture of a ranking pipeline",path:"",caption:"A conceptual overview of candidate generation, feature extraction, and learning-to-rank reranking.",zoom:"false"}),"\n",r.createElement(t.hr),"\n",r.createElement(t.p,null,"Below, as an additional illustration, is a second snippet that might show how to set up a basic lambda-based approach in a gradient boosting context (using pseudocode rather than a specific library). The idea is that each iteration calculates a pseudo-residual incorporating a factor derived from how swapping two items in the current list affects the target metric:"),"\n",r.createElement(l.A,{text:"\n# Pseudocode sketch for one iteration of LambdaMART:\n# docs_for_query: list of docs relevant to a single query\n# current_scores: scores from the current model\n# rel_labels: the ground-truth relevance for each doc\n\nfor each doc_i, doc_j in docs_for_query:\n    if rel_labels[i] > rel_labels[j]:\n        # doc_i is more relevant than doc_j\n        S_ij = 1\n    else:\n        S_ij = -1\n    \n    # partial derivative of logistic loss\n    rho = 1.0 / (1 + exp(current_scores[doc_i] - current_scores[doc_j])) \n    lambda_ij = - S_ij * rho\n    \n    # factor for NDCG impact:\n    delta_ndcg = estimate_delta_ndcg_if_swapped(doc_i, doc_j)\n    \n    # final gradient for doc_i, doc_j\n    lambda_ij *= delta_ndcg\n    \n    # accumulate the lambdas to produce a single gradient for doc_i \n    # and doc_j used in the next tree fit\n"}),"\n",r.createElement(t.p,null,"The final line shows how ",r.createElement(t.strong,null,"LambdaRank")," modifies the gradient used in boosting by multiplying in the change in nDCG that would result from swapping the items ",r.createElement(s.A,{text:"\\( i \\)"})," and ",r.createElement(s.A,{text:"\\( j \\)"}),". This approach (plus a tree-building algorithm that fits these pseudo-residuals) is roughly how ",r.createElement(t.strong,null,"LambdaMART")," is implemented in practice."),"\n",r.createElement(t.hr),"\n",r.createElement(t.h2,{id:"optional-additional-advanced-themes",style:{position:"relative"}},r.createElement(t.a,{href:"#optional-additional-advanced-themes","aria-label":"optional additional advanced themes permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"(Optional) Additional advanced themes"),"\n",r.createElement(t.p,null,"To make this article as comprehensive as possible for an advanced ML audience, I want to highlight a few specialized topics, though they are somewhat beyond the conventional scope of a straightforward learning-to-rank introduction:"),"\n",r.createElement(t.ol,null,"\n",r.createElement(t.li,null,"\n",r.createElement(t.p,null,r.createElement(t.strong,null,"Cascaded ranking"),": Where you partially evaluate items or use smaller models in an initial stage and only apply a computationally expensive re-ranker on a smaller subset. This is crucial in large-scale systems to reduce latency."),"\n"),"\n",r.createElement(t.li,null,"\n",r.createElement(t.p,null,r.createElement(t.strong,null,"Contextual bandits for ranker optimization"),": Instead of passively collecting labeled data, an online system can explore different orderings and adapt based on user clicks. This crosses into the domain of reinforcement learning for ranking."),"\n"),"\n",r.createElement(t.li,null,"\n",r.createElement(t.p,null,r.createElement(t.strong,null,"Multi-objective ranking"),": In many applications, you want to optimize not just user relevance but also fairness, diversity, or coverage. Combining multiple objectives can be done via specialized constraints or multi-objective optimization frameworks."),"\n"),"\n",r.createElement(t.li,null,"\n",r.createElement(t.p,null,r.createElement(t.strong,null,"Counterfactual learning to rank"),": Handling biased user feedback by modeling the data generation process. For example, using inverse propensity weighting to correct for position bias."),"\n"),"\n",r.createElement(t.li,null,"\n",r.createElement(t.p,null,r.createElement(t.strong,null,"Transformer-based cross-attention rankers"),": For text-heavy ranking tasks (e.g., passage re-ranking in question answering systems), cross-attention between query and text can lead to significantly better semantic matching. Fine-tuning pretrained language models on labeled ranking data (e.g., MS MARCO) is a standard approach."),"\n"),"\n"),"\n",r.createElement(t.hr),"\n",r.createElement(t.h2,{id:"end-note",style:{position:"relative"}},r.createElement(t.a,{href:"#end-note","aria-label":"end note permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"End note"),"\n",r.createElement(t.p,null,"Learning to rank is a vibrant subfield of machine learning, bridging theoretical elegance with wide-ranging practical utility. Researchers continue to devise new metrics, optimization techniques, and approaches to handle partial or noisy labels at scale. Practitioners, meanwhile, rely on robust, proven algorithms like gradient boosted decision trees (LambdaMART) or advanced neural rankers finetuned from large pretrained models. The interplay of these approaches and the myriad of domain-specific nuances — from search engine design to e-commerce personalization — makes learning to rank a uniquely challenging and rewarding field to master."),"\n",r.createElement(t.p,null,"Whether you choose a pointwise, pairwise, or listwise approach, the success of your ranking system ultimately depends on carefully engineered features (or embeddings), well-chosen metrics (like NDCG), reliable training procedures (with the right objective function), and thoughtful evaluation (both offline and online). Through a balanced understanding of each step — from conceptual motivations to advanced distributed training strategies — you can build ranking models that profoundly impact user experience and business outcomes."),"\n",r.createElement(t.p,null,"I hope this extended tour has illuminated both the conceptual underpinnings and the practical considerations involved in learning to rank. As you progress through this advanced course, you will see how these ideas intersect with numerous other topics, from large-scale data pipelines to specialized deep neural architectures and beyond. By experimenting with the code snippets, exploring the frameworks mentioned, and staying current with the latest research, you will be well equipped to develop powerful ranking systems that meet the demands of modern applications."))}var c=function(e){void 0===e&&(e={});const{wrapper:t}=Object.assign({},(0,i.RP)(),e.components);return t?r.createElement(t,e,r.createElement(o,e)):o(e)};var m=n(36710),d=n(58481),h=n.n(d),p=n(36310),u=n(87245),g=n(27042),f=n(59849),v=n(5591),b=n(61122),E=n(9219),y=n(33203),w=n(95751),k=n(94328),x=n(80791),_=n(78137);const S=e=>{let{toc:t}=e;if(!t||!t.items)return null;return r.createElement("nav",{className:x.R},r.createElement("ul",null,t.items.map(((e,t)=>r.createElement("li",{key:t},r.createElement("a",{href:e.url,onClick:t=>((e,t)=>{e.preventDefault();const n=t.replace("#",""),a=document.getElementById(n);a&&a.scrollIntoView({behavior:"smooth",block:"start"})})(t,e.url)},e.title),e.items&&r.createElement(S,{toc:{items:e.items}}))))))};function H(e){let{data:{mdx:t,allMdx:l,allPostImages:s},children:o}=e;const{frontmatter:c,body:m,tableOfContents:d}=t,f=c.index,x=c.slug.split("/")[1],H=l.nodes.filter((e=>e.frontmatter.slug.includes(`/${x}/`))).sort(((e,t)=>e.frontmatter.index-t.frontmatter.index)),z=H.findIndex((e=>e.frontmatter.index===f)),A=H[z+1],C=H[z-1],M=c.slug.replace(/\/$/,""),T=/[^/]*$/.exec(M)[0],L=`posts/${x}/content/${T}/`,{0:N,1:P}=(0,r.useState)(c.flagWideLayoutByDefault),{0:j,1:V}=(0,r.useState)(!1);var I;(0,r.useEffect)((()=>{V(!0);const e=setTimeout((()=>V(!1)),340);return()=>clearTimeout(e)}),[N]),"adventures"===x?I=E.cb:"research"===x?I=E.Qh:"thoughts"===x&&(I=E.T6);const B=h()(m).replace(/import .*? from .*?;/g,"").replace(/<.*?>/g,"").replace(/\{\/\*[\s\S]*?\*\/\}/g,"").trim().split(/\s+/).length,q=function(e){if(e<=10)return"~10 min";if(e<=20)return"~20 min";if(e<=30)return"~30 min";if(e<=40)return"~40 min";if(e<=50)return"~50 min";if(e<=60)return"~1 h";const t=Math.floor(e/60),n=e%60;return n<=30?`~${t}${n>0?".5":""} h`:`~${t+1} h`}(Math.ceil(B/I)+(c.extraReadTimeMin||0)),G=[{flag:c.flagDraft,component:()=>Promise.all([n.e(3231),n.e(8809)]).then(n.bind(n,28809))},{flag:c.flagMindfuckery,component:()=>Promise.all([n.e(3231),n.e(2471)]).then(n.bind(n,67709))},{flag:c.flagRewrite,component:()=>Promise.all([n.e(3231),n.e(6764)]).then(n.bind(n,62002))},{flag:c.flagOffensive,component:()=>Promise.all([n.e(3231),n.e(2443)]).then(n.bind(n,17681))},{flag:c.flagProfane,component:()=>Promise.all([n.e(3231),n.e(8048)]).then(n.bind(n,53286))},{flag:c.flagMultilingual,component:()=>Promise.all([n.e(3231),n.e(4069)]).then(n.bind(n,78831))},{flag:c.flagUnreliably,component:()=>Promise.all([n.e(3231),n.e(3417)]).then(n.bind(n,8179))},{flag:c.flagPolitical,component:()=>Promise.all([n.e(3231),n.e(5195)]).then(n.bind(n,30433))},{flag:c.flagCognitohazard,component:()=>Promise.all([n.e(3231),n.e(3175)]).then(n.bind(n,8413))},{flag:c.flagHidden,component:()=>Promise.all([n.e(3231),n.e(9556)]).then(n.bind(n,14794))}],{0:R,1:D}=(0,r.useState)([]);return(0,r.useEffect)((()=>{G.forEach((e=>{let{flag:t,component:n}=e;t&&n().then((e=>{D((t=>[].concat((0,a.A)(t),[e.default])))}))}))}),[]),r.createElement(g.P.div,{initial:{opacity:0},animate:{opacity:1},exit:{opacity:0},transition:{duration:.15}},r.createElement(v.A,{postNumber:c.index,date:c.date,updated:c.updated,readTime:q,difficulty:c.difficultyLevel,title:c.title,desc:c.desc,banner:c.banner,section:x,postKey:T,isMindfuckery:c.flagMindfuckery,mainTag:c.mainTag}),r.createElement("div",{style:{display:"flex",justifyContent:"flex-end",flexWrap:"wrap",maxWidth:"75%",marginLeft:"auto",paddingRight:"1vw",marginTop:"-6vh",marginBottom:"4vh"}},c.otherTags.map(((e,t)=>r.createElement("span",{key:t,className:`noselect ${_.MW}`,style:{margin:"0 5px 5px 0"}},e)))),r.createElement("div",{className:"postBody"},r.createElement(S,{toc:d})),r.createElement("br"),r.createElement("div",{style:{margin:"0 10% -2vh 30%",textAlign:"right"}},r.createElement(g.P.button,{className:`noselect ${k.pb}`,id:k.xG,onClick:()=>{P(!N)},whileTap:{scale:.93}},r.createElement(g.P.div,{className:w.DJ,key:N,initial:{opacity:0},animate:{opacity:1},exit:{opacity:0},transition:{duration:.3,ease:"easeInOut"}},N?"Switch to default layout":"Switch to wide layout"))),r.createElement("br"),r.createElement("div",{className:"postBody",style:{margin:N?"0 -14%":"",maxWidth:N?"200%":"",transition:"margin 1s ease, max-width 1s ease, padding 1s ease"}},r.createElement("div",{className:`${k.P_} ${j?k.Xn:k.qG}`},R.map(((e,t)=>r.createElement(e,{key:t}))),c.indexCourse?r.createElement(y.A,{index:c.indexCourse,category:c.courseCategoryName}):"",r.createElement(p.Z.Provider,{value:{images:s.nodes,basePath:L.replace(/\/$/,"")+"/"}},r.createElement(i.xA,{components:{Image:u.A}},o)))),r.createElement(b.A,{nextPost:A,lastPost:C,keyCurrent:T,section:x}))}function z(e){return r.createElement(H,e,r.createElement(c,e))}function A(e){var t,n,a,i,l;let{data:s}=e;const{frontmatter:o}=s.mdx,c=o.titleSEO||o.title,d=o.titleOG||c,h=o.titleTwitter||c,p=o.descSEO||o.desc,u=o.descOG||p,g=o.descTwitter||p,v=o.schemaType||"BlogPosting",b=o.keywordsSEO,E=o.date,y=o.updated||E,w=o.imageOG||(null===(t=o.banner)||void 0===t||null===(n=t.childImageSharp)||void 0===n||null===(a=n.gatsbyImageData)||void 0===a||null===(i=a.images)||void 0===i||null===(l=i.fallback)||void 0===l?void 0:l.src),k=o.imageAltOG||u,x=o.imageTwitter||w,_=o.imageAltTwitter||g,S=o.canonicalURL,H=o.flagHidden||!1,z=o.mainTag||"Posts",A=o.slug.split("/")[1]||"posts",{siteUrl:C}=(0,m.Q)(),M={"@context":"https://schema.org","@type":"BreadcrumbList",itemListElement:[{"@type":"ListItem",position:1,name:"Home",item:C},{"@type":"ListItem",position:2,name:z,item:`${C}/${o.slug.split("/")[1]}`},{"@type":"ListItem",position:3,name:c,item:`${C}${o.slug}`}]};return r.createElement(f.A,{title:c+" - avrtt.blog",titleOG:d,titleTwitter:h,description:p,descriptionOG:u,descriptionTwitter:g,schemaType:v,keywords:b,datePublished:E,dateModified:y,imageOG:w,imageAltOG:k,imageTwitter:x,imageAltTwitter:_,canonicalUrl:S,flagHidden:H,mainTag:z,section:A,type:"article"},r.createElement("script",{type:"application/ld+json"},JSON.stringify(M)))}},96098:function(e,t,n){var a=n(96540),i=n(7978);t.A=e=>{let{text:t}=e;return a.createElement(i.A,null,t)}}}]);
//# sourceMappingURL=component---src-templates-post-js-content-file-path-src-pages-posts-research-learning-to-rank-mdx-cb2f560d624ee6926abb.js.map