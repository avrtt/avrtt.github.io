"use strict";(self.webpackChunkavrtt_blog=self.webpackChunkavrtt_blog||[]).push([[2724],{3962:function(e,t){t.A="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iaXNvLTg4NTktMSI/Pgo8IS0tIEdlbmVyYXRvcjogQWRvYmUgSWxsdXN0cmF0b3IgMTYuMC4wLCBTVkcgRXhwb3J0IFBsdWctSW4gLiBTVkcgVmVyc2lvbjogNi4wMCBCdWlsZCAwKSAgLS0+CjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+CjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iQ2FwYV8xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4PSIwcHgiIHk9IjBweCIKCSB3aWR0aD0iNDE2Ljk3OXB4IiBoZWlnaHQ9IjQxNi45NzlweCIgdmlld0JveD0iMCAwIDQxNi45NzkgNDE2Ljk3OSIgc3R5bGU9ImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgNDE2Ljk3OSA0MTYuOTc5OyIKCSB4bWw6c3BhY2U9InByZXNlcnZlIj4KPGc+Cgk8cGF0aCBkPSJNMzU2LjAwNCw2MS4xNTZjLTgxLjM3LTgxLjQ3LTIxMy4zNzctODEuNTUxLTI5NC44NDgtMC4xODJjLTgxLjQ3LDgxLjM3MS04MS41NTIsMjEzLjM3OS0wLjE4MSwyOTQuODUKCQljODEuMzY5LDgxLjQ3LDIxMy4zNzgsODEuNTUxLDI5NC44NDksMC4xODFDNDM3LjI5MywyNzQuNjM2LDQzNy4zNzUsMTQyLjYyNiwzNTYuMDA0LDYxLjE1NnogTTIzNy42LDM0MC43ODYKCQljMCwzLjIxNy0yLjYwNyw1LjgyMi01LjgyMiw1LjgyMmgtNDYuNTc2Yy0zLjIxNSwwLTUuODIyLTIuNjA1LTUuODIyLTUuODIyVjE2Ny44ODVjMC0zLjIxNywyLjYwNy01LjgyMiw1LjgyMi01LjgyMmg0Ni41NzYKCQljMy4yMTUsMCw1LjgyMiwyLjYwNCw1LjgyMiw1LjgyMlYzNDAuNzg2eiBNMjA4LjQ5LDEzNy45MDFjLTE4LjYxOCwwLTMzLjc2Ni0xNS4xNDYtMzMuNzY2LTMzLjc2NQoJCWMwLTE4LjYxNywxNS4xNDctMzMuNzY2LDMzLjc2Ni0zMy43NjZjMTguNjE5LDAsMzMuNzY2LDE1LjE0OCwzMy43NjYsMzMuNzY2QzI0Mi4yNTYsMTIyLjc1NSwyMjcuMTA3LDEzNy45MDEsMjA4LjQ5LDEzNy45MDF6Ii8+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPC9zdmc+Cg=="},9831:function(e,t,n){n.r(t),n.d(t,{Head:function(){return T},PostTemplate:function(){return I},default:function(){return D}});var a=n(54506),i=n(28453),l=n(96540),r=n(66501),s=n(16886),o=(n(46295),n(96098));function c(e){const t=Object.assign({p:"p",ul:"ul",li:"li",h2:"h2",a:"a",span:"span",ol:"ol",strong:"strong",h3:"h3",hr:"hr",em:"em"},(0,i.RP)(),e.components);return l.createElement(l.Fragment,null,"\n",l.createElement("br"),"\n","\n","\n",l.createElement(t.p,null,"Density-based clustering is an influential paradigm in unsupervised learning that has been widely utilized across various fields, such as computer vision, geospatial analysis, anomaly detection, astronomy, and more. Unlike partition-based clustering algorithms (e.g., ",l.createElement(o.A,{text:"\\(k\\)"}),'-means) or hierarchical methods, density-based approaches focus on identifying "dense" regions in the data space, treating regions of lower density as separators between clusters or as potential outliers. When properly applied, density-based clustering can seamlessly uncover clusters of arbitrary shapes — including complex, nonconvex patterns — while simultaneously handling noise in a naturally integrated fashion.'),"\n",l.createElement(t.p,null,"This article focuses on two canonical density-based clustering techniques: ",l.createElement(s.A,null,"DBSCAN")," (Density-Based Spatial Clustering of Applications with Noise) and ",l.createElement(s.A,null,"OPTICS")," (Ordering Points to Identify the Clustering Structure). Both have become core components in advanced machine learning pipelines and continue to be subjects of active research. By the end of this reading, you should be able to:"),"\n",l.createElement(t.ul,null,"\n",l.createElement(t.li,null,"Comprehend the primary motivations behind density-based clustering;"),"\n",l.createElement(t.li,null,"Differentiate between density-based clustering and other mainstream clustering approaches such as ",l.createElement(o.A,{text:"\\(k\\)"}),"-means, hierarchical clustering, and Gaussian mixture models;"),"\n",l.createElement(t.li,null,"Understand the internal mechanisms of DBSCAN, including the critical concepts of core points, border points, noise points, and the essential parameters (",l.createElement(o.A,{text:"\\(\\epsilon\\)"})," and ",l.createElement(o.A,{text:"\\( \\text{minPts} \\)"}),");"),"\n",l.createElement(t.li,null,"Learn how to implement DBSCAN step by step, interpret its results, and tune it for specific datasets;"),"\n",l.createElement(t.li,null,"Understand the design principles behind OPTICS, how it is an extension of DBSCAN that gracefully handles varying-density clusters, and how to interpret its famous reachability plot;"),"\n",l.createElement(t.li,null,"Compare DBSCAN and OPTICS in terms of algorithmic complexity, parameter sensitivity, and performance in the presence of varying density regions."),"\n"),"\n",l.createElement(t.p,null,"Throughout this article, we aim to clarify even the more intricate or subtle aspects of these algorithms while preserving a relatively informal tone. Whenever beneficial, we will highlight relevant theoretical and practical points. We will also refer to seminal and modern research papers (e.g., Ester and gang, KDD 1996; Ankerst and gang, SIGMOD 1999; Campello and gang, JMLR 2013; Schubert and gang, KDD 2017; Schubert and gang, ICML 2021), elaborating on how density-based methods have evolved and remain at the forefront of clustering research. We will provide Python code snippets demonstrating fundamental implementations, as well as placeholders for illustrative figures where appropriate."),"\n",l.createElement(t.p,null,"Moreover, for those exploring advanced data science topics and the specialized intricacies of density-based techniques, we will offer references to variations and extensions, including ",l.createElement(s.A,null,"HDBSCAN")," (Hierarchical DBSCAN) and extended versions of OPTICS, as well as practical tips for managing large-scale and high-dimensional datasets. For instance, many real-world use cases require special data structures (e.g., KD-trees, ball trees, or approximate nearest neighbor indices) to attain acceptable performance, particularly as data sizes surpass millions of points."),"\n",l.createElement(t.p,null,"We will begin by surveying the fundamentals of density-based clustering, explaining how it contrasts with other paradigms and clarifying its unique features and use cases. We will then dive into DBSCAN in depth, covering everything from the theoretical underpinnings to typical parameter-tuning heuristics. Next, we shift focus to OPTICS, highlighting its conceptual similarities with DBSCAN but also its ability to handle variable densities more gracefully. Finally, we will compare DBSCAN and OPTICS with an eye toward how they scale, how they treat outliers, and how they respond to different types of data distributions."),"\n",l.createElement(t.p,null,"Let's jump right in."),"\n",l.createElement("br"),"\n",l.createElement(t.h2,{id:"2-fundamentals-of-density-based-clustering",style:{position:"relative"}},l.createElement(t.a,{href:"#2-fundamentals-of-density-based-clustering","aria-label":"2 fundamentals of density based clustering permalink",className:"anchor before"},l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"2. Fundamentals of density-based clustering"),"\n",l.createElement(t.p,null,"Density-based clustering stems from the idea that clusters are contiguous regions of high density separated by contiguous regions of low density. In other words, if you can draw a continuous path from one point to another that stays within dense regions, then those points should reside in the same cluster. This general notion stands in stark contrast to many other clustering paradigms:"),"\n",l.createElement(t.ol,null,"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"Partition-based clustering")," (e.g., ",l.createElement(o.A,{text:"\\(k\\)"}),"-means) relies on iterative updates of cluster centers, encouraging spherical or convex cluster shapes around centroids. It requires specifying the number of clusters ",l.createElement(o.A,{text:"\\(k\\)"})," in advance and often breaks down for nonconvex clusters, intricate cluster shapes, or heavy outlier presence."),"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"Hierarchical clustering")," begins by either recursively merging or splitting clusters. Although it can reveal multilevel data structure, it also suffers from inefficiencies when ",l.createElement(o.A,{text:"\\(N\\)"}),' (the number of data points) is very large; moreover, it does not have a straightforward "noise" concept unless specifically adapted.'),"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"Model-based methods")," (e.g., Gaussian mixture models) assume that data originates from known parametric distributions and typically aim to estimate the parameters via maximum likelihood or Bayesian inference. Density-based methods, in contrast, do not require distributional assumptions about the data."),"\n"),"\n",l.createElement(t.p,null,"Common to all density-based methods is the notion of a ",l.createElement(s.A,null,"local density threshold"),". Points that surpass this threshold are grouped together, forming dense regions. These dense regions correspond to clusters, and any points that do not belong to any such dense region are treated as potential noise or outliers. This approach is extremely effective when:"),"\n",l.createElement(t.ul,null,"\n",l.createElement(t.li,null,"The cluster shapes are complex (e.g., curved manifolds, nested structures, varying densities);"),"\n",l.createElement(t.li,null,"You wish to automatically detect outliers without a separate anomaly detection step;"),"\n",l.createElement(t.li,null,"The data may contain large swathes of empty or sparse regions that partition the clusters naturally."),"\n"),"\n",l.createElement(t.p,null,'Due to these strengths, density-based algorithms remain popular in a wide range of tasks, such as geospatial data clustering (identifying dense populated areas vs. unpopulated or low-density regions), image segmentation, and web user behavior grouping (where some users might form highly dense usage patterns, while others remain more "distant").'),"\n",l.createElement(t.p,null,"Still, density-based methods have their own caveats. Standard DBSCAN, for instance, uses fixed global parameters ",l.createElement(o.A,{text:"\\(\\epsilon\\)"})," (neighborhood radius) and ",l.createElement(o.A,{text:"\\( \\text{minPts} \\)"})," (minimum number of points to form a dense region). If the data exhibits clusters with widely differing densities, a single global threshold may not suffice, leading to under- or over-segmentation. This is precisely where algorithms like ",l.createElement(s.A,null,"OPTICS")," and ",l.createElement(s.A,null,"HDBSCAN")," come in."),"\n",l.createElement("br"),"\n",l.createElement(t.h2,{id:"3-dbscan",style:{position:"relative"}},l.createElement(t.a,{href:"#3-dbscan","aria-label":"3 dbscan permalink",className:"anchor before"},l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"3. DBSCAN"),"\n",l.createElement(t.p,null,"DBSCAN (",l.createElement(s.A,null,"D"),"ensity-",l.createElement(s.A,null,"B"),"ased ",l.createElement(s.A,null,"S"),"patial ",l.createElement(s.A,null,"C"),"lustering of ",l.createElement(s.A,null,"A"),"pplications with ",l.createElement(s.A,null,"N"),"oise) was introduced in a seminal paper by Ester, Kriegel, Sander, and Xu at KDD 1996. It remains one of the most widely implemented clustering methods in many libraries, including scikit-learn (",l.createElement(r.A,{text:"scikit-learn's DBSCAN is in sklearn.cluster.DBSCAN"}),"), R's dbscan package, and others."),"\n",l.createElement(t.p,null,"Conceptually, DBSCAN divides the data points into the following categories:"),"\n",l.createElement(t.ul,null,"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"Core points"),": Points that lie in particularly dense neighborhoods."),"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"Border points"),": Points that are not necessarily dense themselves but are within the neighborhood of a core point."),"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"Noise (outlier) points"),": Points that do not belong to any cluster."),"\n"),"\n",l.createElement(t.p,null,"Once these categories are established, DBSCAN groups core points and border points connected via dense regions into the same cluster, and labels other points as noise."),"\n",l.createElement(t.h3,{id:"31-neighborhood-definition-and-distance-metrics",style:{position:"relative"}},l.createElement(t.a,{href:"#31-neighborhood-definition-and-distance-metrics","aria-label":"31 neighborhood definition and distance metrics permalink",className:"anchor before"},l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"3.1. Neighborhood definition and distance metrics"),"\n",l.createElement(t.p,null,"DBSCAN first requires defining a neighborhood of a point ",l.createElement(o.A,{text:"\\( x \\)"}),". Typically, an ",l.createElement(o.A,{text:"\\(\\epsilon\\)"}),"-neighborhood for point ",l.createElement(o.A,{text:"\\( x \\)"})," is the set of points within a radius ",l.createElement(o.A,{text:"\\(\\epsilon\\)"})," (with respect to some distance function ",l.createElement(o.A,{text:"\\(\\rho\\)"}),") of ",l.createElement(o.A,{text:"\\( x \\)"}),":"),"\n",l.createElement(o.A,{text:"\\[\nE_\\epsilon(x) = \\{ y \\mid \\rho(x, y) \\leq \\epsilon \\}.\n\\]"}),"\n",l.createElement(t.ul,null,"\n",l.createElement(t.li,null,l.createElement(o.A,{text:"\\(\\rho(\\cdot,\\cdot)\\)"})," can be any metric, such as Euclidean, Manhattan, Minkowski, or even specialized domain-specific metrics (e.g., edit distance for text)."),"\n",l.createElement(t.li,null,"In high-dimensional scenarios, using Euclidean distance might be less informative (due to the ",l.createElement(s.A,null,"curse of dimensionality"),"), so alternative metrics or dimension-reduction pre-processing is sometimes applied."),"\n"),"\n",l.createElement(t.p,null,"Depending on the data type, DBSCAN's performance hinges on efficient retrieval of the points in ",l.createElement(o.A,{text:"\\( E_\\epsilon(x) \\)"}),". Data structures like KD-trees and ball trees often help accelerate neighborhood queries from ",l.createElement(o.A,{text:"\\(O(N)\\)"})," per query to about ",l.createElement(o.A,{text:"\\(O(\\log N)\\)"})," per query in many practical situations."),"\n",l.createElement("br"),"\n",l.createElement(t.h3,{id:"32-core-points-border-points-and-noise-points",style:{position:"relative"}},l.createElement(t.a,{href:"#32-core-points-border-points-and-noise-points","aria-label":"32 core points border points and noise points permalink",className:"anchor before"},l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"3.2. Core points, border points, and noise points"),"\n",l.createElement(t.p,null,"Two hyperparameters are key to DBSCAN:"),"\n",l.createElement(t.ol,null,"\n",l.createElement(t.li,null,l.createElement(o.A,{text:"\\(\\epsilon\\)"})," (",l.createElement(o.A,{text:"\\( \\varepsilon \\)"}),") – the radius of the neighborhood;"),"\n",l.createElement(t.li,null,l.createElement(o.A,{text:"\\( \\text{minPts} \\)"})," – the minimum number of neighbors (including the point itself) required to declare a point as ",l.createElement(s.A,null,"core"),"."),"\n"),"\n",l.createElement(t.p,null,l.createElement(t.strong,null,"Core point"),": A point ",l.createElement(o.A,{text:"\\( x \\)"})," is called a core point if:"),"\n",l.createElement(o.A,{text:"\\[\n|E_\\epsilon(x)| \\geq \\text{minPts}.\n\\]"}),"\n",l.createElement(t.p,null,"Here, ",l.createElement(o.A,{text:"\\(\\lvert E_\\epsilon(x) \\rvert\\)"})," denotes the number of points in the ",l.createElement(o.A,{text:"\\(\\epsilon\\)"}),"-neighborhood of ",l.createElement(o.A,{text:"\\( x \\)"}),"."),"\n",l.createElement(t.p,null,l.createElement(t.strong,null,"Border point"),": A point ",l.createElement(o.A,{text:"\\( x \\)"})," is labeled as border if ",l.createElement(o.A,{text:"\\(\\lvert E_\\epsilon(x) \\rvert < \\text{minPts}\\)"})," but it is within the ",l.createElement(o.A,{text:"\\(\\epsilon\\)"}),'-neighborhood of a core point. Intuitively, border points are not individually dense enough to start their own clusters but can be "reached" from a dense region.'),"\n",l.createElement(t.p,null,l.createElement(t.strong,null,"Noise point"),": A point is labeled as noise (outlier) if it is neither a core point nor a border point. It does not satisfy the density criteria, nor does it belong to the neighborhood of a core point."),"\n",l.createElement("br"),"\n",l.createElement(t.h3,{id:"33-impact-of-eps-and-minpts-parameters",style:{position:"relative"}},l.createElement(t.a,{href:"#33-impact-of-eps-and-minpts-parameters","aria-label":"33 impact of eps and minpts parameters permalink",className:"anchor before"},l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"3.3. Impact of eps and minPts parameters"),"\n",l.createElement(t.p,null,"The parameters ",l.createElement(o.A,{text:"\\(\\epsilon\\)"})," and ",l.createElement(o.A,{text:"\\( \\text{minPts} \\)"})," collectively define how strict or lenient DBSCAN is in forming clusters:"),"\n",l.createElement(t.ul,null,"\n",l.createElement(t.li,null,"If ",l.createElement(o.A,{text:"\\(\\epsilon\\)"})," is very large and ",l.createElement(o.A,{text:"\\( \\text{minPts} \\)"})," is very small, the algorithm tends to lump many points into a single cluster (large neighborhood radius, small density requirement). This risks merging distinct clusters and drastically reducing the count of outliers."),"\n",l.createElement(t.li,null,"If ",l.createElement(o.A,{text:"\\(\\epsilon\\)"})," is very small or ",l.createElement(o.A,{text:"\\( \\text{minPts} \\)"})," is very large, DBSCAN might find many points to be outliers (strict density criteria), potentially fracturing what should be single clusters or labeling almost everything as noise."),"\n"),"\n",l.createElement(t.p,null,"The sweet spot often depends on domain knowledge: if the typical pairwise distance between data points is known or if an expected minimal cluster density can be estimated, these guidelines help in choosing ",l.createElement(o.A,{text:"\\(\\epsilon\\)"})," and ",l.createElement(o.A,{text:"\\( \\text{minPts} \\)"}),". Many practitioners rely on plotting the distance to the ",l.createElement(o.A,{text:"\\(k\\)"}),'-th nearest neighbor (e.g., the "k-distance graph") and looking for an "elbow," a common heuristic also recommended by authors such as Ertoz and gang (SDM 2003) and others.'),"\n",l.createElement("br"),"\n",l.createElement(t.h3,{id:"34-step-by-step-outline",style:{position:"relative"}},l.createElement(t.a,{href:"#34-step-by-step-outline","aria-label":"34 step by step outline permalink",className:"anchor before"},l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"3.4. Step-by-step outline"),"\n",l.createElement(t.p,null,"DBSCAN proceeds in the following conceptual steps (pseudocode adapted from Ester and gang, KDD 1996):"),"\n",l.createElement(t.ol,null,"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"Initialization"),': Mark all points as "unvisited."'),"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"Iteration"),": For each unvisited point ",l.createElement(o.A,{text:"\\(P\\)"}),":","\n",l.createElement(t.ol,null,"\n",l.createElement(t.li,null,"Mark ",l.createElement(o.A,{text:"\\(P\\)"})," as visited."),"\n",l.createElement(t.li,null,"Retrieve the ",l.createElement(o.A,{text:"\\(\\epsilon\\)"}),"-neighborhood of ",l.createElement(o.A,{text:"\\(P\\)"}),". If ",l.createElement(o.A,{text:"\\(\\lvert E_\\epsilon(P) \\rvert < \\text{minPts}\\)"}),", mark ",l.createElement(o.A,{text:"\\(P\\)"})," as noise. (This label might later be overridden if ",l.createElement(o.A,{text:"\\(P\\)"})," is found to be within the neighborhood of a core point.)"),"\n",l.createElement(t.li,null,"If ",l.createElement(o.A,{text:"\\(P\\)"})," is a core point (",l.createElement(o.A,{text:"\\(\\lvert E_\\epsilon(P) \\rvert \\geq \\text{minPts}\\)"}),"):","\n",l.createElement(t.ol,null,"\n",l.createElement(t.li,null,"Create a new cluster and add ",l.createElement(o.A,{text:"\\(P\\)"})," to this cluster."),"\n",l.createElement(t.li,null,"Expand the cluster by recursively adding all points in ",l.createElement(o.A,{text:"\\(P\\)"}),"'s neighborhood that are either unvisited core points or border points. Continue until no new points can be added."),"\n"),"\n"),"\n"),"\n"),"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"Result"),": All points are now either assigned to a cluster or designated as noise."),"\n"),"\n",l.createElement(t.p,null,"An important detail is how border points are handled if they are within the ",l.createElement(o.A,{text:"\\(\\epsilon\\)"}),'-neighborhoods of multiple distinct clusters. By design, DBSCAN will assign a border point to whichever cluster first expands into it. Because border points cannot "expand" a cluster further (they are not core points themselves), it is quite rare for this assignment to cause large-scale changes in the final clusters. As a result, many implementations of DBSCAN accept this small level of nondeterminism for performance efficiency.'),"\n",l.createElement("br"),"\n",l.createElement(t.h3,{id:"35-implementation",style:{position:"relative"}},l.createElement(t.a,{href:"#35-implementation","aria-label":"35 implementation permalink",className:"anchor before"},l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"3.5. Implementation"),"\n",l.createElement(t.p,null,"Below is a short, illustrative Python-like code snippet. While not fully optimized for production, it conveys the core logic of DBSCAN in a straightforward manner. Please note the usage of ",l.createElement(s.A,null,"regionQuery")," to find all neighbors within distance ",l.createElement(o.A,{text:"\\(\\epsilon\\)"}),". In practice, you would accelerate queries with specialized spatial data structures."),"\n",l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">&lt;Code text={`\nimport numpy as np\n\ndef dbscan(points, eps, minPts, distance_func):\n    """\n    A naive DBSCAN implementation.\n    \n    :param points: List (or array) of points in the dataset.\n    :param eps: Neighborhood radius.\n    :param minPts: Minimum number of points to form a dense region.\n    :param distance_func: Function that computes distance between two points.\n    :return: A list \'labels\' where each index corresponds to the cluster label\n             for each point (or -1 for noise).\n    """\n    NOISE = -1\n    n = len(points)\n    labels = [None] * n   # Cluster labels initialized to None\n    current_cluster = 0\n    visited = [False] * n\n    \n    def region_query(idx):\n        neighbors = []\n        for i in range(n):\n            if distance_func(points[idx], points[i]) &lt;= eps:\n                neighbors.append(i)\n        return neighbors\n    \n    for idx in range(n):\n        if not visited[idx]:\n            visited[idx] = True\n            neighbors = region_query(idx)\n            if len(neighbors) &lt; minPts:\n                labels[idx] = NOISE\n            else:\n                current_cluster += 1\n                # Expand cluster\n                labels[idx] = current_cluster\n                queue = list(neighbors)\n                while queue:\n                    neighbor_idx = queue.pop()\n                    if not visited[neighbor_idx]:\n                        visited[neighbor_idx] = True\n                        nbrs = region_query(neighbor_idx)\n                        if len(nbrs) >= minPts:\n                            queue.extend(nbrs)\n                    if labels[neighbor_idx] is None:\n                        labels[neighbor_idx] = current_cluster\n                        \n    return labels\n`}/></code></pre></div>'}}),"\n",l.createElement(t.p,null,l.createElement(t.strong,null,"Notes"),":"),"\n",l.createElement(t.ul,null,"\n",l.createElement(t.li,null,"The above code uses an ",l.createElement(o.A,{text:"\\(O(N^2)\\)"})," approach to finding neighbors, which is suitable only for relatively small datasets. For larger datasets, it is critical to use an index structure (e.g., ",l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">sklearn.neighbors.BallTree</code>'}})," or ",l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">sklearn.neighbors.KDTree</code>'}}),") or approximate nearest neighbor libraries like ",l.createElement(s.A,null,"FAISS")," (Facebook AI Similarity Search) or ",l.createElement(s.A,null,"Annoy")," to reduce the query time."),"\n",l.createElement(t.li,null,'The "visited" array is crucial to avoid processing the same point multiple times.'),"\n"),"\n",l.createElement("br"),"\n",l.createElement(t.h3,{id:"36-complexity-analysis",style:{position:"relative"}},l.createElement(t.a,{href:"#36-complexity-analysis","aria-label":"36 complexity analysis permalink",className:"anchor before"},l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"3.6. Complexity analysis"),"\n",l.createElement(t.p,null,"The best-case time complexity of DBSCAN can be ",l.createElement(o.A,{text:"\\(O(N \\log N)\\)"})," if efficient data structures (e.g., KD-tree) are used for neighbor searches, and if the data distribution does not degenerate into worst-case scenarios. In practice, many common data distributions allow DBSCAN to achieve sub-quadratic performance. However, the worst case can reach ",l.createElement(o.A,{text:"\\(O(N^2)\\)"}),", especially if:"),"\n",l.createElement(t.ol,null,"\n",l.createElement(t.li,null,"The dimensionality is high, making spatial trees less effective."),"\n",l.createElement(t.li,null,"The dataset is large but not organized in ways that typical tree-based indices can exploit (e.g., points are all near each other or in artificially structured distributions)."),"\n",l.createElement(t.li,null,'A naive "double loop" approach is used without any indexing.'),"\n"),"\n",l.createElement(t.p,null,"Memory usage can also vary. Some naive implementations store a complete distance matrix of size ",l.createElement(o.A,{text:"\\(O(N^2)\\)"}),". More optimized implementations compute neighborhoods on-the-fly. Libraries like scikit-learn allow you to pass a parameter specifying the indexing structure or to supply a precomputed distance matrix."),"\n",l.createElement("br"),"\n",l.createElement(t.h3,{id:"37-parameter-tuning-strategies",style:{position:"relative"}},l.createElement(t.a,{href:"#37-parameter-tuning-strategies","aria-label":"37 parameter tuning strategies permalink",className:"anchor before"},l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"3.7. Parameter tuning strategies"),"\n",l.createElement(t.p,null,"Choosing good values for ",l.createElement(o.A,{text:"\\(\\epsilon\\)"})," and ",l.createElement(o.A,{text:"\\( \\text{minPts} \\)"})," is often dataset-specific. However, a common heuristic is:"),"\n",l.createElement(t.ol,null,"\n",l.createElement(t.li,null,"Select a small integer for ",l.createElement(o.A,{text:"\\( \\text{minPts} \\)"})," (often between 3 and 10) based on your expectation of how dense a valid cluster must be."),"\n",l.createElement(t.li,null,"For each point, compute the distance to its ",l.createElement(o.A,{text:"\\( \\text{minPts} \\)"}),"-th nearest neighbor."),"\n",l.createElement(t.li,null,'Plot these distances in ascending order. Look for a "knee" or "elbow" in the plot — that distance is a good starting point for ',l.createElement(o.A,{text:"\\(\\epsilon\\)"}),"."),"\n"),"\n",l.createElement(t.p,null,"This approach was popularized by ",l.createElement(t.strong,null,"Ester and gang (KDD 1996)"),' and has been widely adapted. That said, in real-world scenarios, the "elbow" might not always be obvious, and domain knowledge might be needed for a final check.'),"\n",l.createElement("br"),"\n",l.createElement(t.h3,{id:"38-handling-high-dimensional-data",style:{position:"relative"}},l.createElement(t.a,{href:"#38-handling-high-dimensional-data","aria-label":"38 handling high dimensional data permalink",className:"anchor before"},l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"3.8. Handling high-dimensional data"),"\n",l.createElement(t.p,null,"In higher dimensions, Euclidean distance can become less meaningful, and all points may appear roughly equidistant from each other (",l.createElement(s.A,null,"curse of dimensionality"),"). If you want to apply DBSCAN in high dimensions:"),"\n",l.createElement(t.ol,null,"\n",l.createElement(t.li,null,"Consider dimension reduction techniques such as ",l.createElement(t.strong,null,"PCA"),", ",l.createElement(t.strong,null,"t-SNE"),", or ",l.createElement(t.strong,null,"UMAP")," to project data into a lower-dimensional space where density-based methods are more discriminative."),"\n",l.createElement(t.li,null,"Use specialized metrics that align better with your domain. For example, in text analysis, you might employ cosine similarity instead of Euclidean distance."),"\n",l.createElement(t.li,null,"Evaluate advanced indexing approaches or rely on approximate neighbor search to keep computations feasible, especially when ",l.createElement(o.A,{text:"\\(N\\)"})," is large (in the range of hundreds of thousands or millions)."),"\n"),"\n",l.createElement("br"),"\n",l.createElement(t.h3,{id:"39-limitations-and-variations-of-dbscan",style:{position:"relative"}},l.createElement(t.a,{href:"#39-limitations-and-variations-of-dbscan","aria-label":"39 limitations and variations of dbscan permalink",className:"anchor before"},l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"3.9. Limitations and variations of DBSCAN"),"\n",l.createElement(t.p,null,l.createElement(t.strong,null,"Limitations"),":"),"\n",l.createElement(t.ul,null,"\n",l.createElement(t.li,null,"DBSCAN uses a global radius ",l.createElement(o.A,{text:"\\(\\epsilon\\)"}),". If the dataset contains clusters of very different densities, a single ",l.createElement(o.A,{text:"\\(\\epsilon\\)"})," may cause either over-merging or fragmentation of clusters."),"\n",l.createElement(t.li,null,"In borderline scenarios where clusters are close to each other, DBSCAN might incorrectly connect them if an ",l.createElement(o.A,{text:"\\(\\epsilon\\)"}),'-"bridge" of sufficient density exists.'),"\n",l.createElement(t.li,null,"Parameter selection can be non-trivial, especially in high-dimensional data or data with large density variations."),"\n"),"\n",l.createElement(t.p,null,l.createElement(t.strong,null,"Variations"),":"),"\n",l.createElement(t.ul,null,"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"HDBSCAN")," (Hierarchical DBSCAN): This extension (Campello and gang, JMLR 2013; McInnes and gang, 2017) addresses the issue of varying density by building a hierarchy of clusters. Then, a stability measure is used to extract a flat clustering from the hierarchical tree. HDBSCAN typically requires fewer parameters and can produce better results across a range of densities."),"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"Varying ",l.createElement(o.A,{text:"\\(\\epsilon\\)"}),"-DBSCAN"),": Some proposals adapt ",l.createElement(o.A,{text:"\\(\\epsilon\\)"})," regionally, but this introduces more complexity and additional parameters or heuristics."),"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"Parallel DBSCAN"),": On very large datasets, parallel or distributed implementations exist (e.g., using Spark), but care must be taken when merging subclusters found in different data partitions."),"\n"),"\n",l.createElement("br"),"\n",l.createElement(t.h2,{id:"4-optics",style:{position:"relative"}},l.createElement(t.a,{href:"#4-optics","aria-label":"4 optics permalink",className:"anchor before"},l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"4. OPTICS"),"\n",l.createElement(t.p,null,l.createElement(s.A,null,"OPTICS")," (Ordering Points to Identify the Clustering Structure) was introduced by Ankerst, Breunig, Kriegel, and Sander (SIGMOD 1999) as a next-generation solution to some of DBSCAN's most pressing limitations. While OPTICS uses the same overall notion of density-based clustering, it addresses the issue of finding a single global ",l.createElement(o.A,{text:"\\(\\epsilon\\)"})," by producing an ordering of points that captures the cluster structure at multiple density levels. This characteristic makes OPTICS especially valuable for datasets with clusters of significantly varying densities."),"\n",l.createElement(t.h3,{id:"41-reachability-distance-and-ordering",style:{position:"relative"}},l.createElement(t.a,{href:"#41-reachability-distance-and-ordering","aria-label":"41 reachability distance and ordering permalink",className:"anchor before"},l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"4.1. Reachability distance and ordering"),"\n",l.createElement(t.p,null,"The core concept in OPTICS is the ",l.createElement(s.A,null,"reachability distance"),". For two points ",l.createElement(o.A,{text:"\\( p \\)"})," and ",l.createElement(o.A,{text:"\\( o \\)"}),", given parameters ",l.createElement(o.A,{text:"\\(\\epsilon\\)"})," and ",l.createElement(o.A,{text:"\\( \\text{minPts} \\)"}),", we define:"),"\n",l.createElement(t.ul,null,"\n",l.createElement(t.li,null,"\n",l.createElement(t.p,null,l.createElement(t.strong,null,"Core distance")," of point ",l.createElement(o.A,{text:"\\( o \\)"}),": the distance ",l.createElement(o.A,{text:"\\( \\text{CoreDist}_{\\text{minPts}}(o) \\)"})," which is the smallest radius such that the neighborhood of ",l.createElement(o.A,{text:"\\( o \\)"})," contains at least ",l.createElement(o.A,{text:"\\( \\text{minPts} \\)"})," points."),"\n",l.createElement(o.A,{text:"\\[\n\\text{CoreDist}_{\\text{minPts}}(o) = \n\\begin{cases}\n\\text{distance to the minPts-th nearest neighbor of } o, & \\text{if } |E_\\epsilon(o)| \\ge \\text{minPts},\\\\\n\\text{undefined}, & \\text{otherwise}.\n\\end{cases}\n\\]"}),"\n"),"\n",l.createElement(t.li,null,"\n",l.createElement(t.p,null,l.createElement(t.strong,null,"Reachability distance")," of ",l.createElement(o.A,{text:"\\( p \\)"})," from ",l.createElement(o.A,{text:"\\( o \\)"}),":"),"\n",l.createElement(o.A,{text:"\\[\n\\text{ReachDist}(p, o) = \n\\max\\bigl(\\text{CoreDist}_{\\text{minPts}}(o), \\rho(o, p)\\bigr).\n\\]"}),"\n",l.createElement(t.p,null,"If ",l.createElement(o.A,{text:"\\( o \\)"})," is not a core point, the reachability distance is undefined."),"\n"),"\n"),"\n",l.createElement(t.p,null,"OPTICS produces an ",l.createElement(s.A,null,"ordering"),' of the points by expanding out from the "most central" points (small core distances) to the outer edges. Along the way, each point ',l.createElement(o.A,{text:"\\( p \\)"})," receives a reachability distance that indicates how close ",l.createElement(o.A,{text:"\\( p \\)"})," is to the nearest cluster structure discovered so far. For points in dense regions, the reachability distance remains small. For points in sparser regions, the reachability distance grows."),"\n",l.createElement(t.h3,{id:"42-visual-representation-reachability-plots",style:{position:"relative"}},l.createElement(t.a,{href:"#42-visual-representation-reachability-plots","aria-label":"42 visual representation reachability plots permalink",className:"anchor before"},l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"4.2. Visual representation (reachability plots)"),"\n",l.createElement(t.p,null,"Once OPTICS is run, we get a list of points in the order in which they were expanded, each with an associated reachability distance. A ",l.createElement(s.A,null,"reachability plot"),' is then produced by plotting these distances along the x-axis in the order the points were processed. Peaks in this plot correspond to gaps between clusters or transitions from dense to sparser regions, while valleys correspond to the "dense cores" of clusters. By slicing this reachability plot at certain thresholds, one can mimic the effect of DBSCAN at various densities without re-running the algorithm multiple times.'),"\n",l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">&lt;Image alt="Illustration of a generic reachability plot" path="" caption="A hypothetical reachability plot demonstrating major peaks that separate clusters." zoom="false" /></code></pre></div>'}}),"\n",l.createElement(t.p,null,'In such a plot, you often see "valleys" of low reachability distances that correspond to well-defined clusters. The "peaks" indicate large jumps in distance, suggesting that the algorithm is transitioning from one cluster to another (or from a cluster to a region of noise).'),"\n",l.createElement(t.h3,{id:"43-step-by-step-outline",style:{position:"relative"}},l.createElement(t.a,{href:"#43-step-by-step-outline","aria-label":"43 step by step outline permalink",className:"anchor before"},l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"4.3. Step-by-step outline"),"\n",l.createElement(t.p,null,"Here is a concise conceptual outline of OPTICS:"),"\n",l.createElement(t.ol,null,"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"Initialization"),': For each point in the dataset, mark the point as "unprocessed."'),"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"Main loop"),":","\n",l.createElement(t.ul,null,"\n",l.createElement(t.li,null,"Select an unprocessed point ",l.createElement(o.A,{text:"\\( p \\)"}),' with the smallest "reachability distance" discovered so far (or ',l.createElement(o.A,{text:"\\( \\infty \\)"})," if no reachability distance is assigned yet)."),"\n",l.createElement(t.li,null,"Compute ",l.createElement(o.A,{text:"\\( \\text{CoreDist}_{\\text{minPts}}(p) \\)"}),". If ",l.createElement(o.A,{text:"\\( p \\)"})," is not a core point, it will receive no further expansions but still gets added to the ordering."),"\n",l.createElement(t.li,null,"If ",l.createElement(o.A,{text:"\\( p \\)"})," is a core point, retrieve its neighbors, update their reachability distances if needed, and place them into a priority queue, which is then used to pick the next point with the smallest reachability distance."),"\n",l.createElement(t.li,null,"Mark ",l.createElement(o.A,{text:"\\( p \\)"})," as processed and append ",l.createElement(o.A,{text:"\\( p \\)"})," to the final ordering list."),"\n"),"\n"),"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"Output"),": The final ordering of points, alongside each point's reachability distance and core distance. From these, you can create a reachability plot or derive a cluster structure by choosing appropriate thresholds."),"\n"),"\n",l.createElement(t.h3,{id:"44-implementation",style:{position:"relative"}},l.createElement(t.a,{href:"#44-implementation","aria-label":"44 implementation permalink",className:"anchor before"},l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"4.4. Implementation"),"\n",l.createElement(t.p,null,"An illustrative Python snippet that demonstrates how one might implement OPTICS in a naive manner follows. Note that this omits many low-level optimizations (e.g., using a priority queue or specialized data structure for neighbor queries):"),"\n",l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">&lt;Code text={`\nimport numpy as np\nimport heapq\n\ndef optics(points, eps, minPts, distance_func):\n    """\n    A naive OPTICS implementation for demonstration.\n    \n    :param points: list of points\n    :param eps: maximum radius for considering neighbors\n    :param minPts: minimum number of points for core distance\n    :param distance_func: function to compute distance\n    :return: ordering (list of point indices in the order they are processed),\n             reachability (list of distances for each point in the final order),\n             core_distances (list of core distances for each point in the final order).\n    """\n    n = len(points)\n    # Each point\'s reachability distance, initialized to infinity\n    reach_dist = [np.inf] * n\n    # Each point\'s core distance, also init to infinity\n    core_dist = [np.inf] * n\n    processed = [False] * n\n    # The final ordering of point indices\n    ordering = []\n    \n    neighbors_cache = [[] for _ in range(n)]\n    \n    # Precompute neighbors up to eps\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                d = distance_func(points[i], points[j])\n                if d &lt;= eps:\n                    neighbors_cache[i].append(j)\n    \n    # Function to update the reachability distances of neighbors\n    def update(neighbors_idx, center_idx):\n        c_dist = core_dist[center_idx]\n        for nb in neighbors_idx:\n            if not processed[nb]:\n                new_reach_dist = max(c_dist, distance_func(points[center_idx], points[nb]))\n                if new_reach_dist &lt; reach_dist[nb]:\n                    reach_dist[nb] = new_reach_dist\n                    # Use a heap to keep track of the next best point\n                    heapq.heappush(seeds, (new_reach_dist, nb))\n    \n    for i in range(n):\n        # If this point is already processed, skip\n        if processed[i]:\n            continue\n        \n        # Retrieve neighbors\n        neigh = neighbors_cache[i]\n        # Mark as processed\n        processed[i] = True\n        ordering.append(i)\n        \n        # Compute core distance\n        if len(neigh) >= minPts:\n            dists = [distance_func(points[i], points[nbr]) for nbr in neigh]\n            dists.sort()\n            core_dist[i] = dists[minPts - 1]\n        \n        # If it\'s a core point, place its neighbors in seeds\n        if core_dist[i] != np.inf:\n            seeds = []\n            update(neigh, i)\n            # Expand the cluster\n            while seeds:\n                _, next_idx = heapq.heappop(seeds)\n                if not processed[next_idx]:\n                    processed[next_idx] = True\n                    ordering.append(next_idx)\n                    nbr_next = neighbors_cache[next_idx]\n                    if len(nbr_next) >= minPts:\n                        dists_next = [distance_func(points[next_idx], points[nbr]) \n                                      for nbr in nbr_next]\n                        dists_next.sort()\n                        core_dist[next_idx] = dists_next[minPts - 1]\n                        update(nbr_next, next_idx)\n    \n    return ordering, reach_dist, core_dist\n`}/></code></pre></div>'}}),"\n",l.createElement(t.p,null,l.createElement(t.strong,null,"Key Observations"),":"),"\n",l.createElement(t.ul,null,"\n",l.createElement(t.li,null,"We keep track of each point's best-known reachability distance in a priority queue (",l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">seeds</code>'}}),")."),"\n",l.createElement(t.li,null,"For each point chosen to be expanded, if it's a core point, we update the neighbors' reachability distances accordingly."),"\n",l.createElement(t.li,null,'Unlike DBSCAN, we do not immediately assign cluster labels. Instead, we produce an "augmented ordering" from which a cluster hierarchy can be inferred.'),"\n"),"\n",l.createElement(t.h3,{id:"45-complexity-analysis",style:{position:"relative"}},l.createElement(t.a,{href:"#45-complexity-analysis","aria-label":"45 complexity analysis permalink",className:"anchor before"},l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"4.5. Complexity analysis"),"\n",l.createElement(t.p,null,"Similar to DBSCAN, the complexity of OPTICS strongly depends on the efficiency of neighbor searches. A naive approach can lead to ",l.createElement(o.A,{text:"\\(O(N^2)\\)"})," computations, but using appropriate spatial indices (e.g., KD-trees) often yields average-case complexities near ",l.createElement(o.A,{text:"\\(O(N \\log N)\\)"}),"."),"\n",l.createElement(t.p,null,'One major advantage of OPTICS is that once you have the ordering, you can retrieve clusterings of different densities without re-running the entire algorithm multiple times. You can think of it as performing "DBSCAN at multiple ',l.createElement(o.A,{text:"\\(\\epsilon\\)"}),' values" in one pass, which can be quite valuable for data exploration.'),"\n",l.createElement("br"),"\n",l.createElement(t.h2,{id:"5-comparing-dbscan-and-optics",style:{position:"relative"}},l.createElement(t.a,{href:"#5-comparing-dbscan-and-optics","aria-label":"5 comparing dbscan and optics permalink",className:"anchor before"},l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"5. Comparing DBSCAN and OPTICS"),"\n",l.createElement(t.p,null,"Although OPTICS was designed as a next-step improvement over DBSCAN, both algorithms share many foundational ideas. Below is a summary of how they overlap and where they differ."),"\n",l.createElement(t.ol,null,"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"Core principle"),": Both rely on the concept of ",l.createElement(o.A,{text:"\\(\\epsilon\\)"}),"-neighborhood and ",l.createElement(o.A,{text:"\\( \\text{minPts} \\)"})," to define dense regions."),"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"Noise/outlier handling"),": Both algorithms treat points that cannot belong to any dense region as outliers. However, the notion of outliers in OPTICS can be more fluid depending on the chosen reachability threshold."),"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"Fixed vs. variable density"),":","\n",l.createElement(t.ul,null,"\n",l.createElement(t.li,null,"DBSCAN uses a global ",l.createElement(o.A,{text:"\\(\\epsilon\\)"}),", making it effective when cluster densities are relatively uniform or when domain knowledge suggests a natural scale for the data."),"\n",l.createElement(t.li,null,"OPTICS effectively processes multiple ",l.createElement(o.A,{text:"\\(\\epsilon\\)"})," thresholds by building an ordering, enabling it to separate clusters with varying densities more easily."),"\n"),"\n"),"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"Parameter selection"),":","\n",l.createElement(t.ul,null,"\n",l.createElement(t.li,null,"DBSCAN requires ",l.createElement(o.A,{text:"\\(\\epsilon\\)"})," and ",l.createElement(o.A,{text:"\\( \\text{minPts} \\)"})," upfront. Proper tuning can be challenging if you do not have good heuristics or domain knowledge."),"\n",l.createElement(t.li,null,"OPTICS also needs ",l.createElement(o.A,{text:"\\(\\epsilon\\)"})," and ",l.createElement(o.A,{text:"\\( \\text{minPts} \\)"}),", but the primary difference is that you can choose a ",l.createElement(s.A,null,"post-processing")," threshold on the reachability plot to define clusters. Even if you pick an ",l.createElement(o.A,{text:"\\(\\epsilon\\)"}),' that is "too large," you can still unravel cluster structure at various density levels using the reachability plot.'),"\n"),"\n"),"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"Scalability"),":","\n",l.createElement(t.ul,null,"\n",l.createElement(t.li,null,"Both can achieve near ",l.createElement(o.A,{text:"\\(O(N \\log N)\\)"})," average complexity for spatial queries with efficient indexing."),"\n",l.createElement(t.li,null,"Both can degrade to ",l.createElement(o.A,{text:"\\(O(N^2)\\)"})," in the worst case, especially if the dimensionality is high or if the data distribution is pathological."),"\n",l.createElement(t.li,null,"DBSCAN might be simpler to parallelize in certain distributed environments, although parallel OPTICS is possible. Merging partial results can be more involved in either method, requiring specialized distributed data structures."),"\n"),"\n"),"\n"),"\n",l.createElement(t.p,null,'In practice, DBSCAN is often the first go-to solution if you suspect clusters are well-separated in terms of density. If you find yourself dealing with strongly varying densities across the dataset, or you want to explore the data for multiple potential clusterings, or you\'d like to easily "zoom in" or "zoom out" on different density levels, OPTICS (or HDBSCAN) becomes the more suitable approach.'),"\n",l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">&lt;Image alt="High-level DBSCAN vs. OPTICS illustration" path="" caption="Conceptual illustration: DBSCAN uses a single global eps, whereas OPTICS allows discovering structures at multiple density thresholds." zoom="false" /></code></pre></div>'}}),"\n",l.createElement(t.hr),"\n",l.createElement(t.p,null,"Where DBSCAN stands out:"),"\n",l.createElement(t.ul,null,"\n",l.createElement(t.li,null,"Simpler conceptually, typically faster on moderate-scale data if the chosen ",l.createElement(o.A,{text:"\\(\\epsilon\\)"})," is good."),"\n",l.createElement(t.li,null,"Easily implemented in many mainstream libraries."),"\n",l.createElement(t.li,null,"Straightforward outlier detection (noise points are simply those unassigned to clusters)."),"\n"),"\n",l.createElement(t.p,null,"Where OPTICS stands out:"),"\n",l.createElement(t.ul,null,"\n",l.createElement(t.li,null,"Flexible handling of varying density clusters without re-running the algorithm for different ",l.createElement(o.A,{text:"\\(\\epsilon\\)"})," values."),"\n",l.createElement(t.li,null,"Intuitive reachability plot for cluster exploration."),"\n",l.createElement(t.li,null,"Great synergy with domain-exploratory tasks (e.g., analyzing satellite images with multiple density levels)."),"\n"),"\n",l.createElement(t.hr),"\n",l.createElement(t.p,null,'Throughout modern machine learning and data analytics pipelines, both DBSCAN and OPTICS have proven invaluable for tasks ranging from major geospatial analyses (e.g., identifying "hotspots" in crime or real estate data) to advanced image recognition (segmenting images based on pixel intensity distributions), from analyzing traffic patterns (identifying dense routes vs. underused streets) to generating high-level features for anomaly or novelty detection frameworks. Their popularity stems from their interpretability (clusters = contiguous high-density regions) and the built-in outlier detection, which in many domains obviates the need for a separate outlier detection step.'),"\n",l.createElement(t.p,null,"In research circles, the impetus to refine DBSCAN-like methods remains high. For instance, at NeurIPS and ICML, advanced variants continue to appear that incorporate adaptive distance metrics, incorporate embeddings from deep neural networks, or integrate efficient GPU-based indexing. Meanwhile, domain-specific modifications handle specialized data types (geographic coordinates, time series, graph structures, etc.). The well-established success of DBSCAN and OPTICS ensures they remain bedrock algorithms in density-based clustering."),"\n",l.createElement("br"),"\n",l.createElement(t.hr),"\n",l.createElement(t.p,null,"Should you wish to dive deeper into practical experiments, open-source libraries like scikit-learn (Python), ",l.createElement(r.A,{text:"R library 'dbscan' from Michael Hahsler"})," (R), ELKI (Java-based data mining framework) offer well-tested implementations of DBSCAN and OPTICS. Many can directly produce reachability plots or cluster labels with minimal overhead."),"\n",l.createElement(t.p,null,"If your dataset exhibits a wide range of densities or you want to truly explore different density levels without re-running an algorithm multiple times, ",l.createElement(s.A,null,"OPTICS")," and ",l.createElement(s.A,null,"HDBSCAN")," are strong candidates. If you already have a specific target density scale in mind, ",l.createElement(s.A,null,"DBSCAN")," typically suffices and remains one of the easiest approaches to implement and interpret."),"\n",l.createElement(t.p,null,"Regardless of the approach you choose, density-based clustering demands a robust distance measure, the right data representation, and (in higher dimensions) prudent dimensionality-reduction or specialized indexing techniques. When used wisely, DBSCAN and OPTICS are not only academically fascinating but also highly practical for real-world clustering challenges."),"\n",l.createElement("br"),"\n",l.createElement(t.hr),"\n",l.createElement(t.p,null,l.createElement(t.em,null,"Final Note"),": As is often the case in clustering tasks, an essential part of the process is iterative experimentation, domain expertise, and thorough evaluation. Because unsupervised learning has no ground-truth labels, you typically rely on internal metrics (like Silhouette score, or DB index) or external domain knowledge to decide if the discovered clusters make sense. DBSCAN and OPTICS empower you with flexible tools for unraveling complex data distributions and discovering hidden structures, making them indispensable for advanced data scientists and machine learning practitioners alike."),"\n",l.createElement("br"),"\n",l.createElement(t.hr),"\n",l.createElement(t.p,null,l.createElement(t.em,null,"References and Further Reading")," (selected):"),"\n",l.createElement(t.ul,null,"\n",l.createElement(t.li,null,'M. Ester, H.-P. Kriegel, J. Sander, X. Xu. "A Density-Based Algorithm for Discovering Clusters in Large Spatial Databases with Noise." ',l.createElement(t.em,null,"KDD")," (1996)."),"\n",l.createElement(t.li,null,'M. Ankerst, M. Breunig, H.-P. Kriegel, J. Sander. "OPTICS: Ordering Points to Identify the Clustering Structure." ',l.createElement(t.em,null,"SIGMOD")," (1999)."),"\n",l.createElement(t.li,null,'R. J. G. B. Campello, D. Moulavi, J. Sander. "Density-Based Clustering Based on Hierarchical Density Estimates." ',l.createElement(t.em,null,"PAKDD"),", and extended: ",l.createElement(t.em,null,"JMLR")," (2013)."),"\n",l.createElement(t.li,null,'L. McInnes, J. Healy, S. Astels. "hdbscan: Hierarchical density based clustering." ',l.createElement(t.em,null,"J. Open Source Software")," (2017)."),"\n",l.createElement(t.li,null,'E. Schubert and gang "DBSCAN Revisited, Revisited: Why and How You Should (Still) Use DBSCAN." ',l.createElement(t.em,null,"ACM TODS")," (2017)."),"\n",l.createElement(t.li,null,'D. Schubert and gang "Fast Parallel DBSCAN." ',l.createElement(t.em,null,"ICML")," (2021)."),"\n"),"\n",l.createElement(t.p,null,"These references include the original DBSCAN and OPTICS papers, improvements, and broader frameworks that continue to evolve and refine these classic algorithms."))}var d=function(e){void 0===e&&(e={});const{wrapper:t}=Object.assign({},(0,i.RP)(),e.components);return t?l.createElement(t,e,l.createElement(c,e)):c(e)},m=n(36710),h=n(58481),u=n.n(h),p=n(36310),g=n(87245),f=n(27042),y=n(59849),E=n(5591),b=n(61122),v=n(9219),x=n(33203),w=n(95751),S=n(94328),A=n(80791),C=n(78137);const N=e=>{let{toc:t}=e;if(!t||!t.items)return null;return l.createElement("nav",{className:A.R},l.createElement("ul",null,t.items.map(((e,t)=>l.createElement("li",{key:t},l.createElement("a",{href:e.url,onClick:t=>((e,t)=>{e.preventDefault();const n=t.replace("#",""),a=document.getElementById(n);a&&a.scrollIntoView({behavior:"smooth",block:"start"})})(t,e.url)},e.title),e.items&&l.createElement(N,{toc:{items:e.items}}))))))};function I(e){let{data:{mdx:t,allMdx:r,allPostImages:s},children:o}=e;const{frontmatter:c,body:d,tableOfContents:m}=t,h=c.index,y=c.slug.split("/")[1],A=r.nodes.filter((e=>e.frontmatter.slug.includes(`/${y}/`))).sort(((e,t)=>e.frontmatter.index-t.frontmatter.index)),I=A.findIndex((e=>e.frontmatter.index===h)),D=A[I+1],T=A[I-1],M=c.slug.replace(/\/$/,""),P=/[^/]*$/.exec(M)[0],B=`posts/${y}/content/${P}/`,{0:k,1:_}=(0,l.useState)(c.flagWideLayoutByDefault),{0:L,1:z}=(0,l.useState)(!1);var H;(0,l.useEffect)((()=>{z(!0);const e=setTimeout((()=>z(!1)),340);return()=>clearTimeout(e)}),[k]),"adventures"===y?H=v.cb:"research"===y?H=v.Qh:"thoughts"===y&&(H=v.T6);const O=u()(d).replace(/import .*? from .*?;/g,"").replace(/<.*?>/g,"").replace(/\{\/\*[\s\S]*?\*\/\}/g,"").trim().split(/\s+/).length,j=function(e){if(e<=10)return"~10 min";if(e<=20)return"~20 min";if(e<=30)return"~30 min";if(e<=40)return"~40 min";if(e<=50)return"~50 min";if(e<=60)return"~1 h";const t=Math.floor(e/60),n=e%60;return n<=30?`~${t}${n>0?".5":""} h`:`~${t+1} h`}(Math.ceil(O/H)+(c.extraReadTimeMin||0)),V=[{flag:c.flagDraft,component:()=>Promise.all([n.e(3231),n.e(8809)]).then(n.bind(n,28809))},{flag:c.flagMindfuckery,component:()=>Promise.all([n.e(3231),n.e(2471)]).then(n.bind(n,67709))},{flag:c.flagRewrite,component:()=>Promise.all([n.e(3231),n.e(6764)]).then(n.bind(n,62002))},{flag:c.flagOffensive,component:()=>Promise.all([n.e(3231),n.e(2443)]).then(n.bind(n,17681))},{flag:c.flagProfane,component:()=>Promise.all([n.e(3231),n.e(8048)]).then(n.bind(n,53286))},{flag:c.flagMultilingual,component:()=>Promise.all([n.e(3231),n.e(4069)]).then(n.bind(n,78831))},{flag:c.flagUnreliably,component:()=>Promise.all([n.e(3231),n.e(3417)]).then(n.bind(n,8179))},{flag:c.flagPolitical,component:()=>Promise.all([n.e(3231),n.e(5195)]).then(n.bind(n,30433))},{flag:c.flagCognitohazard,component:()=>Promise.all([n.e(3231),n.e(3175)]).then(n.bind(n,8413))},{flag:c.flagHidden,component:()=>Promise.all([n.e(3231),n.e(9556)]).then(n.bind(n,14794))}],{0:q,1:K}=(0,l.useState)([]);return(0,l.useEffect)((()=>{V.forEach((e=>{let{flag:t,component:n}=e;t&&n().then((e=>{K((t=>[].concat((0,a.A)(t),[e.default])))}))}))}),[]),l.createElement(f.P.div,{initial:{opacity:0},animate:{opacity:1},exit:{opacity:0},transition:{duration:.15}},l.createElement(E.A,{postNumber:c.index,date:c.date,updated:c.updated,readTime:j,difficulty:c.difficultyLevel,title:c.title,desc:c.desc,banner:c.banner,section:y,postKey:P,isMindfuckery:c.flagMindfuckery,mainTag:c.mainTag}),l.createElement("div",{style:{display:"flex",justifyContent:"flex-end",flexWrap:"wrap",maxWidth:"75%",marginLeft:"auto",paddingRight:"1vw",marginTop:"-6vh",marginBottom:"4vh"}},c.otherTags.map(((e,t)=>l.createElement("span",{key:t,className:`noselect ${C.MW}`,style:{margin:"0 5px 5px 0"}},e)))),l.createElement("div",{className:"postBody"},l.createElement(N,{toc:m})),l.createElement("br"),l.createElement("div",{style:{margin:"0 10% -2vh 30%",textAlign:"right"}},l.createElement(f.P.button,{className:`noselect ${S.pb}`,id:S.xG,onClick:()=>{_(!k)},whileTap:{scale:.93}},l.createElement(f.P.div,{className:w.DJ,key:k,initial:{opacity:0},animate:{opacity:1},exit:{opacity:0},transition:{duration:.3,ease:"easeInOut"}},k?"Switch to default layout":"Switch to wide layout"))),l.createElement("br"),l.createElement("div",{className:"postBody",style:{margin:k?"0 -14%":"",maxWidth:k?"200%":"",transition:"margin 1s ease, max-width 1s ease, padding 1s ease"}},l.createElement("div",{className:`${S.P_} ${L?S.Xn:S.qG}`},q.map(((e,t)=>l.createElement(e,{key:t}))),c.indexCourse?l.createElement(x.A,{index:c.indexCourse,category:c.courseCategoryName}):"",l.createElement(p.Z.Provider,{value:{images:s.nodes,basePath:B.replace(/\/$/,"")+"/"}},l.createElement(i.xA,{components:{Image:g.A}},o)))),l.createElement(b.A,{nextPost:D,lastPost:T,keyCurrent:P,section:y}))}function D(e){return l.createElement(I,e,l.createElement(d,e))}function T(e){var t,n,a,i,r;let{data:s}=e;const{frontmatter:o}=s.mdx,c=o.titleSEO||o.title,d=o.titleOG||c,h=o.titleTwitter||c,u=o.descSEO||o.desc,p=o.descOG||u,g=o.descTwitter||u,f=o.schemaType||"BlogPosting",E=o.keywordsSEO,b=o.date,v=o.updated||b,x=o.imageOG||(null===(t=o.banner)||void 0===t||null===(n=t.childImageSharp)||void 0===n||null===(a=n.gatsbyImageData)||void 0===a||null===(i=a.images)||void 0===i||null===(r=i.fallback)||void 0===r?void 0:r.src),w=o.imageAltOG||p,S=o.imageTwitter||x,A=o.imageAltTwitter||g,C=o.canonicalURL,N=o.flagHidden||!1,I=o.mainTag||"Posts",D=o.slug.split("/")[1]||"posts",{siteUrl:T}=(0,m.Q)(),M={"@context":"https://schema.org","@type":"BreadcrumbList",itemListElement:[{"@type":"ListItem",position:1,name:"Home",item:T},{"@type":"ListItem",position:2,name:I,item:`${T}/${o.slug.split("/")[1]}`},{"@type":"ListItem",position:3,name:c,item:`${T}${o.slug}`}]};return l.createElement(y.A,{title:c+" - avrtt.blog",titleOG:d,titleTwitter:h,description:u,descriptionOG:p,descriptionTwitter:g,schemaType:f,keywords:E,datePublished:b,dateModified:v,imageOG:x,imageAltOG:w,imageTwitter:S,imageAltTwitter:A,canonicalUrl:C,flagHidden:N,mainTag:I,section:D,type:"article"},l.createElement("script",{type:"application/ld+json"},JSON.stringify(M)))}},66501:function(e,t,n){n.d(t,{A:function(){return r}});var a=n(96540),i=n(3962),l="styles-module--tooltiptext--a263b";var r=e=>{let{text:t,isBadge:n=!1}=e;const{0:r,1:s}=(0,a.useState)(!1),o=(0,a.useRef)(null);return(0,a.useEffect)((()=>{function e(e){o.current&&!o.current.contains(e.target)&&s(!1)}return document.addEventListener("click",e),()=>{document.removeEventListener("click",e)}}),[]),a.createElement("span",{className:"styles-module--tooltipWrapper--75ebf",ref:o},a.createElement("img",{id:n?"styles-module--infoBadge--e3d66":"styles-module--info--26c1f",src:i.A,alt:"info",onClick:e=>{e.stopPropagation(),s((e=>!e))}}),a.createElement("span",{className:r?`${l} styles-module--visible--c063c`:l},t))}},96098:function(e,t,n){var a=n(96540),i=n(7978);t.A=e=>{let{text:t}=e;return a.createElement(i.A,null,t)}}}]);
//# sourceMappingURL=component---src-templates-post-js-content-file-path-src-pages-posts-research-dbscan-and-optics-mdx-2d59c40b08971a2a99d8.js.map