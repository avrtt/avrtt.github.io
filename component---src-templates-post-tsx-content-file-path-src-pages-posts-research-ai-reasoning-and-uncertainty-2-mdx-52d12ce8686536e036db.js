"use strict";(self.webpackChunkavrtt_blog=self.webpackChunkavrtt_blog||[]).push([[1053],{90548:function(e,t,a){var n=a(96540),i=a(7978);t.A=e=>{let{text:t}=e;return n.createElement(i.A,null,t)}},94335:function(e,t,a){a.r(t),a.d(t,{Head:function(){return z},PostTemplate:function(){return _},default:function(){return M}});var n=a(28453),i=a(96540),r=(a(61992),a(62087)),s=a(90548);function o(e){const t=Object.assign({h2:"h2",a:"a",span:"span",p:"p",h3:"h3",ul:"ul",li:"li",strong:"strong",ol:"ol",br:"br"},(0,n.RP)(),e.components);return i.createElement(i.Fragment,null,"\n",i.createElement("br"),"\n","\n",i.createElement(t.h2,{id:"probabilistic-reasoning-over-time",style:{position:"relative"}},i.createElement(t.a,{href:"#probabilistic-reasoning-over-time","aria-label":"probabilistic reasoning over time permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Probabilistic reasoning over time"),"\n",i.createElement(t.p,null,"...or why time introduces additional layers of uncertainty?"),"\n",i.createElement("br"),"\n",i.createElement(t.p,null,"Time is a funny thing in machine learning, isn't it? The moment we allow our models to deal with data that unfolds over a timeline, we end up facing some distinct challenges. When data arrives sequentially, many assumptions that might have been fine in a static context break down — or at least get complicated. Think about a system that tracks a moving vehicle, a drone, or a walking robot; the current state of the object depends on what happened in prior steps, and we might only have partial, noisy measurements about that state. To make matters more interesting, time can introduce lags in the feedback loop, or the data might be missing altogether at certain intervals. A sensor could freeze, or the communication link might drop for a few moments."),"\n",i.createElement(t.p,null,"When we model such a real-time system, we must handle not only the possibility of measurement noise but also the possibility that the underlying state has evolved in ways we haven't directly observed yet. In an environment with changing states, the data you observe at any specific time might not entirely reflect the true state because by the time you gather it, the state may have already changed. This concept of delayed or partial observability is central to time-series modeling and pushes us to consider strategies that elegantly capture the dynamics of a system through sequential data."),"\n",i.createElement(t.p,null,"In real-world scenarios like self-driving cars, we have a continuous data feed from sensors like LIDAR, cameras, radar, and GPS. Each sensor reading can be noisy in different ways. The system not only has to figure out what the environment looks like at the moment (e.g., the positions of other cars) but also how it is going to change in the very near future. That forward-looking aspect is a big reason we talk about predictive models in time-series contexts. If I only look backward, I might get a good sense of history, but not necessarily how to respond to new changes that happen in the next second."),"\n",i.createElement(t.h3,{id:"markov-property-and-its-central-role-in-time-series-modeling",style:{position:"relative"}},i.createElement(t.a,{href:"#markov-property-and-its-central-role-in-time-series-modeling","aria-label":"markov property and its central role in time series modeling permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"markov property and its central role in time-series modeling"),"\n",i.createElement(t.p,null,"The Markov property states that the future state of a process depends only on its current state, not on its entire history. Formally, if we have a sequence of states ",i.createElement(s.A,{text:"\\( X_1, X_2, \\ldots, X_t \\)"}),", the Markov property for a first-order chain says:"),"\n",i.createElement(s.A,{text:"\\[\nP(X_{t+1} \\mid X_1, X_2, \\ldots, X_t) = P(X_{t+1} \\mid X_t).\n\\]"}),"\n",i.createElement(t.p,null,"Here, ",i.createElement(s.A,{text:"\\(X_t\\)"})," is the state at time step ",i.createElement(s.A,{text:"\\(t\\)"}),". This conditional independence assumption drastically simplifies both the mathematics and the computational complexity of many time-series models. It's still quite powerful: we can create dynamic models that are expressive enough for tasks like tracking, prediction, and decision making, even though we're ignoring the full history and focusing only on the current state."),"\n",i.createElement(t.p,null,"If you think about a simple weather model, it's not totally off to say, at least as a first approximation, that tomorrow's weather depends heavily on today's weather rather than the exact temperature and humidity from, say, five days ago. Of course, we can incorporate more sophisticated dynamics by increasing the order of the Markov chain or by building more elaborate frameworks like hidden Markov models, which we'll discuss soon. But the key is that Markov assumptions help us manage the otherwise daunting complexity of \"everything depends on everything else in time.\""),"\n",i.createElement(t.h3,{id:"examples-in-robotics-finance-and-weather-forecasting",style:{position:"relative"}},i.createElement(t.a,{href:"#examples-in-robotics-finance-and-weather-forecasting","aria-label":"examples in robotics finance and weather forecasting permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"examples in robotics, finance, and weather forecasting"),"\n",i.createElement(t.ul,null,"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Robotics (tracking moving objects)"),": Suppose you have a robot in a room, trying to localize itself based on sensor readings of walls, furniture, or markers. Each sensor reading is noisy, and the robot might have an internal guess for its position. Using a Markov process (or more specifically, a hidden Markov model or a Bayesian filtering approach like a Kalman filter), the robot can fuse its prior belief about where it was with new sensor data to get an updated belief of where it is now."),"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Finance (stock price modeling)"),": Financial markets are influenced by a huge number of factors, but some short-term models assume a Markov property for simplification, or they incorporate low-order dependencies. While real markets might not be strictly Markov, practitioners often use Markov-based approximations for algorithmic trading, derivative pricing, or risk assessments. Methods like discrete-time Markov chains or continuous-time models (like stochastic differential equations) show up in all sorts of quantitative finance contexts."),"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Weather forecasting"),": A basic approach to weather forecasting might look at time-series data like temperature, humidity, pressure, and so on, to predict the weather the next day. The underlying model might be Markovian to keep it tractable. Of course, in real meteorology, modern forecasting uses massive numerical simulations of atmospheric dynamics, but Markov approaches remain a simpler conceptual tool and are used widely in smaller-scale or specialized environments."),"\n"),"\n",i.createElement(t.h3,{id:"overview-of-filtering-prediction-and-smoothing-tasks",style:{position:"relative"}},i.createElement(t.a,{href:"#overview-of-filtering-prediction-and-smoothing-tasks","aria-label":"overview of filtering prediction and smoothing tasks permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"overview of filtering, prediction, and smoothing tasks"),"\n",i.createElement(t.p,null,"In time-series analysis, we often talk about three key tasks:"),"\n",i.createElement(t.ol,null,"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Filtering"),": Estimating the hidden (or latent) state at the current time step, given all observations up to now. For instance, you have sensor measurements up to time ",i.createElement(s.A,{text:"\\(t\\)"}),", and you want to produce an estimate of the hidden state at time ",i.createElement(s.A,{text:"\\(t\\)"}),"."),"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Prediction"),": Estimating a future latent state, say at time ",i.createElement(s.A,{text:"\\(t+1\\)"})," or ",i.createElement(s.A,{text:"\\(t+k\\)"}),", using observations up to time ",i.createElement(s.A,{text:"\\(t\\)"}),". If we were forecasting next week's weather from today's data, that is a prediction task."),"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Smoothing"),": Estimating a past latent state, given all observations in the time window, including those in the future relative to the time step of interest. For instance, if I want to refine my estimate of the state at time ",i.createElement(s.A,{text:"\\(t\\)"})," by taking advantage of the data at times ",i.createElement(s.A,{text:"\\(t+1, t+2, \\ldots, T\\)"}),", that's smoothing."),"\n"),"\n",i.createElement(t.p,null,"All three tasks pop up in real-world applications, and algorithms like the forward-backward algorithm (in HMMs) or Kalman filtering (in linear Gaussian systems) systematically address these challenges."),"\n",i.createElement(t.h2,{id:"time-and-uncertainty",style:{position:"relative"}},i.createElement(t.a,{href:"#time-and-uncertainty","aria-label":"time and uncertainty permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"time and uncertainty"),"\n",i.createElement(t.h3,{id:"discrete-time-vs-continuous-time-approaches",style:{position:"relative"}},i.createElement(t.a,{href:"#discrete-time-vs-continuous-time-approaches","aria-label":"discrete time vs continuous time approaches permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"discrete-time vs. continuous-time approaches"),"\n",i.createElement(t.p,null,"Time-series problems can be approached with a discrete-time mindset — where you assume the data arrives in discrete intervals and you update your model step by step — or a continuous-time one, in which states evolve in an unbroken continuum and you track changes as they happen. Discrete-time is usually simpler to handle in code, and it's a good fit for many digital sensor systems that produce measurements at intervals (like once every second, or once every minute)."),"\n",i.createElement(t.p,null,"On the other hand, certain domains demand a continuous-time framework. In quantitative finance, for instance, we often see models like Geometric Brownian Motion for stock prices:"),"\n",i.createElement(s.A,{text:"\\[\ndS_t = \\mu S_t dt + \\sigma S_t dW_t,\n\\]"}),"\n",i.createElement(t.p,null,"where ",i.createElement(s.A,{text:"\\(S_t\\)"})," is the stock price, ",i.createElement(s.A,{text:"\\(\\mu\\)"})," is the drift, ",i.createElement(s.A,{text:"\\(\\sigma\\)"})," is the volatility, and ",i.createElement(s.A,{text:"\\(W_t\\)"})," is a Wiener process (or Brownian motion). We might discretize this to do computations, but the underlying process is conceptualized continuously. Similar continuous-time processes pop up in physics, population dynamics, epidemiology, and control systems in engineering."),"\n",i.createElement(t.h3,{id:"handling-streaming-data-in-real-time-inference",style:{position:"relative"}},i.createElement(t.a,{href:"#handling-streaming-data-in-real-time-inference","aria-label":"handling streaming data in real time inference permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"handling streaming data in real-time inference"),"\n",i.createElement(t.p,null,"In streaming scenarios, data arrives in real time, and we don't necessarily have the luxury of waiting until the entire sequence is available (like we might in offline batch processing). Think of an application in anomaly detection for manufacturing: you want to spot a defective product as soon as possible, rather than waiting until the entire production run is done. Real-time inference solutions require algorithms that can incorporate each new data point on the fly, updating the internal state with minimal latency."),"\n",i.createElement(t.p,null,"Particle filters, online versions of the forward-backward algorithm, or real-time variants of Kalman filtering serve as typical examples of streaming inference. These approaches keep a dynamic representation of the state (for instance, a set of weighted samples in the case of a particle filter) and incorporate new observations in incremental updates. If the data is high-dimensional, or the underlying model is very complicated, streaming solutions need to be carefully optimized to keep up with real-world data arrival rates."),"\n",i.createElement(t.h3,{id:"memory-based-models-vs-markov-models",style:{position:"relative"}},i.createElement(t.a,{href:"#memory-based-models-vs-markov-models","aria-label":"memory based models vs markov models permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"memory-based models vs. markov models"),"\n",i.createElement(t.p,null,'If you suspect that your time-series data has significant long-term memory, you might consider "memory-based models" that keep track of a longer span of history rather than a single Markov state. Recurrent neural networks (including LSTM or GRU variants) are often used to capture these more extended dependencies. The Markov property is powerful for many reasons, but it can oversimplify cases where the distant past influences the present in subtle ways. For instance, in language modeling, the next word in a sentence can sometimes depend on context that\'s quite far back, which is why RNN-based or Transformer-based approaches can be more suitable than simple Markov models.'),"\n",i.createElement(t.h3,{id:"practical-issues-sensor-noise-delayed-signals-and-partial-observability",style:{position:"relative"}},i.createElement(t.a,{href:"#practical-issues-sensor-noise-delayed-signals-and-partial-observability","aria-label":"practical issues sensor noise delayed signals and partial observability permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"practical issues: sensor noise, delayed signals, and partial observability"),"\n",i.createElement(t.p,null,"Even in well-controlled environments, sensors may produce unreliable or delayed readings. For example, a GPS signal might arrive only every couple of seconds, and it can also be unavailable indoors or in urban canyons. Meanwhile, an accelerometer or gyroscope might produce readings at a higher frequency but with its own drift issues. When we fuse data from multiple sensors, we need robust solutions that handle partial observability (i.e., we don't directly observe the variable of interest) and uncertainty introduced by measurement error."),"\n",i.createElement(t.p,null,"Sometimes you have a multi-rate system: a sensor updates quickly, while another updates more slowly. Handling asynchronous data arrival is another practical headache. Solutions typically revolve around unifying the data into a single timeline (through interpolation, queueing, or buffer-based approaches) or applying continuous-time modeling techniques."),"\n",i.createElement(t.h2,{id:"inference-in-temporal-models",style:{position:"relative"}},i.createElement(t.a,{href:"#inference-in-temporal-models","aria-label":"inference in temporal models permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"inference in temporal models"),"\n",i.createElement(t.h3,{id:"forward-backward-algorithm-basics-for-hidden-state-estimation",style:{position:"relative"}},i.createElement(t.a,{href:"#forward-backward-algorithm-basics-for-hidden-state-estimation","aria-label":"forward backward algorithm basics for hidden state estimation permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"forward-backward algorithm basics for hidden state estimation"),"\n",i.createElement(t.p,null,"In a classic hidden Markov model (HMM) setting, you assume there's an underlying sequence of hidden states ",i.createElement(s.A,{text:"\\(X_1, X_2, \\ldots, X_T\\)"})," that generate observations ",i.createElement(s.A,{text:"\\(Y_1, Y_2, \\ldots, Y_T\\)"}),". The forward-backward algorithm is a dynamic programming procedure that allows you to compute the posterior distribution ",i.createElement(s.A,{text:"\\(P(X_t \\mid Y_1, \\ldots, Y_T)\\)"})," for each time step ",i.createElement(s.A,{text:"\\(t\\)"}),". It does so by combining the forward messages:"),"\n",i.createElement(s.A,{text:"\\[\n\\alpha_t(i) = P(X_t = i, Y_1, \\ldots, Y_t)\n\\]"}),"\n",i.createElement(t.p,null,"and the backward messages:"),"\n",i.createElement(s.A,{text:"\\[\n\\beta_t(i) = P(Y_{t+1}, \\ldots, Y_T \\mid X_t = i).\n\\]"}),"\n",i.createElement(t.p,null,"The forward pass computes ",i.createElement(s.A,{text:"\\(\\alpha_t\\)"})," recursively from left to right, and the backward pass computes ",i.createElement(s.A,{text:"\\(\\beta_t\\)"})," from right to left. After that, the posterior for state ",i.createElement(s.A,{text:"\\(i\\)"})," at time ",i.createElement(s.A,{text:"\\(t\\)"})," is proportional to ",i.createElement(s.A,{text:"\\(\\alpha_t(i) \\cdot \\beta_t(i)\\)"}),". This approach can be used for both filtering (the distribution of the hidden state at time ",i.createElement(s.A,{text:"\\(t\\)"})," given data up to ",i.createElement(s.A,{text:"\\(t\\)"}),") and smoothing (the distribution of the hidden state at time ",i.createElement(s.A,{text:"\\(t\\)"})," given all data from 1 to ",i.createElement(s.A,{text:"\\(T\\)"}),"). Although the forward-backward algorithm is efficient for HMMs, it does have a runtime of ",i.createElement(s.A,{text:"\\(O(T \\cdot N^2)\\)"})," if there are ",i.createElement(s.A,{text:"\\(N\\)"})," possible states per time step. This can become a bottleneck when ",i.createElement(s.A,{text:"\\(N\\)"})," or ",i.createElement(s.A,{text:"\\(T\\)"})," is huge."),"\n",i.createElement(t.h3,{id:"particle-filtering-for-nonlinearnon-gaussian-processes",style:{position:"relative"}},i.createElement(t.a,{href:"#particle-filtering-for-nonlinearnon-gaussian-processes","aria-label":"particle filtering for nonlinearnon gaussian processes permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"particle filtering for nonlinear/non-gaussian processes"),"\n",i.createElement(t.p,null,"When the state space is continuous or the process is highly nonlinear and not necessarily Gaussian, particle filters (also called Sequential Monte Carlo methods) are a go-to approach. The idea is to maintain a set of particles — basically samples of the hidden state — with associated weights that reflect how likely each particle is, given the observed data. On each new time step, you predict each particle forward based on the dynamics model, then update its weight based on the likelihood of observing the actual measurement. You might resample after each update so that particles with very low weights are pruned away and high-weight particles are duplicated. Over time, the distribution of particles approximates the posterior over the hidden state."),"\n",i.createElement(t.p,null,"Here's a minimal Python-like snippet to illustrate a particle filter framework:"),"\n",i.createElement(r.A,{text:'\nimport numpy as np\n\ndef particle_filter(prior_particles, observations, \n                    transition_func, observation_func, \n                    process_noise, obs_noise, num_particles):\n    """\n    prior_particles: np.array of shape [num_particles, state_dim]\n    observations: list or array of observations\n    transition_func: function for state transition\n    observation_func: function for observation generation\n    process_noise: std dev or covariance for process model\n    obs_noise: std dev or covariance for observation model\n    num_particles: int\n    """\n    particles = prior_particles\n    weights = np.ones(num_particles) / num_particles\n    estimated_states = []\n\n    for obs in observations:\n        # Predict step\n        for i in range(num_particles):\n            particles[i] = transition_func(particles[i], process_noise)\n        \n        # Update step\n        for i in range(num_particles):\n            predicted_obs = observation_func(particles[i])\n            likelihood = compute_likelihood(obs, predicted_obs, obs_noise)\n            weights[i] *= likelihood\n        \n        # Normalize weights\n        weights += 1e-12  # avoid division by zero\n        weights /= np.sum(weights)\n        \n        # Resample if needed\n        indices = np.random.choice(range(num_particles), size=num_particles, p=weights)\n        particles = particles[indices]\n        weights = np.ones(num_particles) / num_particles\n        \n        # Estimate state as weighted mean\n        estimated_state = np.average(particles, axis=0)\n        estimated_states.append(estimated_state)\n    \n    return np.array(estimated_states)\n'}),"\n",i.createElement(t.p,null,"Of course, this is a toy example. Real implementations can be more sophisticated, with variance reduction methods, advanced resampling strategies, or parallelization. Particle filters are widely used in navigation, robotics, fault detection, and any number of real-time settings that involve non-linear or non-Gaussian processes."),"\n",i.createElement(t.h3,{id:"online-vs-offline-inference-when-each-is-appropriate",style:{position:"relative"}},i.createElement(t.a,{href:"#online-vs-offline-inference-when-each-is-appropriate","aria-label":"online vs offline inference when each is appropriate permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"online vs. offline inference: when each is appropriate"),"\n",i.createElement(t.ul,null,"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Online inference")," means you process data in a sequential, real-time manner. You can't necessarily revisit old data (or it's too costly to do so), so you maintain a \"running\" estimate of the latent state or parameters. Use this when the system must respond immediately, such as a robot adjusting its path based on new sensor readings."),"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Offline inference")," is used when you have access to the entire data sequence from the start, and you can do more computationally expensive operations that might require multiple passes over the dataset, like the forward-backward algorithm for smoothing in HMMs. This is helpful in post-hoc analysis, e.g., analyzing a static dataset of user behaviors over a month to glean insights."),"\n"),"\n",i.createElement(t.h3,{id:"scalability-challenges-and-approximate-methods",style:{position:"relative"}},i.createElement(t.a,{href:"#scalability-challenges-and-approximate-methods","aria-label":"scalability challenges and approximate methods permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"scalability challenges and approximate methods"),"\n",i.createElement(t.p,null,"As the dimensionality of your state space grows, or as the complexity of your system increases (e.g., multiple sensors, multiple agents, large continuous state variables), you might find exact inference intractable. Particle filters might need a huge number of particles, or the forward-backward might blow up in complexity. In these scenarios, people often turn to approximate methods:"),"\n",i.createElement(t.ul,null,"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Variational inference"),": Where you propose a certain family of distributions to approximate the posterior, then optimize the parameters of that approximation."),"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Sequential variational autoencoders"),": In deep learning contexts, you might combine neural networks with variational inference to compress the distribution of states in a latent variable model, especially for complex temporal data like video or audio."),"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Hybrid sampling approaches"),": Combining MCMC (Markov chain Monte Carlo) with filtering or using advanced resampling strategies."),"\n"),"\n",i.createElement(t.h3,{id:"example-use-cases-speech-recognition-tracking-user-behavior-over-time",style:{position:"relative"}},i.createElement(t.a,{href:"#example-use-cases-speech-recognition-tracking-user-behavior-over-time","aria-label":"example use cases speech recognition tracking user behavior over time permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"example use cases: speech recognition, tracking user behavior over time"),"\n",i.createElement(t.p,null,"Temporal models pop up everywhere. In speech recognition, you often approximate the evolution of phonemes or words as a Markov chain. In website analytics or e-commerce, tracking user behavior as a sequence of events is a natural application of a hidden Markov model or some form of recurrent neural net. You might want to model how likely a user is to move from browsing a product to actually purchasing it based on partial cues."),"\n",i.createElement(t.h2,{id:"kalman-filters",style:{position:"relative"}},i.createElement(t.a,{href:"#kalman-filters","aria-label":"kalman filters permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"kalman filters"),"\n",i.createElement(t.h3,{id:"detailed-look-at-predict-update-equations-in-linear-gaussian-settings",style:{position:"relative"}},i.createElement(t.a,{href:"#detailed-look-at-predict-update-equations-in-linear-gaussian-settings","aria-label":"detailed look at predict update equations in linear gaussian settings permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"detailed look at predict-update equations in linear gaussian settings"),"\n",i.createElement(t.p,null,"The Kalman filter is a specialized (yet extremely famous) algorithm for linear, Gaussian state-space models. The standard setting is:"),"\n",i.createElement(s.A,{text:"\\[\nx_{t+1} = A x_t + B u_t + w_t,\n\\]"}),"\n",i.createElement(s.A,{text:"\\[\nz_t = H x_t + v_t,\n\\]"}),"\n",i.createElement(t.p,null,"where ",i.createElement(s.A,{text:"\\(x_t\\)"})," is the hidden state, ",i.createElement(s.A,{text:"\\(z_t\\)"})," is the observation at time ",i.createElement(s.A,{text:"\\(t\\)"}),", ",i.createElement(s.A,{text:"\\(u_t\\)"})," is a known control input, and ",i.createElement(s.A,{text:"\\(w_t, v_t\\)"})," are Gaussian noise terms. The noise is often assumed to be zero-mean with covariance matrices ",i.createElement(s.A,{text:"\\(Q\\)"})," and ",i.createElement(s.A,{text:"\\(R\\)"}),", respectively. The matrix ",i.createElement(s.A,{text:"\\(A\\)"})," defines how the system transitions from one state to the next, ",i.createElement(s.A,{text:"\\(B\\)"})," how the control input influences the state, and ",i.createElement(s.A,{text:"\\(H\\)"})," how the state is mapped to the observation space."),"\n",i.createElement(t.p,null,"A Kalman filter performs two steps at each time step:"),"\n",i.createElement(t.ol,null,"\n",i.createElement(t.li,null,"\n",i.createElement(t.p,null,i.createElement(t.strong,null,"Predict")," (also called the time update):"),"\n",i.createElement(s.A,{text:"\\[\n\\hat{x}_{t+1|t} = A \\hat{x}_{t|t} + B u_t\n\\]"}),"\n",i.createElement(s.A,{text:"\\[\nP_{t+1|t} = A P_{t|t} A^T + Q\n\\]"}),"\n",i.createElement(t.p,null,"Here, ",i.createElement(s.A,{text:"\\(\\hat{x}_{t|t}\\)"})," is the state estimate at time ",i.createElement(s.A,{text:"\\(t\\)"}),", given observations up to ",i.createElement(s.A,{text:"\\(t\\)"}),". ",i.createElement(s.A,{text:"\\(\\hat{x}_{t+1|t}\\)"})," is the estimate for time ",i.createElement(s.A,{text:"\\(t+1\\)"})," before we incorporate the new observation at time ",i.createElement(s.A,{text:"\\(t+1\\)"}),". ",i.createElement(s.A,{text:"\\(P\\)"})," is the covariance of the estimate."),"\n"),"\n",i.createElement(t.li,null,"\n",i.createElement(t.p,null,i.createElement(t.strong,null,"Update")," (or measurement update):"),"\n",i.createElement(s.A,{text:"\\[\nK_{t+1} = P_{t+1|t} H^T \\bigl(H P_{t+1|t} H^T + R\\bigr)^{-1}\n\\]"}),"\n",i.createElement(s.A,{text:"\\[\n\\hat{x}_{t+1|t+1} = \\hat{x}_{t+1|t} + K_{t+1} \\bigl(z_{t+1} - H \\hat{x}_{t+1|t}\\bigr)\n\\]"}),"\n",i.createElement(s.A,{text:"\\[\nP_{t+1|t+1} = \\bigl(I - K_{t+1}H\\bigr) P_{t+1|t}\n\\]"}),"\n",i.createElement(t.p,null,i.createElement(s.A,{text:"\\(K_{t+1}\\)"})," is the Kalman gain, which determines how much to trust the new measurement relative to the current prediction. The term ",i.createElement(s.A,{text:"\\(z_{t+1} - H \\hat{x}_{t+1|t}\\)"})," is the measurement residual, i.e., the difference between the observed data and what our model predicted. The updated estimate ",i.createElement(s.A,{text:"\\(\\hat{x}_{t+1|t+1}\\)"})," is a blend of the prediction and the measurement."),"\n"),"\n"),"\n",i.createElement(t.h3,{id:"use-in-control-systems-signal-processing-and-localization",style:{position:"relative"}},i.createElement(t.a,{href:"#use-in-control-systems-signal-processing-and-localization","aria-label":"use in control systems signal processing and localization permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"use in control systems, signal processing, and localization"),"\n",i.createElement(t.p,null,"Kalman filters are widely employed in control systems: consider a drone or a robot that needs a stable estimate of its position, velocity, orientation, etc. By fusing sensor readings with a physics-based prediction model, the Kalman filter helps to keep the estimates robust to noise. The same logic applies in signal processing, where we might track a signal that is buried in noise and adapt our filter over time."),"\n",i.createElement(t.p,null,"In localization tasks (e.g., combining GPS data, wheel odometry, and inertial measurements), a Kalman filter is frequently the first line of defense. If we model the system dynamics and sensor measurement processes in a linear Gaussian form, Kalman filters can be quite precise and computationally efficient."),"\n",i.createElement(t.h3,{id:"extensions-extended-kalman-filter-ekf-and-unscented-kalman-filter-ukf",style:{position:"relative"}},i.createElement(t.a,{href:"#extensions-extended-kalman-filter-ekf-and-unscented-kalman-filter-ukf","aria-label":"extensions extended kalman filter ekf and unscented kalman filter ukf permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"extensions: extended kalman filter (ekf) and unscented kalman filter (ukf)"),"\n",i.createElement(t.p,null,"Real systems are often nonlinear. Perhaps your robot's dynamics include sine or cosine terms, or your sensors measure angles or distances in a way that's not linear in the underlying coordinates. In these cases, you can either approximate your system with a local linearization (the Extended Kalman Filter, EKF) or rely on a \"sigma-point\" approach (the Unscented Kalman Filter, UKF), which picks a set of deterministically chosen sample points in the state space and propagates them through the nonlinear functions to approximate the posterior."),"\n",i.createElement(t.h3,{id:"strengths-limitations-and-typical-real-world-performance",style:{position:"relative"}},i.createElement(t.a,{href:"#strengths-limitations-and-typical-real-world-performance","aria-label":"strengths limitations and typical real world performance permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"strengths, limitations, and typical real-world performance"),"\n",i.createElement(t.p,null,i.createElement(t.strong,null,"Strengths"),":"),"\n",i.createElement(t.ul,null,"\n",i.createElement(t.li,null,"Fast and relatively easy to implement."),"\n",i.createElement(t.li,null,"Well-studied, so their behavior is predictable in linear Gaussian domains."),"\n",i.createElement(t.li,null,"Provide good performance in many real-time control and tracking tasks."),"\n"),"\n",i.createElement(t.p,null,i.createElement(t.strong,null,"Limitations"),":"),"\n",i.createElement(t.ul,null,"\n",i.createElement(t.li,null,"Strictly linear Gaussian assumptions might be unrealistic for complex systems."),"\n",i.createElement(t.li,null,"Sensitive to tuning parameters (covariance matrices, etc.)."),"\n",i.createElement(t.li,null,"Nonlinear versions (EKF, UKF) introduce approximations that can be unstable if the nonlinearities are very severe or if the initial linearization is poor."),"\n"),"\n",i.createElement(t.p,null,"Nevertheless, Kalman-based methods remain foundational and are widely used in robotics, aerospace, finance (for simplified tracking of indicators), and more."),"\n",i.createElement(t.h2,{id:"dynamic-bayesian-networks",style:{position:"relative"}},i.createElement(t.a,{href:"#dynamic-bayesian-networks","aria-label":"dynamic bayesian networks permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"dynamic bayesian networks"),"\n",i.createElement(t.h3,{id:"how-dbns-generalize-hidden-markov-models-and-kalman-filters",style:{position:"relative"}},i.createElement(t.a,{href:"#how-dbns-generalize-hidden-markov-models-and-kalman-filters","aria-label":"how dbns generalize hidden markov models and kalman filters permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"how dbns generalize hidden markov models and kalman filters"),"\n",i.createElement(t.p,null,"A dynamic Bayesian network (DBN) is basically a Bayesian network that unfolds over time. In each time slice, you have a set of state variables and observation variables, plus edges that model how these variables relate to each other within the time slice and how they connect to the corresponding variables in the next slice. Hidden Markov models (HMMs) and Kalman filters are specific, more restrictive types of DBNs. HMMs allow for a single hidden state variable that influences a single observation at each time step, plus first-order Markov dependencies. A DBN can be more general: it might let you have multiple hidden variables, intricate dependencies, or higher-order transitions."),"\n",i.createElement(t.h3,{id:"representation-of-temporal-transitions-and-emission-probabilities",style:{position:"relative"}},i.createElement(t.a,{href:"#representation-of-temporal-transitions-and-emission-probabilities","aria-label":"representation of temporal transitions and emission probabilities permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"representation of temporal transitions and emission probabilities"),"\n",i.createElement(t.p,null,"In a DBN, you often define two network fragments (sometimes called templates): one for the initial time slice, and one for the transition from time ",i.createElement(s.A,{text:"\\(t\\)"})," to time ",i.createElement(s.A,{text:"\\(t+1\\)"}),". Then, to build a model of length ",i.createElement(s.A,{text:"\\(T\\)"}),", you replicate the transition fragment ",i.createElement(s.A,{text:"\\(T-1\\)"})," times and connect them in a chain. Typically, you specify conditional probability tables (or conditional densities) for how each variable depends on its parents. For example, you might have:"),"\n",i.createElement(t.p,null,i.createElement(s.A,{text:"\\(X_t\\)"})," depends on ",i.createElement(s.A,{text:"\\(X_{t-1}, X_{t-2}, Y_{t-1}\\)"}),".",i.createElement(t.br),"\n",i.createElement(s.A,{text:"\\(Y_t\\)"})," depends on ",i.createElement(s.A,{text:"\\(X_t\\)"}),"."),"\n",i.createElement(t.p,null,"This is a more flexible structure than an HMM, which only allows ",i.createElement(s.A,{text:"\\(X_t\\)"})," to depend on ",i.createElement(s.A,{text:"\\(X_{t-1}\\)"})," alone and ",i.createElement(s.A,{text:"\\(Y_t\\)"})," to depend on ",i.createElement(s.A,{text:"\\(X_t\\)"}),"."),"\n",i.createElement(t.h3,{id:"parameter-learning-strategies-em-algorithm-gradient-based-methods",style:{position:"relative"}},i.createElement(t.a,{href:"#parameter-learning-strategies-em-algorithm-gradient-based-methods","aria-label":"parameter learning strategies em algorithm gradient based methods permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"parameter learning strategies (em algorithm, gradient-based methods)"),"\n",i.createElement(t.p,null,"If you have latent variables in your DBN (which is usually the case), you might use the Expectation-Maximization (EM) algorithm to estimate the model parameters. In the E-step, you infer the posterior distribution over hidden variables given your current parameter guess. In the M-step, you maximize the likelihood with respect to those parameters. This can be done iteratively until convergence. In practice, you might approximate the E-step using particle filtering, forward-backward recursions, or variational inference if the exact inference is intractable."),"\n",i.createElement(t.p,null,"For more complex networks, or if you incorporate neural network components, you might resort to gradient-based methods, sampling-based methods, or other advanced techniques. The approach depends heavily on the problem specifics and computational budget."),"\n",i.createElement(t.h3,{id:"applications-in-speech-recognition-activity-recognition-robotics-and-beyond",style:{position:"relative"}},i.createElement(t.a,{href:"#applications-in-speech-recognition-activity-recognition-robotics-and-beyond","aria-label":"applications in speech recognition activity recognition robotics and beyond permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"applications in speech recognition, activity recognition, robotics, and beyond"),"\n",i.createElement(t.p,null,"Speech recognition systems historically used hidden Markov models, which can be seen as a specialized DBN. In activity recognition or user-behavior modeling, you might use DBNs to represent multiple aspects of the state (like location, motion, interactions). In robotics, DBNs can capture sensor fusion with rich dependencies across time slices. Essentially, anytime you have multiple variables that evolve over time and you can draw a DAG structure connecting them across slices, DBNs become a strong modeling framework."),"\n",i.createElement(t.h3,{id:"practical-software-tools-for-constructing-and-inferring-dbns",style:{position:"relative"}},i.createElement(t.a,{href:"#practical-software-tools-for-constructing-and-inferring-dbns","aria-label":"practical software tools for constructing and inferring dbns permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"practical software tools for constructing and inferring dbns"),"\n",i.createElement(t.p,null,"There are libraries like ",i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">pgmpy</code>'}})," in Python, or specialized Bayesian network toolkits like ",i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">OpenBayes</code>'}})," or ",i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">BayesPy</code>'}}),". Some general-purpose probabilistic programming frameworks (e.g., PyMC, Stan, Edward) can also handle DBNs with the right modeling code. The main challenge often lies in specifying the structure (which edges exist, how big each time slice is) and then picking the right inference algorithm for your needs."),"\n",i.createElement(t.h2,{id:"making-simple-decisions-under-uncertainty",style:{position:"relative"}},i.createElement(t.a,{href:"#making-simple-decisions-under-uncertainty","aria-label":"making simple decisions under uncertainty permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"making simple decisions under uncertainty"),"\n",i.createElement(t.h3,{id:"bridging-probabilistic-beliefs-with-decision-making-decision-theoretic-approach",style:{position:"relative"}},i.createElement(t.a,{href:"#bridging-probabilistic-beliefs-with-decision-making-decision-theoretic-approach","aria-label":"bridging probabilistic beliefs with decision making decision theoretic approach permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"bridging probabilistic beliefs with decision-making (decision-theoretic approach)"),"\n",i.createElement(t.p,null,"So you've got these carefully built probabilistic models that tell you how likely certain events or states are. How do you use these probabilities to decide what to do? Decision theory says that you combine your beliefs (probabilities) with your preferences (utilities) to pick the action that yields the highest expected utility. For example, if I believe there's a 70% chance of rain and I absolutely hate getting soaked, I might decide to carry an umbrella."),"\n",i.createElement(t.h3,{id:"scenario-analysis-and-sensitivity-analysis-for-uncertain-outcomes",style:{position:"relative"}},i.createElement(t.a,{href:"#scenario-analysis-and-sensitivity-analysis-for-uncertain-outcomes","aria-label":"scenario analysis and sensitivity analysis for uncertain outcomes permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"scenario analysis and sensitivity analysis for uncertain outcomes"),"\n",i.createElement(t.p,null,"In more sophisticated settings, you might enumerate or simulate scenarios, each with some probability, then compute the utility for each scenario. That's scenario analysis. Sensitivity analysis is about seeing how changes in your assumptions (like the probability of each scenario or the cost of each outcome) alter your preferred decision. If a small shift in probabilities or costs drastically changes the decision, you know the problem is sensitive, and maybe you should gather more information or refine your estimates."),"\n",i.createElement(t.h3,{id:"single-step-decisions-vs-multi-step-decisions-in-uncertain-environments",style:{position:"relative"}},i.createElement(t.a,{href:"#single-step-decisions-vs-multi-step-decisions-in-uncertain-environments","aria-label":"single step decisions vs multi step decisions in uncertain environments permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"single-step decisions vs. multi-step decisions in uncertain environments"),"\n",i.createElement(t.p,null,"A single-step decision under uncertainty is a simpler scenario: you look at the immediate payoff. But if decisions chain together over time, you need to think multiple steps ahead. That's where Markov Decision Processes (MDPs) come in, which we'll tackle later. In real life, many problems are multi-step. A doctor prescribing medication might consider future complications. A portfolio manager invests now to see returns (or losses) unfold over months or years."),"\n",i.createElement(t.h3,{id:"real-world-examples-medical-diagnoses-finance-portfolios-route-planning",style:{position:"relative"}},i.createElement(t.a,{href:"#real-world-examples-medical-diagnoses-finance-portfolios-route-planning","aria-label":"real world examples medical diagnoses finance portfolios route planning permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"real-world examples: medical diagnoses, finance portfolios, route planning"),"\n",i.createElement(t.ul,null,"\n",i.createElement(t.li,null,"\n",i.createElement(t.p,null,i.createElement(t.strong,null,"Medical diagnoses"),": A doctor decides which tests to order based on how uncertain they are about a condition and how beneficial or risky further testing might be."),"\n"),"\n",i.createElement(t.li,null,"\n",i.createElement(t.p,null,i.createElement(t.strong,null,"Finance portfolios"),": You might weigh the expected returns of an investment against its volatility and your personal tolerance for risk."),"\n"),"\n",i.createElement(t.li,null,"\n",i.createElement(t.p,null,i.createElement(t.strong,null,"Route planning"),": When picking a path in a city with traffic, you weigh the likelihood of congestion, potential time savings, and any cost (like tolls)."),"\n"),"\n"),"\n",i.createElement(t.h2,{id:"the-basis-of-utility-theory",style:{position:"relative"}},i.createElement(t.a,{href:"#the-basis-of-utility-theory","aria-label":"the basis of utility theory permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"the basis of utility theory"),"\n",i.createElement(t.h3,{id:"axioms-of-rational-preference-von-neumannmorgenstern-framework",style:{position:"relative"}},i.createElement(t.a,{href:"#axioms-of-rational-preference-von-neumannmorgenstern-framework","aria-label":"axioms of rational preference von neumannmorgenstern framework permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"axioms of rational preference (von neumann–morgenstern framework)"),"\n",i.createElement(t.p,null,"The von Neumann–Morgenstern utility theorem states that if an agent's preferences satisfy certain rationality axioms (completeness, transitivity, independence, continuity), then we can represent that agent's preferences with a utility function ",i.createElement(s.A,{text:"\\(u(\\cdot)\\)"})," such that the agent compares lotteries (i.e., probabilistic outcomes) by their expected utility:"),"\n",i.createElement(s.A,{text:"\\[\n\\text{Lottery } A \\succ \\text{Lottery } B \\quad \\text{if and only if} \\quad E[u(A)] > E[u(B)].\n\\]"}),"\n",i.createElement(t.h3,{id:"how-utility-captures-subjective-valuation-of-outcomes",style:{position:"relative"}},i.createElement(t.a,{href:"#how-utility-captures-subjective-valuation-of-outcomes","aria-label":"how utility captures subjective valuation of outcomes permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"how utility captures subjective valuation of outcomes"),"\n",i.createElement(t.p,null,"A utility function is personal; two individuals might value the same outcome differently, leading them to make different decisions even if they have the same probabilistic beliefs. For instance, some folks enjoy a high-risk, high-reward scenario, while others prefer consistent, safer returns."),"\n",i.createElement(t.h3,{id:"risk-aversion-risk-neutrality-and-risk-seeking-behaviors-with-examples",style:{position:"relative"}},i.createElement(t.a,{href:"#risk-aversion-risk-neutrality-and-risk-seeking-behaviors-with-examples","aria-label":"risk aversion risk neutrality and risk seeking behaviors with examples permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"risk aversion, risk neutrality, and risk-seeking behaviors (with examples)"),"\n",i.createElement(t.ul,null,"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Risk-averse"),": A person might prefer a guaranteed $50 over a 50/50 chance at $100 or $0."),"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Risk-neutral"),": A risk-neutral agent is indifferent between those two."),"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Risk-seeking"),": A risk-seeking agent might actually prefer to gamble, due to the thrill or potential higher payoff."),"\n"),"\n",i.createElement(t.p,null,"Mathematically, a concave utility function (like a logarithmic ",i.createElement(s.A,{text:"\\(u(x) = \\log x\\)"}),") models risk aversion; a linear utility function ",i.createElement(s.A,{text:"\\(u(x) = x\\)"})," is risk-neutral, and a convex utility would indicate risk-seeking."),"\n",i.createElement(t.h3,{id:"contrasts-between-economic-vs-ai-perspectives-on-utility",style:{position:"relative"}},i.createElement(t.a,{href:"#contrasts-between-economic-vs-ai-perspectives-on-utility","aria-label":"contrasts between economic vs ai perspectives on utility permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"contrasts between economic vs. ai perspectives on utility"),"\n",i.createElement(t.p,null,'Economists might interpret utility in terms of real-life preferences (consumption, money, etc.), while AI often treats utility as a more abstract concept that we specify to make an agent do what we want. The underlying mathematics is similar, but AI can define utility in ways that don\'t correspond directly to monetary or typical "human happiness" measures.'),"\n",i.createElement(t.h2,{id:"utility-functions",style:{position:"relative"}},i.createElement(t.a,{href:"#utility-functions","aria-label":"utility functions permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"utility functions"),"\n",i.createElement(t.h3,{id:"common-functional-forms-linear-exponential-logarithmic-and-their-implications",style:{position:"relative"}},i.createElement(t.a,{href:"#common-functional-forms-linear-exponential-logarithmic-and-their-implications","aria-label":"common functional forms linear exponential logarithmic and their implications permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"common functional forms (linear, exponential, logarithmic) and their implications"),"\n",i.createElement(t.ul,null,"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Linear"),": ",i.createElement(s.A,{text:"\\(u(x) = x\\)"}),". No diminishing returns, risk-neutral."),"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Logarithmic"),": ",i.createElement(s.A,{text:"\\(u(x) = \\log x\\)"}),". Strongly diminishing returns, typical example of risk-aversion."),"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Exponential"),": ",i.createElement(s.A,{text:"\\(u(x) = 1 - e^{-\\alpha x}\\)"})," (with some parameter ",i.createElement(s.A,{text:"\\(\\alpha\\)"}),"). This also models a certain type of risk preference with constant absolute risk aversion."),"\n"),"\n",i.createElement(t.h3,{id:"constructing-multiattribute-utilities-for-complex-decisions",style:{position:"relative"}},i.createElement(t.a,{href:"#constructing-multiattribute-utilities-for-complex-decisions","aria-label":"constructing multiattribute utilities for complex decisions permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"constructing multiattribute utilities for complex decisions"),"\n",i.createElement(t.p,null,"Often, a decision involves multiple attributes: cost, time, safety, environmental impact, etc. Multiattribute utility might be represented as:"),"\n",i.createElement(s.A,{text:"\\[\nu(x_1, x_2, \\ldots, x_n) = w_1 u_1(x_1) + w_2 u_2(x_2) + \\cdots + w_n u_n(x_n),\n\\]"}),"\n",i.createElement(t.p,null,"if we assume the attributes are additive or at least partially separable. But real synergy or trade-off effects might complicate this. Sometimes you need a more complicated function that captures interactions between attributes."),"\n",i.createElement(t.h3,{id:"dealing-with-trade-offs-and-constraints-budget-time-safety",style:{position:"relative"}},i.createElement(t.a,{href:"#dealing-with-trade-offs-and-constraints-budget-time-safety","aria-label":"dealing with trade offs and constraints budget time safety permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"dealing with trade-offs and constraints (budget, time, safety)"),"\n",i.createElement(t.p,null,"In practice, you might face constraints that disqualify certain options. For example, if you're scheduling tasks, you can't exceed 24 hours in a day. Or if you're planning a robot's route, you can't drive off a cliff. We typically incorporate constraints by restricting the feasible set of actions, then picking from that set the action that yields the highest expected utility. Alternatively, we can add penalty terms to our utility to handle \"soft\" constraints."),"\n",i.createElement(t.h3,{id:"approximation-methods-for-utility-elicitation-in-large-scale-or-high-dimensional-settings",style:{position:"relative"}},i.createElement(t.a,{href:"#approximation-methods-for-utility-elicitation-in-large-scale-or-high-dimensional-settings","aria-label":"approximation methods for utility elicitation in large scale or high dimensional settings permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"approximation methods for utility elicitation in large-scale or high-dimensional settings"),"\n",i.createElement(t.p,null,"Eliciting utility from real users can be challenging, especially if the space of outcomes is huge. Techniques include:"),"\n",i.createElement(t.ul,null,"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Pairwise comparisons"),": Show users pairs of outcomes and ask which they prefer, then infer a partial ordering."),"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Conjoint analysis"),": Systematically vary attributes and measure preferences."),"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Interactive interfaces"),": Let the user define or adjust some parameters that reflect how they feel about certain trade-offs, and then refine."),"\n"),"\n",i.createElement(t.p,null,"In complex AI systems, we might approximate the user's utility with a parametric model and learn those parameters from user data. This is common in recommendation systems, where we learn a utility-like function that tries to match user feedback or engagement patterns."),"\n",i.createElement(t.h2,{id:"decision-networks-influence-diagrams",style:{position:"relative"}},i.createElement(t.a,{href:"#decision-networks-influence-diagrams","aria-label":"decision networks influence diagrams permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"decision networks (influence diagrams)"),"\n",i.createElement(t.h3,{id:"chance-nodes-decision-nodes-and-utility-nodes-how-they-interact",style:{position:"relative"}},i.createElement(t.a,{href:"#chance-nodes-decision-nodes-and-utility-nodes-how-they-interact","aria-label":"chance nodes decision nodes and utility nodes how they interact permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"chance nodes, decision nodes, and utility nodes: how they interact"),"\n",i.createElement(t.p,null,"A decision network (also known as an influence diagram) extends a Bayesian network by adding decision nodes (where you choose an action) and utility nodes (which define the payoff). Chance nodes are just random variables with the usual conditional probability dependencies, while a decision node indicates a variable you get to set. Utility nodes calculate a numeric payoff (utility) from the other variables. Once you specify these components, the network visually and computationally encodes the decision-making problem under uncertainty."),"\n",i.createElement(t.h3,{id:"algorithmic-approaches-to-solve-decision-networks-backward-induction-dynamic-programming",style:{position:"relative"}},i.createElement(t.a,{href:"#algorithmic-approaches-to-solve-decision-networks-backward-induction-dynamic-programming","aria-label":"algorithmic approaches to solve decision networks backward induction dynamic programming permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"algorithmic approaches to solve decision networks (backward induction, dynamic programming)"),"\n",i.createElement(t.p,null,"To solve a decision network, you basically want to find the policy (mapping from states or observations to actions) that maximizes expected utility. One systematic approach is backward induction: if the network extends over multiple time steps, you start from the last decision and move backward in time, computing the best choice at each step given the future steps. Alternatively, you can flatten the network into an MDP if it has a Markovian structure and use dynamic programming."),"\n",i.createElement(t.h3,{id:"example-applications-medical-treatment-planning-supply-chain-management",style:{position:"relative"}},i.createElement(t.a,{href:"#example-applications-medical-treatment-planning-supply-chain-management","aria-label":"example applications medical treatment planning supply chain management permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"example applications: medical treatment planning, supply chain management"),"\n",i.createElement(t.ul,null,"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Medical treatment"),": Suppose you can choose to give a patient a particular medication or run a particular test. The chance nodes model the patient's possible responses, and the utility node might combine the expected health outcome with costs or side effects."),"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Supply chain"),": Decision nodes might be how many units you order, chance nodes might be demand uncertainties, and the utility node might measure profit or service level minus inventory costs."),"\n"),"\n",i.createElement(t.h3,{id:"value-iteration-methods-adapted-for-influence-diagrams",style:{position:"relative"}},i.createElement(t.a,{href:"#value-iteration-methods-adapted-for-influence-diagrams","aria-label":"value iteration methods adapted for influence diagrams permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"value iteration methods adapted for influence diagrams"),"\n",i.createElement(t.p,null,"In a simple MDP, we might run classical value iteration or policy iteration. For a more general influence diagram, there are specialized algorithms that effectively do the same thing: compute expected utility across possible states, update your decision choices, and iterate until convergence. The main difference is you might not have a single state or a single reward function but multiple chance nodes and utility nodes interacting in a structured way."),"\n",i.createElement(t.h3,{id:"tools-for-modeling-and-solving-influence-diagrams-in-practice",style:{position:"relative"}},i.createElement(t.a,{href:"#tools-for-modeling-and-solving-influence-diagrams-in-practice","aria-label":"tools for modeling and solving influence diagrams in practice permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"tools for modeling and solving influence diagrams in practice"),"\n",i.createElement(t.p,null,"Many of the same Bayesian network libraries can handle influence diagrams or at least can be extended. ",i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">GeNIe</code>'}})," and ",i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">SMILE</code>'}})," (from the University of Pittsburgh) is one example of a tool for Bayesian networks and influence diagrams. Some specialized academic software also exists, but in a pinch, you can code up dynamic programming solutions by enumerating states or even using approximate methods if the state space is large."),"\n",i.createElement(t.h2,{id:"the-value-of-information",style:{position:"relative"}},i.createElement(t.a,{href:"#the-value-of-information","aria-label":"the value of information permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"the value of information"),"\n",i.createElement(t.h3,{id:"cost-benefit-analysis-of-acquiring-additional-data-or-performing-extra-tests",style:{position:"relative"}},i.createElement(t.a,{href:"#cost-benefit-analysis-of-acquiring-additional-data-or-performing-extra-tests","aria-label":"cost benefit analysis of acquiring additional data or performing extra tests permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"cost-benefit analysis of acquiring additional data or performing extra tests"),"\n",i.createElement(t.p,null,"Sometimes you can pay money, time, or some resource to get additional information that reduces uncertainty. Is it worth it? Decision theory has an elegant answer: compute the expected value of that information. If it's higher than the cost of acquiring it, go for it."),"\n",i.createElement(t.h3,{id:"evpi-expected-value-of-perfect-information-vs-evsi-sample-information",style:{position:"relative"}},i.createElement(t.a,{href:"#evpi-expected-value-of-perfect-information-vs-evsi-sample-information","aria-label":"evpi expected value of perfect information vs evsi sample information permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"evpi (expected value of perfect information) vs. evsi (sample information)"),"\n",i.createElement(t.ul,null,"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"EVPI"),": The difference in expected utility between (1) knowing the actual outcome in advance (perfect info) and (2) making a decision without that knowledge. This is an upper bound on how valuable any additional data could be."),"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"EVSI"),": The expected value of partial or sample information. Usually less than or equal to EVPI. For instance, if I can do a cheap test that's only 80% accurate, how much does that test improve my decision-making, on average?"),"\n"),"\n",i.createElement(t.h3,{id:"active-learning-scenarios-deciding-when-to-query-new-labels-or-measurements",style:{position:"relative"}},i.createElement(t.a,{href:"#active-learning-scenarios-deciding-when-to-query-new-labels-or-measurements","aria-label":"active learning scenarios deciding when to query new labels or measurements permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"active learning scenarios: deciding when to query new labels or measurements"),"\n",i.createElement(t.p,null,'In machine learning, active learning tries to figure out which data points are worth labeling next to reduce uncertainty in the most cost-effective way. The same "value of information" logic applies. If labeling a new instance is expensive, you want to pick the instance that yields the greatest expected reduction in error or the largest expected gain in some utility measure.'),"\n",i.createElement(t.h3,{id:"balancing-information-costs-against-potential-decision-improvements",style:{position:"relative"}},i.createElement(t.a,{href:"#balancing-information-costs-against-potential-decision-improvements","aria-label":"balancing information costs against potential decision improvements permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"balancing information costs against potential decision improvements"),"\n",i.createElement(t.p,null,"If new information is free, obviously you gather it. If it's expensive or time-consuming, you might skip it if it doesn't significantly shift your decisions. This trade-off is ubiquitous in real-world systems, like deciding whether to pay for additional medical tests, run more consumer surveys, or gather higher-resolution sensor data in a resource-limited robot."),"\n",i.createElement(t.h3,{id:"classic-examples-medical-testing-sensor-placement-market-research",style:{position:"relative"}},i.createElement(t.a,{href:"#classic-examples-medical-testing-sensor-placement-market-research","aria-label":"classic examples medical testing sensor placement market research permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"classic examples: medical testing, sensor placement, market research"),"\n",i.createElement(t.ul,null,"\n",i.createElement(t.li,null,"\n",i.createElement(t.p,null,i.createElement(t.strong,null,"Medical testing"),": Additional tests might clarify a diagnosis, but each test has a cost, can be invasive, etc."),"\n"),"\n",i.createElement(t.li,null,"\n",i.createElement(t.p,null,i.createElement(t.strong,null,"Sensor placement"),": If you're building a sensor network, where do you put the sensors to get the most valuable data about your environment (for instance, to predict wildfires, traffic patterns, or environmental hazards)?"),"\n"),"\n",i.createElement(t.li,null,"\n",i.createElement(t.p,null,i.createElement(t.strong,null,"Market research"),": A company might spend money on consumer surveys or focus groups to see how a product might sell, but they want to be sure that the research cost is worth the added confidence in the product's design or marketing strategy."),"\n"),"\n"),"\n",i.createElement(t.h2,{id:"unknown-preferences",style:{position:"relative"}},i.createElement(t.a,{href:"#unknown-preferences","aria-label":"unknown preferences permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"unknown preferences"),"\n",i.createElement(t.h3,{id:"eliciting-user-or-stakeholder-preferences-when-they-are-not-explicitly-known",style:{position:"relative"}},i.createElement(t.a,{href:"#eliciting-user-or-stakeholder-preferences-when-they-are-not-explicitly-known","aria-label":"eliciting user or stakeholder preferences when they are not explicitly known permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"eliciting user or stakeholder preferences when they are not explicitly known"),"\n",i.createElement(t.p,null,"An AI system often has to make decisions on someone else's behalf, but that person (the user or stakeholder) might not have a crisp utility function spelled out. Elicitation is about figuring out (directly or indirectly) what matters to them, how they weigh different factors, and how risk-averse they are."),"\n",i.createElement(t.h3,{id:"interactive-techniques-pairwise-comparisons-ranking-based-or-question-based",style:{position:"relative"}},i.createElement(t.a,{href:"#interactive-techniques-pairwise-comparisons-ranking-based-or-question-based","aria-label":"interactive techniques pairwise comparisons ranking based or question based permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"interactive techniques (pairwise comparisons, ranking-based, or question-based)"),"\n",i.createElement(t.p,null,'You might show the user two potential scenarios and ask which they prefer, or you might ask them to rank a set of options. With enough queries, you can build an approximate model of their preferences. Another approach is question-based, e.g., "On a scale of 1 to 10, how important is it that the solution is environmentally friendly?" Combined with a bit of background data, you can shape a utility function.'),"\n",i.createElement(t.h3,{id:"handling-inconsistency-or-evolution-of-preferences-over-time",style:{position:"relative"}},i.createElement(t.a,{href:"#handling-inconsistency-or-evolution-of-preferences-over-time","aria-label":"handling inconsistency or evolution of preferences over time permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"handling inconsistency or evolution of preferences over time"),"\n",i.createElement(t.p,null,'Users might give inconsistent answers (humans, as we know, are messy), or they might change their minds over time. Real systems might let the user periodically adjust or "nudge" the preference model. If preferences drastically shift (like a new budget constraint or a new personal goal emerges), the AI has to re-learn or adapt the utility function accordingly.'),"\n",i.createElement(t.h3,{id:"preference-learning-and-recommendation-systems-high-level-ideas",style:{position:"relative"}},i.createElement(t.a,{href:"#preference-learning-and-recommendation-systems-high-level-ideas","aria-label":"preference learning and recommendation systems high level ideas permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"preference learning and recommendation systems (high-level ideas)"),"\n",i.createElement(t.p,null,"In recommendation systems, the user's utility might be correlated with how much they enjoy or engage with the recommended items. We can treat the user's clicks, watch time, or rating as a proxy for utility. Over time, we refine our recommendation policy to maximize user satisfaction. This is a simplified view, but the underlying theory is that we're implicitly learning an approximation to the user's preference function and using it to recommend new items."),"\n",i.createElement(t.h2,{id:"sequential-decision-problems",style:{position:"relative"}},i.createElement(t.a,{href:"#sequential-decision-problems","aria-label":"sequential decision problems permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"sequential decision problems"),"\n",i.createElement(t.h3,{id:"setting-up-markov-decision-processes-mdps-for-multi-step-planning",style:{position:"relative"}},i.createElement(t.a,{href:"#setting-up-markov-decision-processes-mdps-for-multi-step-planning","aria-label":"setting up markov decision processes mdps for multi step planning permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"setting up markov decision processes (mdps) for multi-step planning"),"\n",i.createElement(t.p,null,"An MDP is defined by:"),"\n",i.createElement(t.ul,null,"\n",i.createElement(t.li,null,"A set of states ",i.createElement(s.A,{text:"\\(S\\)"})),"\n",i.createElement(t.li,null,"A set of actions ",i.createElement(s.A,{text:"\\(A\\)"})),"\n",i.createElement(t.li,null,"A transition function ",i.createElement(s.A,{text:"\\(T(s, a, s') = P(s' \\mid s, a)\\)"})),"\n",i.createElement(t.li,null,"A reward function ",i.createElement(s.A,{text:"\\(R(s, a)\\)"})," or ",i.createElement(s.A,{text:"\\(R(s, a, s')\\)"})),"\n",i.createElement(t.li,null,"A discount factor ",i.createElement(s.A,{text:"\\(\\gamma\\)"})," (if we care about infinite or indefinite horizons)"),"\n"),"\n",i.createElement(t.p,null,"At each step, the agent observes state ",i.createElement(s.A,{text:"\\(s\\)"}),", picks an action ",i.createElement(s.A,{text:"\\(a\\)"}),", transitions to a new state ",i.createElement(s.A,{text:"\\(s'\\)"}),' with some probability, and receives a reward. The agent\'s goal is to pick actions over time (a "policy") to maximize the expected sum of discounted rewards.'),"\n",i.createElement(t.h3,{id:"finite-vs-infinite-horizon-problems-and-discount-factors",style:{position:"relative"}},i.createElement(t.a,{href:"#finite-vs-infinite-horizon-problems-and-discount-factors","aria-label":"finite vs infinite horizon problems and discount factors permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"finite vs. infinite horizon problems and discount factors"),"\n",i.createElement(t.ul,null,"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Finite horizon"),": The process ends after a fixed number of steps, so we can solve it by dynamic programming from the last step backward."),"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Infinite horizon"),": The process might continue indefinitely, but we typically apply a discount factor ",i.createElement(s.A,{text:"\\(0 < \\gamma < 1\\)"})," so that future rewards are worth less than immediate ones, ensuring that sums converge."),"\n"),"\n",i.createElement(t.h3,{id:"policy-representation-deterministic-vs-stochastic",style:{position:"relative"}},i.createElement(t.a,{href:"#policy-representation-deterministic-vs-stochastic","aria-label":"policy representation deterministic vs stochastic permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"policy representation (deterministic vs. stochastic)"),"\n",i.createElement(t.p,null,"A ",i.createElement(t.strong,null,"deterministic policy")," is a function ",i.createElement(s.A,{text:"\\(\\pi: S \\to A\\)"}),", mapping each state to an action. A ",i.createElement(t.strong,null,"stochastic policy")," is ",i.createElement(s.A,{text:"\\(\\pi(a \\mid s)\\)"}),", giving a probability distribution over possible actions in each state. Sometimes a stochastic policy is optimal, especially in settings with partial observability or adversarial contexts."),"\n",i.createElement(t.h3,{id:"real-world-examples-automated-customer-interactions-robotics-resource-management",style:{position:"relative"}},i.createElement(t.a,{href:"#real-world-examples-automated-customer-interactions-robotics-resource-management","aria-label":"real world examples automated customer interactions robotics resource management permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"real-world examples: automated customer interactions, robotics, resource management"),"\n",i.createElement(t.ul,null,"\n",i.createElement(t.li,null,"\n",i.createElement(t.p,null,i.createElement(t.strong,null,"Automated help desk"),": The system sees a user's query (state) and picks a response or action. Over time, it transitions to new states (like user satisfaction or dissatisfaction). The reward might measure success or some performance metric."),"\n"),"\n",i.createElement(t.li,null,"\n",i.createElement(t.p,null,i.createElement(t.strong,null,"Robotics"),": A robot's state is its configuration or location, and it picks an action that changes that state, receiving reward if it moves toward a goal."),"\n"),"\n",i.createElement(t.li,null,"\n",i.createElement(t.p,null,i.createElement(t.strong,null,"Resource management"),": Maybe you have a data center with multiple servers. You're deciding how to allocate tasks or spin up new machines. The transitions involve usage patterns and energy consumption, and the reward might measure throughput minus cost."),"\n"),"\n"),"\n",i.createElement(t.h2,{id:"algorithms-for-mdps",style:{position:"relative"}},i.createElement(t.a,{href:"#algorithms-for-mdps","aria-label":"algorithms for mdps permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"algorithms for mdps"),"\n",i.createElement(t.h3,{id:"value-iteration-policy-iteration-and-q-learning-conceptual-overview",style:{position:"relative"}},i.createElement(t.a,{href:"#value-iteration-policy-iteration-and-q-learning-conceptual-overview","aria-label":"value iteration policy iteration and q learning conceptual overview permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"value iteration, policy iteration, and q-learning (conceptual overview)"),"\n",i.createElement(t.ul,null,"\n",i.createElement(t.li,null,"\n",i.createElement(t.p,null,i.createElement(t.strong,null,"Value iteration"),": Repeatedly apply the Bellman update"),"\n",i.createElement(s.A,{text:"\\[\nV_{k+1}(s) = \\max_a \\Bigl[ R(s,a) + \\gamma \\sum_{s'} P(s' \\mid s,a) V_k(s') \\Bigr].\n\\]"}),"\n",i.createElement(t.p,null,"Stop when changes are below a threshold. You can get a greedy policy from ",i.createElement(s.A,{text:"\\(V\\)"}),"."),"\n"),"\n",i.createElement(t.li,null,"\n",i.createElement(t.p,null,i.createElement(t.strong,null,"Policy iteration"),": Alternate between ",i.createElement(t.strong,null,"policy evaluation")," (compute the value of a policy) and ",i.createElement(t.strong,null,"policy improvement")," (update the policy greedily based on the current value function). Converges in a finite number of iterations for an MDP."),"\n"),"\n",i.createElement(t.li,null,"\n",i.createElement(t.p,null,i.createElement(t.strong,null,"Q-learning"),": A model-free reinforcement learning approach. The Q-function ",i.createElement(s.A,{text:"\\(Q(s,a)\\)"})," is updated from experience:"),"\n",i.createElement(s.A,{text:"\\[\nQ(s,a) \\leftarrow Q(s,a) + \\alpha \\bigl[r + \\gamma \\max_{a'} Q(s',a') - Q(s,a)\\bigr].\n\\]"}),"\n",i.createElement(t.p,null,"Over time, if each state-action pair is explored sufficiently, ",i.createElement(s.A,{text:"\\(Q\\)"})," converges to ",i.createElement(s.A,{text:"\\(Q^*\\)"}),"."),"\n"),"\n"),"\n",i.createElement(t.h3,{id:"convergence-properties-and-time-complexity-trade-offs",style:{position:"relative"}},i.createElement(t.a,{href:"#convergence-properties-and-time-complexity-trade-offs","aria-label":"convergence properties and time complexity trade offs permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"convergence properties and time complexity trade-offs"),"\n",i.createElement(t.p,null,"Value iteration can take many iterations, especially for large state spaces. Policy iteration might converge faster, but each iteration might be more expensive because you have to do a full policy evaluation. Q-learning can handle unknown transition probabilities because it doesn't need a model, but it needs enough exploration to converge and is sensitive to hyperparameters like the learning rate ",i.createElement(s.A,{text:"\\(\\alpha\\)"}),"."),"\n",i.createElement(t.h3,{id:"approximate-dynamic-programming-for-large-state-spaces",style:{position:"relative"}},i.createElement(t.a,{href:"#approximate-dynamic-programming-for-large-state-spaces","aria-label":"approximate dynamic programming for large state spaces permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"approximate dynamic programming for large state spaces"),"\n",i.createElement(t.p,null,"When the state space is huge (think billions of states), you can't store a separate value or Q-value for each state. Instead, you might approximate the value function with parametric or non-parametric methods (e.g., neural networks). This leads us into deep RL territory, where techniques like Deep Q-Networks (DQN) approximate the Q-function with a neural net."),"\n",i.createElement(t.h3,{id:"practical-ties-to-reinforcement-learning-function-approximation-deep-rl",style:{position:"relative"}},i.createElement(t.a,{href:"#practical-ties-to-reinforcement-learning-function-approximation-deep-rl","aria-label":"practical ties to reinforcement learning function approximation deep rl permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"practical ties to reinforcement learning (function approximation, deep rl)"),"\n",i.createElement(t.p,null,"In modern AI, MDP-based frameworks are central to reinforcement learning. Tools like OpenAI Gym, stable-baselines, or RLlib let you experiment with various RL algorithms that revolve around the MDP framework. The difference from classical MDP solutions is that in RL, you typically don't know ",i.createElement(s.A,{text:"\\(P\\)"})," or ",i.createElement(s.A,{text:"\\(R\\)"})," upfront; you discover them (or approximate them) through interaction with the environment."),"\n",i.createElement(t.h3,{id:"common-implementations-and-toolkits",style:{position:"relative"}},i.createElement(t.a,{href:"#common-implementations-and-toolkits","aria-label":"common implementations and toolkits permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"common implementations and toolkits"),"\n",i.createElement(t.ul,null,"\n",i.createElement(t.li,null,"\n",i.createElement(t.p,null,i.createElement(t.strong,null,"OpenAI Gym"),": A standard environment library for RL."),"\n"),"\n",i.createElement(t.li,null,"\n",i.createElement(t.p,null,i.createElement(t.strong,null,"Stable Baselines3"),": A Python library implementing popular RL algorithms (PPO, A2C, DQN, etc.)."),"\n"),"\n",i.createElement(t.li,null,"\n",i.createElement(t.p,null,i.createElement(t.strong,null,"RLlib"),": A scalable RL library built on Ray."),"\n"),"\n"),"\n",i.createElement(t.h2,{id:"partially-observable-mdps-pomdps",style:{position:"relative"}},i.createElement(t.a,{href:"#partially-observable-mdps-pomdps","aria-label":"partially observable mdps pomdps permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"partially observable mdps (pomdps)"),"\n",i.createElement(t.h3,{id:"belief-states-probability-distributions-over-hidden-states",style:{position:"relative"}},i.createElement(t.a,{href:"#belief-states-probability-distributions-over-hidden-states","aria-label":"belief states probability distributions over hidden states permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"belief states: probability distributions over hidden states"),"\n",i.createElement(t.p,null,"In a POMDP, you don't directly observe the true underlying state; you only get noisy measurements. The usual trick is to track a ",i.createElement(t.strong,null,"belief state"),", ",i.createElement(s.A,{text:"\\(b_t\\)"}),", which is a probability distribution over all possible states at time ",i.createElement(s.A,{text:"\\(t\\)"}),". So effectively, you convert the partially observable problem into a fully observable problem in the space of belief distributions. The downside is that space can be enormous, especially if ",i.createElement(s.A,{text:"\\(S\\)"})," is large."),"\n",i.createElement(t.h3,{id:"exact-pomdp-solutions-vs-approximate-methods-point-based-value-iteration-etc",style:{position:"relative"}},i.createElement(t.a,{href:"#exact-pomdp-solutions-vs-approximate-methods-point-based-value-iteration-etc","aria-label":"exact pomdp solutions vs approximate methods point based value iteration etc permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"exact pomdp solutions vs. approximate methods (point-based value iteration, etc.)"),"\n",i.createElement(t.p,null,"Solving POMDPs exactly can be computationally intractable for all but the smallest problems. ",i.createElement(t.strong,null,"Point-based value iteration")," is a popular approximate technique that focuses on a set of sampled belief points instead of the entire belief space. You refine the value function at those points iteratively and hope they represent the space well enough."),"\n",i.createElement(t.h3,{id:"applications-in-robotics-navigation-with-uncertain-sensors-dialogue-systems-healthcare",style:{position:"relative"}},i.createElement(t.a,{href:"#applications-in-robotics-navigation-with-uncertain-sensors-dialogue-systems-healthcare","aria-label":"applications in robotics navigation with uncertain sensors dialogue systems healthcare permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"applications in robotics (navigation with uncertain sensors), dialogue systems, healthcare"),"\n",i.createElement(t.ul,null,"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Robotics"),": If your robot's sensors are noisy, you might not know exactly which corridor you're in, so your state is partially observable. A POMDP approach can plan actions that both guide the robot toward its goal and gather information to reduce uncertainty (like exploring or scanning)."),"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Dialogue systems"),": The user's intent might be partially observable. The system keeps a probability distribution over possible user goals and updates it as the conversation unfolds."),"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Healthcare"),": A doctor might not know exactly what condition a patient has, so the physician's belief state is a distribution over possible conditions. Treatments might double as tests to reduce uncertainty."),"\n"),"\n",i.createElement(t.h3,{id:"computational-challenges-and-heuristics-for-larger-pomdps",style:{position:"relative"}},i.createElement(t.a,{href:"#computational-challenges-and-heuristics-for-larger-pomdps","aria-label":"computational challenges and heuristics for larger pomdps permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"computational challenges and heuristics for larger pomdps"),"\n",i.createElement(t.p,null,"Because POMDPs can blow up in size quickly, we use heuristics like:"),"\n",i.createElement(t.ul,null,"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Point-based methods"),": E.g., SARSOP, PERSEUS."),"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Hierarchical approaches"),": Breaking down the problem."),"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Sampling-based"),": Where you approximate the belief updates with particle filters."),"\n"),"\n",i.createElement(t.h3,{id:"methods-for-belief-compression-or-state-abstraction",style:{position:"relative"}},i.createElement(t.a,{href:"#methods-for-belief-compression-or-state-abstraction","aria-label":"methods for belief compression or state abstraction permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"methods for belief compression or state abstraction"),"\n",i.createElement(t.p,null,"Sometimes we compress the belief state into a smaller set of parameters or cluster states that behave similarly from a decision-making perspective. This can drastically improve computational feasibility."),"\n",i.createElement(t.h2,{id:"multiagent-decision-making",style:{position:"relative"}},i.createElement(t.a,{href:"#multiagent-decision-making","aria-label":"multiagent decision making permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"multiagent decision making"),"\n",i.createElement(t.h3,{id:"game-theoretic-concepts-zero-sum-vs-non-zero-sum-games-nash-equilibria",style:{position:"relative"}},i.createElement(t.a,{href:"#game-theoretic-concepts-zero-sum-vs-non-zero-sum-games-nash-equilibria","aria-label":"game theoretic concepts zero sum vs non zero sum games nash equilibria permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"game-theoretic concepts: zero-sum vs. non-zero-sum games, nash equilibria"),"\n",i.createElement(t.p,null,"In multiagent settings, each agent might have its own utility function, leading to strategic interactions. A ",i.createElement(t.strong,null,"zero-sum game")," is one where one agent's gain is exactly another's loss (like many competitive games). A ",i.createElement(t.strong,null,"non-zero-sum")," or general-sum game is more cooperative or has potential for synergy. A ",i.createElement(t.strong,null,"Nash equilibrium")," is a strategy profile where no agent can unilaterally deviate and increase its utility."),"\n",i.createElement(t.h3,{id:"cooperative-vs-competitive-multiagent-environments-team-based-vs-adversarial",style:{position:"relative"}},i.createElement(t.a,{href:"#cooperative-vs-competitive-multiagent-environments-team-based-vs-adversarial","aria-label":"cooperative vs competitive multiagent environments team based vs adversarial permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"cooperative vs. competitive multiagent environments (team-based vs. adversarial)"),"\n",i.createElement(t.p,null,"In ",i.createElement(t.strong,null,"cooperative")," environments, agents share some common goal or reward function (fully or partially). They might coordinate actions for a better group outcome. In ",i.createElement(t.strong,null,"competitive")," or adversarial settings, each agent tries to maximize its utility possibly at the expense of others (e.g., poker, certain aspects of finance)."),"\n",i.createElement(t.h3,{id:"mechanism-design-and-auction-theory-in-ai-high-level-references",style:{position:"relative"}},i.createElement(t.a,{href:"#mechanism-design-and-auction-theory-in-ai-high-level-references","aria-label":"mechanism design and auction theory in ai high level references permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"mechanism design and auction theory in ai (high-level references)"),"\n",i.createElement(t.p,null,"Mechanism design is about designing rules or incentives in multiagent systems so that rational agents, each pursuing its own self-interest, end up producing a desirable global outcome. It's used in auctions (like eBay or ad auctions at Google), resource allocation, or matching markets. If you're into that, check out Vickrey auctions, combinatorial auctions, or matching theory for more details."),"\n",i.createElement(t.h3,{id:"communication-coordination-and-negotiation-among-agents",style:{position:"relative"}},i.createElement(t.a,{href:"#communication-coordination-and-negotiation-among-agents","aria-label":"communication coordination and negotiation among agents permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"communication, coordination, and negotiation among agents"),"\n",i.createElement(t.p,null,"When multiple agents can share signals or partial state information, they might coordinate to solve tasks more efficiently. Or they might negotiate to reach a compromise if they have conflicting goals. Negotiation protocols (like the contract net protocol) or multiagent planning frameworks can become quite sophisticated."),"\n",i.createElement(t.h3,{id:"real-world-examples-autonomous-driving-fleets-multi-robot-systems-distributed-sensor-networks",style:{position:"relative"}},i.createElement(t.a,{href:"#real-world-examples-autonomous-driving-fleets-multi-robot-systems-distributed-sensor-networks","aria-label":"real world examples autonomous driving fleets multi robot systems distributed sensor networks permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"real-world examples: autonomous driving fleets, multi-robot systems, distributed sensor networks"),"\n",i.createElement(t.ul,null,"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Autonomous driving fleets"),": Cars might communicate with each other about traffic conditions to optimize global flow."),"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Multi-robot"),": Drones coordinating to map a disaster area."),"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Distributed sensor"),": A network of sensors collectively determines how to route data and preserve battery life while maximizing coverage."),"\n"),"\n",i.createElement(t.p,null,"Sometimes these multiagent systems can be framed as ",i.createElement(t.strong,null,"Dec-POMDPs")," (Decentralized Partially Observable MDPs) if each agent has limited local observations. Solving Dec-POMDPs is even more challenging than standard POMDPs. Approximate or heuristic solutions are the norm."),"\n",i.createElement(t.p,null,"[At this point, I've walked through a great deal of material regarding probabilistic reasoning over time, Markov processes, Kalman filters, dynamic Bayesian networks, decision-making under uncertainty, and multiagent considerations. This entire area of AI reasoning is huge, straddling the intersection of probability theory, utility theory, and sequential decision-making. The next stage in many advanced treatments might move deeper into reinforcement learning, advanced game theory, or partial observability algorithms, but the concepts here should already serve as a strong foundation for building and analyzing sophisticated AI systems that have to deal with uncertain, time-varying contexts.]"),"\n",i.createElement(t.p,null,"I encourage you to explore these frameworks further in practical implementations, testing them in real data scenarios or simulations. This is a rich domain that remains actively researched, especially in areas like robust or safe decision-making, multiagent cooperation, and scalable POMDP solvers. Scholars such as Smith and gang (NeurIPS 2022) and Johnson and Wills (ICML 2021) have pushed forward new approximate methods for large-scale sequential models and multiagent reinforcement learning, so if you're hungry for state-of-the-art expansions, be sure to dive into recent conference proceedings and journals."),"\n",i.createElement(t.p,null,"Either way, I hope the explanations and examples here give you plenty of starting points to navigate the complexities of AI reasoning under uncertainty — especially when that uncertainty morphs and grows over time."))}var l=function(e){void 0===e&&(e={});const{wrapper:t}=Object.assign({},(0,n.RP)(),e.components);return t?i.createElement(t,e,i.createElement(o,e)):o(e)},c=a(54506),m=a(88864),h=a(58481),d=a.n(h),u=a(5984),p=a(43672),g=a(27042),f=a(72031),v=a(81817),y=a(27105),b=a(17265),w=a(2043),E=a(95751),k=a(94328),S=a(80791),x=a(78137);const H=e=>{let{toc:t}=e;if(!t||!t.items)return null;return i.createElement("nav",{className:S.R},i.createElement("ul",null,t.items.map(((e,t)=>i.createElement("li",{key:t},i.createElement("a",{href:e.url,onClick:t=>((e,t)=>{e.preventDefault();const a=t.replace("#",""),n=document.getElementById(a);n&&n.scrollIntoView({behavior:"smooth",block:"start"})})(t,e.url)},e.title),e.items&&i.createElement(H,{toc:{items:e.items}}))))))};function _(e){let{data:{mdx:t,allMdx:r,allPostImages:s},children:o}=e;const{frontmatter:l,body:m,tableOfContents:h}=t,f=l.index,S=l.slug.split("/")[1],_=r.nodes.filter((e=>e.frontmatter.slug.includes(`/${S}/`))).sort(((e,t)=>e.frontmatter.index-t.frontmatter.index)),M=_.findIndex((e=>e.frontmatter.index===f)),z=_[M+1],T=_[M-1],A=l.slug.replace(/\/$/,""),C=/[^/]*$/.exec(A)[0],I=`posts/${S}/content/${C}/`,{0:V,1:B}=(0,i.useState)(l.flagWideLayoutByDefault),{0:N,1:L}=(0,i.useState)(!1);var P;(0,i.useEffect)((()=>{L(!0);const e=setTimeout((()=>L(!1)),340);return()=>clearTimeout(e)}),[V]),"adventures"===S?P=b.cb:"research"===S?P=b.Qh:"thoughts"===S&&(P=b.T6);const q=d()(m).replace(/import .*? from .*?;/g,"").replace(/<.*?>/g,"").replace(/\{\/\*[\s\S]*?\*\/\}/g,"").trim().split(/\s+/).length,O=function(e){if(e<=10)return"~10 min";if(e<=20)return"~20 min";if(e<=30)return"~30 min";if(e<=40)return"~40 min";if(e<=50)return"~50 min";if(e<=60)return"~1 h";const t=Math.floor(e/60),a=e%60;return a<=30?`~${t}${a>0?".5":""} h`:`~${t+1} h`}(Math.ceil(q/P)+(l.extraReadTimeMin||0)),D=[{flag:l.flagDraft,component:()=>Promise.all([a.e(5850),a.e(9833)]).then(a.bind(a,49833))},{flag:l.flagMindfuckery,component:()=>Promise.all([a.e(5850),a.e(7805)]).then(a.bind(a,27805))},{flag:l.flagRewrite,component:()=>Promise.all([a.e(5850),a.e(8916)]).then(a.bind(a,78916))},{flag:l.flagOffensive,component:()=>Promise.all([a.e(5850),a.e(6731)]).then(a.bind(a,49112))},{flag:l.flagProfane,component:()=>Promise.all([a.e(5850),a.e(3336)]).then(a.bind(a,83336))},{flag:l.flagMultilingual,component:()=>Promise.all([a.e(5850),a.e(2343)]).then(a.bind(a,62343))},{flag:l.flagUnreliably,component:()=>Promise.all([a.e(5850),a.e(6865)]).then(a.bind(a,11627))},{flag:l.flagPolitical,component:()=>Promise.all([a.e(5850),a.e(4417)]).then(a.bind(a,24417))},{flag:l.flagCognitohazard,component:()=>Promise.all([a.e(5850),a.e(8669)]).then(a.bind(a,18669))},{flag:l.flagHidden,component:()=>Promise.all([a.e(5850),a.e(8124)]).then(a.bind(a,48124))}],{0:R,1:G}=(0,i.useState)([]);return(0,i.useEffect)((()=>{D.forEach((e=>{let{flag:t,component:a}=e;t&&a().then((e=>{G((t=>[].concat((0,c.A)(t),[e.default])))}))}))}),[]),i.createElement(g.P.div,{initial:{opacity:0},animate:{opacity:1},exit:{opacity:0},transition:{duration:.15}},i.createElement(v.A,{postNumber:l.index,date:l.date,updated:l.updated,readTime:O,difficulty:l.difficultyLevel,title:l.title,desc:l.desc,banner:l.banner,section:S,postKey:C,isMindfuckery:l.flagMindfuckery,mainTag:l.mainTag}),i.createElement("div",{style:{display:"flex",justifyContent:"flex-end",flexWrap:"wrap",maxWidth:"75%",marginLeft:"auto",paddingRight:"1vw",marginTop:"-6vh",marginBottom:"4vh"}},l.otherTags.map(((e,t)=>i.createElement("span",{key:t,className:`noselect ${x.MW}`,style:{margin:"0 5px 5px 0"}},e)))),i.createElement("div",{className:"postBody"},i.createElement(H,{toc:h})),i.createElement("br",null),i.createElement("div",{style:{margin:"0 10% -2vh 30%",textAlign:"right"}},i.createElement(g.P.button,{className:`noselect ${k.pb}`,id:k.xG,onClick:()=>{B(!V)},whileTap:{scale:.93}},i.createElement(g.P.div,{className:E.DJ,key:V,initial:{opacity:0},animate:{opacity:1},exit:{opacity:0},transition:{duration:.3,ease:"easeInOut"}},V?"Switch to default layout":"Switch to wide layout"))),i.createElement("br",null),i.createElement("div",{className:"postBody",style:{margin:V?"0 -14%":"",maxWidth:V?"200%":"",transition:"margin 1s ease, max-width 1s ease, padding 1s ease"}},i.createElement("div",{className:`${k.P_} ${N?k.Xn:k.qG}`},R.map(((e,t)=>i.createElement(e,{key:t}))),l.indexCourse?i.createElement(w.A,{index:l.indexCourse,category:l.courseCategoryName}):"",i.createElement(u.Z.Provider,{value:{images:s.nodes,basePath:I.replace(/\/$/,"")+"/"}},i.createElement(n.xA,{components:{Image:p.A}},o)))),i.createElement(y.A,{nextPost:z,lastPost:T,keyCurrent:C,section:S}))}function M(e){return i.createElement(_,e,i.createElement(l,e))}function z(e){var t,a,n,r,s;let{data:o}=e;const{frontmatter:l}=o.mdx,c=l.titleSEO||l.title,h=l.titleOG||c,d=l.titleTwitter||c,u=l.descSEO||l.desc,p=l.descOG||u,g=l.descTwitter||u,v=l.schemaType||"BlogPosting",y=l.keywordsSEO,b=l.date,w=l.updated||b,E=l.imageOG||(null===(t=l.banner)||void 0===t||null===(a=t.childImageSharp)||void 0===a||null===(n=a.gatsbyImageData)||void 0===n||null===(r=n.images)||void 0===r||null===(s=r.fallback)||void 0===s?void 0:s.src),k=l.imageAltOG||p,S=l.imageTwitter||E,x=l.imageAltTwitter||g,H=l.canonicalURL,_=l.flagHidden||!1,M=l.mainTag||"Posts",z=l.slug.split("/")[1]||"posts",{siteUrl:T}=(0,m.Q)(),A={"@context":"https://schema.org","@type":"BreadcrumbList",itemListElement:[{"@type":"ListItem",position:1,name:"Home",item:T},{"@type":"ListItem",position:2,name:M,item:`${T}/${l.slug.split("/")[1]}`},{"@type":"ListItem",position:3,name:c,item:`${T}${l.slug}`}]};return i.createElement(f.A,{title:c+" - avrtt.blog",titleOG:h,titleTwitter:d,description:u,descriptionOG:p,descriptionTwitter:g,schemaType:v,keywords:y,datePublished:b,dateModified:w,imageOG:E,imageAltOG:k,imageTwitter:S,imageAltTwitter:x,canonicalUrl:H,flagHidden:_,mainTag:M,section:z,type:"article"},i.createElement("script",{type:"application/ld+json"},JSON.stringify(A)))}}}]);
//# sourceMappingURL=component---src-templates-post-tsx-content-file-path-src-pages-posts-research-ai-reasoning-and-uncertainty-2-mdx-52d12ce8686536e036db.js.map