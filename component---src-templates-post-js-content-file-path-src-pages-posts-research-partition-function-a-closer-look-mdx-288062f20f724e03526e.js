"use strict";(self.webpackChunkavrtt_blog=self.webpackChunkavrtt_blog||[]).push([[8428],{3962:function(e,t){t.A="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iaXNvLTg4NTktMSI/Pgo8IS0tIEdlbmVyYXRvcjogQWRvYmUgSWxsdXN0cmF0b3IgMTYuMC4wLCBTVkcgRXhwb3J0IFBsdWctSW4gLiBTVkcgVmVyc2lvbjogNi4wMCBCdWlsZCAwKSAgLS0+CjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+CjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iQ2FwYV8xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4PSIwcHgiIHk9IjBweCIKCSB3aWR0aD0iNDE2Ljk3OXB4IiBoZWlnaHQ9IjQxNi45NzlweCIgdmlld0JveD0iMCAwIDQxNi45NzkgNDE2Ljk3OSIgc3R5bGU9ImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgNDE2Ljk3OSA0MTYuOTc5OyIKCSB4bWw6c3BhY2U9InByZXNlcnZlIj4KPGc+Cgk8cGF0aCBkPSJNMzU2LjAwNCw2MS4xNTZjLTgxLjM3LTgxLjQ3LTIxMy4zNzctODEuNTUxLTI5NC44NDgtMC4xODJjLTgxLjQ3LDgxLjM3MS04MS41NTIsMjEzLjM3OS0wLjE4MSwyOTQuODUKCQljODEuMzY5LDgxLjQ3LDIxMy4zNzgsODEuNTUxLDI5NC44NDksMC4xODFDNDM3LjI5MywyNzQuNjM2LDQzNy4zNzUsMTQyLjYyNiwzNTYuMDA0LDYxLjE1NnogTTIzNy42LDM0MC43ODYKCQljMCwzLjIxNy0yLjYwNyw1LjgyMi01LjgyMiw1LjgyMmgtNDYuNTc2Yy0zLjIxNSwwLTUuODIyLTIuNjA1LTUuODIyLTUuODIyVjE2Ny44ODVjMC0zLjIxNywyLjYwNy01LjgyMiw1LjgyMi01LjgyMmg0Ni41NzYKCQljMy4yMTUsMCw1LjgyMiwyLjYwNCw1LjgyMiw1LjgyMlYzNDAuNzg2eiBNMjA4LjQ5LDEzNy45MDFjLTE4LjYxOCwwLTMzLjc2Ni0xNS4xNDYtMzMuNzY2LTMzLjc2NQoJCWMwLTE4LjYxNywxNS4xNDctMzMuNzY2LDMzLjc2Ni0zMy43NjZjMTguNjE5LDAsMzMuNzY2LDE1LjE0OCwzMy43NjYsMzMuNzY2QzI0Mi4yNTYsMTIyLjc1NSwyMjcuMTA3LDEzNy45MDEsMjA4LjQ5LDEzNy45MDF6Ii8+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPC9zdmc+Cg=="},6231:function(e,t,a){a.r(t),a.d(t,{Head:function(){return H},PostTemplate:function(){return C},default:function(){return z}});var n=a(54506),i=a(28453),r=a(96540),o=a(66501),l=a(16886),s=a(46295),c=a(96098);function h(e){const t=Object.assign({p:"p",h3:"h3",a:"a",span:"span",h2:"h2",ul:"ul",li:"li",strong:"strong",ol:"ol",hr:"hr"},(0,i.RP)(),e.components),{Image:a}=t;return a||function(e,t){throw new Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Image",!0),r.createElement(r.Fragment,null,"\n",r.createElement("br"),"\n","\n","\n",r.createElement(t.p,null,"When diving into probabilistic models — especially those that are undirected or energy-based — there is a central concept we cannot avoid: the partition function. I find it crucial to shine a bright spotlight on this because the partition function is at once ubiquitous and famously troublesome. It appears in virtually all undirected models, from ",r.createElement(l.A,null,"Restricted Boltzmann Machines")," (RBMs) to ",r.createElement(l.A,null,"Markov Random Fields")," (MRFs) and beyond, serving as the normalizing constant that transforms raw energy functions (or unnormalized log probabilities) into well-defined probability distributions. The partition function, often denoted as ",r.createElement(c.A,{text:"\\(Z\\)"}),", is often the direct cause of computational nightmares: it involves summing (or integrating) a potentially astronomical number of configurations across a high-dimensional space. Because of its fundamental importance — as well as its notorious intractability — an entire ecosystem of approximation strategies, alternative learning objectives, and algorithmic cleverness has emerged around it."),"\n",r.createElement(t.p,null,"The reason I dedicate a separate article to the partition function is the sheer depth of theoretical and practical methods that revolve around either avoiding it, approximating it, or circumventing its direct computation. In many advanced machine learning contexts, especially in the realm of energy-based models, the presence of the partition function ",r.createElement(c.A,{text:"\\(Z\\)"})," in the log-likelihood invites an elaborate interplay of gradient terms, sampling techniques, and approximate inference strategies. If we don't fully understand the role of ",r.createElement(c.A,{text:"\\(Z\\)"})," — and the difficulty it poses — our grasp of these learning algorithms will remain incomplete or superficial at best."),"\n",r.createElement(t.h3,{id:"role-of-the-partition-function-in-undirected-probabilistic-models",style:{position:"relative"}},r.createElement(t.a,{href:"#role-of-the-partition-function-in-undirected-probabilistic-models","aria-label":"role of the partition function in undirected probabilistic models permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Role of the partition function in undirected probabilistic models"),"\n",r.createElement(t.p,null,"To understand what ",r.createElement(c.A,{text:"\\(Z\\)"})," is, let's consider a general undirected model that assigns an energy ",r.createElement(c.A,{text:"\\(E(\\mathbf{x}; \\theta)\\)"})," (where ",r.createElement(c.A,{text:"\\(\\mathbf{x}\\)"})," is the data and ",r.createElement(c.A,{text:"\\(\\theta\\)"})," denotes parameters) to each possible configuration of ",r.createElement(c.A,{text:"\\(\\mathbf{x}\\)"}),". The unnormalized probability of a particular configuration ",r.createElement(c.A,{text:"\\(\\mathbf{x}\\)"})," can be expressed as:"),"\n",r.createElement(c.A,{text:"\\[\n\\tilde{p}(\\mathbf{x}; \\theta) = \\exp\\bigl(-E(\\mathbf{x}; \\theta)\\bigr).\n\\]"}),"\n",r.createElement(t.p,null,"The partition function ",r.createElement(c.A,{text:"\\(Z(\\theta)\\)"})," is then defined as"),"\n",r.createElement(c.A,{text:"\\[\nZ(\\theta) = \\sum_{\\mathbf{x}} \\exp\\bigl(-E(\\mathbf{x}; \\theta)\\bigr),\n\\]"}),"\n",r.createElement(t.p,null,"if ",r.createElement(c.A,{text:"\\(\\mathbf{x}\\)"})," is discrete, or"),"\n",r.createElement(c.A,{text:"\\[\nZ(\\theta) = \\int \\exp\\bigl(-E(\\mathbf{x}; \\theta)\\bigr)\\, d\\mathbf{x}\n\\]"}),"\n",r.createElement(t.p,null,"if ",r.createElement(c.A,{text:"\\(\\mathbf{x}\\)"})," is continuous. The fully normalized probability distribution ",r.createElement(c.A,{text:"\\(p(\\mathbf{x}; \\theta)\\)"})," is then:"),"\n",r.createElement(c.A,{text:"\\[\np(\\mathbf{x}; \\theta) = \\frac{\\tilde{p}(\\mathbf{x}; \\theta)}{Z(\\theta)}.\n\\]"}),"\n",r.createElement(t.p,null,"Hence, ",r.createElement(c.A,{text:"\\(Z(\\theta)\\)"})," is the global normalizer. If ",r.createElement(c.A,{text:"\\(Z(\\theta)\\)"})," is very difficult to compute or approximate, it complicates any method that relies on evaluating ",r.createElement(c.A,{text:"\\(p(\\mathbf{x}; \\theta)\\)"})," or its gradient with respect to ",r.createElement(c.A,{text:"\\(\\theta\\)"}),"."),"\n",r.createElement(t.h3,{id:"challenges-in-high-dimensional-spaces",style:{position:"relative"}},r.createElement(t.a,{href:"#challenges-in-high-dimensional-spaces","aria-label":"challenges in high dimensional spaces permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Challenges in high-dimensional spaces"),"\n",r.createElement(t.p,null,"In high-dimensional spaces — typical for image data, large-scale textual data, or other complex domains — computing ",r.createElement(c.A,{text:"\\(Z(\\theta)\\)"})," exactly is typically out of the question. The number of configurations ",r.createElement(c.A,{text:"\\(\\mathbf{x}\\)"})," can be astronomically large. Even approximate summation or integration can be burdensome without careful sampling or specialized methods. This intractability is what led to the development of widely used approximation strategies like ",r.createElement(l.A,null,"Contrastive Divergence")," and ",r.createElement(l.A,null,"Noise-Contrastive Estimation"),", as well as specialized sampling methods such as ",r.createElement(l.A,null,"Annealed Importance Sampling"),"."),"\n",r.createElement(t.h3,{id:"importance-of-partition-function-free-methods",style:{position:"relative"}},r.createElement(t.a,{href:"#importance-of-partition-function-free-methods","aria-label":"importance of partition function free methods permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Importance of partition-function-free methods"),"\n",r.createElement(t.p,null,"An important thread in the literature is the desire to circumvent ",r.createElement(c.A,{text:"\\(Z\\)"})," altogether. One might consider alternative objectives or surrogate losses that do not explicitly include ",r.createElement(c.A,{text:"\\(Z(\\theta)\\)"}),". This has led to methods such as ",r.createElement(l.A,null,"Pseudolikelihood")," and ",r.createElement(l.A,null,"Score Matching"),", each with its own nuances and domain of applicability. These methods are often deeply connected with fundamental statistical theory. For instance, score matching has roots in older ideas from ",r.createElement(l.A,null,"Fisher divergence")," and leads to interesting ways to estimate parameters by matching model gradients to data gradients. Meanwhile, pseudolikelihood builds upon the factorization properties of conditional distributions and is sometimes used in fields like ",r.createElement(o.A,{text:"social network analysis"})," to handle large, complex networks of variables."),"\n",r.createElement(t.p,null,"By the end of this article, I hope you will see not only the specific reasons why the partition function demands so much care, but also the variety of ways researchers have tackled it. The theoretical insights, the sampling-based methods, and the approximate objectives form a multifaceted toolbox. When confronted with the dreaded ",r.createElement(c.A,{text:"\\(Z(\\theta)\\)"})," in your own projects, you can decide whether to approximate it directly, bypass it with an alternative learning criterion, or try something more exotic altogether."),"\n",r.createElement(t.h2,{id:"2-the-log-likelihood-gradient",style:{position:"relative"}},r.createElement(t.a,{href:"#2-the-log-likelihood-gradient","aria-label":"2 the log likelihood gradient permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"2. The log-likelihood gradient"),"\n",r.createElement(t.p,null,"When we train an undirected model such as an RBM or a Markov Random Field using maximum likelihood, we typically consider the log-likelihood function:"),"\n",r.createElement(c.A,{text:"\\[\n\\mathcal{L}(\\theta) = \\log p(\\mathbf{X}; \\theta) = \\sum_{i=1}^N \\log p(\\mathbf{x}^{(i)}; \\theta),\n\\]"}),"\n",r.createElement(t.p,null,"where ",r.createElement(c.A,{text:"\\( \\mathbf{x}^{(i)} \\)"})," is the ",r.createElement(c.A,{text:"\\(i\\)"}),"-th data point and ",r.createElement(c.A,{text:"\\(N\\)"})," is the size of the dataset. Expanding ",r.createElement(c.A,{text:"\\(\\log p(\\mathbf{x}; \\theta)\\)"}),", we get:"),"\n",r.createElement(c.A,{text:"\\[\n\\log p(\\mathbf{x}; \\theta) = -E(\\mathbf{x}; \\theta) - \\log Z(\\theta).\n\\]"}),"\n",r.createElement(t.p,null,"Thus, the log-likelihood for the entire dataset is:"),"\n",r.createElement(c.A,{text:"\\[\n\\mathcal{L}(\\theta) = -\\sum_{i=1}^N E(\\mathbf{x}^{(i)}; \\theta) - N \\log Z(\\theta),\n\\]"}),"\n",r.createElement(t.p,null,"assuming a single ",r.createElement(c.A,{text:"\\(E\\)"})," for all data points, though in some contexts we might have a sum of energies if the model factorizes in certain ways."),"\n",r.createElement(t.h3,{id:"positive-and-negative-phases",style:{position:"relative"}},r.createElement(t.a,{href:"#positive-and-negative-phases","aria-label":"positive and negative phases permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Positive and negative phases"),"\n",r.createElement(t.p,null,"The gradient of ",r.createElement(c.A,{text:"\\(\\mathcal{L}(\\theta)\\)"}),' typically separates into what many in the Boltzmann machine literature call the "positive phase" and "negative phase". Specifically,'),"\n",r.createElement(c.A,{text:"\\[\n\\nabla_\\theta \\mathcal{L}(\\theta) = -\\sum_{i=1}^N \\nabla_\\theta E(\\mathbf{x}^{(i)}; \\theta) - N \\nabla_\\theta \\log Z(\\theta).\n\\]"}),"\n",r.createElement(t.p,null,"When distributing the negative sign, you might see it more commonly expressed as:"),"\n",r.createElement(c.A,{text:"\\[\n\\nabla_\\theta \\mathcal{L}(\\theta) \n= -\\sum_{i=1}^N \\nabla_\\theta E(\\mathbf{x}^{(i)}; \\theta) + N \\mathbb{E}_{p(\\mathbf{x}; \\theta)}\\bigl[\\nabla_\\theta E(\\mathbf{x}; \\theta)\\bigr].\n\\]"}),"\n",r.createElement(t.p,null,"Here the term involving ",r.createElement(c.A,{text:"\\(\\log Z(\\theta)\\)"})," has been rewritten as an expectation under the model distribution:"),"\n",r.createElement(c.A,{text:"\\[\n\\nabla_\\theta \\log Z(\\theta) \n= \\frac{\\nabla_\\theta Z(\\theta)}{Z(\\theta)} \n= \\mathbb{E}_{p(\\mathbf{x}; \\theta)}\\bigl[\\nabla_\\theta E(\\mathbf{x}; \\theta)\\bigr].\n\\]"}),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Positive phase"),": ",r.createElement(c.A,{text:"\\(-\\sum_{i=1}^N \\nabla_\\theta E(\\mathbf{x}^{(i)}; \\theta)\\)"})," corresponds to matching the model's parameters so that it assigns low energy (thus high probability) to observed data ",r.createElement(c.A,{text:"\\(\\mathbf{x}^{(i)}\\)"}),"."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Negative phase"),": ",r.createElement(c.A,{text:"\\(+ N \\mathbb{E}_{p(\\mathbf{x}; \\theta)}\\bigl[\\nabla_\\theta E(\\mathbf{x}; \\theta)\\bigr]\\)"})," corresponds to ensuring that the overall probability mass does not blow up, by nudging the parameters so that the model distribution does not assign too much probability to non-data configurations."),"\n"),"\n",r.createElement(t.h3,{id:"why-the-partition-function-term-makes-the-gradient-hard",style:{position:"relative"}},r.createElement(t.a,{href:"#why-the-partition-function-term-makes-the-gradient-hard","aria-label":"why the partition function term makes the gradient hard permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Why the partition function term makes the gradient hard"),"\n",r.createElement(t.p,null,"The crux of the difficulty is that to compute ",r.createElement(c.A,{text:"\\(\\mathbb{E}_{p(\\mathbf{x}; \\theta)}\\bigl[\\nabla_\\theta E(\\mathbf{x}; \\theta)\\bigr]\\)"}),", one must sample from the current model distribution ",r.createElement(c.A,{text:"\\(p(\\mathbf{x}; \\theta)\\)"})," or otherwise approximate it. Direct summation or integration over ",r.createElement(c.A,{text:"\\(\\mathbf{x}\\)"})," is generally intractable, so we need to rely on methods such as ",r.createElement(l.A,null,"Monte Carlo Markov Chain")," (MCMC) to approximate this expectation. If the MCMC chain mixes slowly or dimension is large, accurate sampling can become an expensive proposition."),"\n",r.createElement(t.p,null,"The partition function's gradient ",r.createElement(c.A,{text:"\\(\\nabla_\\theta \\log Z(\\theta)\\)"})," thus stands out as the key computational burden. Indeed, the entire impetus behind many alternative objectives is to avoid explicit computation of ",r.createElement(c.A,{text:"\\(Z(\\theta)\\)"})," or its gradient. As we shall see in subsequent chapters, approaches like ",r.createElement(l.A,null,"Pseudolikelihood"),", ",r.createElement(l.A,null,"Score Matching"),", and ",r.createElement(l.A,null,"Noise-Contrastive Estimation")," are creative attempts to get around the intractable nature of the partition function while still capturing meaningful statistics about the data."),"\n",r.createElement(t.h3,{id:"interpreting-the-gradient-of-log-z",style:{position:"relative"}},r.createElement(t.a,{href:"#interpreting-the-gradient-of-log-z","aria-label":"interpreting the gradient of log z permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Interpreting the gradient of log Z"),"\n",r.createElement(t.p,null,"Another lens to see this from: ",r.createElement(c.A,{text:"\\(Z(\\theta)\\)"}),' can be interpreted in thermodynamic or statistical-physics terms as a normalizing factor ensuring that the "energy landscape" is consistent with a proper probability distribution. Its gradient effectively measures how changes in ',r.createElement(c.A,{text:"\\(\\theta\\)"})," stretch or squash that landscape globally. Understanding this helps to see why we might approximate it locally (as in pseudolikelihood), or in a more global sense with approximate sampling (Contrastive Divergence), or by turning the problem into a classification problem (Noise-Contrastive Estimation)."),"\n",r.createElement(t.h2,{id:"3-stochastic-maximum-likelihood-and-contrastive-divergence",style:{position:"relative"}},r.createElement(t.a,{href:"#3-stochastic-maximum-likelihood-and-contrastive-divergence","aria-label":"3 stochastic maximum likelihood and contrastive divergence permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"3. Stochastic maximum likelihood and contrastive divergence"),"\n",r.createElement(t.p,null,"Historically, one of the early successes in dealing with the partition function within RBMs and other Boltzmann machines was the introduction of ",r.createElement(l.A,null,"Contrastive Divergence")," (CD) by Hinton and subsequent refinements like ",r.createElement(l.A,null,"Persistent Contrastive Divergence")," (PCD) or ",r.createElement(l.A,null,"Stochastic Maximum Likelihood")," (SML). These methods revolve around MCMC sampling, but they do so in ways that reduce the computational cost and, crucially, the burden of having to approximate ",r.createElement(c.A,{text:"\\(\\log Z(\\theta)\\)"})," too precisely."),"\n",r.createElement(t.h3,{id:"naive-mcmc-approaches",style:{position:"relative"}},r.createElement(t.a,{href:"#naive-mcmc-approaches","aria-label":"naive mcmc approaches permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Naive MCMC approaches"),"\n",r.createElement(t.p,null,"Let us consider the naive approach to maximum likelihood. We know that the gradient has this negative-phase term requiring samples ",r.createElement(c.A,{text:"\\(\\mathbf{x}\\)"})," from the model distribution. One might try a straightforward Markov chain approach: for each gradient update, run a Markov chain from scratch (starting from a random initialization) to approximate the model distribution at the current ",r.createElement(c.A,{text:"\\(\\theta\\)"}),". But in many high-dimensional models, this chain could take a prohibitive number of steps to mix properly. Doing that at each parameter update is unrealistic. The result is that naive MCMC maximum likelihood can be extremely slow, often so slow as to be infeasible."),"\n",r.createElement(t.h3,{id:"contrastive-divergence-cd-k",style:{position:"relative"}},r.createElement(t.a,{href:"#contrastive-divergence-cd-k","aria-label":"contrastive divergence cd k permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Contrastive divergence (CD-k)"),"\n",r.createElement(t.p,null,'Contrastive Divergence proposed a more practical compromise: rather than sampling from the model distribution until full mixing, one initializes the chain with the actual data (often called the "clamped" state) and then runs a small number of Gibbs sampling steps — ',r.createElement(c.A,{text:"\\(k\\)"}),' steps is typical — to get a "negative sample". The intuition is that starting from real data hopefully puts us in a region of high probability under the model, so we do not need as many steps to reach some approximate sample from ',r.createElement(c.A,{text:"\\(p(\\mathbf{x}; \\theta)\\)"}),". Then we use that sample to estimate the negative phase. Formally, the CD-k gradient update looks like:"),"\n",r.createElement(c.A,{text:"\\[\n\\nabla_\\theta \\mathcal{L}(\\theta) \\approx -\\sum_{i=1}^N \\nabla_\\theta E(\\mathbf{x}^{(i)}; \\theta) + \\sum_{i=1}^N \\nabla_\\theta E(\\mathbf{x}'^{(i)}; \\theta),\n\\]"}),"\n",r.createElement(t.p,null,"where ",r.createElement(c.A,{text:"\\(\\mathbf{x}'^{(i)}\\)"})," is the sample obtained after ",r.createElement(c.A,{text:"\\(k\\)"})," steps of Gibbs sampling starting from ",r.createElement(c.A,{text:"\\(\\mathbf{x}^{(i)}\\)"}),'. This is sometimes referred to as a form of "short-run MCMC".'),"\n",r.createElement(t.p,null,"CD-k is fast, especially for an RBM where Gibbs sampling can be split into an alternating procedure between hidden and visible units in ",r.createElement(c.A,{text:"\\(O(k)\\)"})," time. However, it introduces bias: the samples you get may not match the true stationary distribution of the model. Interestingly, for small ",r.createElement(c.A,{text:"\\(k\\)"}),", the method often works well in practice (particularly in generative pretraining of deep networks). Yet for pure maximum likelihood, it is no longer guaranteed that we are performing gradient ascent on the true log-likelihood."),"\n",r.createElement(t.h3,{id:"stochastic-maximum-likelihood-sml-or-persistent-contrastive-divergence-pcd",style:{position:"relative"}},r.createElement(t.a,{href:"#stochastic-maximum-likelihood-sml-or-persistent-contrastive-divergence-pcd","aria-label":"stochastic maximum likelihood sml or persistent contrastive divergence pcd permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Stochastic maximum likelihood (SML) or persistent contrastive divergence (PCD)"),"\n",r.createElement(t.p,null,'A refinement to mitigate the short-run bias is to maintain a set of "persistent" MCMC chains across parameter updates, rather than re-initializing from the data each time. This approach is known as ',r.createElement(l.A,null,"Persistent Contrastive Divergence")," or ",r.createElement(l.A,null,"Stochastic Maximum Likelihood")," (SML). The idea is:"),"\n",r.createElement(t.ol,null,"\n",r.createElement(t.li,null,"Initialize one (or more) Markov chains at random once at the beginning."),"\n",r.createElement(t.li,null,"For each update, sample a mini-batch of data for the positive phase."),"\n",r.createElement(t.li,null,"Use the current state(s) of the persistent Markov chain(s) for the negative phase, running a few Gibbs steps on these chains to update them."),"\n",r.createElement(t.li,null,"Update parameters based on the difference between the positive-phase gradient and the negative-phase gradient."),"\n",r.createElement(t.li,null,"Keep the updated chain states around for the next parameter update."),"\n"),"\n",r.createElement(t.p,null,"Because these chains are not reset to the data at each iteration, they can potentially explore the model distribution more globally. SML is an (asymptotically) unbiased estimator of the gradient under certain conditions (e.g., if the chain is long-lived enough to approximate the stationary distribution). Still, the success of SML in practice depends heavily on the mixing properties of the chain and the complexity of the energy landscape."),"\n",r.createElement(t.h3,{id:"other-related-details",style:{position:"relative"}},r.createElement(t.a,{href:"#other-related-details","aria-label":"other related details permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Other related details"),"\n",r.createElement(t.p,null,"Many research papers have proposed improvements, from parallel tempering to advanced sampling methods like ",r.createElement(l.A,null,"Annealed Importance Sampling")," (which we will see in a later section) to reduce bias further and speed up mixing. In general, though, if your model is high-dimensional and has complicated energy contours, even these advanced MCMC-based approaches can be slow or get stuck in local modes. This persistent difficulty is a major driver of alternative methods that avoid the partition function entirely."),"\n",r.createElement(t.h2,{id:"4-pseudolikelihood",style:{position:"relative"}},r.createElement(t.a,{href:"#4-pseudolikelihood","aria-label":"4 pseudolikelihood permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"4. Pseudolikelihood"),"\n",r.createElement(t.p,null,r.createElement(l.A,null,"Pseudolikelihood")," is a venerable approach introduced by Besag in the 1970s. It seeks to circumvent direct computation of ",r.createElement(c.A,{text:"\\(Z(\\theta)\\)"})," by replacing the joint likelihood ",r.createElement(c.A,{text:"\\(p(\\mathbf{x}; \\theta)\\)"})," with a product of conditional probabilities of each variable given all the others. Specifically, for a discrete variable set ",r.createElement(c.A,{text:"\\(\\mathbf{x} = (x_1, \\dots, x_d)\\)"}),", the pseudolikelihood is:"),"\n",r.createElement(c.A,{text:"\\[\n\\prod_{j=1}^d p(x_j \\mid \\mathbf{x}_{\\setminus j}; \\theta),\n\\]"}),"\n",r.createElement(t.p,null,"where ",r.createElement(c.A,{text:"\\(\\mathbf{x}_{\\setminus j}\\)"}),' means "all variables except ',r.createElement(c.A,{text:"\\(x_j\\)"}),'". Taking the log of that product gives:'),"\n",r.createElement(c.A,{text:"\\[\n\\log \\mathrm{PL}(\\theta) \n= \\sum_{j=1}^d \\sum_{i=1}^N \\log p\\bigl(x_j^{(i)} \\mid \\mathbf{x}_{\\setminus j}^{(i)}; \\theta\\bigr).\n\\]"}),"\n",r.createElement(t.h3,{id:"avoiding-the-partition-function-via-conditional-probabilities",style:{position:"relative"}},r.createElement(t.a,{href:"#avoiding-the-partition-function-via-conditional-probabilities","aria-label":"avoiding the partition function via conditional probabilities permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Avoiding the partition function via conditional probabilities"),"\n",r.createElement(t.p,null,"Why does this help? Each conditional probability can often be computed without requiring the full ",r.createElement(c.A,{text:"\\(Z(\\theta)\\)"}),". For instance, in an Ising model or a discrete MRF, one might have:"),"\n",r.createElement(c.A,{text:"\\[\np(x_j \\mid \\mathbf{x}_{\\setminus j}; \\theta) \n= \\frac{\\exp\\bigl(-E(x_j, \\mathbf{x}_{\\setminus j}; \\theta)\\bigr)}{\\sum_{x_j'} \\exp\\bigl(-E(x_j', \\mathbf{x}_{\\setminus j}; \\theta)\\bigr)},\n\\]"}),"\n",r.createElement(t.p,null,"and that summation in the denominator is only over the local states of ",r.createElement(c.A,{text:"\\(x_j\\)"})," (e.g., ",r.createElement(c.A,{text:"\\(\\pm 1\\)"})," in an Ising spin system or a small discrete set). That is far easier to compute than the global ",r.createElement(c.A,{text:"\\(Z(\\theta)\\)"}),", which sums over all variables ",r.createElement(c.A,{text:"\\(x_1, \\dots, x_d\\)"})," simultaneously."),"\n",r.createElement(t.h3,{id:"strengths-of-pseudolikelihood",style:{position:"relative"}},r.createElement(t.a,{href:"#strengths-of-pseudolikelihood","aria-label":"strengths of pseudolikelihood permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Strengths of pseudolikelihood"),"\n",r.createElement(t.p,null,"One immediate benefit is that pseudolikelihood drastically cuts computation time for models with discrete local variables — especially if the local variable state space is small. The method also has theoretical guarantees in certain asymptotic regimes, meaning that it can yield consistent parameter estimates under some assumptions on the dependency structure. In some specialized tasks such as ",r.createElement(l.A,null,"missing data imputation"),", optimizing conditional distributions may actually be more natural than focusing on the full joint distribution."),"\n",r.createElement(t.h3,{id:"limitations-in-density-estimation",style:{position:"relative"}},r.createElement(t.a,{href:"#limitations-in-density-estimation","aria-label":"limitations in density estimation permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Limitations in density estimation"),"\n",r.createElement(t.p,null,"However, pseudolikelihood can be a poor approximation to the true log-likelihood in settings where global dependencies matter a great deal. It does not necessarily place the correct amount of mass on joint configurations if each variable's local conditionals do not adequately capture the multi-way interactions present in ",r.createElement(c.A,{text:"\\(p(\\mathbf{x}; \\theta)\\)"}),". Thus, for pure density modeling or generative tasks, pseudolikelihood might fail to produce samples that match the global structure of the data. In fields like image modeling or any domain with complex dependencies, pseudolikelihood can produce subpar generative performance even if the local conditionals are well fit."),"\n",r.createElement(t.h3,{id:"implementation-details",style:{position:"relative"}},r.createElement(t.a,{href:"#implementation-details","aria-label":"implementation details permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Implementation details"),"\n",r.createElement(t.p,null,"In practice, one typically just replaces the negative log-likelihood with the negative log-pseudolikelihood and does standard optimization. Gradient-based methods remain feasible, and indeed are often simpler than MCMC-based maximum likelihood. Another use case is in certain forms of cross validation or hyperparameter tuning, where the pseudolikelihood can be computed quickly and used as a proxy objective in place of the intractable true likelihood."),"\n",r.createElement(t.h2,{id:"5-score-matching-and-ratio-matching",style:{position:"relative"}},r.createElement(t.a,{href:"#5-score-matching-and-ratio-matching","aria-label":"5 score matching and ratio matching permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"5. Score matching and ratio matching"),"\n",r.createElement(t.p,null,r.createElement(l.A,null,"Score Matching"),", introduced by Hyvärinen (2005), is another strategy for models that might have an intractable normalizing constant. The idea is elegantly different from pseudolikelihood. Instead of trying to maximize ",r.createElement(c.A,{text:"\\(\\log p(\\mathbf{x}; \\theta)\\)"}),' directly, you match the gradient ("score") of the log-density with respect to ',r.createElement(c.A,{text:"\\(\\mathbf{x}\\)"})," between model and data. A key advantage is that it can be done without ever computing ",r.createElement(c.A,{text:"\\(Z(\\theta)\\)"}),"."),"\n",r.createElement(t.h3,{id:"basic-principle-of-score-matching",style:{position:"relative"}},r.createElement(t.a,{href:"#basic-principle-of-score-matching","aria-label":"basic principle of score matching permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Basic principle of score matching"),"\n",r.createElement(t.p,null,"Let ",r.createElement(c.A,{text:"\\(s_\\theta(\\mathbf{x}) = \\nabla_{\\mathbf{x}} \\log p(\\mathbf{x}; \\theta)\\)"})," be the score function, i.e., the gradient of the log-probability with respect to the data ",r.createElement(c.A,{text:"\\(\\mathbf{x}\\)"}),". Score matching tries to find ",r.createElement(c.A,{text:"\\(\\theta\\)"})," so that:"),"\n",r.createElement(c.A,{text:"\\[\n\\mathbb{E}_{p_{\\text{data}}(\\mathbf{x})}\\bigl[\\| s_\\theta(\\mathbf{x}) - s_{\\text{data}}(\\mathbf{x}) \\|^2 \\bigr]\n\\]"}),"\n",r.createElement(t.p,null,"is minimized, where ",r.createElement(c.A,{text:"\\(s_{\\text{data}}(\\mathbf{x})\\)"})," is the true gradient of the data distribution (in practice, we do not know this function, but the method sets up an alternative objective that is computable). Hyvärinen derived a neat trick that the difference of these gradients can be simplified so that the partition function disappears from the resulting formula. In short, the objective for score matching does not require ",r.createElement(c.A,{text:"\\(Z(\\theta)\\)"}),"."),"\n",r.createElement(t.h3,{id:"interpretation",style:{position:"relative"}},r.createElement(t.a,{href:"#interpretation","aria-label":"interpretation permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Interpretation"),"\n",r.createElement(t.p,null,"Intuitively, if two distributions match in terms of the derivatives of their log-densities, they must be the same distribution (under suitable regularity conditions). So matching the score function is a proxy for matching the distribution itself. Score matching can be particularly elegant in continuous spaces, e.g., in modeling natural images or other real-valued data, provided we can define ",r.createElement(c.A,{text:"\\(E(\\mathbf{x}; \\theta)\\)"})," in a differentiable manner."),"\n",r.createElement(t.h3,{id:"incompatibility-with-discrete-variable-models",style:{position:"relative"}},r.createElement(t.a,{href:"#incompatibility-with-discrete-variable-models","aria-label":"incompatibility with discrete variable models permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Incompatibility with discrete-variable models"),"\n",r.createElement(t.p,null,"A known drawback: standard score matching is not well-defined for discrete-variable models because you cannot treat ",r.createElement(c.A,{text:"\\(p(\\mathbf{x}; \\theta)\\)"})," as a smooth function in a continuous domain. One can attempt modifications for discrete data, but this is less straightforward and can degrade into complexity. Indeed, methods like ",r.createElement(l.A,null,"ratio matching")," have been proposed for certain discrete scenarios."),"\n",r.createElement(t.h3,{id:"ratio-matching",style:{position:"relative"}},r.createElement(t.a,{href:"#ratio-matching","aria-label":"ratio matching permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Ratio matching"),"\n",r.createElement(t.p,null,"Ratio matching tries to match ",r.createElement(c.A,{text:"\\(\\frac{p(\\mathbf{x}; \\theta)}{p_{\\text{data}}(\\mathbf{x})}\\)"})," in local neighborhoods. As with score matching, the idea is to circumvent direct normalizing constants. Ratio matching sometimes finds use in specialized contexts, but it is far less mainstream than either pseudolikelihood or score matching. One might see it in cases where ",r.createElement(c.A,{text:"\\(p_{\\text{data}}(\\mathbf{x})\\)"})," is partially known or can be replaced with local empirical densities. For the majority of large-scale discrete tasks, though, methods such as ",r.createElement(l.A,null,"Noise-Contrastive Estimation")," or ",r.createElement(l.A,null,"Contrastive Divergence")," remain more common."),"\n",r.createElement(t.h2,{id:"6-denoising-score-matching",style:{position:"relative"}},r.createElement(t.a,{href:"#6-denoising-score-matching","aria-label":"6 denoising score matching permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"6. Denoising score matching"),"\n",r.createElement(t.p,null,r.createElement(l.A,null,"Denoising score matching")," extends the core idea of score matching by introducing an explicit noise model. It is deeply related to ",r.createElement(l.A,null,"Denoising Autoencoders")," and has seen a recent surge of interest for tasks like generative modeling of images in the form of ",r.createElement(l.A,null,"Denoising Diffusion Probabilistic Models"),"."),"\n",r.createElement(t.h3,{id:"motivation-for-adding-noise",style:{position:"relative"}},r.createElement(t.a,{href:"#motivation-for-adding-noise","aria-label":"motivation for adding noise permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Motivation for adding noise"),"\n",r.createElement(t.p,null,"One practical issue with score matching is that the model might overfit the data's local geometry, especially if there is insufficient coverage of the space. By adding noise to ",r.createElement(c.A,{text:"\\(\\mathbf{x}\\)"})," — essentially observing a perturbed version of ",r.createElement(c.A,{text:"\\(\\mathbf{x}\\)"})," — you gain a smoothed version of the data distribution. The method trains the model to predict the score of the underlying clean distribution from the noisy samples. This also helps address regions of the space where the data is sparse, since you do not want your model to blow up arbitrarily in small pockets."),"\n",r.createElement(t.h3,{id:"mathematical-form",style:{position:"relative"}},r.createElement(t.a,{href:"#mathematical-form","aria-label":"mathematical form permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Mathematical form"),"\n",r.createElement(t.p,null,"The standard formulation, as introduced by Vincent in the context of denoising autoencoders, is that given a noisy sample ",r.createElement(c.A,{text:"\\(\\mathbf{x}_{\\text{noisy}}\\)"})," created by adding a small Gaussian perturbation to ",r.createElement(c.A,{text:"\\(\\mathbf{x}\\)"}),", the network (or model) tries to reconstruct the original ",r.createElement(c.A,{text:"\\(\\mathbf{x}\\)"}),", or equivalently, to learn the gradient of the log of the clean data density. This can be cast as a form of score matching:"),"\n",r.createElement(c.A,{text:"\\[\n\\min_\\theta \\mathbb{E}_{\\mathbf{x} \\sim p_{\\text{data}}, \\mathbf{x}_{\\text{noisy}} \\mid \\mathbf{x}} \n\\bigl[\\| s_\\theta(\\mathbf{x}_{\\text{noisy}}) - \\nabla_{\\mathbf{x}_{\\text{noisy}}}\\log p_{\\text{noisy}}(\\mathbf{x}_{\\text{noisy}}) \\|^2 \\bigr].\n\\]"}),"\n",r.createElement(t.p,null,"Often, ",r.createElement(c.A,{text:"\\(p_{\\text{noisy}}(\\mathbf{x}_{\\text{noisy}})\\)"})," is a known Gaussian corruption process. The partition function of the underlying distribution still never enters explicitly, so we circumvent ",r.createElement(c.A,{text:"\\(Z(\\theta)\\)"}),"."),"\n",r.createElement(t.h3,{id:"relationship-to-autoencoder-training",style:{position:"relative"}},r.createElement(t.a,{href:"#relationship-to-autoencoder-training","aria-label":"relationship to autoencoder training permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Relationship to autoencoder training"),"\n",r.createElement(t.p,null,"Denoising autoencoders similarly attempt to reconstruct the clean data from noisy input, effectively learning a latent representation that discerns the manifold of real data. The gradient-based viewpoint of denoising score matching unifies these ideas: in certain architectures, learning to denoise is analogous to learning local directions pointing back toward the data manifold, i.e., the negative gradient of the energy. This synergy has led to state-of-the-art generative modeling approaches, including ",r.createElement(l.A,null,"score-based generative modeling")," in continuous time (also known as ",r.createElement(l.A,null,"diffusion models"),") that unify the notion of iterative denoising with a continuous Markov process that can be reversed to generate new samples."),"\n",r.createElement(t.h2,{id:"7-noise-contrastive-estimation",style:{position:"relative"}},r.createElement(t.a,{href:"#7-noise-contrastive-estimation","aria-label":"7 noise contrastive estimation permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"7. Noise-contrastive estimation"),"\n",r.createElement(t.p,null,r.createElement(l.A,null,"Noise-Contrastive Estimation"),' (NCE), introduced by Gutmann and Hyvärinen, is a technique that recasts unsupervised density estimation as a supervised binary classification problem. The partition function is learned as a parameter (often called the "bias" or offset) that helps discriminate between "real data samples" and "noise samples".'),"\n",r.createElement(t.h3,{id:"reduction-to-binary-classification",style:{position:"relative"}},r.createElement(t.a,{href:"#reduction-to-binary-classification","aria-label":"reduction to binary classification permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Reduction to binary classification"),"\n",r.createElement(t.p,null,'The key idea is: create a "noisy distribution" ',r.createElement(c.A,{text:"\\(q(\\mathbf{x})\\)"})," that you can sample from easily, such as a uniform distribution or some other convenient distribution. Then combine real data samples (labeled ",r.createElement(c.A,{text:"\\(y=1\\)"}),") with noise samples (",r.createElement(c.A,{text:"\\(y=0\\)"}),") into a single dataset. Train a classifier that tries to predict whether a sample is real or noise by looking at ",r.createElement(c.A,{text:"\\(\\log p(\\mathbf{x}; \\theta)\\)"})," minus ",r.createElement(c.A,{text:"\\(\\log q(\\mathbf{x})\\)"}),". More concretely, define:"),"\n",r.createElement(c.A,{text:"\\[\nD_\\theta(\\mathbf{x}) = \\sigma\\bigl(\\log p(\\mathbf{x}; \\theta) - \\log q(\\mathbf{x})\\bigr),\n\\]"}),"\n",r.createElement(t.p,null,"where ",r.createElement(c.A,{text:"\\(\\sigma\\)"})," is the logistic sigmoid function. If ",r.createElement(c.A,{text:"\\(p(\\mathbf{x}; \\theta)\\)"})," is unnormalized as ",r.createElement(c.A,{text:"\\(\\tilde{p}(\\mathbf{x}; \\theta)\\)"}),", you can treat ",r.createElement(c.A,{text:"\\(\\log Z(\\theta)\\)"})," as a parameter that is learned via gradient-based classification. Minimizing the cross-entropy classification loss with a balanced set of real and noise examples yields consistent estimates of both the model parameters ",r.createElement(c.A,{text:"\\(\\theta\\)"})," and the partition function offset."),"\n",r.createElement(t.h3,{id:"simultaneous-estimation-of-parameters-and-partition-function",style:{position:"relative"}},r.createElement(t.a,{href:"#simultaneous-estimation-of-parameters-and-partition-function","aria-label":"simultaneous estimation of parameters and partition function permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Simultaneous estimation of parameters and partition function"),"\n",r.createElement(t.p,null,"The partition function effectively shows up in the log-odds for distinguishing real from noise. If ",r.createElement(c.A,{text:"\\(\\log Z(\\theta)\\)"})," is a free parameter, gradient descent will adjust it so that the separation between real and noise samples is maximized. One advantage is that you never explicitly sum over the entire data space. Another is that we can choose ",r.createElement(c.A,{text:"\\(q(\\mathbf{x})\\)"})," in a way that makes sampling trivial."),"\n",r.createElement(t.h3,{id:"advantages-and-drawbacks",style:{position:"relative"}},r.createElement(t.a,{href:"#advantages-and-drawbacks","aria-label":"advantages and drawbacks permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Advantages and drawbacks"),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Advantages"),": NCE can be an elegant approach when dealing with large vocabulary but relatively simpler single-variable or low-dimensional contexts, e.g., certain language modeling tasks. It's also straightforward to implement since it reuses standard binary classification routines."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Drawbacks"),": In large multi-variable contexts with complex dependencies, choosing a suitable noise distribution ",r.createElement(c.A,{text:"\\(q(\\mathbf{x})\\)"})," can be non-trivial. If ",r.createElement(c.A,{text:"\\(q(\\mathbf{x})\\)"})," is too simplistic, the classifier finds the discrimination task too easy, leading to poor density estimates. On the other hand, generating noise samples that mimic real data intricacies might defeat the purpose. Moreover, the approach typically scales poorly if the dimensionality or complexity of ",r.createElement(c.A,{text:"\\(\\mathbf{x}\\)"})," is high unless you have a very clever or domain-specific noise model."),"\n"),"\n",r.createElement(t.h2,{id:"8-estimating-the-partition-function",style:{position:"relative"}},r.createElement(t.a,{href:"#8-estimating-the-partition-function","aria-label":"8 estimating the partition function permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"8. Estimating the partition function"),"\n",r.createElement(t.p,null,"Even though many methods circumvent direct computation of ",r.createElement(c.A,{text:"\\(Z(\\theta)\\)"}),", there are still scenarios where we may want an actual estimate of ",r.createElement(c.A,{text:"\\(Z(\\theta)\\)"}),". For instance, in evaluating the absolute log-likelihood of a generative model, or comparing models by their ",r.createElement(c.A,{text:"\\(\\log p(\\mathbf{X}; \\theta)\\)"})," on a validation set, or computing certain Bayesian model selection criteria, we need an estimate of ",r.createElement(c.A,{text:"\\(\\log Z(\\theta)\\)"}),". This final chapter surveys some of the widely used estimation techniques — mostly based on importance sampling variants and bridging methods."),"\n",r.createElement(t.h3,{id:"importance-sampling",style:{position:"relative"}},r.createElement(t.a,{href:"#importance-sampling","aria-label":"importance sampling permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Importance sampling"),"\n",r.createElement(t.p,null,r.createElement(l.A,null,"Importance sampling")," is a standard technique for estimating integrals or sums with respect to a difficult distribution ",r.createElement(c.A,{text:"\\(p(\\mathbf{x}; \\theta)\\)"})," by using samples drawn from an easier proposal distribution ",r.createElement(c.A,{text:"\\(r(\\mathbf{x})\\)"}),". Suppose we want:"),"\n",r.createElement(c.A,{text:"\\[\nZ(\\theta) = \\int \\exp\\bigl(-E(\\mathbf{x}; \\theta)\\bigr)\\, d\\mathbf{x}.\n\\]"}),"\n",r.createElement(t.p,null,"We can write:"),"\n",r.createElement(c.A,{text:"\\[\nZ(\\theta) = \\int \\frac{\\exp\\bigl(-E(\\mathbf{x}; \\theta)\\bigr)}{r(\\mathbf{x})} r(\\mathbf{x})\\, d\\mathbf{x}.\n\\]"}),"\n",r.createElement(t.p,null,"Hence, if we sample ",r.createElement(c.A,{text:"\\(\\{\\mathbf{x}^{(i)}\\}_{i=1}^M\\)"})," i.i.d. from ",r.createElement(c.A,{text:"\\(r(\\mathbf{x})\\)"}),", an unbiased estimator is:"),"\n",r.createElement(c.A,{text:"\\[\n\\hat{Z} = \\frac{1}{M} \\sum_{i=1}^M \\frac{\\exp\\bigl(-E(\\mathbf{x}^{(i)}; \\theta)\\bigr)}{r(\\mathbf{x}^{(i)})}.\n\\]"}),"\n",r.createElement(t.p,null,"Choosing ",r.createElement(c.A,{text:"\\(r(\\mathbf{x})\\)"})," so that it resembles ",r.createElement(c.A,{text:"\\(\\exp\\bigl(-E(\\mathbf{x}; \\theta)\\bigr)\\)"})," can reduce variance. But for high-dimensional distributions, finding or sampling from such an ",r.createElement(c.A,{text:"\\(r(\\mathbf{x})\\)"})," is not trivial. If ",r.createElement(c.A,{text:"\\(r(\\mathbf{x})\\)"})," does not adequately cover the important regions, the estimator can suffer from extremely high variance."),"\n",r.createElement(t.h3,{id:"annealed-importance-sampling-ais",style:{position:"relative"}},r.createElement(t.a,{href:"#annealed-importance-sampling-ais","aria-label":"annealed importance sampling ais permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Annealed importance sampling (AIS)"),"\n",r.createElement(t.p,null,r.createElement(l.A,null,"Annealed Importance Sampling"),", proposed by Neal (2001), is a significant improvement for evaluating ",r.createElement(c.A,{text:"\\(Z(\\theta)\\)"}),". The method constructs a sequence of intermediate distributions bridging a tractable base distribution (e.g., a factorized Gaussian) and the target distribution ",r.createElement(c.A,{text:"\\(p(\\mathbf{x}; \\theta)\\)"}),". One typically uses a temperature parameter ",r.createElement(c.A,{text:"\\(\\beta\\)"})," that goes from 0 to 1 in small steps:"),"\n",r.createElement(c.A,{text:"\\[\np_k(\\mathbf{x}) \\propto \\exp\\bigl(-\\beta_k E(\\mathbf{x}; \\theta)\\bigr),\n\\]"}),"\n",r.createElement(t.p,null,"where ",r.createElement(c.A,{text:"\\(0 = \\beta_0 < \\beta_1 < \\dots < \\beta_K = 1\\)"}),". For each step, you do importance sampling or MCMC transitions to move from ",r.createElement(c.A,{text:"\\(p_{k-1}(\\mathbf{x})\\)"})," to ",r.createElement(c.A,{text:"\\(p_k(\\mathbf{x})\\)"}),". The final product of importance weights across the chain yields an estimate of the ratio ",r.createElement(c.A,{text:"\\(\\frac{Z(\\theta)}{Z_0}\\)"}),", where ",r.createElement(c.A,{text:"\\(Z_0\\)"})," is the known normalizer of the base distribution. AIS often yields lower-variance estimates than a single-step importance sampling, given the chain of intermediate bridging distributions allows a more incremental adaptation from the easy distribution to the difficult one."),"\n",r.createElement(t.h3,{id:"bridge-sampling",style:{position:"relative"}},r.createElement(t.a,{href:"#bridge-sampling","aria-label":"bridge sampling permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Bridge sampling"),"\n",r.createElement(t.p,null,r.createElement(l.A,null,"Bridge sampling"),' is a related idea in which you define a single "bridge" distribution ',r.createElement(c.A,{text:"\\(r(\\mathbf{x})\\)"})," that lies somewhere between the base and target distributions. One sets up an estimator for ",r.createElement(c.A,{text:"\\(Z(\\theta)\\)"})," that uses samples from both the base distribution and the target distribution with a bridging function that helps reduce variance. AIS can be viewed as an extension of bridge sampling in which you use multiple bridging distributions in a chain rather than just one."),"\n",r.createElement(t.h3,{id:"linked-importance-sampling-and-variance-reduction",style:{position:"relative"}},r.createElement(t.a,{href:"#linked-importance-sampling-and-variance-reduction","aria-label":"linked importance sampling and variance reduction permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Linked importance sampling and variance reduction"),"\n",r.createElement(t.p,null,"Numerous variants exist, such as ",r.createElement(l.A,null,"linked importance sampling"),", ",r.createElement(l.A,null,"sequential Monte Carlo"),", and other advanced techniques that attempt to reduce variance by carefully correlating samples or controlling the shape of the bridging distributions. Each has its own set of pros and cons. The main takeaway is that if you truly need an accurate estimate of ",r.createElement(c.A,{text:"\\(Z(\\theta)\\)"})," (or ",r.createElement(c.A,{text:"\\(\\log Z(\\theta)\\)"}),"), these bridging or annealing approaches usually perform better than naive importance sampling."),"\n",r.createElement(t.h3,{id:"practical-considerations",style:{position:"relative"}},r.createElement(t.a,{href:"#practical-considerations","aria-label":"practical considerations permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Practical considerations"),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"When to estimate ",r.createElement(c.A,{text:"\\(Z\\)"})),": If your downstream task only depends on unnormalized probabilities or partial derivatives of ",r.createElement(c.A,{text:"\\(\\log p(\\mathbf{x}; \\theta)\\)"}),", you might circumvent ",r.createElement(c.A,{text:"\\(Z\\)"}),". Indeed, many modern generative modeling frameworks do not bother with explicit ",r.createElement(c.A,{text:"\\(Z\\)"})," estimation."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Computational cost"),": AIS and related methods require carefully tuned MCMC steps and bridging schedules. They can be computationally expensive."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Model comparison"),": In practice, if you want to compare two models by their log-likelihood, approximate partition function estimates can have non-negligible variance. Tools like ",r.createElement(l.A,null,"PSRF (Potential Scale Reduction Factor)")," from MCMC diagnostics or repeated runs can help gauge reliability."),"\n"),"\n",r.createElement(a,{alt:"Partition function schematic",path:"",caption:"A schematic illustration of how an unnormalized model distribution compares to a known base distribution. The partition function is the ratio between the integral under the unnormalized function and the integral under the base distribution, bridging them is the essence of AIS.",zoom:"false"}),"\n",r.createElement(t.hr),"\n",r.createElement(t.p,null,"Below, I include a brief code snippet showing how one might implement a simplified AIS procedure in Python for a toy 2D energy function — just to illustrate the concept. Naturally, for real-world high-dimensional data, one must incorporate more sophisticated MCMC transition operators and schedules for ",r.createElement(c.A,{text:"\\(\\beta\\)"}),"."),"\n",r.createElement(s.A,{text:'\nimport numpy as np\n\ndef energy_function(x, y):\n    # Simple 2D double well or ring structure as an example\n    r2 = x**2 + y**2\n    return 0.1 * (r2 - 1.0)**2  # Some contrived energy for demonstration\n\ndef base_log_prob(x, y):\n    # Base distribution: e.g., isotropic Gaussian with mean 0, variance=1\n    return -(x**2 + y**2) / 2.0\n\ndef ais(num_samples=10000, num_steps=1000):\n    samples = np.random.randn(num_samples, 2)  # from the base distribution\n    log_w = np.zeros(num_samples)\n    \n    # Beta schedule\n    betas = np.linspace(0, 1, num_steps)\n    delta_betas = betas[1:] - betas[:-1]\n\n    for i in range(num_steps-1):\n        beta0, beta1 = betas[i], betas[i+1]\n        \n        # Compute log unnormalized density difference\n        # which is [ -beta1 * E + beta1 * log base ] - [ -beta0 * E + beta0 * log base ]\n        # Because AIS is bridging from base to target\n        e_vals = np.array([energy_function(s[0], s[1]) for s in samples])\n        log_base = np.array([base_log_prob(s[0], s[1]) for s in samples])\n        \n        log_w += -beta1 * e_vals + beta1 * log_base - (-beta0 * e_vals + beta0 * log_base)\n        \n        # MCMC step (very naive: small random walk or something more advanced)\n        # We\'ll do a small Gaussian move\n        proposals = samples + 0.01 * np.random.randn(num_samples, 2)\n        \n        # Accept/reject with Metropolis-Hastings based on the intermediate distribution\n        current_energy = beta1 * np.array([energy_function(s[0], s[1]) for s in samples])                          - beta1 * np.array([base_log_prob(s[0], s[1]) for s in samples])\n        proposal_energy = beta1 * np.array([energy_function(p[0], p[1]) for p in proposals])                           - beta1 * np.array([base_log_prob(p[0], p[1]) for p in proposals])\n        \n        # Metropolis acceptance\n        accept_prob = np.exp(-(proposal_energy - current_energy))\n        rand_u = np.random.rand(num_samples)\n        accepts = rand_u < accept_prob\n        samples[accepts] = proposals[accepts]\n    \n    # Estimate ratio\n    z_base = 1.0  # The normalizer for the base distribution (2D Gaussian = 2*pi for sigma=1, ignoring constants for example)\n    w = np.exp(log_w)\n    z_est = np.mean(w) * z_base\n    return z_est\n\nif __name__ == "__main__":\n    z_est = ais(num_samples=20000, num_steps=500)\n    print("Estimated partition function:", z_est)\n'}),"\n",r.createElement(t.p,null,"This snippet is not optimized, but it should convey the essence: we start from an easy-to-sample distribution (the base), gradually anneal toward the target distribution, track the change in unnormalized log probabilities, and combine them into a single importance weight. The method ends up with an estimate of ",r.createElement(c.A,{text:"\\(Z(\\theta)\\)"}),". Of course, for a real model, the energy function and base distribution would be replaced accordingly, and the MCMC steps would be carefully tuned."),"\n",r.createElement(t.hr),"\n",r.createElement(t.p,null,"This concludes our in-depth journey through the partition function, the difficulties it imposes, and the wide array of methods used to either approximate it or circumvent it altogether. I hope this article has shed some light on why the partition function merits its own dedicated discussion: from Contrastive Divergence to Noise-Contrastive Estimation to sophisticated AIS procedures for explicit computation, the partition function is the pivotal factor in many advanced probabilistic models. Understanding it, and understanding the techniques for dealing with it, is key to mastering energy-based modeling and a host of other undirected graphical models in modern machine learning."))}var m=function(e){void 0===e&&(e={});const{wrapper:t}=Object.assign({},(0,i.RP)(),e.components);return t?r.createElement(t,e,r.createElement(h,e)):h(e)};var d=a(36710),p=a(58481),u=a.n(p),g=a(36310),f=a(87245),b=a(27042),v=a(59849),E=a(5591),x=a(61122),y=a(9219),w=a(33203),S=a(95751),A=a(94328),M=a(80791),_=a(78137);const k=e=>{let{toc:t}=e;if(!t||!t.items)return null;return r.createElement("nav",{className:M.R},r.createElement("ul",null,t.items.map(((e,t)=>r.createElement("li",{key:t},r.createElement("a",{href:e.url,onClick:t=>((e,t)=>{e.preventDefault();const a=t.replace("#",""),n=document.getElementById(a);n&&n.scrollIntoView({behavior:"smooth",block:"start"})})(t,e.url)},e.title),e.items&&r.createElement(k,{toc:{items:e.items}}))))))};function C(e){let{data:{mdx:t,allMdx:o,allPostImages:l},children:s}=e;const{frontmatter:c,body:h,tableOfContents:m}=t,d=c.index,p=c.slug.split("/")[1],v=o.nodes.filter((e=>e.frontmatter.slug.includes(`/${p}/`))).sort(((e,t)=>e.frontmatter.index-t.frontmatter.index)),M=v.findIndex((e=>e.frontmatter.index===d)),C=v[M+1],z=v[M-1],H=c.slug.replace(/\/$/,""),I=/[^/]*$/.exec(H)[0],T=`posts/${p}/content/${I}/`,{0:L,1:N}=(0,r.useState)(c.flagWideLayoutByDefault),{0:j,1:V}=(0,r.useState)(!1);var B;(0,r.useEffect)((()=>{V(!0);const e=setTimeout((()=>V(!1)),340);return()=>clearTimeout(e)}),[L]),"adventures"===p?B=y.cb:"research"===p?B=y.Qh:"thoughts"===p&&(B=y.T6);const Z=u()(h).replace(/import .*? from .*?;/g,"").replace(/<.*?>/g,"").replace(/\{\/\*[\s\S]*?\*\/\}/g,"").trim().split(/\s+/).length,D=function(e){if(e<=10)return"~10 min";if(e<=20)return"~20 min";if(e<=30)return"~30 min";if(e<=40)return"~40 min";if(e<=50)return"~50 min";if(e<=60)return"~1 h";const t=Math.floor(e/60),a=e%60;return a<=30?`~${t}${a>0?".5":""} h`:`~${t+1} h`}(Math.ceil(Z/B)+(c.extraReadTimeMin||0)),P=[{flag:c.flagDraft,component:()=>Promise.all([a.e(3231),a.e(8809)]).then(a.bind(a,28809))},{flag:c.flagMindfuckery,component:()=>Promise.all([a.e(3231),a.e(2471)]).then(a.bind(a,67709))},{flag:c.flagRewrite,component:()=>Promise.all([a.e(3231),a.e(6764)]).then(a.bind(a,62002))},{flag:c.flagOffensive,component:()=>Promise.all([a.e(3231),a.e(2443)]).then(a.bind(a,17681))},{flag:c.flagProfane,component:()=>Promise.all([a.e(3231),a.e(8048)]).then(a.bind(a,53286))},{flag:c.flagMultilingual,component:()=>Promise.all([a.e(3231),a.e(4069)]).then(a.bind(a,78831))},{flag:c.flagUnreliably,component:()=>Promise.all([a.e(3231),a.e(3417)]).then(a.bind(a,8179))},{flag:c.flagPolitical,component:()=>Promise.all([a.e(3231),a.e(5195)]).then(a.bind(a,30433))},{flag:c.flagCognitohazard,component:()=>Promise.all([a.e(3231),a.e(3175)]).then(a.bind(a,8413))},{flag:c.flagHidden,component:()=>Promise.all([a.e(3231),a.e(9556)]).then(a.bind(a,14794))}],{0:O,1:G}=(0,r.useState)([]);return(0,r.useEffect)((()=>{P.forEach((e=>{let{flag:t,component:a}=e;t&&a().then((e=>{G((t=>[].concat((0,n.A)(t),[e.default])))}))}))}),[]),r.createElement(b.P.div,{initial:{opacity:0},animate:{opacity:1},exit:{opacity:0},transition:{duration:.15}},r.createElement(E.A,{postNumber:c.index,date:c.date,updated:c.updated,readTime:D,difficulty:c.difficultyLevel,title:c.title,desc:c.desc,banner:c.banner,section:p,postKey:I,isMindfuckery:c.flagMindfuckery,mainTag:c.mainTag}),r.createElement("div",{style:{display:"flex",justifyContent:"flex-end",flexWrap:"wrap",maxWidth:"75%",marginLeft:"auto",paddingRight:"1vw",marginTop:"-6vh",marginBottom:"4vh"}},c.otherTags.map(((e,t)=>r.createElement("span",{key:t,className:`noselect ${_.MW}`,style:{margin:"0 5px 5px 0"}},e)))),r.createElement("div",{class:"postBody"},r.createElement(k,{toc:m})),r.createElement("br"),r.createElement("div",{style:{margin:"0 10% -2vh 30%",textAlign:"right"}},r.createElement(b.P.button,{class:"noselect",className:A.pb,id:A.xG,onClick:()=>{N(!L)},whileTap:{scale:.93}},r.createElement(b.P.div,{className:S.DJ,key:L,initial:{opacity:0},animate:{opacity:1},exit:{opacity:0},transition:{duration:.3,ease:"easeInOut"}},L?"Switch to default layout":"Switch to wide layout"))),r.createElement("br"),r.createElement("div",{class:"postBody",style:{margin:L?"0 -14%":"",maxWidth:L?"200%":"",transition:"margin 1s ease, max-width 1s ease, padding 1s ease"}},r.createElement("div",{className:`${A.P_} ${j?A.Xn:A.qG}`},O.map(((e,t)=>r.createElement(e,{key:t}))),c.indexCourse?r.createElement(w.A,{index:c.indexCourse,category:c.courseCategoryName}):"",r.createElement(g.Z.Provider,{value:{images:l.nodes,basePath:T.replace(/\/$/,"")+"/"}},r.createElement(i.xA,{components:{Image:f.A}},s)))),r.createElement(x.A,{nextPost:C,lastPost:z,keyCurrent:I,section:p}))}function z(e){return r.createElement(C,e,r.createElement(m,e))}function H(e){var t,a,n,i,o;let{data:l}=e;const{frontmatter:s}=l.mdx,c=s.titleSEO||s.title,h=s.titleOG||c,m=s.titleTwitter||c,p=s.descSEO||s.desc,u=s.descOG||p,g=s.descTwitter||p,f=s.schemaType||"BlogPosting",b=s.keywordsSEO,E=s.date,x=s.updated||E,y=s.imageOG||(null===(t=s.banner)||void 0===t||null===(a=t.childImageSharp)||void 0===a||null===(n=a.gatsbyImageData)||void 0===n||null===(i=n.images)||void 0===i||null===(o=i.fallback)||void 0===o?void 0:o.src),w=s.imageAltOG||u,S=s.imageTwitter||y,A=s.imageAltTwitter||g,M=s.canonicalURL,_=s.flagHidden||!1,k=s.mainTag||"Posts",C=s.slug.split("/")[1]||"posts",{siteUrl:z}=(0,d.Q)(),H={"@context":"https://schema.org","@type":"BreadcrumbList",itemListElement:[{"@type":"ListItem",position:1,name:"Home",item:z},{"@type":"ListItem",position:2,name:k,item:`${z}/${s.slug.split("/")[1]}`},{"@type":"ListItem",position:3,name:c,item:`${z}${s.slug}`}]};return r.createElement(v.A,{title:c+" - avrtt.blog",titleOG:h,titleTwitter:m,description:p,descriptionOG:u,descriptionTwitter:g,schemaType:f,keywords:b,datePublished:E,dateModified:x,imageOG:y,imageAltOG:w,imageTwitter:S,imageAltTwitter:A,canonicalUrl:M,flagHidden:_,mainTag:k,section:C,type:"article"},r.createElement("script",{type:"application/ld+json"},JSON.stringify(H)))}},66501:function(e,t,a){a.d(t,{A:function(){return o}});var n=a(96540),i=a(3962),r="styles-module--tooltiptext--a263b";var o=e=>{let{text:t,isBadge:a=!1}=e;const{0:o,1:l}=(0,n.useState)(!1),s=(0,n.useRef)(null);return(0,n.useEffect)((()=>{function e(e){s.current&&!s.current.contains(e.target)&&l(!1)}return document.addEventListener("click",e),()=>{document.removeEventListener("click",e)}}),[]),n.createElement("span",{className:"styles-module--tooltipWrapper--75ebf",ref:s},n.createElement("img",{id:a?"styles-module--infoBadge--e3d66":"styles-module--info--26c1f",src:i.A,alt:"info",onClick:e=>{e.stopPropagation(),l((e=>!e))}}),n.createElement("span",{className:o?`${r} styles-module--visible--c063c`:r},t))}},96098:function(e,t,a){var n=a(96540),i=a(7978);t.A=e=>{let{text:t}=e;return n.createElement(i.A,null,t)}}}]);
//# sourceMappingURL=component---src-templates-post-js-content-file-path-src-pages-posts-research-partition-function-a-closer-look-mdx-288062f20f724e03526e.js.map