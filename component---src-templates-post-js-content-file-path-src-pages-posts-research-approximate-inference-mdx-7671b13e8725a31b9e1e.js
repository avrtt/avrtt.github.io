"use strict";(self.webpackChunkavrtt_blog=self.webpackChunkavrtt_blog||[]).push([[2828],{67546:function(e,a,t){t.r(a),t.d(a,{Head:function(){return C},PostTemplate:function(){return M},default:function(){return _}});var n=t(54506),i=t(28453),r=t(96540),o=t(16886),l=t(46295),s=t(96098);function c(e){const a=Object.assign({p:"p",h3:"h3",a:"a",span:"span",h2:"h2",ul:"ul",li:"li"},(0,i.RP)(),e.components),{Image:t}=a;return t||function(e,a){throw new Error("Expected "+(a?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Image",!0),r.createElement(r.Fragment,null,"\n",r.createElement("br"),"\n","\n",r.createElement(a.p,null,"Approximate inference is one of the most pivotal topics in data science and machine learning, enabling practitioners and researchers to handle complex probabilistic models in scenarios where exact computations are computationally prohibitive. In plain terms, approximate inference is the art of trading off a certain degree of accuracy for a gain in efficiency, allowing us to tackle real-world problems that would otherwise be utterly intractable. The concept arises most notably when dealing with high-dimensional data and sophisticated models that require evaluating integrals or summations over a large or infinite space. In many such instances, computing these integrals exactly has been shown to be ",r.createElement(o.A,null,"NP-hard")," or at least extremely costly. By embracing approximate methods, advanced practitioners manage to glean meaningful insights and make robust predictions under constraints of time and computational power."),"\n",r.createElement(a.p,null,"We can see direct evidence of the necessity of approximate inference when we examine how modern machine learning has progressed in tandem with the growth of datasets. As data has surged in volume and variety, the complexity of models has also escalated. Exact inference in models like fully Bayesian neural networks, Markov random fields, graphical models, or hierarchical Bayesian structures quickly becomes intractable. Researchers have therefore invented a spectrum of approaches to approximate these complex posteriors or marginal likelihoods in a manner that remains feasible and tractable at scale."),"\n",r.createElement(a.p,null,"Broadly speaking, these families of methods include ",r.createElement(o.A,null,"Laplace's approximation"),", ",r.createElement(o.A,null,"Variational Bayesian methods"),", ",r.createElement(o.A,null,"Markov chain Monte Carlo (MCMC)"),", ",r.createElement(o.A,null,"Expectation Propagation (EP)"),", and methods rooted in ",r.createElement(o.A,null,"Bayesian networks")," and ",r.createElement(o.A,null,"Markov random fields"),", among others. Each of these techniques exhibits different performance trade-offs and theoretical foundations, yet all revolve around one unifying goal: shaping a simpler approximate distribution or simplified inference mechanism that remains faithful to the actual distribution in practice, while dramatically reducing the required computational overhead."),"\n",r.createElement(a.h3,{id:"11-the-concept-of-approximate-inference",style:{position:"relative"}},r.createElement(a.a,{href:"#11-the-concept-of-approximate-inference","aria-label":"11 the concept of approximate inference permalink",className:"anchor before"},r.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"1.1 The concept of approximate inference"),"\n",r.createElement(a.p,null,"The foundational idea behind approximate inference is straightforward on the surface: we want to find or represent properties of a ",r.createElement(s.A,{text:"\\(p(\\theta \\mid \\mathcal{D})\\)"})," — for instance, the posterior distribution of latent parameters ",r.createElement(s.A,{text:"\\(\\theta\\)"})," given observed data ",r.createElement(s.A,{text:"\\(\\mathcal{D}\\)"})," — without computing the integrals that define ",r.createElement(s.A,{text:"\\(p(\\theta \\mid \\mathcal{D})\\)"})," in an exact manner. This typically involves some form of approximation. In a Bayesian setup, if we have a prior distribution ",r.createElement(s.A,{text:"\\(p(\\theta)\\)"})," and a likelihood ",r.createElement(s.A,{text:"\\(p(\\mathcal{D} \\mid \\theta)\\)"}),", the posterior is:"),"\n",r.createElement(s.A,{text:"\\[\np(\\theta \\mid \\mathcal{D}) = \\frac{p(\\theta)\\, p(\\mathcal{D}\\mid \\theta)}{p(\\mathcal{D})}.\n\\]"}),"\n",r.createElement(a.p,null,"However, the evidence ",r.createElement(s.A,{text:"\\(p(\\mathcal{D})\\)"})," (the normalizing constant) is itself an integral (or sum, if discrete) over all possible latent configurations:"),"\n",r.createElement(s.A,{text:"\\[\np(\\mathcal{D}) = \\int p(\\theta)\\, p(\\mathcal{D}\\mid \\theta) \\, d\\theta.\n\\]"}),"\n",r.createElement(a.p,null,"Such integrals can be extremely high-dimensional and prohibitively expensive to compute exactly when ",r.createElement(s.A,{text:"\\(\\theta\\)"})," is in a large parameter space, or when the model is nonlinearly structured."),"\n",r.createElement(a.p,null,"Approximate inference addresses this by either sampling from ",r.createElement(s.A,{text:"\\(p(\\theta \\mid \\mathcal{D})\\)"})," using Monte Carlo techniques, or by positing a simpler class of distributions — such as a factorized Gaussian — and optimizing the parameters of that simpler class in order to approximate the true posterior. Another approach is to iteratively refine local approximations to each factor or node in a graphical model, as in expectation propagation or loopy belief propagation. In all cases, the overarching concept is: we can't do it exactly, so we approximate."),"\n",r.createElement(a.h3,{id:"12-the-need-for-approximation-in-large-scale-models",style:{position:"relative"}},r.createElement(a.a,{href:"#12-the-need-for-approximation-in-large-scale-models","aria-label":"12 the need for approximation in large scale models permalink",className:"anchor before"},r.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"1.2 The need for approximation in large-scale models"),"\n",r.createElement(a.p,null,'The main driver for approximate methods is scale. When dealing with big data or extremely expressive models (e.g., deep neural networks with hierarchical Bayesian structure or very large random fields in computer vision), exact approaches to inference become infeasible. Even in moderate-scale problems, the integrals or summations required by exact inference often grow exponentially with dimension or complexity. This growth is sometimes referred to as the "curse of dimensionality".'),"\n",r.createElement(a.p,null,"Approximate inference solutions, by design, allow for different trade-offs: some approximate methods give faster but less accurate results, while others require more computation but achieve closer approximations. For example, Markov chain Monte Carlo can deliver highly accurate results if we allow enough time for the chain to mix, but it may be slower for extremely large datasets. Variational inference, on the other hand, can be faster but may introduce biases depending on how we factorize the approximate distribution. The ultimate choice depends on the problem setting, the structure of the model, the computational resources at hand, and the precision needed."),"\n",r.createElement(a.h3,{id:"13-organization-of-this-article",style:{position:"relative"}},r.createElement(a.a,{href:"#13-organization-of-this-article","aria-label":"13 organization of this article permalink",className:"anchor before"},r.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"1.3 Organization of this article"),"\n",r.createElement(a.p,null,"In this expansive piece, I will guide you through the main theoretical setups and computational strategies used in approximate inference. We'll start by reviewing the computational burden that motivates approximate inference. Then, we'll dive into the principal families of approximate inference approaches, including Laplace's approximation, Markov chain Monte Carlo, variational methods, and expectation propagation. Next, we'll take a deeper look at variational inference — a particularly popular and general-purpose technique — and see its specialization to logistic regression, linear regression, and mixture models. We'll also devote space to expectation propagation and discuss how inference can be viewed as a form of optimization. We'll close with an overview of learned approximate inference techniques and some advanced references. Throughout, I'll highlight the interplay between these methods and mention relevant advanced frameworks, from Hamiltonian Monte Carlo to black-box variational inference."),"\n",r.createElement(a.p,null,"As we progress, I encourage you to keep in mind that the choice between these different approximate inference methods usually involves a delicate balance between computational efficiency, ease of implementation, theoretical guarantees, and empirical performance. Each method has strengths and shortcomings; the path forward often lies in your specific domain constraints and objectives."),"\n",r.createElement("br"),"\n",r.createElement(a.h2,{id:"2-the-computational-challenge",style:{position:"relative"}},r.createElement(a.a,{href:"#2-the-computational-challenge","aria-label":"2 the computational challenge permalink",className:"anchor before"},r.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"2. The computational challenge"),"\n",r.createElement(a.h3,{id:"21-np-hardness-in-inference",style:{position:"relative"}},r.createElement(a.a,{href:"#21-np-hardness-in-inference","aria-label":"21 np hardness in inference permalink",className:"anchor before"},r.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"2.1 NP-hardness in inference"),"\n",r.createElement(a.p,null,"Many exact inference problems in graphical models, random fields, and Bayesian networks have been proven to be NP-hard. This is pivotal to understanding the necessity for approximations: if, for instance, you have a complex Markov random field with a large number of interdependent nodes, the partition function ",r.createElement(s.A,{text:"\\(Z\\)"})," of that field can be extremely challenging to compute:"),"\n",r.createElement(s.A,{text:"\\[\nZ = \\sum_{\\mathbf{x}} \\exp\\bigl(-E(\\mathbf{x})\\bigr),\n\\]"}),"\n",r.createElement(a.p,null,"where ",r.createElement(s.A,{text:"\\(E(\\mathbf{x})\\)"})," is an energy function. In continuous analogs, we have integrals in place of sums. The sheer number of terms or the complexity of the integrand can become unmanageable quickly. In fact, studies in the late 20th century (e.g., Cooper, 1990) established that exact inference in general Bayesian networks is NP-hard, and follow-up research (e.g., Dagum & Luby) has added to this notion. Even small increases in model dimension can lead to an exponential blow-up in computational costs."),"\n",r.createElement(a.h3,{id:"22-the-curse-of-dimensionality",style:{position:"relative"}},r.createElement(a.a,{href:"#22-the-curse-of-dimensionality","aria-label":"22 the curse of dimensionality permalink",className:"anchor before"},r.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"2.2 The curse of dimensionality"),"\n",r.createElement(a.p,null,'The curse of dimensionality references how the volume of space grows so quickly with dimension that data become "sparse" relative to the space. For probabilistic inference, it implies that integrals over high-dimensional parameter spaces or latent variable spaces become more difficult to evaluate. Monte Carlo methods can help by exploring this space stochastically, but they can also suffer from slow mixing times if the posterior distribution is very complicated. Variational methods attempt to circumvent the curse of dimensionality by employing factorized approximations that reduce computational demands — though at the cost of possibly introducing systematic errors.'),"\n",r.createElement("br"),"\n",r.createElement(a.h2,{id:"3-main-families-of-approximate-inference",style:{position:"relative"}},r.createElement(a.a,{href:"#3-main-families-of-approximate-inference","aria-label":"3 main families of approximate inference permalink",className:"anchor before"},r.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"3. Main families of approximate inference"),"\n",r.createElement(a.p,null,"In broad terms, we can classify approximate inference approaches into a few major families. While these groups undoubtedly overlap, they serve as useful conceptual signposts."),"\n",r.createElement(a.h3,{id:"31-laplaces-approximation",style:{position:"relative"}},r.createElement(a.a,{href:"#31-laplaces-approximation","aria-label":"31 laplaces approximation permalink",className:"anchor before"},r.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"3.1 Laplace's approximation"),"\n",r.createElement(a.p,null,"Laplace's approximation is one of the earliest approaches to approximate integrals of the form:"),"\n",r.createElement(s.A,{text:"\\[\n\\int f(\\theta)\\exp\\bigl( -E(\\theta)\\bigr)\\, d\\theta.\n\\]"}),"\n",r.createElement(a.p,null,"Intuitively, Laplace's approximation finds the mode (i.e., maximum a posteriori, or a maximum of ",r.createElement(s.A,{text:"\\(-E(\\theta)\\)"}),") and locally approximates the posterior as Gaussian around that mode. Significantly, the performance of Laplace's approximation depends on how well a local Gaussian can capture your posterior distribution. If the posterior is unimodal and somewhat \"peaked\" around a single maximum, Laplace's approximation can be quite a powerful method. However, for distributions with multiple modes, heavy tails, or non-Gaussian shapes, it might fail to capture critical aspects of the distribution. This method often appears in simpler Bayesian logistic regression or neural network classifiers, though nowadays it is overshadowed in many large-scale contexts by more flexible approaches like variational methods or MCMC."),"\n",r.createElement(a.h3,{id:"32-markov-chain-monte-carlo-mcmc",style:{position:"relative"}},r.createElement(a.a,{href:"#32-markov-chain-monte-carlo-mcmc","aria-label":"32 markov chain monte carlo mcmc permalink",className:"anchor before"},r.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"3.2 Markov chain Monte Carlo (MCMC)"),"\n",r.createElement(a.p,null,"MCMC-based techniques like Metropolis-Hastings and Gibbs sampling have been a mainstay of approximate inference for decades (Gelfand & Smith, 1990). The core idea is to construct a Markov chain that asymptotically converges to the distribution of interest. We generate samples from this chain, and those samples approximate either the posterior distribution or other quantities of interest (e.g., marginal likelihoods). MCMC can be very accurate given sufficient time (burn-in and adequate sampling steps), but it can be slow if the state space is large, complex, or if the chain suffers from poor mixing. Specializations and enhancements like Hamiltonian Monte Carlo (Neal, 2011; Betancourt, 2017) and slice sampling can improve performance by using gradient information or adaptive sampling strategies."),"\n",r.createElement(a.h3,{id:"33-variational-methods",style:{position:"relative"}},r.createElement(a.a,{href:"#33-variational-methods","aria-label":"33 variational methods permalink",className:"anchor before"},r.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"3.3 Variational methods"),"\n",r.createElement(a.p,null,"Variational inference recasts inference as an optimization problem: we propose a restricted family of distributions ",r.createElement(s.A,{text:"\\(q(\\theta)\\)"})," and find the member of that family that minimizes the Kullback-Leibler divergence ",r.createElement(s.A,{text:"\\(\\mathrm{KL}[q(\\theta)\\,\\|\\, p(\\theta \\mid \\mathcal{D})]\\)"})," or equivalently maximizes the evidence lower bound (",r.createElement(o.A,null,"ELBO"),"). The approach can be much faster than MCMC for large datasets and also lends itself well to modern automatic differentiation frameworks. Its main drawback is that the factorization assumptions or chosen family might be too restrictive, introducing a bias. Over the years, more flexible forms of variational distributions (normalizing flows, mixture distributions, etc.) and advanced parameterization techniques have improved the expressiveness of variational methods (Rezende & Mohamed, 2015)."),"\n",r.createElement(a.h3,{id:"34-expectation-propagation-ep",style:{position:"relative"}},r.createElement(a.a,{href:"#34-expectation-propagation-ep","aria-label":"34 expectation propagation ep permalink",className:"anchor before"},r.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"3.4 Expectation propagation (EP)"),"\n",r.createElement(a.p,null,"EP, proposed by Minka (2001), is another iterative approach that refines local approximate factors while aiming to match exact moments in a global sense. EP can be more accurate than simpler variational mean-field methods in cases where the posterior has complicated correlations, but it can also be more delicate to implement. EP is particularly appealing for certain classes of graphical models or integrated likelihood problems."),"\n",r.createElement(a.h3,{id:"35-markov-random-fields-and-bayesian-networks",style:{position:"relative"}},r.createElement(a.a,{href:"#35-markov-random-fields-and-bayesian-networks","aria-label":"35 markov random fields and bayesian networks permalink",className:"anchor before"},r.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"3.5 Markov random fields and Bayesian networks"),"\n",r.createElement(a.p,null,"Markov random fields (MRFs) and Bayesian networks often require approximate inference in practice. Both rely on the factorization properties of probability distributions to simplify computation, but once the graphs become large or contain loops, exact inference is typically unworkable for real-world problems. Methods like belief propagation (and its variant, loopy belief propagation) are widely used, but they frequently require approximations to handle loops or high-dimensional node states. MRFs are common in computer vision, natural language processing, and other domains where local interactions create a high number of dependencies."),"\n",r.createElement(a.h3,{id:"36-belief-propagation-loopy-and-generalized",style:{position:"relative"}},r.createElement(a.a,{href:"#36-belief-propagation-loopy-and-generalized","aria-label":"36 belief propagation loopy and generalized permalink",className:"anchor before"},r.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"3.6 Belief propagation (loopy and generalized)"),"\n",r.createElement(a.p,null,'Belief propagation is an algorithm that passes "messages" along the edges of a graphical model to iteratively update local beliefs about each node. The algorithm is exact on certain acyclic structures (like trees), but in graphs with loops (e.g., grids in image processing), it becomes approximate and is then called "loopy belief propagation". Generalized belief propagation extends the approach further, partitioning the graph into regions, each of which can have more complex interactions. While not guaranteed to converge in every instance, it often provides surprisingly good approximations in practice.'),"\n",r.createElement(a.h3,{id:"37-factor-graphs-perspective",style:{position:"relative"}},r.createElement(a.a,{href:"#37-factor-graphs-perspective","aria-label":"37 factor graphs perspective permalink",className:"anchor before"},r.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"3.7 Factor graphs perspective"),"\n",r.createElement(a.p,null,"A factor graph is yet another way of representing how a global function factors into smaller parts. For an inference problem with a joint distribution ",r.createElement(s.A,{text:"\\(p(\\mathbf{x})\\)"})," factored into multiple components, each factor is associated with a set of variables. Message passing on a factor graph unifies many of the ideas behind belief propagation. Various approximate inference algorithms are readily interpretable in this factor graph setting, including expectation propagation (EP) and variational message passing (VMP)."),"\n",r.createElement("br"),"\n",r.createElement(a.h2,{id:"4-variational-inference-fundamentals",style:{position:"relative"}},r.createElement(a.a,{href:"#4-variational-inference-fundamentals","aria-label":"4 variational inference fundamentals permalink",className:"anchor before"},r.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"4. Variational inference fundamentals"),"\n",r.createElement(a.p,null,"Variational inference is a cornerstone method in modern approximate inference, used extensively when dealing with high-dimensional data or large hierarchical models. The approach rests on the principle of turning an integral or summation-based inference problem into an optimization problem, typically leveraging gradient-based methods. One can see this approach widely employed in large-scale Bayesian neural network training, topic modeling, and even in certain reinforcement learning contexts."),"\n",r.createElement(a.h3,{id:"41-factorized-distributions-and-mean-field-approximation",style:{position:"relative"}},r.createElement(a.a,{href:"#41-factorized-distributions-and-mean-field-approximation","aria-label":"41 factorized distributions and mean field approximation permalink",className:"anchor before"},r.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"4.1 Factorized distributions and mean-field approximation"),"\n",r.createElement(a.p,null,"A defining assumption in many variational inference methods is known as the ",r.createElement(o.A,null,"mean-field approximation"),". The idea is to assume the posterior factorizes over latent variables, for instance:"),"\n",r.createElement(s.A,{text:"\\[\nq(\\theta_1, \\ldots, \\theta_K) = \\prod_{k=1}^K q(\\theta_k),\n\\]"}),"\n",r.createElement(a.p,null,"where each ",r.createElement(s.A,{text:"\\(q(\\theta_k)\\)"})," is (in the simplest version) an independent factor. Although this drastically simplifies the problem, it often introduces significant bias if the true posterior has strong correlations among these parameters. Nonetheless, the mean-field approach allows us to derive closed-form update rules in certain exponential family models, leading to the classic coordinate ascent variational inference algorithm."),"\n",r.createElement(a.h3,{id:"42-variational-lower-bound-and-objective",style:{position:"relative"}},r.createElement(a.a,{href:"#42-variational-lower-bound-and-objective","aria-label":"42 variational lower bound and objective permalink",className:"anchor before"},r.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"4.2 Variational lower bound and objective"),"\n",r.createElement(a.p,null,"The fundamental objective in variational inference is the ",r.createElement(o.A,null,"Evidence Lower BOund (ELBO)"),", defined as:"),"\n",r.createElement(s.A,{text:"\\[\n\\mathcal{L}(q) = \\mathbb{E}_{q(\\theta)}[\\log p(\\mathcal{D}\\mid \\theta)] - \\mathrm{KL}[\\,q(\\theta)\\,\\|\\,p(\\theta)\\,].\n\\]"}),"\n",r.createElement(a.p,null,"This is called a lower bound because it bounds the log-evidence ",r.createElement(s.A,{text:"\\(\\log p(\\mathcal{D})\\)"}),", meaning:"),"\n",r.createElement(s.A,{text:"\\[\n\\log p(\\mathcal{D}) \\ge \\mathcal{L}(q).\n\\]"}),"\n",r.createElement(a.p,null,"Optimizing ",r.createElement(s.A,{text:"\\(\\mathcal{L}(q)\\)"})," with respect to the parameters of ",r.createElement(s.A,{text:"\\(q(\\theta)\\)"})," will produce a ",r.createElement(s.A,{text:"\\(q\\)"})," that approximates the true posterior. The ",r.createElement(s.A,{text:"\\(\\mathrm{KL}\\)"})," term penalizes deviation from the prior, while the expected log likelihood term tries to fit the observed data."),"\n",r.createElement(a.p,null,"In many typical scenarios, we break down ",r.createElement(s.A,{text:"\\(q(\\theta)\\)"})," or assume certain parametric forms that facilitate differentiation or closed-form updates. This approach is now widely used in combination with stochastic gradient optimization, known as ",r.createElement(o.A,null,"Stochastic Variational Inference (SVI)")," (Hoffman and gang, 2013), which partitions the dataset into mini-batches."),"\n",r.createElement(a.h3,{id:"43-example-univariate-gaussian",style:{position:"relative"}},r.createElement(a.a,{href:"#43-example-univariate-gaussian","aria-label":"43 example univariate gaussian permalink",className:"anchor before"},r.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"4.3 Example: univariate Gaussian"),"\n",r.createElement(a.p,null,"Let's consider a simple scenario to build intuition, where our posterior in a univariate Gaussian setting might be something of the form:"),"\n",r.createElement(s.A,{text:"\\[\np(\\mu \\mid X) \\propto \\mathcal{N}(\\mu \\mid \\mu_0, \\sigma_0^2) \\prod_{i=1}^N \\mathcal{N}(x_i \\mid \\mu, \\sigma^2).\n\\]"}),"\n",r.createElement(a.p,null,"We might pick ",r.createElement(s.A,{text:"\\(q(\\mu) = \\mathcal{N}(\\mu \\mid m, s^2)\\)"})," as our approximate distribution. We want to find ",r.createElement(s.A,{text:"\\(m\\)"})," and ",r.createElement(s.A,{text:"\\(s^2\\)"})," that maximize the ELBO. In many simpler cases, we can derive closed-form solutions for these variational parameters. However, in more complicated models, we resort to gradient-based optimization."),"\n",r.createElement(a.h3,{id:"44-variational-mixture-of-gaussians",style:{position:"relative"}},r.createElement(a.a,{href:"#44-variational-mixture-of-gaussians","aria-label":"44 variational mixture of gaussians permalink",className:"anchor before"},r.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"4.4 Variational mixture of Gaussians"),"\n",r.createElement(a.p,null,"Another illustrative case is a mixture of Gaussians. Suppose we have a mixture model with ",r.createElement(s.A,{text:"\\(K\\)"})," components, each with unknown mean and variance (and unknown mixture weights). Variational inference will place a ",r.createElement(s.A,{text:"\\(q\\)"})," distribution on each latent component assignment as well as on the continuous parameters. In effect, the entire distribution is factorized, for instance:"),"\n",r.createElement(s.A,{text:"\\[\nq(\\mathbf{Z}, \\boldsymbol{\\theta}) = \\Bigl(\\prod_{n} q(z_n)\\Bigr)\\, \\Bigl(\\prod_{k} q(\\theta_k)\\Bigr),\n\\]"}),"\n",r.createElement(a.p,null,"where ",r.createElement(s.A,{text:"\\(z_n\\)"})," is the latent cluster assignment for data point ",r.createElement(s.A,{text:"\\(n\\)"}),", and ",r.createElement(s.A,{text:"\\(\\theta_k\\)"})," includes the parameters of cluster ",r.createElement(s.A,{text:"\\(k\\)"}),". We can then derive update equations for ",r.createElement(s.A,{text:"\\(z_n\\)"})," and ",r.createElement(s.A,{text:"\\(\\theta_k\\)"})," in alternation. This is reminiscent of the ",r.createElement(o.A,null,"Expectation-Maximization (EM)")," algorithm, though from a variational perspective, each step is a coordinate ascent in the space of distributions, rather than maximizing with respect to single point estimates."),"\n",r.createElement(a.h3,{id:"45-predictive-density",style:{position:"relative"}},r.createElement(a.a,{href:"#45-predictive-density","aria-label":"45 predictive density permalink",className:"anchor before"},r.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"4.5 Predictive density"),"\n",r.createElement(a.p,null,"In a variational setting, once we have ",r.createElement(s.A,{text:"\\(q(\\theta)\\)"}),", we can compute the predictive distribution for a new observation ",r.createElement(s.A,{text:"\\(x_{new}\\)"})," as:"),"\n",r.createElement(s.A,{text:"\\[\np(x_{new}\\mid \\mathcal{D}) \\approx \\int p(x_{new}\\mid \\theta) \\, q(\\theta) \\, d\\theta.\n\\]"}),"\n",r.createElement(a.p,null,"This integral might be simpler to approximate than the original exact version, especially if ",r.createElement(s.A,{text:"\\(q(\\theta)\\)"})," has a tractable form. The predictive distribution helps us evaluate the performance and generalization ability of our approximate inference approach."),"\n",r.createElement(a.h3,{id:"46-determining-the-number-of-components",style:{position:"relative"}},r.createElement(a.a,{href:"#46-determining-the-number-of-components","aria-label":"46 determining the number of components permalink",className:"anchor before"},r.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"4.6 Determining the number of components"),"\n",r.createElement(a.p,null,"In mixture models, the question of how many mixture components ",r.createElement(s.A,{text:"\\(K\\)"})," to use arises frequently. A fully Bayesian approach might introduce a prior over ",r.createElement(s.A,{text:"\\(K\\)"})," (like a Dirichlet Process prior). Within a variational framework, we can also incorporate model comparison or monitor the ELBO for varying ",r.createElement(s.A,{text:"\\(K\\)"}),". Typically, a higher ",r.createElement(s.A,{text:"\\(K\\)"})," might lead to a better fit (higher ELBO), but at the cost of complexity and potential overfitting if we are not using a nonparametric prior."),"\n",r.createElement(a.h3,{id:"47-induced-factorizations",style:{position:"relative"}},r.createElement(a.a,{href:"#47-induced-factorizations","aria-label":"47 induced factorizations permalink",className:"anchor before"},r.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"4.7 Induced factorizations"),"\n",r.createElement(a.p,null,"When we assume or impose factorizations in ",r.createElement(s.A,{text:"\\(q(\\theta)\\)"}),", those assumptions can propagate constraints throughout the model. The factorized nature might, for example, ignore correlated structure in the true posterior. This trade-off is one of the reasons that more advanced forms of variational inference have been explored, such as structured variational approximations, hierarchical factorization schemes, or normalizing flows. Each approach tries to break away from the naive independence assumptions that hamper standard mean-field approaches."),"\n",r.createElement("br"),"\n",r.createElement(a.h2,{id:"5-variational-linear-regression",style:{position:"relative"}},r.createElement(a.a,{href:"#5-variational-linear-regression","aria-label":"5 variational linear regression permalink",className:"anchor before"},r.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"5. Variational linear regression"),"\n",r.createElement(a.h3,{id:"51-setting-up-the-linear-model",style:{position:"relative"}},r.createElement(a.a,{href:"#51-setting-up-the-linear-model","aria-label":"51 setting up the linear model permalink",className:"anchor before"},r.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"5.1 Setting up the linear model"),"\n",r.createElement(a.p,null,"In variational linear regression, we assume a likelihood of the form:"),"\n",r.createElement(s.A,{text:"\\[\np(\\mathbf{y} \\mid \\mathbf{X}, \\beta, \\sigma^2) = \\prod_{n=1}^N \\mathcal{N}(y_n \\mid \\mathbf{x}_n^\\top \\beta, \\sigma^2),\n\\]"}),"\n",r.createElement(a.p,null,"where ",r.createElement(s.A,{text:"\\(\\mathbf{x}_n\\)"})," is the ",r.createElement(s.A,{text:"\\(n\\)"}),"th row of the design matrix ",r.createElement(s.A,{text:"\\(\\mathbf{X}\\)"}),", ",r.createElement(s.A,{text:"\\(\\beta\\)"})," is the vector of regression coefficients, and ",r.createElement(s.A,{text:"\\(\\sigma^2\\)"})," is the noise variance. A Bayesian treatment places priors on ",r.createElement(s.A,{text:"\\(\\beta\\)"})," (e.g., a Gaussian with mean 0 and covariance ",r.createElement(s.A,{text:"\\(\\alpha^{-1}\\mathbf{I}\\)"}),") and possibly on ",r.createElement(s.A,{text:"\\(\\sigma^2\\)"})," (like an inverse-Gamma prior)."),"\n",r.createElement(a.h3,{id:"52-variational-distribution",style:{position:"relative"}},r.createElement(a.a,{href:"#52-variational-distribution","aria-label":"52 variational distribution permalink",className:"anchor before"},r.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"5.2 Variational distribution"),"\n",r.createElement(a.p,null,"We can propose a variational distribution such as:"),"\n",r.createElement(s.A,{text:"\\[\nq(\\beta, \\alpha, \\sigma^2) = q(\\beta \\mid \\alpha, \\sigma^2)\\, q(\\alpha)\\, q(\\sigma^2),\n\\]"}),"\n",r.createElement(a.p,null,"or potentially a simpler factorization. We then write down the ELBO for the linear model, deriving update equations for ",r.createElement(s.A,{text:"\\(q(\\beta \\mid \\alpha, \\sigma^2)\\)"})," or whichever factor we are optimizing at each step."),"\n",r.createElement(a.h3,{id:"53-predictive-distribution",style:{position:"relative"}},r.createElement(a.a,{href:"#53-predictive-distribution","aria-label":"53 predictive distribution permalink",className:"anchor before"},r.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"5.3 Predictive distribution"),"\n",r.createElement(a.p,null,"The predictive distribution for a new data point ",r.createElement(s.A,{text:"\\(\\mathbf{x}_{\\text{new}}\\)"})," is:"),"\n",r.createElement(s.A,{text:"\\[\np(y_{\\text{new}} \\mid \\mathbf{x}_{\\text{new}}, \\mathbf{X}, \\mathbf{y}) \\approx \\int p(y_{\\text{new}} \\mid \\mathbf{x}_{\\text{new}}, \\beta, \\sigma^2)\\, q(\\beta, \\sigma^2)\\, d\\beta\\, d\\sigma^2.\n\\]"}),"\n",r.createElement(a.p,null,"If ",r.createElement(s.A,{text:"\\(q\\)"})," is factorized Gaussian, this integral can often be performed analytically, though in some cases we rely on numerical approximations or further assumptions. This yields a sense of uncertainty in predictions that purely frequentist linear regression does not directly provide."),"\n",r.createElement(a.h3,{id:"54-lower-bound-interpretation",style:{position:"relative"}},r.createElement(a.a,{href:"#54-lower-bound-interpretation","aria-label":"54 lower bound interpretation permalink",className:"anchor before"},r.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"5.4 Lower bound interpretation"),"\n",r.createElement(a.p,null,"The variational lower bound in linear regression captures how well the approximate posterior of ",r.createElement(s.A,{text:"\\(\\beta\\)"})," and ",r.createElement(s.A,{text:"\\(\\sigma^2\\)"})," explains the observed data, minus the KL divergence to the prior distributions. Interpreting the ",r.createElement(s.A,{text:"\\(\\mathrm{KL}\\)"})," term as a complexity penalty helps connect these Bayesian methods to regularization ideas from classical statistics."),"\n",r.createElement("br"),"\n",r.createElement(a.h2,{id:"6-the-exponential-family-and-local-variational-methods",style:{position:"relative"}},r.createElement(a.a,{href:"#6-the-exponential-family-and-local-variational-methods","aria-label":"6 the exponential family and local variational methods permalink",className:"anchor before"},r.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"6. The exponential family and local variational methods"),"\n",r.createElement(a.h3,{id:"61-recap-of-the-exponential-family",style:{position:"relative"}},r.createElement(a.a,{href:"#61-recap-of-the-exponential-family","aria-label":"61 recap of the exponential family permalink",className:"anchor before"},r.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"6.1 Recap of the exponential family"),"\n",r.createElement(a.p,null,"Many common distributions belong to the exponential family, e.g., the Gaussian, Bernoulli, Beta, Gamma, Poisson, and so on. A distribution in the exponential family can be written as:"),"\n",r.createElement(s.A,{text:"\\[\np(x \\mid \\eta) = h(x)\\exp\\bigl(\\eta^\\top T(x) - A(\\eta)\\bigr),\n\\]"}),"\n",r.createElement(a.p,null,"where ",r.createElement(s.A,{text:"\\(\\eta\\)"})," is the natural parameter, ",r.createElement(s.A,{text:"\\(T(x)\\)"})," is the sufficient statistic, ",r.createElement(s.A,{text:"\\(A(\\eta)\\)"})," is the log-partition function, and ",r.createElement(s.A,{text:"\\(h(x)\\)"})," is the base measure. The factorization properties of the exponential family greatly simplify learning and inference in many Bayesian models, especially if the prior is conjugate to the likelihood."),"\n",r.createElement(a.h3,{id:"62-variational-message-passing",style:{position:"relative"}},r.createElement(a.a,{href:"#62-variational-message-passing","aria-label":"62 variational message passing permalink",className:"anchor before"},r.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"6.2 Variational message passing"),"\n",r.createElement(a.p,null,"Variational message passing (VMP) is a technique that generalizes the mean-field updates in factorized approximations by systematically passing messages in a graphical model. Each factor in the model is updated based on local computations that rely on the current estimates of the other factors, typically using the exponential family conjugacy to keep updates in closed form. Some advanced frameworks (e.g., Infer.NET from Microsoft Research) implement VMP as a general-purpose engine for approximate inference in factor graphs. VMP can be seen as a specialized instance of the larger concept of message passing in approximate inference, with a particular emphasis on factorization and conjugacy."),"\n",r.createElement("br"),"\n",r.createElement(a.h2,{id:"7-variational-logistic-regression",style:{position:"relative"}},r.createElement(a.a,{href:"#7-variational-logistic-regression","aria-label":"7 variational logistic regression permalink",className:"anchor before"},r.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"7. Variational logistic regression"),"\n",r.createElement(a.h3,{id:"71-variational-posterior-distribution",style:{position:"relative"}},r.createElement(a.a,{href:"#71-variational-posterior-distribution","aria-label":"71 variational posterior distribution permalink",className:"anchor before"},r.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"7.1 Variational posterior distribution"),"\n",r.createElement(a.p,null,"In logistic regression, the likelihood for a binary target ",r.createElement(s.A,{text:"\\(y_i \\in \\{0,1\\}\\)"})," given covariates ",r.createElement(s.A,{text:"\\(\\mathbf{x}_i\\)"})," is:"),"\n",r.createElement(s.A,{text:"\\[\np(y_i = 1 \\mid \\mathbf{x}_i, \\beta) = \\sigma(\\mathbf{x}_i^\\top \\beta),\n\\]"}),"\n",r.createElement(a.p,null,"where ",r.createElement(s.A,{text:"\\(\\sigma(\\cdot)\\)"})," is the logistic sigmoid function. A Bayesian approach places a prior on ",r.createElement(s.A,{text:"\\(\\beta\\)"}),", typically a Gaussian. Because the logistic function is non-conjugate to the Gaussian prior, the posterior distribution ",r.createElement(s.A,{text:"\\(p(\\beta \\mid \\mathbf{X}, \\mathbf{y})\\)"})," is not available in closed form. Variational methods remedy this by introducing a simpler ",r.createElement(s.A,{text:"\\(q(\\beta)\\)"})," distribution, often Gaussian with a diagonal covariance (in the simplest mean-field approach)."),"\n",r.createElement(a.h3,{id:"72-optimizing-the-variational-parameters",style:{position:"relative"}},r.createElement(a.a,{href:"#72-optimizing-the-variational-parameters","aria-label":"72 optimizing the variational parameters permalink",className:"anchor before"},r.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"7.2 Optimizing the variational parameters"),"\n",r.createElement(a.p,null,"We define the ELBO for logistic regression similarly, involving the expected log-likelihood under our ",r.createElement(s.A,{text:"\\(q(\\beta)\\)"})," and the KL divergence from the prior. We then apply gradient-based optimization to refine the variational parameters (the mean and variance of ",r.createElement(s.A,{text:"\\(q(\\beta)\\)"}),", for instance). Modern libraries facilitate this procedure by automatically computing gradients via backpropagation. However, the logistic function's presence typically means we resort to either numerical approximations or analytically tractable bounds to handle the logistic link within the ELBO."),"\n",r.createElement(a.h3,{id:"73-inference-of-hyperparameters",style:{position:"relative"}},r.createElement(a.a,{href:"#73-inference-of-hyperparameters","aria-label":"73 inference of hyperparameters permalink",className:"anchor before"},r.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"7.3 Inference of hyperparameters"),"\n",r.createElement(a.p,null,"In some cases, we may not only treat ",r.createElement(s.A,{text:"\\(\\beta\\)"})," as unknown but also treat the noise variance or regularization hyperparameters as latent variables. The complexity rises if we place hierarchical priors on those hyperparameters. Variational inference extends naturally to these hierarchical setups by augmenting ",r.createElement(s.A,{text:"\\(q\\)"})," to also approximate the distribution over that additional set of hyperparameters, albeit with further assumptions to keep computations manageable."),"\n",r.createElement("br"),"\n",r.createElement(a.h2,{id:"8-expectation-propagation",style:{position:"relative"}},r.createElement(a.a,{href:"#8-expectation-propagation","aria-label":"8 expectation propagation permalink",className:"anchor before"},r.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"8. Expectation propagation"),"\n",r.createElement(a.h3,{id:"81-intro-to-ep",style:{position:"relative"}},r.createElement(a.a,{href:"#81-intro-to-ep","aria-label":"81 intro to ep permalink",className:"anchor before"},r.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"8.1 Intro to EP"),"\n",r.createElement(a.p,null,"Expectation propagation (EP), introduced by Minka (2001), is another message-passing algorithm for approximate inference. It retains site approximations of each factor of the posterior, then iteratively refines these local approximations to match moments (usually means and variances) of certain cavity distributions. Unlike the typical mean-field approach, which can systematically underestimate variances, EP can sometimes better preserve correlations among parameters."),"\n",r.createElement(a.h3,{id:"82-example-the-clutter-problem",style:{position:"relative"}},r.createElement(a.a,{href:"#82-example-the-clutter-problem","aria-label":"82 example the clutter problem permalink",className:"anchor before"},r.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"8.2 Example: The clutter problem"),"\n",r.createElement(a.p,null,'One commonly-cited example is the "clutter problem," in which we have data that might correspond to a real signal plus many noise outliers, requiring a robust inference method. EP can handle these outliers by refining approximate factors that capture heavier tails or certain robust likelihood properties. EP iterates through each data point or factor, removing its approximate contribution from the global posterior (resulting in a cavity distribution), recomputing the refined factor, and then "inserting" it back into the approximate posterior. This cyclical scheme continues until convergence.'),"\n",r.createElement(a.h3,{id:"83-ep-in-graphs-local-updates",style:{position:"relative"}},r.createElement(a.a,{href:"#83-ep-in-graphs-local-updates","aria-label":"83 ep in graphs local updates permalink",className:"anchor before"},r.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"8.3 EP in graphs, local updates"),"\n",r.createElement(a.p,null,"For graphical models, EP generalizes well: each factor node in the graph has an approximate factor that gets updated based on the current approximation of all other factors. The local updates can be viewed as corrections to second-order moments that ensure the approximate distribution remains close to the exact posterior in a moment-matching sense. However, EP may fail to converge in some loopy graphs, and when it does converge, it doesn't always guarantee a global optimum. Nonetheless, in many applications like Bayesian neural networks or Gaussian process classification, EP demonstrates strong empirical performance."),"\n",r.createElement("br"),"\n",r.createElement(a.h2,{id:"9-inference-as-optimization",style:{position:"relative"}},r.createElement(a.a,{href:"#9-inference-as-optimization","aria-label":"9 inference as optimization permalink",className:"anchor before"},r.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"9. Inference as optimization"),"\n",r.createElement(a.h3,{id:"91-the-link-between-inference-and-parameter-optimization",style:{position:"relative"}},r.createElement(a.a,{href:"#91-the-link-between-inference-and-parameter-optimization","aria-label":"91 the link between inference and parameter optimization permalink",className:"anchor before"},r.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"9.1 The link between inference and parameter optimization"),"\n",r.createElement(a.p,null,"Variational methods illustrate a profound link: we can interpret inference as an optimization problem over distributions, quite akin to parameter estimation in classical machine learning. This viewpoint has been expanded by advanced frameworks that treat the posterior distribution's parameters as hyperparameters in a neural network used to approximate the posterior. More concretely, one might define a neural network that outputs the mean and variance for a factor ",r.createElement(s.A,{text:"\\(q(\\theta)\\)"})," given certain conditions, in which case training that neural network is effectively approximate Bayesian inference."),"\n",r.createElement(a.h3,{id:"92-stochastic-optimization-in-inference",style:{position:"relative"}},r.createElement(a.a,{href:"#92-stochastic-optimization-in-inference","aria-label":"92 stochastic optimization in inference permalink",className:"anchor before"},r.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"9.2 Stochastic optimization in inference"),"\n",r.createElement(a.p,null,"Stochastic optimization, widespread in deep learning, is readily applied to approximate inference. For instance, ",r.createElement(o.A,null,"stochastic gradient variational Bayes")," breaks the data into mini-batches, computes unbiased gradient estimates of the ELBO, and increments the variational parameters. Similarly, advanced MCMC methods can harness mini-batches to approximate likelihood gradients (so-called Stochastic Gradient MCMC). These developments make approximate inference feasible and scalable on large, streaming datasets."),"\n",r.createElement(a.h3,{id:"93-the-role-of-gradient-based-methods",style:{position:"relative"}},r.createElement(a.a,{href:"#93-the-role-of-gradient-based-methods","aria-label":"93 the role of gradient based methods permalink",className:"anchor before"},r.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"9.3 The role of gradient-based methods"),"\n",r.createElement(a.p,null,"One of the biggest leaps in approximate inference in the past decade has been the synergy with gradient-based deep learning libraries. Tools like PyTorch, TensorFlow, and JAX allow for automatic differentiation of complex log-likelihood expressions, making it far easier to implement black-box approximate inference. The ",r.createElement(o.A,null,"reparameterization trick")," introduced by Kingma and Welling (2014) in the context of variational autoencoders (VAEs) is precisely about enabling unbiased gradient estimators of the ELBO. The entire field of deep generative models (e.g. VAEs, normalizing flows, and certain types of diffusion models) rests heavily on the premise of approximate inference as gradient-based optimization."),"\n",r.createElement("br"),"\n",r.createElement(a.h2,{id:"10-expectation-maximization-em",style:{position:"relative"}},r.createElement(a.a,{href:"#10-expectation-maximization-em","aria-label":"10 expectation maximization em permalink",className:"anchor before"},r.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"10. Expectation Maximization (EM)"),"\n",r.createElement(a.h3,{id:"101-revisiting-the-em-algorithm",style:{position:"relative"}},r.createElement(a.a,{href:"#101-revisiting-the-em-algorithm","aria-label":"101 revisiting the em algorithm permalink",className:"anchor before"},r.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"10.1 Revisiting the EM algorithm"),"\n",r.createElement(a.p,null,"The classic EM algorithm, widely known from mixture models, can also be viewed through the lens of approximate inference. EM alternates between the E-step (computing posterior distributions of latent variables, given parameters) and the M-step (maximizing with respect to parameters, given the distribution of latent variables). In a fully Bayesian approach, we consider the distributions over parameters as well, but EM can be reinterpreted as coordinate ascent on the joint log-likelihood. The schema is reminiscent of the coordinate ascent used in mean-field variational inference, though EM typically yields a single parameter point estimate rather than a distribution over parameters."),"\n",r.createElement(a.h3,{id:"102-em-in-mixture-models",style:{position:"relative"}},r.createElement(a.a,{href:"#102-em-in-mixture-models","aria-label":"102 em in mixture models permalink",className:"anchor before"},r.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"10.2 EM in mixture models"),"\n",r.createElement(a.p,null,"An iconic example is the Gaussian mixture model. In the E-step, we compute the posterior responsibility that each mixture component has for each data point, while the M-step updates the component means, variances, and mixture weights. This is akin to a variational approach that factorizes the distribution of latent cluster assignments. Thus, EM can be seen as a limiting special case of variational inference when ",r.createElement(s.A,{text:"\\(q(\\theta)\\)"})," is restricted to be a delta function over parameters (i.e., no uncertainty about the parameters themselves)."),"\n",r.createElement(a.h3,{id:"103-link-to-approximate-inference-methods",style:{position:"relative"}},r.createElement(a.a,{href:"#103-link-to-approximate-inference-methods","aria-label":"103 link to approximate inference methods permalink",className:"anchor before"},r.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"10.3 Link to approximate inference methods"),"\n",r.createElement(a.p,null,"While EM remains algorithmically simpler in certain classical setups, it does not typically provide full posterior distributions over parameters. That's the difference between a maximum-likelihood or MAP approach and a fully Bayesian method. However, variations like ",r.createElement(o.A,null,"variational EM")," exist, bridging these ideas by updating an approximate posterior in the E-step and maximizing hyperparameters or other global parameters in the M-step."),"\n",r.createElement("br"),"\n",r.createElement(a.h2,{id:"11-map-inference-and-sparse-coding",style:{position:"relative"}},r.createElement(a.a,{href:"#11-map-inference-and-sparse-coding","aria-label":"11 map inference and sparse coding permalink",className:"anchor before"},r.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"11. MAP inference and sparse coding"),"\n",r.createElement(a.h3,{id:"111-map-fundamentals",style:{position:"relative"}},r.createElement(a.a,{href:"#111-map-fundamentals","aria-label":"111 map fundamentals permalink",className:"anchor before"},r.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"11.1 MAP fundamentals"),"\n",r.createElement(a.p,null,"Maximum a posteriori (MAP) inference is slightly different from the broader problem of computing a full posterior distribution. Instead, MAP focuses on finding the mode of the posterior:"),"\n",r.createElement(s.A,{text:"\\[\n\\hat{\\theta}_{\\text{MAP}} = \\arg\\max_\\theta \\; p(\\theta \\mid \\mathcal{D}).\n\\]"}),"\n",r.createElement(a.p,null,"When the posterior is unimodal and well-behaved, MAP can be close to the mean of the posterior, but if the posterior is skewed or multimodal, MAP can be an incomplete representation."),"\n",r.createElement(a.h3,{id:"112-connections-to-l1-and-l2-regularization",style:{position:"relative"}},r.createElement(a.a,{href:"#112-connections-to-l1-and-l2-regularization","aria-label":"112 connections to l1 and l2 regularization permalink",className:"anchor before"},r.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"11.2 Connections to L1 and L2 regularization"),"\n",r.createElement(a.p,null,"When we place a Gaussian prior on parameters ",r.createElement(s.A,{text:"\\(\\theta\\)"}),", performing MAP estimation is equivalent to adding an ",r.createElement(s.A,{text:"\\(L_2\\)"})," (ridge) regularization term during maximum likelihood estimation. Similarly, a Laplace prior leads to ",r.createElement(s.A,{text:"\\(L_1\\)"})," (lasso) regularization. Hence, these popular forms of regularization in classical machine learning can be interpreted as approximate Bayesian inference under specific prior assumptions, albeit focusing only on the mode."),"\n",r.createElement(a.h3,{id:"113-sparse-coding-as-approximate-inference",style:{position:"relative"}},r.createElement(a.a,{href:"#113-sparse-coding-as-approximate-inference","aria-label":"113 sparse coding as approximate inference permalink",className:"anchor before"},r.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"11.3 Sparse coding as approximate inference"),"\n",r.createElement(a.p,null,"Sparse coding, used extensively in signal processing and image recognition, posits that data can be represented by a sparse combination of basis vectors. Often, this is shown mathematically through a cost function that includes an ",r.createElement(s.A,{text:"\\(L_1\\)"})," penalty, reflecting a Laplacian prior on the sparse codes. Minimizing that cost is effectively performing MAP inference for the latent codes. Thus, many popular techniques in compressed sensing and dictionary learning can be tied back to approximate inference ideals."),"\n",r.createElement("br"),"\n",r.createElement(a.h2,{id:"12-learned-approximate-inference",style:{position:"relative"}},r.createElement(a.a,{href:"#12-learned-approximate-inference","aria-label":"12 learned approximate inference permalink",className:"anchor before"},r.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"12. Learned approximate inference"),"\n",r.createElement(a.h3,{id:"121-neural-network-based-inference",style:{position:"relative"}},r.createElement(a.a,{href:"#121-neural-network-based-inference","aria-label":"121 neural network based inference permalink",className:"anchor before"},r.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"12.1 Neural network-based inference"),"\n",r.createElement(a.p,null,"A striking development in recent years is the use of neural networks to learn an inference mechanism. Instead of deriving a closed-form or an iterative coordinate ascent scheme, we train a neural network to directly output approximate posterior parameters for every input data point. This approach is part of the broader concept of ",r.createElement(o.A,null,"amortized inference"),": the cost of learning the inference mapping is amortized over many data points or tasks (Gershman & Goodman, 2014)."),"\n",r.createElement(a.h3,{id:"122-amortized-inference",style:{position:"relative"}},r.createElement(a.a,{href:"#122-amortized-inference","aria-label":"122 amortized inference permalink",className:"anchor before"},r.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"12.2 Amortized inference"),"\n",r.createElement(a.p,null,"Amortized inference shows up in the ",r.createElement(o.A,null,"variational autoencoder (VAE)")," architecture (Kingma & Welling, 2014). The encoder network learns to predict the distribution of latent variables ",r.createElement(s.A,{text:"\\(z\\)"})," given data ",r.createElement(s.A,{text:"\\(x\\)"})," — effectively a ",r.createElement(s.A,{text:"\\(q(z \\mid x)\\)"}),". This is in contrast to classical variational inference, which might do separate iterative procedures for each data point. By training the encoder to perform this inference for all data points simultaneously, the method reuses computations and can scale extremely well."),"\n",r.createElement(a.h3,{id:"123-black-box-variational-inference",style:{position:"relative"}},r.createElement(a.a,{href:"#123-black-box-variational-inference","aria-label":"123 black box variational inference permalink",className:"anchor before"},r.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"12.3 Black-box variational inference"),"\n",r.createElement(a.p,null,"Black-box variational inference (Ranganath, Gerrish & Blei, 2014) grew out of a desire to unify variational inference with automatic differentiation and sample-based gradient estimates. In black-box inference, we only need to specify a log-likelihood function (and sometimes its gradient), while a general-purpose algorithm performs the necessary steps to update the variational distribution. This method significantly broadens the class of models to which variational inference can be applied, including ones that do not fit neatly into conjugate-exponential family frameworks."),"\n",r.createElement("br"),"\n",r.createElement(a.h2,{id:"13-advanced-references--expansions",style:{position:"relative"}},r.createElement(a.a,{href:"#13-advanced-references--expansions","aria-label":"13 advanced references  expansions permalink",className:"anchor before"},r.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"13. Advanced references & expansions"),"\n",r.createElement(a.p,null,"Approximate inference remains a highly active research area, as evidenced by recent contributions in top-tier conferences like NeurIPS, ICML, ICLR, AISTATS, and leading journals such as JMLR. Much of the cutting-edge work aims to handle non-conjugate models, large-scale streaming data, or complex, high-dimensional latent variable models."),"\n",r.createElement(a.h3,{id:"131-hamiltonian-monte-carlo",style:{position:"relative"}},r.createElement(a.a,{href:"#131-hamiltonian-monte-carlo","aria-label":"131 hamiltonian monte carlo permalink",className:"anchor before"},r.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"13.1 Hamiltonian Monte Carlo"),"\n",r.createElement(a.p,null,"A notable extension in the MCMC realm is ",r.createElement(o.A,null,"Hamiltonian Monte Carlo (HMC)"),', which leverages gradients of the log-posterior to "simulate" a physical system. HMC can traverse parameter space in larger, more efficient jumps, reducing random walk behavior. This typically leads to better mixing and fewer correlation issues between samples. Packages like Stan (Carpenter and gang, 2017) and PyMC embrace HMC as a default sampler for many models.'),"\n",r.createElement(a.h3,{id:"132-variational-flows",style:{position:"relative"}},r.createElement(a.a,{href:"#132-variational-flows","aria-label":"132 variational flows permalink",className:"anchor before"},r.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"13.2 Variational flows"),"\n",r.createElement(a.p,null,"Normalizing flows (Rezende & Mohamed, 2015) allow flexible transformations from a simple distribution (e.g., a Gaussian) into a more complex distribution by applying a sequence of invertible transformations. By incorporating such flows into ",r.createElement(s.A,{text:"\\(q(\\theta)\\)"}),", we can drastically increase the expressive power of the variational family, thereby lowering variational gap. Flow-based approximations facilitate capturing multimodality, skewness, and strong correlations — aspects typically missed by standard mean-field methods."),"\n",r.createElement(a.h3,{id:"133-adaptive-importance-sampling",style:{position:"relative"}},r.createElement(a.a,{href:"#133-adaptive-importance-sampling","aria-label":"133 adaptive importance sampling permalink",className:"anchor before"},r.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"13.3 Adaptive importance sampling"),"\n",r.createElement(a.p,null,"Importance sampling is a classical technique to approximate expected values by weighting samples from a proposal distribution. Modern twists like ",r.createElement(o.A,null,"adaptive importance sampling")," keep adjusting the proposal distribution so as to reduce variance in the importance weights. Variations exist that incorporate normalizing flows or Gaussian mixtures as proposals, bridging the gap between classical sampling methods and advanced variational techniques."),"\n",r.createElement("br"),"\n",r.createElement(a.h2,{id:"14-a-brief-demonstration-in-code",style:{position:"relative"}},r.createElement(a.a,{href:"#14-a-brief-demonstration-in-code","aria-label":"14 a brief demonstration in code permalink",className:"anchor before"},r.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"14. A brief demonstration in code"),"\n",r.createElement(a.p,null,"To illustrate how one might practically implement a simple approximate inference procedure in Python (using a minimal pseudocode approach), consider a Bayesian logistic regression scenario. We'll outline a straightforward variational approach using gradient-based REINFORCE or reparameterization:"),"\n",r.createElement(l.A,{text:'\nimport torch\nimport torch.nn as nn\nimport torch.optim as optim\n\n# Suppose we have data: X (features), y (binary labels)\n\nclass VariationalLogisticRegression(nn.Module):\n    def __init__(self, dim):\n        super().__init__()\n        # For simplicity, let\'s maintain a mean and log-variance for each parameter\n        self.mean = nn.Parameter(torch.zeros(dim))\n        self.log_var = nn.Parameter(torch.zeros(dim))\n        \n    def forward(self, X):\n        # Sample parameters using the reparameterization trick\n        eps = torch.randn_like(self.mean)\n        w = self.mean + torch.exp(0.5 * self.log_var) * eps\n        \n        # Compute logits\n        logits = X.mm(w.unsqueeze(1)).squeeze()\n        return logits, w\n    \ndef elbo(logits, y, model, prior_mean=0.0, prior_log_var=0.0):\n    # Negative log-likelihood (binary cross-entropy)\n    # Here we combine the logistic loss\n    log_likelihood = -nn.functional.binary_cross_entropy_with_logits(logits, y.float(), reduction=\'sum\')\n    \n    # KL term between q(w) and p(w) ~ N(prior_mean, prior_var), \n    # average over all parameters\n    var_q = torch.exp(model.log_var)\n    var_p = torch.exp(torch.tensor(prior_log_var))\n    \n    # KL(q||p) for factorized Gaussians\n    # = 0.5 * sum( var_q/var_p + (mean_q - mean_p)^2/var_p - len(mean_q) + log(var_p) - log(var_q) )\n    kld = 0.5 * torch.sum(var_q/var_p\n                          + (model.mean - prior_mean).pow(2)/var_p\n                          - 1.0 \n                          + prior_log_var \n                          - model.log_var)\n    \n    # We want to maximize the ELBO, so return negative\n    return log_likelihood - kld\n\n# Example usage (toy):\ndim = 5\nmodel = VariationalLogisticRegression(dim)\noptimizer = optim.Adam(model.parameters(), lr=0.01)\n\nX_torch = torch.randn(100, dim)  # dummy data\ny_torch = (torch.randn(100) > 0).float()  # random labels\n\nfor step in range(1000):\n    optimizer.zero_grad()\n    logits, w_samp = model(X_torch)\n    loss = -elbo(logits, y_torch, model)  # negative ELBO\n    loss.backward()\n    optimizer.step()\n\n# After training, we can examine model.mean, model.log_var as the approximate posterior\nprint("Inferred mean:", model.mean.detach().numpy())\nprint("Inferred log_var:", model.log_var.detach().numpy())\n'}),"\n",r.createElement(a.p,null,"This snippet illustrates, in a simplified manner, how one might implement variational logistic regression in a modern machine learning framework. We keep track of the approximate posterior's mean and variance (through ",r.createElement(o.A,null,"log_var"),"), and each forward pass samples parameters from that approximate posterior. We then compute the negative ELBO and backpropagate to update the variational parameters."),"\n",r.createElement("br"),"\n",r.createElement(a.h2,{id:"15-conclusion-like-reflections-and-further-directions",style:{position:"relative"}},r.createElement(a.a,{href:"#15-conclusion-like-reflections-and-further-directions","aria-label":"15 conclusion like reflections and further directions permalink",className:"anchor before"},r.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"15. Conclusion-like reflections and further directions"),"\n",r.createElement(a.p,null,"Approximate inference is essential for enabling modern data science and machine learning to manage complex models under real-world constraints. Ranging from classical approaches like Laplace's approximation and MCMC to sophisticated, gradient-based variational methods and moment-matching algorithms like expectation propagation, these techniques form the backbone of probabilistic modeling at scale. The trade-offs among these methods influence contemporary model design, from hierarchical Bayesian frameworks to deep latent variable models."),"\n",r.createElement(a.p,null,"Furthermore, the synergy with neural networks has sparked a new era of ",r.createElement(o.A,null,"amortized inference"),", significantly accelerating Bayesian workflows that used to be burdensome or even infeasible. Research into normalizing flows, stochastic gradient MCMC, and advanced factorization schemes continues to refine these techniques."),"\n",r.createElement(a.p,null,'We can anticipate that the ongoing proliferation of big data, streaming applications, and deep probabilistic architectures will strengthen and diversify the role of approximate inference even further. Its ability to glean meaningful structure and quantify uncertainty in otherwise "impossible" integrals stands as a testament to the power and elegance of this field. Whether one is working with Markov random fields in image processing, hierarchical mixture models in genetics, or massive-scale latent variable models in natural language processing, approximate inference stands ready to strike the balance between feasible computation and robust, trustworthy insight.'),"\n",r.createElement("br"),"\n",r.createElement(a.h2,{id:"references--further-reading",style:{position:"relative"}},r.createElement(a.a,{href:"#references--further-reading","aria-label":"references  further reading permalink",className:"anchor before"},r.createElement(a.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"References & further reading"),"\n",r.createElement(a.ul,null,"\n",r.createElement(a.li,null,'Carpenter and gang, 2017. "Stan: A probabilistic programming language." Journal of Statistical Software.'),"\n",r.createElement(a.li,null,'Gershman & Goodman, 2014. "Amortized inference in probabilistic reasoning."'),"\n",r.createElement(a.li,null,'Gelfand & Smith, 1990. "Sampling-based approaches to calculating marginal densities." Journal of the American Statistical Association.'),"\n",r.createElement(a.li,null,'Hoffman, Blei, Wang, & Paisley, 2013. "Stochastic variational inference." Journal of Machine Learning Research.'),"\n",r.createElement(a.li,null,'Kingma & Welling, 2014. "Auto-encoding variational Bayes." ICLR.'),"\n",r.createElement(a.li,null,'Minka, 2001. "Expectation propagation for approximate Bayesian inference." UAI.'),"\n",r.createElement(a.li,null,'Neal, 2011. "MCMC using Hamiltonian dynamics." Handbook of Markov Chain Monte Carlo.'),"\n",r.createElement(a.li,null,'Ranganath, Gerrish, & Blei, 2014. "Black box variational inference." AISTATS.'),"\n",r.createElement(a.li,null,'Rezende & Mohamed, 2015. "Variational inference with normalizing flows." ICML.'),"\n",r.createElement(a.li,null,'Cooper, 1990. "The computational complexity of probabilistic inference using Bayesian belief networks." Artificial Intelligence.'),"\n"),"\n",r.createElement(t,{alt:"Graphical model for approximate inference illustration",path:"",caption:"In many real-world graphical models, approximate inference is the lifeline that makes them tractable.",zoom:"false"}))}var h=function(e){void 0===e&&(e={});const{wrapper:a}=Object.assign({},(0,i.RP)(),e.components);return a?r.createElement(a,e,r.createElement(c,e)):c(e)};var m=t(36710),p=t(58481),d=t.n(p),f=t(36310),u=t(87245),g=t(27042),v=t(59849),b=t(5591),y=t(61122),x=t(9219),E=t(33203),w=t(95751),S=t(94328),H=t(80791),k=t(78137);const z=e=>{let{toc:a}=e;if(!a||!a.items)return null;return r.createElement("nav",{className:H.R},r.createElement("ul",null,a.items.map(((e,a)=>r.createElement("li",{key:a},r.createElement("a",{href:e.url,onClick:a=>((e,a)=>{e.preventDefault();const t=a.replace("#",""),n=document.getElementById(t);n&&n.scrollIntoView({behavior:"smooth",block:"start"})})(a,e.url)},e.title),e.items&&r.createElement(z,{toc:{items:e.items}}))))))};function M(e){let{data:{mdx:a,allMdx:o,allPostImages:l},children:s}=e;const{frontmatter:c,body:h,tableOfContents:m}=a,p=c.index,v=c.slug.split("/")[1],H=o.nodes.filter((e=>e.frontmatter.slug.includes(`/${v}/`))).sort(((e,a)=>e.frontmatter.index-a.frontmatter.index)),M=H.findIndex((e=>e.frontmatter.index===p)),_=H[M+1],C=H[M-1],A=c.slug.replace(/\/$/,""),V=/[^/]*$/.exec(A)[0],T=`posts/${v}/content/${V}/`,{0:B,1:I}=(0,r.useState)(c.flagWideLayoutByDefault),{0:L,1:N}=(0,r.useState)(!1);var q;(0,r.useEffect)((()=>{N(!0);const e=setTimeout((()=>N(!1)),340);return()=>clearTimeout(e)}),[B]),"adventures"===v?q=x.cb:"research"===v?q=x.Qh:"thoughts"===v&&(q=x.T6);const P=d()(h).replace(/import .*? from .*?;/g,"").replace(/<.*?>/g,"").replace(/\{\/\*[\s\S]*?\*\/\}/g,"").trim().split(/\s+/).length,G=function(e){if(e<=10)return"~10 min";if(e<=20)return"~20 min";if(e<=30)return"~30 min";if(e<=40)return"~40 min";if(e<=50)return"~50 min";if(e<=60)return"~1 h";const a=Math.floor(e/60),t=e%60;return t<=30?`~${a}${t>0?".5":""} h`:`~${a+1} h`}(Math.ceil(P/q)+(c.extraReadTimeMin||0)),O=[{flag:c.flagDraft,component:()=>Promise.all([t.e(3231),t.e(8809)]).then(t.bind(t,28809))},{flag:c.flagMindfuckery,component:()=>Promise.all([t.e(3231),t.e(2471)]).then(t.bind(t,67709))},{flag:c.flagRewrite,component:()=>Promise.all([t.e(3231),t.e(6764)]).then(t.bind(t,62002))},{flag:c.flagOffensive,component:()=>Promise.all([t.e(3231),t.e(2443)]).then(t.bind(t,17681))},{flag:c.flagProfane,component:()=>Promise.all([t.e(3231),t.e(8048)]).then(t.bind(t,53286))},{flag:c.flagMultilingual,component:()=>Promise.all([t.e(3231),t.e(4069)]).then(t.bind(t,78831))},{flag:c.flagUnreliably,component:()=>Promise.all([t.e(3231),t.e(3417)]).then(t.bind(t,8179))},{flag:c.flagPolitical,component:()=>Promise.all([t.e(3231),t.e(5195)]).then(t.bind(t,30433))},{flag:c.flagCognitohazard,component:()=>Promise.all([t.e(3231),t.e(3175)]).then(t.bind(t,8413))},{flag:c.flagHidden,component:()=>Promise.all([t.e(3231),t.e(9556)]).then(t.bind(t,14794))}],{0:W,1:R}=(0,r.useState)([]);return(0,r.useEffect)((()=>{O.forEach((e=>{let{flag:a,component:t}=e;a&&t().then((e=>{R((a=>[].concat((0,n.A)(a),[e.default])))}))}))}),[]),r.createElement(g.P.div,{initial:{opacity:0},animate:{opacity:1},exit:{opacity:0},transition:{duration:.15}},r.createElement(b.A,{postNumber:c.index,date:c.date,updated:c.updated,readTime:G,difficulty:c.difficultyLevel,title:c.title,desc:c.desc,banner:c.banner,section:v,postKey:V,isMindfuckery:c.flagMindfuckery,mainTag:c.mainTag}),r.createElement("div",{style:{display:"flex",justifyContent:"flex-end",flexWrap:"wrap",maxWidth:"75%",marginLeft:"auto",paddingRight:"1vw",marginTop:"-6vh",marginBottom:"4vh"}},c.otherTags.map(((e,a)=>r.createElement("span",{key:a,className:`noselect ${k.MW}`,style:{margin:"0 5px 5px 0"}},e)))),r.createElement("div",{className:"postBody"},r.createElement(z,{toc:m})),r.createElement("br"),r.createElement("div",{style:{margin:"0 10% -2vh 30%",textAlign:"right"}},r.createElement(g.P.button,{className:`noselect ${S.pb}`,id:S.xG,onClick:()=>{I(!B)},whileTap:{scale:.93}},r.createElement(g.P.div,{className:w.DJ,key:B,initial:{opacity:0},animate:{opacity:1},exit:{opacity:0},transition:{duration:.3,ease:"easeInOut"}},B?"Switch to default layout":"Switch to wide layout"))),r.createElement("br"),r.createElement("div",{className:"postBody",style:{margin:B?"0 -14%":"",maxWidth:B?"200%":"",transition:"margin 1s ease, max-width 1s ease, padding 1s ease"}},r.createElement("div",{className:`${S.P_} ${L?S.Xn:S.qG}`},W.map(((e,a)=>r.createElement(e,{key:a}))),c.indexCourse?r.createElement(E.A,{index:c.indexCourse,category:c.courseCategoryName}):"",r.createElement(f.Z.Provider,{value:{images:l.nodes,basePath:T.replace(/\/$/,"")+"/"}},r.createElement(i.xA,{components:{Image:u.A}},s)))),r.createElement(y.A,{nextPost:_,lastPost:C,keyCurrent:V,section:v}))}function _(e){return r.createElement(M,e,r.createElement(h,e))}function C(e){var a,t,n,i,o;let{data:l}=e;const{frontmatter:s}=l.mdx,c=s.titleSEO||s.title,h=s.titleOG||c,p=s.titleTwitter||c,d=s.descSEO||s.desc,f=s.descOG||d,u=s.descTwitter||d,g=s.schemaType||"BlogPosting",b=s.keywordsSEO,y=s.date,x=s.updated||y,E=s.imageOG||(null===(a=s.banner)||void 0===a||null===(t=a.childImageSharp)||void 0===t||null===(n=t.gatsbyImageData)||void 0===n||null===(i=n.images)||void 0===i||null===(o=i.fallback)||void 0===o?void 0:o.src),w=s.imageAltOG||f,S=s.imageTwitter||E,H=s.imageAltTwitter||u,k=s.canonicalURL,z=s.flagHidden||!1,M=s.mainTag||"Posts",_=s.slug.split("/")[1]||"posts",{siteUrl:C}=(0,m.Q)(),A={"@context":"https://schema.org","@type":"BreadcrumbList",itemListElement:[{"@type":"ListItem",position:1,name:"Home",item:C},{"@type":"ListItem",position:2,name:M,item:`${C}/${s.slug.split("/")[1]}`},{"@type":"ListItem",position:3,name:c,item:`${C}${s.slug}`}]};return r.createElement(v.A,{title:c+" - avrtt.blog",titleOG:h,titleTwitter:p,description:d,descriptionOG:f,descriptionTwitter:u,schemaType:g,keywords:b,datePublished:y,dateModified:x,imageOG:E,imageAltOG:w,imageTwitter:S,imageAltTwitter:H,canonicalUrl:k,flagHidden:z,mainTag:M,section:_,type:"article"},r.createElement("script",{type:"application/ld+json"},JSON.stringify(A)))}},96098:function(e,a,t){var n=t(96540),i=t(7978);a.A=e=>{let{text:a}=e;return n.createElement(i.A,null,a)}}}]);
//# sourceMappingURL=component---src-templates-post-js-content-file-path-src-pages-posts-research-approximate-inference-mdx-7671b13e8725a31b9e1e.js.map