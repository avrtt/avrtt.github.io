"use strict";(self.webpackChunkavrtt_blog=self.webpackChunkavrtt_blog||[]).push([[8366],{3962:function(e,t){t.A="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iaXNvLTg4NTktMSI/Pgo8IS0tIEdlbmVyYXRvcjogQWRvYmUgSWxsdXN0cmF0b3IgMTYuMC4wLCBTVkcgRXhwb3J0IFBsdWctSW4gLiBTVkcgVmVyc2lvbjogNi4wMCBCdWlsZCAwKSAgLS0+CjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+CjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iQ2FwYV8xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4PSIwcHgiIHk9IjBweCIKCSB3aWR0aD0iNDE2Ljk3OXB4IiBoZWlnaHQ9IjQxNi45NzlweCIgdmlld0JveD0iMCAwIDQxNi45NzkgNDE2Ljk3OSIgc3R5bGU9ImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgNDE2Ljk3OSA0MTYuOTc5OyIKCSB4bWw6c3BhY2U9InByZXNlcnZlIj4KPGc+Cgk8cGF0aCBkPSJNMzU2LjAwNCw2MS4xNTZjLTgxLjM3LTgxLjQ3LTIxMy4zNzctODEuNTUxLTI5NC44NDgtMC4xODJjLTgxLjQ3LDgxLjM3MS04MS41NTIsMjEzLjM3OS0wLjE4MSwyOTQuODUKCQljODEuMzY5LDgxLjQ3LDIxMy4zNzgsODEuNTUxLDI5NC44NDksMC4xODFDNDM3LjI5MywyNzQuNjM2LDQzNy4zNzUsMTQyLjYyNiwzNTYuMDA0LDYxLjE1NnogTTIzNy42LDM0MC43ODYKCQljMCwzLjIxNy0yLjYwNyw1LjgyMi01LjgyMiw1LjgyMmgtNDYuNTc2Yy0zLjIxNSwwLTUuODIyLTIuNjA1LTUuODIyLTUuODIyVjE2Ny44ODVjMC0zLjIxNywyLjYwNy01LjgyMiw1LjgyMi01LjgyMmg0Ni41NzYKCQljMy4yMTUsMCw1LjgyMiwyLjYwNCw1LjgyMiw1LjgyMlYzNDAuNzg2eiBNMjA4LjQ5LDEzNy45MDFjLTE4LjYxOCwwLTMzLjc2Ni0xNS4xNDYtMzMuNzY2LTMzLjc2NQoJCWMwLTE4LjYxNywxNS4xNDctMzMuNzY2LDMzLjc2Ni0zMy43NjZjMTguNjE5LDAsMzMuNzY2LDE1LjE0OCwzMy43NjYsMzMuNzY2QzI0Mi4yNTYsMTIyLjc1NSwyMjcuMTA3LDEzNy45MDEsMjA4LjQ5LDEzNy45MDF6Ii8+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPC9zdmc+Cg=="},6793:function(e,t,n){n.r(t),n.d(t,{Head:function(){return _},PostTemplate:function(){return I},default:function(){return M}});var a=n(28453),i=n(96540),r=n(9360),l=n(61992),o=n(62087),s=n(90548);function c(e){const t=Object.assign({p:"p",h3:"h3",a:"a",span:"span",ul:"ul",li:"li",hr:"hr",h2:"h2",strong:"strong",h4:"h4",ol:"ol"},(0,a.RP)(),e.components);return i.createElement(i.Fragment,null,"\n",i.createElement("br"),"\n","\n","\n",i.createElement(t.p,null,'Information theory, conceived by Claude Shannon in his seminal 1948 paper ""A Mathematical Theory of Communication"" (Shannon, Bell System Technical Journal, 1948), provides the mathematical foundations for quantifying uncertainty, information content, and the efficiency of data transmission. The birth of this field revolutionized the way engineers and scientists think about data representation, communication channels, and the very nature of information itself. Since then, information-theoretic concepts — such as entropy, mutual information, Kullback-Leibler divergence, and channel capacity — have permeated virtually every corner of technology, from digital communications to cryptography, and, as we will emphasize in this article, machine learning.'),"\n",i.createElement(t.p,null,"Machine learning is all about extracting useful patterns from data, making decisions under uncertainty, and building models that generalize well to novel situations. Although machine learning can often appear as a purely algorithmic discipline, information theory plays an essential role beneath many learning algorithms. Whether in supervised learning, unsupervised representation learning, or complex multi-agent reinforcement learning tasks, core information-theoretic quantities arise time and again to quantify uncertainty, measure predictive performance, and drive the optimization of model parameters."),"\n",i.createElement(t.p,null,"Information theory offers a language and a toolkit to address fundamental questions in machine learning: How much information about the output labels do our features carry? How can we reduce uncertainty in model predictions through data acquisition? Why do certain regularizers, based on divergences like the Kullback-Leibler divergence, appear in objective functions? How does entropy encourage exploration in reinforcement learning? What does the concept of channel capacity tell us about feature selection in resource-constrained settings?"),"\n",i.createElement(t.p,null,"In this article, I dive into these and many related questions by examining the theoretical backbone of information theory. I explore the fundamental concepts of entropy, mutual information, and divergences, and illustrate their deep ties to practical machine learning applications. I also spotlight advanced topics such as the information bottleneck principle, the role of information measures in multi-agent and reinforcement learning settings, and various ways to estimate or approximate these measures in high-dimensional data scenarios."),"\n",i.createElement(t.p,null,"Ultimately, my goal is to help you see information theory not as an esoteric subfield limited to theoretical research, but rather as a vibrant, unifying set of principles that can elevate your understanding and practice of machine learning. For readers seeking to bridge the gap between the classical theory — as laid out by Shannon — and cutting-edge AI research, I provide insights into how these quantitative measures of information can be harnessed in everything from deep learning to distributed multi-agent systems."),"\n",i.createElement(t.h3,{id:"overview-of-information-theory",style:{position:"relative"}},i.createElement(t.a,{href:"#overview-of-information-theory","aria-label":"overview of information theory permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Overview of information theory"),"\n",i.createElement(t.p,null,'Information theory measures the content of a message, the uncertainty present in random variables, and the capacity of channels to transmit information without loss. In short, it gives us a rigorous framework to answer questions like: "How many bits are needed to describe a random variable\'s outcome?" or "How correlated are two random variables?" or even "How close is one probability distribution to another?"'),"\n",i.createElement(t.ul,null,"\n",i.createElement(t.li,null,"\n",i.createElement(t.p,null,i.createElement(l.A,null,"Claude Shannon"),"'s contribution: Shannon proposed that the amount of information conveyed by a random variable is linked to its unpredictability, or uncertainty. He introduced the concept of ",i.createElement(l.A,null,"entropy")," to quantify this uncertainty in terms of bits."),"\n"),"\n",i.createElement(t.li,null,"\n",i.createElement(t.p,null,"The concept of ",i.createElement(l.A,null,"channel capacity")," tells us the maximum rate of information that can be reliably transmitted over a noisy channel. This concept, while originally developed for telecommunications, is surprisingly relevant to learning algorithms that can be viewed as data channels between input features and model outputs."),"\n"),"\n",i.createElement(t.li,null,"\n",i.createElement(t.p,null,i.createElement(l.A,null,"Mutual information")," is a measure of how much knowing one variable reduces our uncertainty about another. This measure is central to feature selection, data compression, and representation learning in machine learning contexts."),"\n"),"\n",i.createElement(t.li,null,"\n",i.createElement(t.p,null,i.createElement(l.A,null,"Information theory in ML"),": Because training a model can be viewed as compressing or encoding data about the environment (inputs) into weights or model parameters, it is natural that information theory has emerged as one of the key theoretical lenses on machine learning."),"\n"),"\n"),"\n",i.createElement(t.h3,{id:"relevance-to-machine-learning",style:{position:"relative"}},i.createElement(t.a,{href:"#relevance-to-machine-learning","aria-label":"relevance to machine learning permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Relevance to machine learning"),"\n",i.createElement(t.p,null,"Information-theoretic quantities show up in many fundamental ML tasks:"),"\n",i.createElement(t.ul,null,"\n",i.createElement(t.li,null,"\n",i.createElement(t.p,null,i.createElement(l.A,null,"Data encoding and compression"),": In unsupervised learning, autoencoders compress data into a latent representation. Variational autoencoders (VAEs) explicitly rely on Kullback-Leibler divergences to measure how well the latent distribution matches the prior."),"\n"),"\n",i.createElement(t.li,null,"\n",i.createElement(t.p,null,i.createElement(l.A,null,"Decision-making under uncertainty"),': Reinforcement learning systems often strive to balance exploration and exploitation. Some approaches introduce an "entropy bonus" to keep the agent from collapsing to deterministic policies too early, as higher entropy encourages exploration of actions.'),"\n"),"\n",i.createElement(t.li,null,"\n",i.createElement(t.p,null,i.createElement(l.A,null,"Feature selection"),": Mutual information has often been used as a criterion for picking the most informative features to explain a target variable. In high-dimensional datasets, measuring or approximating mutual information helps prune out irrelevant variables."),"\n"),"\n",i.createElement(t.li,null,"\n",i.createElement(t.p,null,i.createElement(l.A,null,"Representation learning"),": The ",i.createElement(r.A,{text:"Information Bottleneck Principle proposes that networks learn to compress input data to preserve only task-relevant signals."})," (Tishby and gang, 2000). This principle has been used to interpret the hidden layers of deep networks."),"\n"),"\n",i.createElement(t.li,null,"\n",i.createElement(t.p,null,i.createElement(l.A,null,"Probabilistic modeling"),": Bayesian neural networks, domain adaptation, and multi-agent policy alignment all rely on various divergences (e.g., KL divergence, Jensen-Shannon divergence) to keep distributions aligned and consistent with prior knowledge or other agents' behaviors."),"\n"),"\n"),"\n",i.createElement(t.h3,{id:"objective-of-the-article",style:{position:"relative"}},i.createElement(t.a,{href:"#objective-of-the-article","aria-label":"objective of the article permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Objective of the article"),"\n",i.createElement(t.p,null,"In this article, I pursue a comprehensive exploration of major information-theoretic concepts and link them to a broad range of machine learning applications. My purpose is to offer intuitive explanations supplemented with relevant mathematical definitions, theoretical underpinnings, and references to cutting-edge developments. By the end, you will see how to:"),"\n",i.createElement(t.ul,null,"\n",i.createElement(t.li,null,"Interpret key quantities such as entropy, mutual information, and divergences in the context of classification, clustering, and reinforcement learning."),"\n",i.createElement(t.li,null,"Understand how the ",i.createElement(l.A,null,"information bottleneck")," principle explains phenomena in deep neural networks, such as hidden-layer representation compression."),"\n",i.createElement(t.li,null,"Harness information theory to guide feature selection, multi-agent communication, model compression (pruning and quantization), and domain adaptation."),"\n",i.createElement(t.li,null,"Implement practical computations of information-theoretic measures in Python, including the intricacies of dealing with high-dimensional data."),"\n"),"\n",i.createElement(t.p,null,"I aim for a deeply technical yet approachable style so that professionals with advanced ML experience can discover new insights or solidify existing understanding. Throughout, I connect fundamental theory with real-world scenarios, bridging that often elusive gap between theoretical constructs and hands-on applications."),"\n",i.createElement(t.hr),"\n",i.createElement(t.h2,{id:"core-concepts-of-information-theory",style:{position:"relative"}},i.createElement(t.a,{href:"#core-concepts-of-information-theory","aria-label":"core concepts of information theory permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Core concepts of information theory"),"\n",i.createElement(t.p,null,'Machine learning, at its root, involves mapping from input data to an output space, guided by an objective function. Information theory starts by quantifying what it means for data to "contain" or "transmit" knowledge. Below, I explore the core constructs of this discipline, explaining why they matter for machine learning.'),"\n",i.createElement(t.h3,{id:"entropy-and-shannon-information",style:{position:"relative"}},i.createElement(t.a,{href:"#entropy-and-shannon-information","aria-label":"entropy and shannon information permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Entropy and shannon information"),"\n",i.createElement(t.p,null,i.createElement(l.A,null,"Entropy"),", typically denoted ",i.createElement(s.A,{text:"\\(H(X)\\)"}),", measures the uncertainty or average surprise of a discrete random variable ",i.createElement(s.A,{text:"\\(X\\)"}),". Formally, if ",i.createElement(s.A,{text:"\\(X\\)"})," takes values ",i.createElement(s.A,{text:"\\(x\\)"})," in some set ",i.createElement(s.A,{text:"\\(\\mathcal{X}\\)"})," with probabilities ",i.createElement(s.A,{text:"\\(p(x)\\)"}),", the entropy is defined as:"),"\n",i.createElement(s.A,{text:"\\[\nH(X) = - \\sum_{x \\in \\mathcal{X}} p(x) \\log_2 p(x).\n\\]"}),"\n",i.createElement(t.p,null,"Here:"),"\n",i.createElement(t.ul,null,"\n",i.createElement(t.li,null,i.createElement(s.A,{text:"\\(p(x)\\)"})," is the probability of outcome ",i.createElement(s.A,{text:"\\(x\\)"}),"."),"\n",i.createElement(t.li,null,"The logarithm is base 2, so the unit is bits."),"\n",i.createElement(t.li,null,i.createElement(s.A,{text:"\\(H(X)\\)"})," is largest when each outcome is equally likely, implying maximal uncertainty."),"\n"),"\n",i.createElement(t.p,null,"In many ML contexts, we deal with continuous variables. The continuous analog is the ",i.createElement(l.A,null,"differential entropy"),", but it can have nuances (such as potentially being negative). Regardless, the discrete version of entropy is typically more intuitive and is widely used in classification tasks and decision trees (e.g., measuring the impurity of a node with the Shannon entropy or Gini impurity)."),"\n",i.createElement(t.p,null,i.createElement(t.strong,null,"Intuition and significance"),": If ",i.createElement(s.A,{text:"\\(H(X)\\)"})," is high, we need more bits on average to describe ",i.createElement(s.A,{text:"\\(X\\)"}),". In supervised learning, if the labels in a dataset are very uncertain, it suggests that the classification problem is challenging. In many algorithms, minimizing a function related to ",i.createElement(s.A,{text:"\\(H(X)\\)"})," or maximizing a function that reduces entropy (like maximizing the negative of it) can lead to better predictive performance."),"\n",i.createElement(t.h4,{id:"practical-example-in-classification",style:{position:"relative"}},i.createElement(t.a,{href:"#practical-example-in-classification","aria-label":"practical example in classification permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Practical example in classification"),"\n",i.createElement(t.p,null,"Suppose you have a dataset with a label ",i.createElement(s.A,{text:"\\(Y\\)"})," that takes three equally likely classes. The entropy of ",i.createElement(s.A,{text:"\\(Y\\)"})," is ",i.createElement(s.A,{text:"\\(H(Y) = -3 \\times (\\frac{1}{3}) \\log_2 (\\frac{1}{3}) \\approx 1.585\\)"})," bits. If your model can reduce the uncertainly about these classes significantly, you can say that your model is effectively capturing the information about ",i.createElement(s.A,{text:"\\(Y\\)"}),"."),"\n",i.createElement(t.h4,{id:"shannon-information-of-an-event",style:{position:"relative"}},i.createElement(t.a,{href:"#shannon-information-of-an-event","aria-label":"shannon information of an event permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Shannon information of an event"),"\n",i.createElement(t.p,null,'The information content (also called the "self-information") of an event ',i.createElement(s.A,{text:"\\(x\\)"})," is ",i.createElement(s.A,{text:"\\(-\\log_2 p(x)\\)"}),', meaning rare events carry more "surprise" or more information. This concept underscores the fundamental principle behind coding: it is more efficient to use short codes for frequent events and longer codes for rare events — an approach used in Huffman coding and other compression algorithms.'),"\n",i.createElement(t.h3,{id:"mutual-information-and-channel-capacity",style:{position:"relative"}},i.createElement(t.a,{href:"#mutual-information-and-channel-capacity","aria-label":"mutual information and channel capacity permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Mutual information and channel capacity"),"\n",i.createElement(t.p,null,i.createElement(l.A,null,"Mutual information (MI)"),", denoted ",i.createElement(s.A,{text:"\\(I(X; Y)\\)"}),", measures how much knowing one variable ",i.createElement(s.A,{text:"\\(X\\)"})," reduces the uncertainty of another variable ",i.createElement(s.A,{text:"\\(Y\\)"}),". It is defined as:"),"\n",i.createElement(s.A,{text:"\\[\nI(X; Y) = H(X) + H(Y) - H(X, Y),\n\\]"}),"\n",i.createElement(t.p,null,"or equivalently,"),"\n",i.createElement(s.A,{text:"\\[\nI(X; Y) = \\sum_{x \\in \\mathcal{X}, y \\in \\mathcal{Y}} p(x, y) \\log_2 \\frac{p(x, y)}{p(x)p(y)}.\n\\]"}),"\n",i.createElement(t.ul,null,"\n",i.createElement(t.li,null,i.createElement(s.A,{text:"\\(H(X, Y)\\)"})," is the joint entropy of ",i.createElement(s.A,{text:"\\(X\\)"})," and ",i.createElement(s.A,{text:"\\(Y\\)"}),"."),"\n",i.createElement(t.li,null,i.createElement(s.A,{text:"\\(p(x, y)\\)"})," is the joint distribution, while ",i.createElement(s.A,{text:"\\(p(x)p(y)\\)"})," is the product of marginals."),"\n"),"\n",i.createElement(t.p,null,i.createElement(t.strong,null,"Interpretation"),": If ",i.createElement(s.A,{text:"\\(I(X; Y)\\)"})," is 0, ",i.createElement(s.A,{text:"\\(X\\)"})," and ",i.createElement(s.A,{text:"\\(Y\\)"})," are independent, meaning knowledge of one does not tell you anything about the other. The maximum possible MI is ",i.createElement(s.A,{text:"\\(\\min\\{H(X), H(Y)\\}\\)"}),"."),"\n",i.createElement(t.h4,{id:"channel-capacity",style:{position:"relative"}},i.createElement(t.a,{href:"#channel-capacity","aria-label":"channel capacity permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Channel capacity"),"\n",i.createElement(t.p,null,"In Shannon's channel coding theorem, the ",i.createElement(l.A,null,"channel capacity")," ",i.createElement(s.A,{text:"\\(C\\)"})," of a noisy channel is the maximum rate at which information can be transmitted with arbitrarily small error. For a simple channel with input ",i.createElement(s.A,{text:"\\(X\\)"})," and output ",i.createElement(s.A,{text:"\\(Y\\)"}),":"),"\n",i.createElement(s.A,{text:"\\[\nC = \\max_{p(x)} I(X; Y).\n\\]"}),"\n",i.createElement(t.p,null,"We can interpret feature selection or representation learning in ML as searching for the distribution (or representation) of ",i.createElement(s.A,{text:"\\(X\\)"})," that maximizes the information about target ",i.createElement(s.A,{text:"\\(Y\\)"})," subject to constraints (like network capacity or computational budgets)."),"\n",i.createElement(t.h3,{id:"kullback-leibler-divergence",style:{position:"relative"}},i.createElement(t.a,{href:"#kullback-leibler-divergence","aria-label":"kullback leibler divergence permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Kullback-Leibler divergence"),"\n",i.createElement(t.p,null,i.createElement(l.A,null,"Kullback-Leibler divergence")," (KL divergence), also known as relative entropy, measures how one probability distribution ",i.createElement(s.A,{text:"\\(p\\)"})," diverges from a reference distribution ",i.createElement(s.A,{text:"\\(q\\)"}),". For discrete distributions:"),"\n",i.createElement(s.A,{text:"\\[\nD_{KL}(p \\parallel q) = \\sum_{x \\in \\mathcal{X}} p(x) \\log_2 \\frac{p(x)}{q(x)}.\n\\]"}),"\n",i.createElement(t.ul,null,"\n",i.createElement(t.li,null,"KL divergence is ",i.createElement(l.A,null,"not")," symmetrical; typically ",i.createElement(s.A,{text:"\\(D_{KL}(p \\parallel q) \\neq D_{KL}(q \\parallel p)\\)"}),"."),"\n",i.createElement(t.li,null,"It is always non-negative and is 0 only if ",i.createElement(s.A,{text:"\\(p = q\\)"})," everywhere."),"\n"),"\n",i.createElement(t.p,null,"In machine learning, KL divergence shows up in:"),"\n",i.createElement(t.ul,null,"\n",i.createElement(t.li,null,i.createElement(l.A,null,"Variational inference"),": We minimize ",i.createElement(s.A,{text:"\\(D_{KL}(q(\\theta) \\parallel p(\\theta|D))\\)"})," or an equivalent term to approximate the posterior distribution ",i.createElement(s.A,{text:"\\(p(\\theta|D)\\)"})," with a simpler distribution ",i.createElement(s.A,{text:"\\(q(\\theta)\\)"}),"."),"\n",i.createElement(t.li,null,i.createElement(l.A,null,"Policy alignment"),": In multi-agent RL, we can constrain each agent's policy to remain close to a prior or to another agent's policy distribution by minimizing the KL divergence between them."),"\n",i.createElement(t.li,null,i.createElement(l.A,null,"Reinforcement learning objectives"),": Surrogate objectives in algorithms like Proximal Policy Optimization (PPO) incorporate KL divergence constraints to limit the size of policy updates."),"\n"),"\n",i.createElement(t.h3,{id:"fisher-information-for-parametric-models",style:{position:"relative"}},i.createElement(t.a,{href:"#fisher-information-for-parametric-models","aria-label":"fisher information for parametric models permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Fisher information for parametric models"),"\n",i.createElement(t.p,null,i.createElement(l.A,null,"Fisher information")," quantifies how sensitive a likelihood function is to changes in its parameters. Given a parametric distribution ",i.createElement(s.A,{text:"\\(p(x|\\theta)\\)"})," with parameter ",i.createElement(s.A,{text:"\\(\\theta\\)"}),":"),"\n",i.createElement(s.A,{text:"\\[\nF(\\theta) = \\mathbb{E}_{x \\sim p(x|\\theta)}\\left[\\nabla_\\theta \\log p(x|\\theta)\\,\\nabla_\\theta \\log p(x|\\theta)^T\\right].\n\\]"}),"\n",i.createElement(t.ul,null,"\n",i.createElement(t.li,null,"Fisher information is a matrix that describes how much information a single observation provides about the parameters."),"\n",i.createElement(t.li,null,"In ",i.createElement(l.A,null,"second-order optimization")," techniques (e.g., Newton's method), the Hessian can be linked to the Fisher information matrix. Natural gradient methods specifically exploit the Fisher geometry."),"\n"),"\n",i.createElement(t.p,null,"In Bayesian statistics, the Fisher information also relates to the curvature of the posterior. In large-scale neural networks, approximations of the Fisher information matrix are sometimes used to create more robust and informed gradient updates (e.g., the ",i.createElement(l.A,null,"Natural Gradient Descent")," approach by Amari)."),"\n",i.createElement(t.hr),"\n",i.createElement(t.h2,{id:"entropy-uncertainty-and-decision-making",style:{position:"relative"}},i.createElement(t.a,{href:"#entropy-uncertainty-and-decision-making","aria-label":"entropy uncertainty and decision making permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Entropy, uncertainty, and decision-making"),"\n",i.createElement(t.p,null,"Information theory provides an attractive way to reason about decisions under uncertainty, which is the lifeblood of many machine learning applications. Whether it's a reinforcement learning agent exploring a vast environment or a classification model dealing with uncertain labels, entropy-based measures can guide the learning process."),"\n",i.createElement(t.h3,{id:"entropy-in-reinforcement-learning",style:{position:"relative"}},i.createElement(t.a,{href:"#entropy-in-reinforcement-learning","aria-label":"entropy in reinforcement learning permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Entropy in reinforcement learning"),"\n",i.createElement(t.p,null,"In ",i.createElement(l.A,null,"reinforcement learning")," (RL), an agent must balance exploring unknown actions with exploiting actions that have yielded high reward in the past. One popular technique to encourage exploration is ",i.createElement(l.A,null,"entropy regularization"),". The idea is to add an entropy term to the objective function, such that the agent is rewarded for keeping its policy ",i.createElement(s.A,{text:"\\(\\pi(a|s)\\)"})," more stochastic. A typical objective might look like:"),"\n",i.createElement(s.A,{text:"\\[\nJ(\\theta) = \\mathbb{E}_{s \\sim d^\\pi, a \\sim \\pi_\\theta} [r(s,a)] + \\beta \\, H(\\pi_\\theta),\n\\]"}),"\n",i.createElement(t.p,null,"where:"),"\n",i.createElement(t.ul,null,"\n",i.createElement(t.li,null,i.createElement(s.A,{text:"\\(d^\\pi\\)"})," is the state distribution under the policy ",i.createElement(s.A,{text:"\\(\\pi\\)"}),"."),"\n",i.createElement(t.li,null,i.createElement(s.A,{text:"\\(r(s,a)\\)"})," is the reward."),"\n",i.createElement(t.li,null,i.createElement(s.A,{text:"\\(H(\\pi_\\theta)\\)"})," is the (Shannon) entropy of the policy distribution over actions."),"\n",i.createElement(t.li,null,i.createElement(s.A,{text:"\\(\\beta\\)"})," is a hyperparameter controlling the strength of entropy regularization."),"\n"),"\n",i.createElement(t.p,null,'This method ensures that if the agent becomes overconfident about its "best" action, it pays a penalty in terms of reduced entropy. Hence, it keeps searching for alternative actions that might yield higher long-term returns. Methods like A3C (Asynchronous Advantage Actor-Critic) and PPO frequently rely on an entropy bonus to keep the policy sufficiently exploratory in the early stages.'),"\n",i.createElement(t.h3,{id:"uncertainty-quantification",style:{position:"relative"}},i.createElement(t.a,{href:"#uncertainty-quantification","aria-label":"uncertainty quantification permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Uncertainty quantification"),"\n",i.createElement(t.p,null,"In real-world ML systems, especially in safety-critical domains like autonomous driving or healthcare, it is essential to measure the uncertainty of predictions. High entropy in a model's output distribution can indicate that the model is unsure, perhaps due to insufficient data or an out-of-distribution input."),"\n",i.createElement(t.p,null,i.createElement(t.strong,null,"Bayesian neural networks")," approximate posterior distributions of weights, allowing them to produce predictive distributions that reflect their confidence. The predictive entropy ",i.createElement(s.A,{text:"\\(H(Y|X)\\)"})," can be used to decide whether the model's predictions are reliable. If the entropy is too high, the system can trigger a fallback plan, request more data, or ask a human for assistance."),"\n",i.createElement(t.h3,{id:"cross-entropy-loss",style:{position:"relative"}},i.createElement(t.a,{href:"#cross-entropy-loss","aria-label":"cross entropy loss permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Cross-entropy loss"),"\n",i.createElement(t.p,null,i.createElement(l.A,null,"Cross-entropy")," is ubiquitous in classification tasks. Given a ground truth distribution ",i.createElement(s.A,{text:"\\(p\\)"})," (often a one-hot vector in classification) and a predicted distribution ",i.createElement(s.A,{text:"\\(q\\)"}),", the cross-entropy is:"),"\n",i.createElement(s.A,{text:"\\[\nH(p, q) = - \\sum_{x} p(x) \\log_2 q(x).\n\\]"}),"\n",i.createElement(t.p,null,"In practice, we typically drop the ",i.createElement(s.A,{text:"\\(\\log_2\\)"})," in favor of the natural logarithm, but the interpretation is the same. The difference between cross-entropy and the entropy ",i.createElement(s.A,{text:"\\(H(p)\\)"})," is precisely the KL divergence ",i.createElement(s.A,{text:"\\(D_{KL}(p \\parallel q)\\)"}),":"),"\n",i.createElement(s.A,{text:"\\[\nH(p, q) = H(p) + D_{KL}(p \\parallel q).\n\\]"}),"\n",i.createElement(t.p,null,i.createElement(t.strong,null,"Implication"),": Minimizing cross-entropy is equivalent to minimizing KL divergence between the true labels and the model's predicted distribution. Cross-entropy can often lead to overconfident predictions, especially when used with powerful models. This phenomenon has spurred research into alternative losses (e.g., focal loss or label smoothing) to calibrate predictions."),"\n",i.createElement(t.h3,{id:"tsallis-entropy",style:{position:"relative"}},i.createElement(t.a,{href:"#tsallis-entropy","aria-label":"tsallis entropy permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Tsallis entropy"),"\n",i.createElement(t.p,null,i.createElement(l.A,null,"Tsallis entropy")," is a generalization of Shannon entropy that introduces a parameter ",i.createElement(s.A,{text:"\\(q\\)"})," controlling the degree of non-extensivity:"),"\n",i.createElement(s.A,{text:"\\[\nH_q(X) = \\frac{1}{q-1} \\left(1 - \\sum_x p(x)^q \\right).\n\\]"}),"\n",i.createElement(t.p,null,"For ",i.createElement(s.A,{text:"\\(q=1\\)"}),", Tsallis entropy reduces to Shannon entropy. In ",i.createElement(l.A,null,"reinforcement learning"),", Tsallis entropy (or related generalized entropies) has been used to control how strongly exploration is encouraged. By tuning ",i.createElement(s.A,{text:"\\(q\\)"}),", one can shift the policy's tendency toward deterministic or more stochastic behavior in a more flexible manner than standard Shannon entropy allows."),"\n",i.createElement(t.hr),"\n",i.createElement(t.h2,{id:"mutual-information-for-feature-selection-and-representation",style:{position:"relative"}},i.createElement(t.a,{href:"#mutual-information-for-feature-selection-and-representation","aria-label":"mutual information for feature selection and representation permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Mutual information for feature selection and representation"),"\n",i.createElement(t.p,null,"Among the numerous metrics introduced by information theory, ",i.createElement(l.A,null,"mutual information")," is particularly critical for ML tasks like feature selection, representation learning, clustering, and multi-agent cooperation."),"\n",i.createElement(t.h3,{id:"feature-relevance-analysis",style:{position:"relative"}},i.createElement(t.a,{href:"#feature-relevance-analysis","aria-label":"feature relevance analysis permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Feature relevance analysis"),"\n",i.createElement(t.p,null,"One of the oldest uses of ",i.createElement(s.A,{text:"\\(I(X; Y)\\)"})," in ML is to assess how well a feature ",i.createElement(s.A,{text:"\\(X\\)"})," (or set of features) explains a target variable ",i.createElement(s.A,{text:"\\(Y\\)"}),". The higher the mutual information, the more effectively ",i.createElement(s.A,{text:"\\(X\\)"})," can reduce uncertainty about ",i.createElement(s.A,{text:"\\(Y\\)"}),". For instance:"),"\n",i.createElement(t.ul,null,"\n",i.createElement(t.li,null,i.createElement(l.A,null,"Feature selection"),": We might pick a subset of features ",i.createElement(s.A,{text:"\\(X_1, X_2, \\dots\\)"})," such that they collectively maximize ",i.createElement(s.A,{text:"\\(I(X_1, X_2, \\ldots; Y)\\)"})," subject to constraints like cardinality or cost."),"\n",i.createElement(t.li,null,i.createElement(l.A,null,"Redundancy minimization"),": If two features are highly correlated, their individual mutual information with ",i.createElement(s.A,{text:"\\(Y\\)"})," might be large but they do not jointly add as much incremental predictive value. This leads to advanced feature selection heuristics that balance relevance and redundancy."),"\n"),"\n",i.createElement(o.A,{text:"\nimport numpy as np\nfrom sklearn.feature_selection import mutual_info_classif\n\n# Suppose X is your feature matrix, y are the labels\nmi_scores = mutual_info_classif(X, y, discrete_features='auto')\nprint(\"Estimated mutual information scores per feature:\", mi_scores)\n"}),"\n",i.createElement(t.p,null,"The snippet above shows how one might compute approximate mutual information between features and a target using scikit-learn's ",i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">mutual_info_classif</code>'}}),". Behind the scenes, this uses a nearest-neighbor or kernel density approach to estimate the distributions needed."),"\n",i.createElement(t.h3,{id:"information-maximization-in-clustering",style:{position:"relative"}},i.createElement(t.a,{href:"#information-maximization-in-clustering","aria-label":"information maximization in clustering permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Information maximization in clustering"),"\n",i.createElement(t.p,null,i.createElement(l.A,null,"Information maximization")," often arises in unsupervised contexts. For example, in ",i.createElement(l.A,null,"InfoGAN")," (Chen and gang, 2016, NeurIPS), the idea is to maximize the mutual information between latent variables and generated samples, encouraging the latent space to learn interpretable features. In clustering, if we treat cluster assignments as ",i.createElement(s.A,{text:"\\(C\\)"})," and data as ",i.createElement(s.A,{text:"\\(X\\)"}),", we can design algorithms to maximize ",i.createElement(s.A,{text:"\\(I(C; X)\\)"})," so that the cluster labels are highly informative of the data distribution."),"\n",i.createElement(t.h3,{id:"multi-agent-information-sharing",style:{position:"relative"}},i.createElement(t.a,{href:"#multi-agent-information-sharing","aria-label":"multi agent information sharing permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Multi-agent information sharing"),"\n",i.createElement(t.p,null,"In distributed or multi-agent systems, ",i.createElement(l.A,null,"communication bandwidth")," and ",i.createElement(l.A,null,"energy constraints")," can be strict. Agents only want to transmit signals that reduce uncertainty in the receiver. ",i.createElement(s.A,{text:"\\(I(A; B)\\)"})," can measure how much the message from agent A reduces the uncertainty of agent B regarding its environment or internal state."),"\n",i.createElement(t.p,null,"In cooperative tasks, designing communication protocols often involves maximizing mutual information subject to channel capacity constraints. The synergy between information theory and multi-agent RL is a rapidly evolving research frontier, with applications to decentralized robotics (where agents need to coordinate in real time) and sensor networks (where only partial local observations are available)."),"\n",i.createElement(t.hr),"\n",i.createElement(t.h2,{id:"the-information-bottleneck-principle",style:{position:"relative"}},i.createElement(t.a,{href:"#the-information-bottleneck-principle","aria-label":"the information bottleneck principle permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"The information bottleneck principle"),"\n",i.createElement(t.p,null,"The ",i.createElement(l.A,null,"information bottleneck principle")," (Tishby, Pereira, and Bialek, 2000) proposes a trade-off between making a representation that is minimal yet maximally relevant. The classical formulation is:"),"\n",i.createElement(t.ul,null,"\n",i.createElement(t.li,null,"We have an input variable ",i.createElement(s.A,{text:"\\(X\\)"})," and a target variable ",i.createElement(s.A,{text:"\\(Y\\)"}),"."),"\n",i.createElement(t.li,null,"We want to create an intermediate representation ",i.createElement(s.A,{text:"\\(T\\)"})," that captures all the necessary information in ",i.createElement(s.A,{text:"\\(X\\)"})," to predict ",i.createElement(s.A,{text:"\\(Y\\)"}),", but discards everything else."),"\n"),"\n",i.createElement(t.p,null,"We formalize this by minimizing:"),"\n",i.createElement(s.A,{text:"\\[\n\\mathcal{L}_{IB} = I(X; T) - \\beta \\, I(T; Y),\n\\]"}),"\n",i.createElement(t.p,null,"where:"),"\n",i.createElement(t.ul,null,"\n",i.createElement(t.li,null,i.createElement(s.A,{text:"\\(I(X; T)\\)"})," is the mutual information between input and representation, which we want to keep small (to compress unnecessary bits)."),"\n",i.createElement(t.li,null,i.createElement(s.A,{text:"\\(I(T; Y)\\)"})," is the mutual information between representation and target, which we want to keep large (to preserve predictive power)."),"\n",i.createElement(t.li,null,i.createElement(s.A,{text:"\\(\\beta\\)"})," trades off compression and prediction quality."),"\n"),"\n",i.createElement(t.h3,{id:"theory-of-optimal-representation",style:{position:"relative"}},i.createElement(t.a,{href:"#theory-of-optimal-representation","aria-label":"theory of optimal representation permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Theory of optimal representation"),"\n",i.createElement(t.p,null,"In deep learning, one can interpret each layer of a neural network as progressively refining the representation, discarding extraneous information about ",i.createElement(s.A,{text:"\\(X\\)"})," while retaining or amplifying the parts that help predict ",i.createElement(s.A,{text:"\\(Y\\)"}),". Some results suggest that as neural networks train, they go through a ",i.createElement(l.A,null,'"drift and diffusion"')," phase in which the hidden layers become more disentangled from the input (Shwartz-Ziv and Tishby, 2017)."),"\n",i.createElement(t.h3,{id:"applications-in-explainability",style:{position:"relative"}},i.createElement(t.a,{href:"#applications-in-explainability","aria-label":"applications in explainability permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Applications in explainability"),"\n",i.createElement(t.p,null,i.createElement(l.A,null,"Information bottlenecks")," can provide insights into ",i.createElement(l.A,null,"explainable AI")," by revealing how much information about input features is retained at each hidden representation. If a hidden layer is extremely compressed, we can hypothesize that the network is ignoring large swaths of input data that it deems irrelevant for classification. This can be used to gauge how a neural network might generalize or fail on out-of-distribution data."),"\n",i.createElement(t.h3,{id:"dynamic-bottlenecks-in-reinforcement-learning",style:{position:"relative"}},i.createElement(t.a,{href:"#dynamic-bottlenecks-in-reinforcement-learning","aria-label":"dynamic bottlenecks in reinforcement learning permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Dynamic bottlenecks in reinforcement learning"),"\n",i.createElement(t.p,null,"RL problems can also incorporate the information bottleneck principle to compress the state into a minimal representation. This helps the agent focus on aspects of the environment that directly affect rewards while ignoring distractors. Some advanced RL algorithms incorporate a learnable bottleneck to adapt the state representation, improving performance in partially observable or noisy tasks."),"\n",i.createElement(t.hr),"\n",i.createElement(t.h2,{id:"kl-divergence-and-model-adaptation",style:{position:"relative"}},i.createElement(t.a,{href:"#kl-divergence-and-model-adaptation","aria-label":"kl divergence and model adaptation permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"KL divergence and model adaptation"),"\n",i.createElement(t.p,null,"While mutual information quantifies how two distributions or variables relate to each other, ",i.createElement(l.A,null,"Kullback-Leibler divergence")," quantifies how one distribution diverges from another. This is at the heart of many model adaptation techniques in machine learning."),"\n",i.createElement(t.h3,{id:"variational-inference",style:{position:"relative"}},i.createElement(t.a,{href:"#variational-inference","aria-label":"variational inference permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Variational inference"),"\n",i.createElement(t.p,null,"In Bayesian machine learning, we often want to compute ",i.createElement(s.A,{text:"\\(p(\\theta | D)\\)"})," (the posterior over parameters ",i.createElement(s.A,{text:"\\(\\theta\\)"})," given data ",i.createElement(s.A,{text:"\\(D\\)"}),"), but direct computation can be intractable. ",i.createElement(l.A,null,"Variational inference")," replaces the true posterior with a simpler distribution ",i.createElement(s.A,{text:"\\(q(\\theta)\\)"})," by minimizing"),"\n",i.createElement(s.A,{text:"\\[\nD_{KL}\\bigl(q(\\theta)\\;\\|\\; p(\\theta|D)\\bigr).\n\\]"}),"\n",i.createElement(t.p,null,"This approach, widely used in ",i.createElement(l.A,null,"variational autoencoders (VAEs)"),", yields approximate posteriors that can be optimized with gradient methods, enabling large-scale Bayesian neural networks."),"\n",i.createElement(t.h3,{id:"domain-adaptation",style:{position:"relative"}},i.createElement(t.a,{href:"#domain-adaptation","aria-label":"domain adaptation permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Domain adaptation"),"\n",i.createElement(t.p,null,"In ",i.createElement(l.A,null,"domain adaptation"),", we have a source domain ",i.createElement(s.A,{text:"\\(p_s(x)\\)"})," and a target domain ",i.createElement(s.A,{text:"\\(p_t(x)\\)"}),". The goal is to learn models robust to distribution shifts. Minimizing divergences like ",i.createElement(s.A,{text:"\\(D_{KL}(p_s \\parallel p_t)\\)"})," or ",i.createElement(s.A,{text:"\\(D_{KL}(p_t \\parallel p_s)\\)"})," can align the feature distributions. Alternative divergences, like ",i.createElement(s.A,{text:"\\(D_{\\mathrm{JS}}\\)"})," (Jensen-Shannon divergence), can also be used when the direct distributions are unknown or partially estimated."),"\n",i.createElement(t.h3,{id:"policy-alignment-in-multi-agent-systems",style:{position:"relative"}},i.createElement(t.a,{href:"#policy-alignment-in-multi-agent-systems","aria-label":"policy alignment in multi agent systems permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Policy alignment in multi-agent systems"),"\n",i.createElement(t.p,null,"In multi-agent settings, we may want multiple agents to converge to similar policies or to share a common policy, especially if they are cooperating. A straightforward approach is to penalize the difference between their policy distributions using a KL term:"),"\n",i.createElement(s.A,{text:"\\[\n\\sum_{i, j} D_{KL}\\bigl(\\pi_i(\\cdot | s)\\;\\|\\;\\pi_j(\\cdot | s)\\bigr).\n\\]"}),"\n",i.createElement(t.p,null,"Such a penalty encourages the agents to remain close in policy space, facilitating coordinated behaviors, while still allowing for some variation."),"\n",i.createElement(t.hr),"\n",i.createElement(t.h2,{id:"rate-distortion-theory-and-efficient-learning",style:{position:"relative"}},i.createElement(t.a,{href:"#rate-distortion-theory-and-efficient-learning","aria-label":"rate distortion theory and efficient learning permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Rate-distortion theory and efficient learning"),"\n",i.createElement(t.p,null,i.createElement(l.A,null,"Rate-distortion theory")," is a branch of information theory that studies the trade-off between the compression rate of a source and the distortion incurred by approximating that source. In machine learning, this is deeply connected to model compression, resource allocation, and trade-offs between fidelity to the original data and the capacity of the model."),"\n",i.createElement(t.h3,{id:"trade-offs-in-lossy-compression",style:{position:"relative"}},i.createElement(t.a,{href:"#trade-offs-in-lossy-compression","aria-label":"trade offs in lossy compression permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Trade-offs in lossy compression"),"\n",i.createElement(t.p,null,"A typical rate-distortion objective is:"),"\n",i.createElement(s.A,{text:"\\[\n\\min_{p(\\hat{x}|x)} \\quad I(X; \\hat{X})\n\\quad\n\\text{subject to}\n\\quad\n\\mathbb{E}[d(X,\\hat{X})] \\leq D,\n\\]"}),"\n",i.createElement(t.p,null,"where:"),"\n",i.createElement(t.ul,null,"\n",i.createElement(t.li,null,i.createElement(s.A,{text:"\\(X\\)"})," is the original source."),"\n",i.createElement(t.li,null,i.createElement(s.A,{text:"\\(\\hat{X}\\)"})," is the compressed representation."),"\n",i.createElement(t.li,null,i.createElement(s.A,{text:"\\(d(\\cdot, \\cdot)\\)"})," is a distortion measure (e.g., mean squared error)."),"\n",i.createElement(t.li,null,i.createElement(s.A,{text:"\\(D\\)"})," is a distortion budget."),"\n"),"\n",i.createElement(t.p,null,"This parallels the process of ",i.createElement(l.A,null,"model pruning")," and ",i.createElement(l.A,null,"quantization"),", where we sacrifice some performance in exchange for smaller model footprints or faster inference."),"\n",i.createElement(t.h3,{id:"resource-constrained-agents",style:{position:"relative"}},i.createElement(t.a,{href:"#resource-constrained-agents","aria-label":"resource constrained agents permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Resource-constrained agents"),"\n",i.createElement(t.p,null,"On the edge or in IoT devices, ",i.createElement(l.A,null,"resource constraints")," (like memory, power, or bandwidth) are real. Rate-distortion concepts guide how to represent data with minimal bits while retaining essential information for decision-making. For instance, an embedded sensor might compress images before sending them to the cloud for classification, balancing bandwidth usage and classification accuracy."),"\n",i.createElement(t.h3,{id:"perceptual-distortion-metrics",style:{position:"relative"}},i.createElement(t.a,{href:"#perceptual-distortion-metrics","aria-label":"perceptual distortion metrics permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Perceptual distortion metrics"),"\n",i.createElement(t.p,null,"In certain tasks like image compression, ",i.createElement(l.A,null,"perceptual quality")," matters more than mean squared error. This has led to advanced ",i.createElement(l.A,null,"distortion metrics")," that incorporate human visual system (HVS) models. Aligning these perceptual metrics with rate-distortion optimization can produce significantly better visual results, relevant in generative modeling or in tasks like super-resolution."),"\n",i.createElement(t.h3,{id:"bits-back-coding",style:{position:"relative"}},i.createElement(t.a,{href:"#bits-back-coding","aria-label":"bits back coding permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Bits-back coding"),"\n",i.createElement(t.p,null,i.createElement(l.A,null,"Bits-back coding"),", used in some VAE-based compression schemes (Townsend and gang, 2019), allows near-lossless compression by leveraging the learned latent distribution. The scheme can effectively reduce the overhead cost of transmitting latent codes by recouping bits from the prior, linking deep generative modeling to practical compression architectures."),"\n",i.createElement(t.hr),"\n",i.createElement(t.h2,{id:"information-theoretic-reinforcement-learning",style:{position:"relative"}},i.createElement(t.a,{href:"#information-theoretic-reinforcement-learning","aria-label":"information theoretic reinforcement learning permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Information-theoretic reinforcement learning"),"\n",i.createElement(t.p,null,"Reinforcement learning tasks often revolve around how an agent acquires information about its environment and how it uses that information to act optimally. Below are some advanced topics that combine RL and information theory."),"\n",i.createElement(t.h3,{id:"empowerment-and-intrinsic-motivation",style:{position:"relative"}},i.createElement(t.a,{href:"#empowerment-and-intrinsic-motivation","aria-label":"empowerment and intrinsic motivation permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Empowerment and intrinsic motivation"),"\n",i.createElement(t.p,null,'In some RL formulations, an agent is "intrinsically motivated" to maximize its ability to affect the environment. ',i.createElement(l.A,null,"Empowerment")," is defined as the maximum mutual information between an agent's actions and its future states:"),"\n",i.createElement(s.A,{text:"\\[\n\\mathrm{Empowerment}(s) = \\max_{p(a_{1:k})} I(A_{1:k}; S_{t+\\Delta} | S_t = s).\n\\]"}),"\n",i.createElement(t.p,null,"This encourages the agent to move to states where it has more potential influence on the environment, often leading to more robust exploration in complex or sparse-reward settings."),"\n",i.createElement(t.h3,{id:"curiosity-driven-exploration",style:{position:"relative"}},i.createElement(t.a,{href:"#curiosity-driven-exploration","aria-label":"curiosity driven exploration permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Curiosity-driven exploration"),"\n",i.createElement(t.p,null,i.createElement(l.A,null,"Curiosity-based methods")," reward an agent when its predictions about the next state (or observations) are incorrect (or high in ",i.createElement(l.A,null,"prediction error"),"), effectively encouraging it to seek out novel states that maximize information gain. This can be interpreted as maximizing ",i.createElement(s.A,{text:"\\(I(\\text{agent's model}; \\text{environment states})\\)"}),". By exploring states that yield the largest model update or biggest reduction in uncertainty, the agent systematically uncovers new parts of the environment."),"\n",i.createElement(t.h3,{id:"information-directed-sampling",style:{position:"relative"}},i.createElement(t.a,{href:"#information-directed-sampling","aria-label":"information directed sampling permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Information-directed sampling"),"\n",i.createElement(t.p,null,i.createElement(l.A,null,"Information-directed sampling")," focuses on action selection by balancing the immediate reward of an action with its potential to reduce uncertainty about the environment model. This approach tries to unify exploration and exploitation by looking at the ratio of expected squared regret to information gain about the optimal action, sometimes leading to more sample-efficient RL than standard heuristics."),"\n",i.createElement(t.hr),"\n",i.createElement(t.h2,{id:"multi-agent-systems-and-distributed-information",style:{position:"relative"}},i.createElement(t.a,{href:"#multi-agent-systems-and-distributed-information","aria-label":"multi agent systems and distributed information permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Multi-agent systems and distributed information"),"\n",i.createElement(t.p,null,"When multiple learning agents operate in the same environment, either competitively or cooperatively, the flow of information is more complex. Information theory can help quantify how agents communicate and how they converge on shared goals or strategies."),"\n",i.createElement(t.h3,{id:"emergent-communication-protocols",style:{position:"relative"}},i.createElement(t.a,{href:"#emergent-communication-protocols","aria-label":"emergent communication protocols permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Emergent communication protocols"),"\n",i.createElement(t.p,null,"In ",i.createElement(l.A,null,"emergent communication"),", multi-agent systems are trained to develop a communication channel from scratch. Agents might exchange messages that are discrete symbols, and the objective is often to maximize the team reward. Over time, the messages can become a discrete language. By analyzing ",i.createElement(s.A,{text:"\\(I(\\text{message}; \\text{environment state})\\)"})," or ",i.createElement(s.A,{text:"\\(I(\\text{message}; \\text{agent actions})\\)"}),", researchers investigate whether the language is efficient, compositional, or correlated with specific task-relevant features."),"\n",i.createElement(t.h3,{id:"consensus-algorithms",style:{position:"relative"}},i.createElement(t.a,{href:"#consensus-algorithms","aria-label":"consensus algorithms permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Consensus algorithms"),"\n",i.createElement(t.p,null,i.createElement(l.A,null,"Consensus")," is a classic problem in distributed computing and robotics: multiple agents or nodes must agree on a certain value or state. From an information-theoretic perspective, consensus can be framed as minimizing the distributed KL divergence across the network. Communication overhead is minimized if the final, agreed-upon state is reached with minimal bits of information exchanged among the agents."),"\n",i.createElement(t.h3,{id:"information-asymmetry-in-game-theory",style:{position:"relative"}},i.createElement(t.a,{href:"#information-asymmetry-in-game-theory","aria-label":"information asymmetry in game theory permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Information asymmetry in game theory"),"\n",i.createElement(t.p,null,"In ",i.createElement(l.A,null,"game-theoretic")," problems, players might not have the same information about the state of the world, leading to incomplete-information games. Real-world examples include negotiations, auctions, or complex multi-agent environments in robotics. The effect of ",i.createElement(l.A,null,"information asymmetry"),' can be studied through the lens of how some players hold "private signals" that others do not, and how rational strategies must account for that. This can lead to phenomena such as ',i.createElement(l.A,null,"information cascades")," or ",i.createElement(l.A,null,"herding"),", where agents ignore their own signals and instead follow the majority, leading to suboptimal outcomes."),"\n",i.createElement(t.hr),"\n",i.createElement(t.h2,{id:"advanced-topics",style:{position:"relative"}},i.createElement(t.a,{href:"#advanced-topics","aria-label":"advanced topics permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Advanced topics"),"\n",i.createElement(t.p,null,"Beyond the core building blocks of information theory, there are several advanced areas that shed more light on how these principles integrate with deep learning and AI research."),"\n",i.createElement(t.h3,{id:"information-bottleneck-in-deep-learning-recent-research",style:{position:"relative"}},i.createElement(t.a,{href:"#information-bottleneck-in-deep-learning-recent-research","aria-label":"information bottleneck in deep learning recent research permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Information bottleneck in deep learning: recent research"),"\n",i.createElement(t.p,null,"While the original ",i.createElement(l.A,null,"information bottleneck")," paper dates back to 2000, recent investigations in deep learning have revived interest in how neural networks implicitly optimize compression of input data. Some researchers hypothesize that in the later stages of training, stochastic gradient descent drives hidden representations to discard high-frequency or irrelevant details, effectively implementing a form of the information bottleneck. This has been used to explain generalization phenomena in large-scale deep networks."),"\n",i.createElement(t.h3,{id:"neural-estimation-of-information-measures",style:{position:"relative"}},i.createElement(t.a,{href:"#neural-estimation-of-information-measures","aria-label":"neural estimation of information measures permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Neural estimation of information measures"),"\n",i.createElement(t.p,null,"In high-dimensional data, classical ways of estimating ",i.createElement(s.A,{text:"\\(H(X)\\)"}),", ",i.createElement(s.A,{text:"\\(I(X;Y)\\)"}),", or ",i.createElement(s.A,{text:"\\(D_{KL}(p \\parallel q)\\)"})," can be unreliable or computationally intractable. ",i.createElement(l.A,null,"Neural estimation")," techniques, such as ",i.createElement(l.A,null,"Mutual Information Neural Estimation (MINE)")," (Belghazi and gang, ICML 2018), use a trainable network to approximate these quantities. By framing mutual information estimation as a ",i.createElement(s.A,{text:"\\(f\\)"}),"-divergence problem, one can learn a parameterized function that provides an unbiased or low-bias estimator for ",i.createElement(s.A,{text:"\\(I(X;Y)\\)"}),"."),"\n",i.createElement(t.h3,{id:"integrated-information-theory-iit",style:{position:"relative"}},i.createElement(t.a,{href:"#integrated-information-theory-iit","aria-label":"integrated information theory iit permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Integrated information theory (IIT)"),"\n",i.createElement(t.p,null,i.createElement(l.A,null,"Integrated information theory (IIT)")," originated from consciousness studies, aiming to measure how integrated and differentiated the information is within a system. While controversial in its direct application to AI, there are ongoing discussions about whether certain complex neural architectures might exhibit forms of integrated information. Proposals exist for bridging concepts from IIT with emergent multi-agent coordination or advanced recurrent networks, but as of now, it remains a niche research domain."),"\n",i.createElement(t.hr),"\n",i.createElement(t.h2,{id:"tools",style:{position:"relative"}},i.createElement(t.a,{href:"#tools","aria-label":"tools permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Tools"),"\n",i.createElement(t.p,null,"Given the variety of ways information-theoretic principles can be applied in machine learning, it is helpful to know the software tools and libraries that can facilitate computations."),"\n",i.createElement(t.h3,{id:"software-for-information-theoretic-ml",style:{position:"relative"}},i.createElement(t.a,{href:"#software-for-information-theoretic-ml","aria-label":"software for information theoretic ml permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Software for information-theoretic ML"),"\n",i.createElement(t.ul,null,"\n",i.createElement(t.li,null,i.createElement(l.A,null,"ITE toolbox")," (Informational Toolkit) is a MATLAB/Python library providing a suite of estimators for Shannon entropy, Rényi entropy, mutual information, and other divergences."),"\n",i.createElement(t.li,null,i.createElement(l.A,null,"PyITLib")," is a Python library offering a variety of ",i.createElement(r.A,{text:"Information Theoretic measures such as Shannon, Rényi entropies, mutual information, partial information decomposition, etc."}),"."),"\n",i.createElement(t.li,null,i.createElement(l.A,null,"scikit-learn")," includes functions like ",i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">mutual_info_score</code>'}})," and ",i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">mutual_info_classif</code>'}})," for discrete variable mutual information estimation."),"\n"),"\n",i.createElement(t.h3,{id:"estimating-entropy-and-mi",style:{position:"relative"}},i.createElement(t.a,{href:"#estimating-entropy-and-mi","aria-label":"estimating entropy and mi permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Estimating entropy and MI"),"\n",i.createElement(t.p,null,"In high-dimensional spaces, direct methods (like naive binning) become infeasible. More advanced approaches include:"),"\n",i.createElement(t.ul,null,"\n",i.createElement(t.li,null,i.createElement(l.A,null,"K-nearest neighbor (KNN)")," estimators (e.g., Kraskov and gang, 2004) that exploit local density estimates."),"\n",i.createElement(t.li,null,i.createElement(l.A,null,"Kernel density")," estimators that approximate the underlying density function."),"\n",i.createElement(t.li,null,i.createElement(l.A,null,"Variational / neural approaches")," (e.g., MINE) that learn function approximators to derive tight lower bounds on ",i.createElement(s.A,{text:"\\(I(X; Y)\\)"}),"."),"\n"),"\n",i.createElement(o.A,{text:'\nimport numpy as np\nfrom pyitlib import discrete_random_variable as drv\n\n# Example: Estimating the mutual information between two discrete arrays\nX = np.random.randint(0, 10, 1000)\nY = X + np.random.randint(0, 2, 1000)  # Y is correlated with X\nmi_est = drv.information_mutual(X, Y)\nprint("Estimated mutual information:", mi_est)\n'}),"\n",i.createElement(t.h3,{id:"case-study-mutual-information-for-feature-selection-in-healthcare",style:{position:"relative"}},i.createElement(t.a,{href:"#case-study-mutual-information-for-feature-selection-in-healthcare","aria-label":"case study mutual information for feature selection in healthcare permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Case study: mutual information for feature selection in healthcare"),"\n",i.createElement(t.p,null,"Imagine you are working with a healthcare dataset, containing demographic information (age, gender), clinical lab results (blood pressure, cholesterol levels, etc.), and a binary label (presence/absence of a particular disease). A typical workflow for mutual-information-based feature selection is:"),"\n",i.createElement(t.ol,null,"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Data collection"),": Gather patient data with relevant attributes and disease labels."),"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Preprocessing"),": Convert categorical features to numeric form, handle missing values, and ensure data is in a workable shape."),"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"MI estimation"),": For each feature ",i.createElement(s.A,{text:"\\(X_i\\)"}),", estimate ",i.createElement(s.A,{text:"\\(I(X_i; Y)\\)"}),". Rank features by this mutual information score."),"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Redundancy analysis"),": Avoid picking multiple features that carry essentially the same information about ",i.createElement(s.A,{text:"\\(Y\\)"}),"."),"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Model building"),": Train classification models using the subset of high-MI features. Evaluate performance on validation sets."),"\n"),"\n",i.createElement(t.p,null,"By iteratively refining the feature set with an MI-based approach, you can isolate those patient attributes that truly matter for diagnosing the condition. This approach is robust even when the relationships are non-linear, a significant advantage over purely linear statistics (like correlation coefficients)."),"\n",i.createElement(t.hr),"\n",i.createElement(t.p,null,i.createElement(l.A,null,"Please note:")," Because this article seeks to provide a thorough, wide-reaching exploration, I will now present additional expansions and elaborations to ensure an even deeper and more holistic coverage of information theory's impact on machine learning. The following sections dive further into advanced nuances, bridging theoretical frameworks with state-of-the-art research insights from leading conferences and journals, and offering more coding examples to solidify practical understanding."),"\n",i.createElement(t.p,null,"This next section significantly extends the discussion, ensuring the article meets the depth and length necessary for advanced study."),"\n",i.createElement(t.hr),"\n",i.createElement(t.h2,{id:"extended-elaborations-and-deep-theoretical-insights",style:{position:"relative"}},i.createElement(t.a,{href:"#extended-elaborations-and-deep-theoretical-insights","aria-label":"extended elaborations and deep theoretical insights permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Extended elaborations and deep theoretical insights"),"\n",i.createElement(t.p,null,"In the preceding sections, I have outlined the major constructs of classical information theory — from Shannon's foundational ideas of entropy and channel capacity to modern applications in ML like the information bottleneck, variational inference, and advanced multi-agent communications. However, the interplay of these constructs with ever-growing deep neural networks, high-dimensional data, and complex multi-modal tasks reveals a wealth of further subtleties."),"\n",i.createElement(t.p,null,"Here, I expand on particular advanced themes, giving you an even deeper dive into contemporary research frontiers and theoretical refinements relevant to machine learning practitioners and researchers."),"\n",i.createElement(t.h3,{id:"1-alternative-divergences-and-f-divergences",style:{position:"relative"}},i.createElement(t.a,{href:"#1-alternative-divergences-and-f-divergences","aria-label":"1 alternative divergences and f divergences permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"1. Alternative divergences and f-divergences"),"\n",i.createElement(t.p,null,"While KL divergence ",i.createElement(s.A,{text:"\\(D_{KL}(p \\parallel q)\\)"})," is the classical measure of how one distribution ",i.createElement(s.A,{text:"\\(p\\)"})," differs from another ",i.createElement(s.A,{text:"\\(q\\)"}),", we also have a broader family of ",i.createElement(l.A,null,"f-divergences"),":"),"\n",i.createElement(s.A,{text:"\\[\nD_f(p \\parallel q) = \\sum_x q(x) f\\!\\Bigl(\\frac{p(x)}{q(x)}\\Bigr)\n\\]"}),"\n",i.createElement(t.p,null,"for some convex function ",i.createElement(s.A,{text:"\\(f\\)"}),". The KL divergence is just one instance (with ",i.createElement(s.A,{text:"\\(f(u) = u \\log u\\)"}),"). Others include ",i.createElement(l.A,null,"Jensen-Shannon")," divergence, ",i.createElement(l.A,null,"Rényi")," divergences, and ",i.createElement(l.A,null,"total variation distance"),". In machine learning, these alternative divergences sometimes have better stability or interpretability properties than KL."),"\n",i.createElement(t.p,null,i.createElement(t.strong,null,"Jensen-Shannon divergence"),", for instance, is symmetrical and always defined (even if ",i.createElement(s.A,{text:"\\(p(x) = 0\\)"})," for some ",i.createElement(s.A,{text:"\\(x\\)"}),"), making it popular for generative adversarial networks (GANs). Indeed, the original GAN used the JS divergence concept, though later it was recast in terms of a ",i.createElement(s.A,{text:"\\(\\log\\)"})," logistic loss interpretation."),"\n",i.createElement(t.h3,{id:"2-rényi-entropy-and-divergences",style:{position:"relative"}},i.createElement(t.a,{href:"#2-r%C3%A9nyi-entropy-and-divergences","aria-label":"2 rényi entropy and divergences permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"2. Rényi entropy and divergences"),"\n",i.createElement(t.p,null,i.createElement(l.A,null,"Rényi entropy"),", a generalization of Shannon entropy, is defined as:"),"\n",i.createElement(s.A,{text:"\\[\nH_\\alpha(X) = \\frac{1}{1-\\alpha} \\log \\sum_x p(x)^\\alpha,\n\\]"}),"\n",i.createElement(t.p,null,"where ",i.createElement(s.A,{text:"\\(\\alpha\\)"})," is a real parameter. When ",i.createElement(s.A,{text:"\\(\\alpha \\to 1\\)"}),", Rényi entropy converges to Shannon entropy. Rényi's generalization also leads to the ",i.createElement(l.A,null,"Rényi divergence")," (or Rényi's ",i.createElement(s.A,{text:"\\(D_\\alpha\\)"}),"), which has found applications in specific ML contexts, for example in controlling the degree of penalization for distribution mismatch or for exploring theoretical bounds in generalized Bayesian approaches."),"\n",i.createElement(t.h3,{id:"3-maximum-entropy-principle-in-ml",style:{position:"relative"}},i.createElement(t.a,{href:"#3-maximum-entropy-principle-in-ml","aria-label":"3 maximum entropy principle in ml permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"3. Maximum entropy principle in ML"),"\n",i.createElement(t.p,null,"The ",i.createElement(l.A,null,"maximum entropy (MaxEnt)")," principle states that subject to known constraints (e.g., expected values), the distribution that best represents our state of knowledge while assuming nothing unwarranted is the one with the greatest entropy. This principle underlies:"),"\n",i.createElement(t.ul,null,"\n",i.createElement(t.li,null,i.createElement(l.A,null,"Maximum entropy classifiers"),", which are logistic regression models generalized to multiclass scenarios."),"\n",i.createElement(t.li,null,i.createElement(l.A,null,"Boltzmann machines"),", where the distribution over states is derived via an energy function and a partition function, ensuring maximum entropy subject to constraints."),"\n"),"\n",i.createElement(t.p,null,"In RL, the MaxEnt principle extends beyond entropy regularization. It fosters approaches like ",i.createElement(l.A,null,"Soft Q-learning")," or ",i.createElement(l.A,null,"Soft Actor-Critic")," that assume the optimal policy is the one that best balances reward maximization with maximum entropy. This perspective can be especially beneficial in continuous control tasks, where the action space is large."),"\n",i.createElement(t.h3,{id:"4-connections-between-compression-and-generalization",style:{position:"relative"}},i.createElement(t.a,{href:"#4-connections-between-compression-and-generalization","aria-label":"4 connections between compression and generalization permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"4. Connections between compression and generalization"),"\n",i.createElement(t.p,null,"A critical question in deep learning is ",i.createElement(l.A,null,"why large networks generalize so well")," despite having more parameters than training examples. One explanation, grounded in information theory, posits that ",i.createElement(l.A,null,"compression")," in the hidden layers helps the model throw away spurious details, focusing on robust features relevant to the target. Some lines of research argue that the implicit regularization of gradient-based training leads the system to solutions that compress the input in ways correlated with better generalization."),"\n",i.createElement(t.p,null,i.createElement(t.strong,null,"Open debate"),": The exact mechanics of how the network compresses, and to what degree this compression is essential, remains a lively debate. Some empirical investigations challenge the idea that compression always occurs, while others refine the argument about which layers do or do not compress. Regardless, the notion of neural networks as lossy compressors of input data remains a powerful conceptual framework."),"\n",i.createElement(t.h3,{id:"5-information-plane-analysis",style:{position:"relative"}},i.createElement(t.a,{href:"#5-information-plane-analysis","aria-label":"5 information plane analysis permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"5. Information plane analysis"),"\n",i.createElement(t.p,null,i.createElement(l.A,null,"Information plane analysis")," visualizes ",i.createElement(s.A,{text:"\\(I(X; T)\\)"})," versus ",i.createElement(s.A,{text:"\\(I(T; Y)\\)"})," over the course of network training. Observing how the hidden layer ",i.createElement(s.A,{text:"\\(T\\)"})," transitions from a high ",i.createElement(s.A,{text:"\\(I(X; T)\\)"})," state to a lower one while increasing ",i.createElement(s.A,{text:"\\(I(T; Y)\\)"}),' can reveal how the model shapes representations. This approach has been used to study epochs of training in large-scale neural networks, linking network optimization to the notion of an "information bottleneck."'),"\n",i.createElement(t.h3,{id:"6-influence-functions-and-sensitivity",style:{position:"relative"}},i.createElement(t.a,{href:"#6-influence-functions-and-sensitivity","aria-label":"6 influence functions and sensitivity permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"6. Influence functions and sensitivity"),"\n",i.createElement(t.p,null,"We briefly touched on ",i.createElement(l.A,null,"Fisher information"),". In modern ML, ",i.createElement(l.A,null,"influence functions")," generalize the concept by measuring how changes in the training data affect the learned parameters and predictions. Influence functions approximate the effect of removing or modifying a single training example on the final model. This is related to the local geometry of the parameter space, often represented by the Hessian or an approximation to the Fisher information. For interpretability, these methods help debug or detect training outliers that disproportionately affect the model."),"\n",i.createElement(t.h3,{id:"7-differential-privacy-and-mutual-information",style:{position:"relative"}},i.createElement(t.a,{href:"#7-differential-privacy-and-mutual-information","aria-label":"7 differential privacy and mutual information permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"7. Differential privacy and mutual information"),"\n",i.createElement(t.p,null,"As data privacy regulations tighten, ",i.createElement(l.A,null,"differential privacy")," (DP) provides a formal guarantee of privacy in ML algorithms by limiting the sensitivity of model outputs to any individual data point. Interestingly, there is a deep tie between DP and information theory — specifically, bounding the ",i.createElement(s.A,{text:"\\(I(X; \\text{output})\\)"})," can help ensure that the model's output does not reveal too much about ",i.createElement(s.A,{text:"\\(X\\)"}),". Understanding this synergy is essential for building ML pipelines that respect user privacy while retaining valuable information for training."),"\n",i.createElement(t.h3,{id:"8-information-theoretic-bounds-on-generalization",style:{position:"relative"}},i.createElement(t.a,{href:"#8-information-theoretic-bounds-on-generalization","aria-label":"8 information theoretic bounds on generalization permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"8. Information-theoretic bounds on generalization"),"\n",i.createElement(t.p,null,"Techniques for bounding generalization error often rely on ",i.createElement(l.A,null,"VC dimension"),", ",i.createElement(l.A,null,"Rademacher complexity"),", or ",i.createElement(l.A,null,"uniform convergence")," arguments. An alternative approach uses ",i.createElement(l.A,null,"information-theoretic generalization bounds"),":"),"\n",i.createElement(s.A,{text:"\\[\n\\text{Generalization Error} \\leq \\sqrt{\\frac{I(\\theta; D)}{N}},\n\\]"}),"\n",i.createElement(t.p,null,"where ",i.createElement(s.A,{text:"\\(I(\\theta; D)\\)"})," is the mutual information between the model parameters and the training data, and ",i.createElement(s.A,{text:"\\(N\\)"})," is the sample size. This elegantly ties the notion of how many bits of information the model encodes about the specific training set to how well the model is expected to generalize. The smaller ",i.createElement(s.A,{text:"\\(I(\\theta; D)\\)"}),", the better the generalization (under certain assumptions)."),"\n",i.createElement(t.p,null,i.createElement(t.strong,null,"Practical insight"),": This aligns with the idea that if a model is too specialized to the training data (i.e., high ",i.createElement(s.A,{text:"\\(I(\\theta; D)\\)"}),"), it might overfit. Conversely, if it learns more general, compressed abstractions, the mutual information with the exact training set is lower, enabling better generalization on unseen data."),"\n",i.createElement(t.h3,{id:"9-relating-mdl-and-bayesian-inference",style:{position:"relative"}},i.createElement(t.a,{href:"#9-relating-mdl-and-bayesian-inference","aria-label":"9 relating mdl and bayesian inference permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"9. Relating MDL and Bayesian inference"),"\n",i.createElement(t.p,null,"The ",i.createElement(l.A,null,"Minimum Description Length (MDL)")," principle is closely related to Bayesian model selection. In essence, a model that can encode the data in fewer bits is preferable. Bayesian approaches implicitly do a similar trade-off through the posterior ",i.createElement(s.A,{text:"\\(p(\\theta|D)\\)"}),", balancing model complexity and data fit. Specifically, the negative log of the evidence ",i.createElement(s.A,{text:"\\(-\\log p(D)\\)"})," can be seen as the coding cost of the data under the model. The synergy of these information-theoretic and Bayesian viewpoints gives a deeper understanding of how to balance complexity and fit in ML."),"\n",i.createElement(t.hr),"\n",i.createElement(t.h2,{id:"additional-multi-agent-and-distributed-applications",style:{position:"relative"}},i.createElement(t.a,{href:"#additional-multi-agent-and-distributed-applications","aria-label":"additional multi agent and distributed applications permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Additional multi-agent and distributed applications"),"\n",i.createElement(t.p,null,"Because multi-agent and distributed learning are increasingly relevant in modern AI systems (e.g., robotics swarms, sensor networks, complex simulations), it is worthwhile to highlight advanced interplay with information theory."),"\n",i.createElement(t.h3,{id:"1-decentralized-partially-observable-mdps-dec-pomdps",style:{position:"relative"}},i.createElement(t.a,{href:"#1-decentralized-partially-observable-mdps-dec-pomdps","aria-label":"1 decentralized partially observable mdps dec pomdps permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"1. Decentralized partially observable MDPs (Dec-POMDPs)"),"\n",i.createElement(t.p,null,'When each agent observes only a part of the environment state, the question arises: "What information should each agent share with others, and when?" ',i.createElement(s.A,{text:"\\(I(A_i; A_j)\\)"})," quantifies how beneficial an agent's messages might be to the joint policy. Some algorithms explicitly optimize a communication policy by maximizing mutual information weighted by communication costs (e.g., if every message has a cost or a bandwidth limit)."),"\n",i.createElement(t.h3,{id:"2-graph-based-communication-topologies",style:{position:"relative"}},i.createElement(t.a,{href:"#2-graph-based-communication-topologies","aria-label":"2 graph based communication topologies permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"2. Graph-based communication topologies"),"\n",i.createElement(t.p,null,"Agents often reside in a network with edges representing communication links. Minimizing total KL divergence or maximizing mutual information subject to graph constraints leads to specialized ",i.createElement(l.A,null,"consensus")," or ",i.createElement(l.A,null,"agreement")," protocols. Tools from spectral graph theory can merge elegantly with information-theoretic frameworks, analyzing how quickly information spreads and consensus is reached given the structure of the graph."),"\n",i.createElement(t.h3,{id:"3-information-cascades",style:{position:"relative"}},i.createElement(t.a,{href:"#3-information-cascades","aria-label":"3 information cascades permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"3. Information cascades"),"\n",i.createElement(t.p,null,"In economics and social dynamics, ",i.createElement(l.A,null,"information cascades")," occur when agents rely heavily on the actions of previous agents, ignoring their own private observations. This can lead to suboptimal herding behavior. From an information-theoretic lens, the system's effective ",i.createElement(s.A,{text:"\\(I(\\text{individual signals}; \\text{actions})\\)"})," might degrade quickly if individuals discard or override personal signals. ML approaches that mitigate cascades often reintroduce or highlight private signals, ensuring each agent's contribution is not overshadowed by the crowd."),"\n",i.createElement(t.hr),"\n",i.createElement(t.h2,{id:"implementation-details-and-extended-code-samples",style:{position:"relative"}},i.createElement(t.a,{href:"#implementation-details-and-extended-code-samples","aria-label":"implementation details and extended code samples permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Implementation details and extended code samples"),"\n",i.createElement(t.p,null,"Below, I expand upon practical code examples illustrating how to compute or approximate key information-theoretic measures in typical ML workflows."),"\n",i.createElement(t.h3,{id:"estimating-shannon-entropy-in-python",style:{position:"relative"}},i.createElement(t.a,{href:"#estimating-shannon-entropy-in-python","aria-label":"estimating shannon entropy in python permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Estimating Shannon entropy in Python"),"\n",i.createElement(o.A,{text:'\nimport numpy as np\nfrom collections import Counter\nimport math\n\ndef shannon_entropy(data):\n    # data is a 1D list or NumPy array of discrete outcomes\n    counter = Counter(data)\n    total = len(data)\n    entropy = 0.0\n    for val, count in counter.items():\n        p = count / total\n        entropy -= p * math.log2(p)\n    return entropy\n\n# Example usage\nnp.random.seed(42)\ndata = np.random.randint(0, 5, 10000)  # 5 classes\nprint("Shannon Entropy:", shannon_entropy(data))\n'}),"\n",i.createElement(t.h3,{id:"approximate-mutual-information-for-continuous-variables-using-knn",style:{position:"relative"}},i.createElement(t.a,{href:"#approximate-mutual-information-for-continuous-variables-using-knn","aria-label":"approximate mutual information for continuous variables using knn permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Approximate mutual information for continuous variables using KNN"),"\n",i.createElement(o.A,{text:'\nimport numpy as np\nfrom sklearn.neighbors import NearestNeighbors\n\ndef knn_mi(x, y, k=5):\n    """\n    A naive KNN-based estimate of mutual information between x and y,\n    both assumed to be 2D arrays of shape (n_samples, dim).\n    """\n    x = np.asarray(x)\n    y = np.asarray(y)\n    \n    # Combined data\n    xy = np.hstack([x, y])\n    \n    n = x.shape[0]\n    \n    # Build KNN for combined space\n    nbrs_xy = NearestNeighbors(n_neighbors=k+1).fit(xy)\n    dist_xy, _ = nbrs_xy.kneighbors(xy)\n    # radius for each point is the distance to the k-th neighbor\n    radius = dist_xy[:, k]\n    \n    # Build KNN for x space\n    nbrs_x = NearestNeighbors(n_neighbors=k).fit(x)\n    count_x = []\n    for i in range(n):\n        # query the number of neighbors within \'radius[i]\' in x-space\n        # minus 1 to exclude the point itself\n        count = nbrs_x.radius_neighbors([x[i]], radius[i], return_distance=False)\n        count_x.append(len(count[0]) - 1)\n    \n    # Build KNN for y space\n    nbrs_y = NearestNeighbors(n_neighbors=k).fit(y)\n    count_y = []\n    for i in range(n):\n        count = nbrs_y.radius_neighbors([y[i]], radius[i], return_distance=False)\n        count_y.append(len(count[0]) - 1)\n    \n    # Summation\n    import math\n    psi = lambda val: math.log(val)  # for simplicity, ignoring digamma for now\n    mi_est = psi(n) + psi(k) - np.mean([psi(count_xi+1) + psi(count_yi+1)\n                                        for count_xi, count_yi in zip(count_x, count_y)])\n    \n    return mi_est\n\n# Example usage:\nrng = np.random.RandomState(0)\nx = rng.normal(0, 1, (1000, 1))\ny = x + rng.normal(0, 0.1, (1000, 1))\nmi_val = knn_mi(x, y)\nprint("Approximate MI using KNN method:", mi_val)\n'}),"\n",i.createElement(t.p,null,"The code above sketches a simplified approach to ",i.createElement(l.A,null,"KNN-based MI estimation"),", suitable for demonstration but not robust for all data distributions. In practice, more sophisticated or specialized libraries may handle edge cases and corrections to reduce bias."),"\n",i.createElement(t.hr),"\n",i.createElement(t.h2,{id:"practical-considerations-and-closing-thoughts",style:{position:"relative"}},i.createElement(t.a,{href:"#practical-considerations-and-closing-thoughts","aria-label":"practical considerations and closing thoughts permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Practical considerations and closing thoughts"),"\n",i.createElement(t.p,null,"Information theory, though originally built for communication systems, now stands as a pillar supporting numerous aspects of ML research and development:"),"\n",i.createElement(t.ul,null,"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Theoretical clarity"),": Concepts like entropy, mutual information, and divergences unify the language of uncertainty and data. They highlight the fundamental limit of what a learning algorithm can achieve given a dataset and a hypothesis space."),"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Algorithmic design"),": Many modern algorithms, from ",i.createElement(l.A,null,"reinforcement learning")," to ",i.createElement(l.A,null,"representation learning"),", incorporate these measures explicitly in their objectives or constraints (e.g., maximizing mutual information or minimizing KL divergence)."),"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Performance insights"),": Information-theoretic generalization bounds and the information bottleneck framework offer ways to think about how and why models generalize, providing alternative perspectives to more traditional statistical or computational complexity-based methods."),"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Implementation challenges"),": Despite their conceptual beauty, ",i.createElement(l.A,null,"estimating information-theoretic quantities")," for high-dimensional, continuous data is non-trivial. This fosters the ongoing research into neural-based estimators, kernel-based methods, and novel bounds that are computationally tractable."),"\n"),"\n",i.createElement(t.p,null,"By weaving together theoretical principles, real-world applications, and practical implementation tips, this article has attempted to illustrate the depth and breadth of how ",i.createElement(l.A,null,"information theory")," powers modern machine learning and AI systems. As you progress in your data science or ML endeavors, I encourage you to keep these information-theoretic concepts at your disposal: they are potent tools for diagnosing, designing, and understanding algorithms that must grapple with uncertainty, complexity, and high-dimensional spaces."),"\n",i.createElement(t.p,null,"Whether you are building specialized feature selectors, harnessing curiosity-driven exploration in RL, or compressing a neural network for deployment on edge devices, the language of bits and uncertainty can guide you to more principled solutions. In the rapidly evolving AI landscape, ",i.createElement(l.A,null,"information theory")," remains an enduring compass, continually pointing toward deeper insights and better algorithmic strategies."),"\n",i.createElement(t.p,null,"In future parts of this course, you might encounter specific specialized domains — such as ",i.createElement(l.A,null,"Bayesian networks"),", ",i.createElement(l.A,null,"Gaussian processes"),", or ",i.createElement(l.A,null,"transformer-based large language models")," — that further exploit these constructs to deal with complex statistical dependencies, uncertain priors, and the need for efficient representation learning. When you see references to cross-entropy or KL divergence in loss functions, or to mutual information in representation learning, I hope you'll now recognize them as powerful building blocks borrowed from a rich intellectual legacy, forming a cohesive approach to the fundamental problem of extracting, transmitting, and exploiting information in uncertain worlds."))}var m=function(e){void 0===e&&(e={});const{wrapper:t}=Object.assign({},(0,a.RP)(),e.components);return t?i.createElement(t,e,i.createElement(c,e)):c(e)},h=n(54506),d=n(88864),u=n(58481),p=n.n(u),g=n(5984),f=n(43672),v=n(27042),y=n(72031),b=n(81817),E=n(27105),w=n(17265),x=n(2043),S=n(95751),A=n(94328),H=n(80791),k=n(78137);const z=e=>{let{toc:t}=e;if(!t||!t.items)return null;return i.createElement("nav",{className:H.R},i.createElement("ul",null,t.items.map(((e,t)=>i.createElement("li",{key:t},i.createElement("a",{href:e.url,onClick:t=>((e,t)=>{e.preventDefault();const n=t.replace("#",""),a=document.getElementById(n);a&&a.scrollIntoView({behavior:"smooth",block:"start"})})(t,e.url)},e.title),e.items&&i.createElement(z,{toc:{items:e.items}}))))))};function I(e){let{data:{mdx:t,allMdx:r,allPostImages:l},children:o}=e;const{frontmatter:s,body:c,tableOfContents:m}=t,d=s.index,u=s.slug.split("/")[1],y=r.nodes.filter((e=>e.frontmatter.slug.includes(`/${u}/`))).sort(((e,t)=>e.frontmatter.index-t.frontmatter.index)),H=y.findIndex((e=>e.frontmatter.index===d)),I=y[H+1],M=y[H-1],_=s.slug.replace(/\/$/,""),L=/[^/]*$/.exec(_)[0],C=`posts/${u}/content/${L}/`,{0:T,1:N}=(0,i.useState)(s.flagWideLayoutByDefault),{0:V,1:B}=(0,i.useState)(!1);var j;(0,i.useEffect)((()=>{B(!0);const e=setTimeout((()=>B(!1)),340);return()=>clearTimeout(e)}),[T]),"adventures"===u?j=w.cb:"research"===u?j=w.Qh:"thoughts"===u&&(j=w.T6);const D=p()(c).replace(/import .*? from .*?;/g,"").replace(/<.*?>/g,"").replace(/\{\/\*[\s\S]*?\*\/\}/g,"").trim().split(/\s+/).length,q=function(e){if(e<=10)return"~10 min";if(e<=20)return"~20 min";if(e<=30)return"~30 min";if(e<=40)return"~40 min";if(e<=50)return"~50 min";if(e<=60)return"~1 h";const t=Math.floor(e/60),n=e%60;return n<=30?`~${t}${n>0?".5":""} h`:`~${t+1} h`}(Math.ceil(D/j)+(s.extraReadTimeMin||0)),P=[{flag:s.flagDraft,component:()=>Promise.all([n.e(5850),n.e(9833)]).then(n.bind(n,49833))},{flag:s.flagMindfuckery,component:()=>Promise.all([n.e(5850),n.e(7805)]).then(n.bind(n,27805))},{flag:s.flagRewrite,component:()=>Promise.all([n.e(5850),n.e(8916)]).then(n.bind(n,78916))},{flag:s.flagOffensive,component:()=>Promise.all([n.e(5850),n.e(6731)]).then(n.bind(n,49112))},{flag:s.flagProfane,component:()=>Promise.all([n.e(5850),n.e(3336)]).then(n.bind(n,83336))},{flag:s.flagMultilingual,component:()=>Promise.all([n.e(5850),n.e(2343)]).then(n.bind(n,62343))},{flag:s.flagUnreliably,component:()=>Promise.all([n.e(5850),n.e(6865)]).then(n.bind(n,11627))},{flag:s.flagPolitical,component:()=>Promise.all([n.e(5850),n.e(4417)]).then(n.bind(n,24417))},{flag:s.flagCognitohazard,component:()=>Promise.all([n.e(5850),n.e(8669)]).then(n.bind(n,18669))},{flag:s.flagHidden,component:()=>Promise.all([n.e(5850),n.e(8124)]).then(n.bind(n,48124))}],{0:X,1:K}=(0,i.useState)([]);return(0,i.useEffect)((()=>{P.forEach((e=>{let{flag:t,component:n}=e;t&&n().then((e=>{K((t=>[].concat((0,h.A)(t),[e.default])))}))}))}),[]),i.createElement(v.P.div,{initial:{opacity:0},animate:{opacity:1},exit:{opacity:0},transition:{duration:.15}},i.createElement(b.A,{postNumber:s.index,date:s.date,updated:s.updated,readTime:q,difficulty:s.difficultyLevel,title:s.title,desc:s.desc,banner:s.banner,section:u,postKey:L,isMindfuckery:s.flagMindfuckery,mainTag:s.mainTag}),i.createElement("div",{style:{display:"flex",justifyContent:"flex-end",flexWrap:"wrap",maxWidth:"75%",marginLeft:"auto",paddingRight:"1vw",marginTop:"-6vh",marginBottom:"4vh"}},s.otherTags.map(((e,t)=>i.createElement("span",{key:t,className:`noselect ${k.MW}`,style:{margin:"0 5px 5px 0"}},e)))),i.createElement("div",{className:"postBody"},i.createElement(z,{toc:m})),i.createElement("br",null),i.createElement("div",{style:{margin:"0 10% -2vh 30%",textAlign:"right"}},i.createElement(v.P.button,{className:`noselect ${A.pb}`,id:A.xG,onClick:()=>{N(!T)},whileTap:{scale:.93}},i.createElement(v.P.div,{className:S.DJ,key:T,initial:{opacity:0},animate:{opacity:1},exit:{opacity:0},transition:{duration:.3,ease:"easeInOut"}},T?"Switch to default layout":"Switch to wide layout"))),i.createElement("br",null),i.createElement("div",{className:"postBody",style:{margin:T?"0 -14%":"",maxWidth:T?"200%":"",transition:"margin 1s ease, max-width 1s ease, padding 1s ease"}},i.createElement("div",{className:`${A.P_} ${V?A.Xn:A.qG}`},X.map(((e,t)=>i.createElement(e,{key:t}))),s.indexCourse?i.createElement(x.A,{index:s.indexCourse,category:s.courseCategoryName}):"",i.createElement(g.Z.Provider,{value:{images:l.nodes,basePath:C.replace(/\/$/,"")+"/"}},i.createElement(a.xA,{components:{Image:f.A}},o)))),i.createElement(E.A,{nextPost:I,lastPost:M,keyCurrent:L,section:u}))}function M(e){return i.createElement(I,e,i.createElement(m,e))}function _(e){var t,n,a,r,l;let{data:o}=e;const{frontmatter:s}=o.mdx,c=s.titleSEO||s.title,m=s.titleOG||c,h=s.titleTwitter||c,u=s.descSEO||s.desc,p=s.descOG||u,g=s.descTwitter||u,f=s.schemaType||"BlogPosting",v=s.keywordsSEO,b=s.date,E=s.updated||b,w=s.imageOG||(null===(t=s.banner)||void 0===t||null===(n=t.childImageSharp)||void 0===n||null===(a=n.gatsbyImageData)||void 0===a||null===(r=a.images)||void 0===r||null===(l=r.fallback)||void 0===l?void 0:l.src),x=s.imageAltOG||p,S=s.imageTwitter||w,A=s.imageAltTwitter||g,H=s.canonicalURL,k=s.flagHidden||!1,z=s.mainTag||"Posts",I=s.slug.split("/")[1]||"posts",{siteUrl:M}=(0,d.Q)(),_={"@context":"https://schema.org","@type":"BreadcrumbList",itemListElement:[{"@type":"ListItem",position:1,name:"Home",item:M},{"@type":"ListItem",position:2,name:z,item:`${M}/${s.slug.split("/")[1]}`},{"@type":"ListItem",position:3,name:c,item:`${M}${s.slug}`}]};return i.createElement(y.A,{title:c+" - avrtt.blog",titleOG:m,titleTwitter:h,description:u,descriptionOG:p,descriptionTwitter:g,schemaType:f,keywords:v,datePublished:b,dateModified:E,imageOG:w,imageAltOG:x,imageTwitter:S,imageAltTwitter:A,canonicalUrl:H,flagHidden:k,mainTag:z,section:I,type:"article"},i.createElement("script",{type:"application/ld+json"},JSON.stringify(_)))}},9360:function(e,t,n){n.d(t,{A:function(){return l}});var a=n(96540),i=n(3962),r="styles-module--tooltiptext--a263b";var l=e=>{let{text:t,isBadge:n=!1}=e;const{0:l,1:o}=(0,a.useState)(!1),s=(0,a.useRef)(null);return(0,a.useEffect)((()=>{function e(e){s.current&&e.target instanceof Node&&!s.current.contains(e.target)&&o(!1)}return document.addEventListener("click",e),()=>{document.removeEventListener("click",e)}}),[]),a.createElement("span",{className:"styles-module--tooltipWrapper--75ebf",ref:s},a.createElement("img",{id:n?"styles-module--infoBadge--e3d66":"styles-module--info--26c1f",src:i.A,alt:"info",onClick:e=>{e.stopPropagation(),o((e=>!e))}}),a.createElement("span",{className:l?`${r} styles-module--visible--c063c`:r},t))}},90548:function(e,t,n){var a=n(96540),i=n(7978);t.A=e=>{let{text:t}=e;return a.createElement(i.A,null,t)}}}]);
//# sourceMappingURL=component---src-templates-post-tsx-content-file-path-src-pages-posts-research-information-theory-for-ml-mdx-474e7409e905774dee4f.js.map