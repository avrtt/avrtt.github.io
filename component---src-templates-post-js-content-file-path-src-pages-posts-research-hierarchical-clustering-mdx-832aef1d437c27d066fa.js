"use strict";(self.webpackChunkavrtt_blog=self.webpackChunkavrtt_blog||[]).push([[9146],{3962:function(e,t){t.A="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iaXNvLTg4NTktMSI/Pgo8IS0tIEdlbmVyYXRvcjogQWRvYmUgSWxsdXN0cmF0b3IgMTYuMC4wLCBTVkcgRXhwb3J0IFBsdWctSW4gLiBTVkcgVmVyc2lvbjogNi4wMCBCdWlsZCAwKSAgLS0+CjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+CjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iQ2FwYV8xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4PSIwcHgiIHk9IjBweCIKCSB3aWR0aD0iNDE2Ljk3OXB4IiBoZWlnaHQ9IjQxNi45NzlweCIgdmlld0JveD0iMCAwIDQxNi45NzkgNDE2Ljk3OSIgc3R5bGU9ImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgNDE2Ljk3OSA0MTYuOTc5OyIKCSB4bWw6c3BhY2U9InByZXNlcnZlIj4KPGc+Cgk8cGF0aCBkPSJNMzU2LjAwNCw2MS4xNTZjLTgxLjM3LTgxLjQ3LTIxMy4zNzctODEuNTUxLTI5NC44NDgtMC4xODJjLTgxLjQ3LDgxLjM3MS04MS41NTIsMjEzLjM3OS0wLjE4MSwyOTQuODUKCQljODEuMzY5LDgxLjQ3LDIxMy4zNzgsODEuNTUxLDI5NC44NDksMC4xODFDNDM3LjI5MywyNzQuNjM2LDQzNy4zNzUsMTQyLjYyNiwzNTYuMDA0LDYxLjE1NnogTTIzNy42LDM0MC43ODYKCQljMCwzLjIxNy0yLjYwNyw1LjgyMi01LjgyMiw1LjgyMmgtNDYuNTc2Yy0zLjIxNSwwLTUuODIyLTIuNjA1LTUuODIyLTUuODIyVjE2Ny44ODVjMC0zLjIxNywyLjYwNy01LjgyMiw1LjgyMi01LjgyMmg0Ni41NzYKCQljMy4yMTUsMCw1LjgyMiwyLjYwNCw1LjgyMiw1LjgyMlYzNDAuNzg2eiBNMjA4LjQ5LDEzNy45MDFjLTE4LjYxOCwwLTMzLjc2Ni0xNS4xNDYtMzMuNzY2LTMzLjc2NQoJCWMwLTE4LjYxNywxNS4xNDctMzMuNzY2LDMzLjc2Ni0zMy43NjZjMTguNjE5LDAsMzMuNzY2LDE1LjE0OCwzMy43NjYsMzMuNzY2QzI0Mi4yNTYsMTIyLjc1NSwyMjcuMTA3LDEzNy45MDEsMjA4LjQ5LDEzNy45MDF6Ii8+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPC9zdmc+Cg=="},13330:function(e,t,n){n.r(t),n.d(t,{Head:function(){return I},PostTemplate:function(){return z},default:function(){return A}});var a=n(54506),i=n(28453),l=n(96540),r=n(16886),s=n(46295),c=n(96098),o=n(66501);function m(e){const t=Object.assign({p:"p",h3:"h3",a:"a",span:"span",ul:"ul",li:"li",strong:"strong",h2:"h2",br:"br",ol:"ol"},(0,i.RP)(),e.components),{Image:n}=t;return n||function(e,t){throw new Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Image",!0),l.createElement(l.Fragment,null,"\n",l.createElement("br"),"\n","\n","\n",l.createElement(t.p,null,'Hierarchical clustering is a technique of cluster analysis that seeks to create a multilevel, tree-like structure of nested clusters, usually represented by a dendrogram. Rather than predetermining the number of clusters, the method explores the data at multiple levels of granularity. When using hierarchical clustering, you can either start with each data point in its own cluster and iteratively merge clusters (agglomerative approach), or place all data points in one cluster and successively divide it (divisive approach). This branching process gives hierarchical clustering a flexible and interpretable nature, as you can "cut" the resulting dendrogram at different heights to obtain a variety of cluster solutions. For many data analysis tasks, especially those requiring intuitive graphical representations, hierarchical clustering serves as a powerful tool for discovering structure.'),"\n",l.createElement(t.h3,{id:"definition-and-key-ideas",style:{position:"relative"}},l.createElement(t.a,{href:"#definition-and-key-ideas","aria-label":"definition and key ideas permalink",className:"anchor before"},l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Definition and key ideas"),"\n",l.createElement(t.p,null,"Hierarchical clustering groups data into a hierarchy of clusters. In the agglomerative process, data points are initially viewed as individual clusters (",l.createElement(o.A,{text:"clusters containing just one point"}),") and are successively merged if they are close or similar according to some distance or similarity measure. In the divisive process, the entire dataset is treated as one single cluster and is subsequently split step by step. The result of either process is a ",l.createElement(r.A,null,"dendrogram")," — a tree structure depicting merges (in agglomerative) or splits (in divisive) at increasing levels of dissimilarity."),"\n",l.createElement(t.p,null,"Hierarchical clustering differs from other clustering algorithms, such as ",l.createElement(r.A,null,"k-means")," (which requires predefining a number of clusters) or ",l.createElement(r.A,null,"DBSCAN")," (which depends on density parameters). Instead, it relies directly on distance or similarity metrics to systematically form or break clusters. Therefore, it is well-suited to exploratory data analysis scenarios in which you may want to see clustering solutions at different levels of granularity."),"\n",l.createElement(t.h3,{id:"differences-from-other-clustering-techniques",style:{position:"relative"}},l.createElement(t.a,{href:"#differences-from-other-clustering-techniques","aria-label":"differences from other clustering techniques permalink",className:"anchor before"},l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Differences from other clustering techniques"),"\n",l.createElement(t.p,null,"Unlike partition-based algorithms (e.g., k-means or k-medoids), hierarchical clustering frees you from specifying the number of clusters in advance. Instead of compressing the data into a fixed set of partitions, you gain a hierarchical perspective from which any slice of the hierarchy can represent a potential clustering solution. This tree-like organization is often more interpretable — for instance, in bioinformatics or taxonomy, you can easily interpret branching in the dendrogram as evolutionary or functional relationships."),"\n",l.createElement(t.p,null,"Furthermore, unlike density-based approaches (e.g., DBSCAN, OPTICS), hierarchical clustering does not depend on density thresholds to form clusters. Instead, it uses distance or similarity measures and linkage criteria, though it can be more susceptible to noise and outliers because even a single distant pair of points can influence merges or splits if the linkage criterion is sensitive."),"\n",l.createElement(t.h3,{id:"advantages-and-disadvantages",style:{position:"relative"}},l.createElement(t.a,{href:"#advantages-and-disadvantages","aria-label":"advantages and disadvantages permalink",className:"anchor before"},l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Advantages and disadvantages"),"\n",l.createElement(t.ul,null,"\n",l.createElement(t.li,null,"\n",l.createElement(t.p,null,l.createElement(t.strong,null,"Advantages")),"\n",l.createElement(t.ul,null,"\n",l.createElement(t.li,null,l.createElement(r.A,null,"Interpretability"),": The dendrogram is easy to visualize and reason about, providing insights into how data groups together at multiple levels."),"\n",l.createElement(t.li,null,l.createElement(r.A,null,"No fixed number of clusters"),": You do not need to guess or specify a target number of clusters ahead of time."),"\n",l.createElement(t.li,null,l.createElement(r.A,null,"Flexibility in exploring solutions"),': You can "cut" the dendrogram at various distances, obtaining cluster solutions that range from very fine-grained to very coarse.'),"\n"),"\n"),"\n",l.createElement(t.li,null,"\n",l.createElement(t.p,null,l.createElement(t.strong,null,"Disadvantages")),"\n",l.createElement(t.ul,null,"\n",l.createElement(t.li,null,l.createElement(r.A,null,"Computational cost"),": For large datasets, constructing the full distance matrix and performing repeated merges can be expensive in terms of both time and memory."),"\n",l.createElement(t.li,null,l.createElement(r.A,null,"Sensitivity to noise and outliers"),": Certain linkage criteria (like single linkage) can form undesirable chaining effects if there is even a single noisy point between clusters."),"\n",l.createElement(t.li,null,l.createElement(r.A,null,"Dependence on distance and linkage criteria"),": Different choices of distance metrics and linkage methods can lead to drastically different dendrogram shapes and cluster outcomes."),"\n"),"\n"),"\n"),"\n",l.createElement(t.h3,{id:"historical-background-and-motivations",style:{position:"relative"}},l.createElement(t.a,{href:"#historical-background-and-motivations","aria-label":"historical background and motivations permalink",className:"anchor before"},l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Historical background and motivations"),"\n",l.createElement(t.p,null,"Hierarchical clustering has a long tradition in fields such as ",l.createElement(o.A,{text:"the scientific classification of organisms"}),"taxonomy, ",l.createElement(o.A,{text:"the study of biological sequences and expression patterns"}),"bioinformatics, and social sciences. Early biological applications involved grouping species based on phenotypic or genetic similarity, producing taxonomies that mirrored evolutionary relationships. Over the decades, hierarchical clustering has found use in text analysis, recommendation systems, marketing, image analysis, and many other applications where interpretability and multi-level structure are essential."),"\n",l.createElement(t.p,null,"Classic works on clustering (e.g., Jain and Dubes, 1988; Rokach and Maimon, 2005) describe hierarchical clustering as one of the fundamental approaches to unsupervised learning. Subsequent research advanced computational aspects (e.g., ",l.createElement(o.A,{text:"SLINK algorithm for single linkage clustering"}),"Sibson, 1973) and theoretical properties, ensuring that hierarchical clustering remains a staple in modern data science."),"\n",l.createElement(t.h2,{id:"foundational-concepts",style:{position:"relative"}},l.createElement(t.a,{href:"#foundational-concepts","aria-label":"foundational concepts permalink",className:"anchor before"},l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Foundational concepts"),"\n",l.createElement(t.p,null,"Hierarchical clustering typically relies on a dissimilarity or distance matrix that represents all pairwise distances between points in a dataset. This matrix is essential, as each step of the clustering algorithm (whether merging or splitting clusters) often depends on how close clusters are to each other. Let me introduce some foundational concepts that underpin the method."),"\n",l.createElement(t.h3,{id:"distance-metrics",style:{position:"relative"}},l.createElement(t.a,{href:"#distance-metrics","aria-label":"distance metrics permalink",className:"anchor before"},l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Distance metrics"),"\n",l.createElement(t.p,null,'A distance metric defines "how far apart" two data points are. Each metric imposes different geometric properties on the data space, which can substantially affect the shape and number of clusters discovered. Common distance metrics include:'),"\n",l.createElement(t.ul,null,"\n",l.createElement(t.li,null,"\n",l.createElement(t.p,null,l.createElement(t.strong,null,"Euclidean distance"),": ",l.createElement(c.A,{text:"\\( d(\\mathbf{x}, \\mathbf{y}) = \\sqrt{\\sum_{i=1}^D (x_i - y_i)^2} \\)"}),l.createElement(t.br),"\n","Often interpreted as the straight-line distance in ",l.createElement(c.A,{text:"\\(D\\)"}),"-dimensional space. It is sensitive to outliers because large deviations in any dimension can significantly increase the distance."),"\n"),"\n",l.createElement(t.li,null,"\n",l.createElement(t.p,null,l.createElement(t.strong,null,"Manhattan distance")," (L1 norm): ",l.createElement(c.A,{text:"\\( d(\\mathbf{x}, \\mathbf{y}) = \\sum_{i=1}^D |x_i - y_i| \\)"}),l.createElement(t.br),"\n","Also called city block distance. Especially suitable when you want robust behavior against outliers or want to measure distances along axes."),"\n"),"\n",l.createElement(t.li,null,"\n",l.createElement(t.p,null,l.createElement(t.strong,null,"Minkowski distance"),": ",l.createElement(c.A,{text:"\\( d(\\mathbf{x}, \\mathbf{y}) = \\Big(\\sum_{i=1}^D |x_i - y_i|^p\\Big)^{1/p} \\)"}),l.createElement(t.br),"\n","A generalization of Euclidean (when ",l.createElement(c.A,{text:"\\(p=2\\)"}),") and Manhattan (when ",l.createElement(c.A,{text:"\\(p=1\\)"}),") distances."),"\n"),"\n",l.createElement(t.li,null,"\n",l.createElement(t.p,null,l.createElement(t.strong,null,"Chebyshev distance"),": ",l.createElement(c.A,{text:"\\( d(\\mathbf{x}, \\mathbf{y}) = \\max_{i}|x_i - y_i| \\)"}),l.createElement(t.br),"\n","This metric emphasizes the largest difference among dimensions, often used in chessboard-like movements."),"\n"),"\n",l.createElement(t.li,null,"\n",l.createElement(t.p,null,l.createElement(t.strong,null,"Cosine distance")," (especially in text mining or high-dimensional vector spaces where magnitude differences matter less): ",l.createElement(c.A,{text:"\\( d(\\mathbf{x}, \\mathbf{y}) = 1 - \\frac{\\mathbf{x}\\cdot \\mathbf{y}}{\\|\\mathbf{x}\\|\\|\\mathbf{y}\\|} \\)"}),l.createElement(t.br),"\n","Measures dissimilarity based on the angle between vectors."),"\n"),"\n"),"\n",l.createElement(t.p,null,"Each choice can yield a different configuration of clusters, so domain knowledge is often used to select a suitable metric. For example, in gene expression data, correlation-based distances might be more relevant than Euclidean distances, since consistent up/down trends may be more important than absolute expression levels."),"\n",l.createElement(t.h3,{id:"similarity-and-dissimilarity-matrices",style:{position:"relative"}},l.createElement(t.a,{href:"#similarity-and-dissimilarity-matrices","aria-label":"similarity and dissimilarity matrices permalink",className:"anchor before"},l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Similarity and dissimilarity matrices"),"\n",l.createElement(t.p,null,"Instead of a distance metric, some problems naturally have a similarity score (e.g., the number of matching attributes between two data points). One can convert similarity to distance and vice versa by transformations like ",l.createElement(c.A,{text:"\\(d = 1 - s\\)"})," (if ",l.createElement(c.A,{text:"\\(s\\)"})," is bounded in ",l.createElement(c.A,{text:"\\([0,1]\\)"}),"), or use other transformations that preserve meaningful relationships. The goal is to summarize data in a ",l.createElement(r.A,null,"pairwise matrix")," that can drive the hierarchical clustering process."),"\n",l.createElement(t.p,null,"For a dataset of size ",l.createElement(c.A,{text:"\\(n\\)"}),", a distance matrix has dimensions ",l.createElement(c.A,{text:"\\(n\\times n\\)"}),". For large ",l.createElement(c.A,{text:"\\(n\\)"}),", storing and manipulating this matrix becomes costly — this is one reason why hierarchical clustering can be computationally prohibitive at scale, and specialized algorithms or approximations become necessary."),"\n",l.createElement(t.h3,{id:"linkage-criteria",style:{position:"relative"}},l.createElement(t.a,{href:"#linkage-criteria","aria-label":"linkage criteria permalink",className:"anchor before"},l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Linkage criteria"),"\n",l.createElement(t.p,null,"In hierarchical clustering, once you define how to measure pairwise distances between points, you need a criterion for measuring the distance between clusters. Several linkage methods are common:"),"\n",l.createElement(t.ol,null,"\n",l.createElement(t.li,null,"\n",l.createElement(t.p,null,l.createElement(t.strong,null,"Single linkage"),": The distance between two clusters is the minimum distance between any pair of points from each cluster. Formally, if clusters ",l.createElement(c.A,{text:"\\(A\\)"})," and ",l.createElement(c.A,{text:"\\(B\\)"})," have points ",l.createElement(c.A,{text:"\\(a\\in A\\)"})," and ",l.createElement(c.A,{text:"\\(b\\in B\\)"}),", then"),"\n",l.createElement(c.A,{text:"\\( d_{\\text{single}}(A,B) = \\min_{a\\in A,b\\in B} d(a,b)\\)"}),"\n",l.createElement(t.p,null,'Single linkage can create "chaining effects", where clusters that have one pair of relatively close points keep getting merged, even if other points in the clusters are far apart.'),"\n"),"\n",l.createElement(t.li,null,"\n",l.createElement(t.p,null,l.createElement(t.strong,null,"Complete linkage"),": The distance between two clusters is the maximum distance between any pair of points from each cluster:"),"\n",l.createElement(c.A,{text:"\\( d_{\\text{complete}}(A,B) = \\max_{a\\in A,b\\in B} d(a,b)\\)"}),"\n",l.createElement(t.p,null,"Complete linkage tends to produce compact clusters, but is sensitive to outliers. One distant point in a cluster can inflate the distance dramatically."),"\n"),"\n",l.createElement(t.li,null,"\n",l.createElement(t.p,null,l.createElement(t.strong,null,"Average linkage"),": The distance between clusters ",l.createElement(c.A,{text:"\\(A\\)"})," and ",l.createElement(c.A,{text:"\\(B\\)"})," is the average distance between all pairs of points, one from each cluster:"),"\n",l.createElement(c.A,{text:"\\[\nd_{\\text{average}}(A,B) = \\frac{1}{|A|\\cdot|B|}\\sum_{a\\in A}\\sum_{b\\in B} d(a,b)\n\\]"}),"\n",l.createElement(t.p,null,"This approach attempts to balance extremes, often generating moderate-sized clusters."),"\n"),"\n",l.createElement(t.li,null,"\n",l.createElement(t.p,null,l.createElement(t.strong,null,"Ward's method"),": Instead of directly measuring distance between clusters, Ward's method merges clusters in a way that minimizes the increase in the total within-cluster variance (error sum of squares). Formally, if you denote the sum of squares within each cluster, merging two clusters with Ward's linkage is the merge that yields the smallest increase in the total sum of squares. This method often produces clusters of relatively uniform size and has shown resilience to noise in many contexts."),"\n"),"\n"),"\n",l.createElement(t.h3,{id:"role-of-data-dimensionality",style:{position:"relative"}},l.createElement(t.a,{href:"#role-of-data-dimensionality","aria-label":"role of data dimensionality permalink",className:"anchor before"},l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Role of data dimensionality"),"\n",l.createElement(t.p,null,'Hierarchical clustering in very high-dimensional spaces becomes tricky due to the "curse of dimensionality", where distances between points start to lose discriminative power. Often, you might:'),"\n",l.createElement(t.ul,null,"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"Perform dimensionality reduction")," with ",l.createElement(r.A,null,"PCA"),", ",l.createElement(r.A,null,"t-SNE"),", or ",l.createElement(r.A,null,"UMAP")," before hierarchical clustering to obtain more meaningful distances."),"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"Select or engineer features")," carefully to avoid cluttering the clustering process with irrelevant or noisy dimensions."),"\n"),"\n",l.createElement(t.p,null,"Although hierarchical clustering can work in moderately high dimensions, the computational complexity and interpretability both degrade if you do not manage dimensionality effectively."),"\n",l.createElement(t.h2,{id:"agglomerative-clustering",style:{position:"relative"}},l.createElement(t.a,{href:"#agglomerative-clustering","aria-label":"agglomerative clustering permalink",className:"anchor before"},l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Agglomerative clustering"),"\n",l.createElement(t.p,null,"Agglomerative clustering is the most widely used form of hierarchical clustering. It follows a bottom-up approach: each data point starts in its own cluster, and then iteratively merges clusters that are closest according to the chosen distance metric and linkage method. Eventually, the entire dataset aggregates into a single cluster."),"\n",l.createElement(t.h3,{id:"basic-principle",style:{position:"relative"}},l.createElement(t.a,{href:"#basic-principle","aria-label":"basic principle permalink",className:"anchor before"},l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Basic principle"),"\n",l.createElement(t.ol,null,"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"Initialization"),": Treat every data point as an individual cluster. Hence, you start with ",l.createElement(c.A,{text:"\\(n\\)"})," clusters if there are ",l.createElement(c.A,{text:"\\(n\\)"})," data points."),"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"Iterative merges"),": At each step, locate the pair of clusters with the smallest distance (according to the linkage criterion) and merge them into a new cluster."),"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"Distance matrix update"),": Once two clusters ",l.createElement(c.A,{text:"\\(A\\)"})," and ",l.createElement(c.A,{text:"\\(B\\)"})," are merged, they form a new cluster ",l.createElement(c.A,{text:"\\(C\\)"}),". You then update the distance matrix by removing the rows/columns for ",l.createElement(c.A,{text:"\\(A\\)"})," and ",l.createElement(c.A,{text:"\\(B\\)"})," and adding a new row/column for ",l.createElement(c.A,{text:"\\(C\\)"}),". The distance of ",l.createElement(c.A,{text:"\\(C\\)"})," to any other cluster depends on the linkage method."),"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"Termination"),": Repeat merging until one cluster remains (or until a stopping criterion is reached)."),"\n"),"\n",l.createElement(t.h3,{id:"step-by-step-process",style:{position:"relative"}},l.createElement(t.a,{href:"#step-by-step-process","aria-label":"step by step process permalink",className:"anchor before"},l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Step-by-step process"),"\n",l.createElement(t.p,null,"Let me illustrate the agglomerative procedure with a short example. Suppose you have 4 data points: ",l.createElement(c.A,{text:"\\(\\{x_1, x_2, x_3, x_4\\}\\)"}),". The steps might be:"),"\n",l.createElement(t.ol,null,"\n",l.createElement(t.li,null,"Compute the pairwise distance matrix ",l.createElement(c.A,{text:"\\(D\\)"})," of size ",l.createElement(c.A,{text:"\\(4\\times 4\\)"}),"."),"\n",l.createElement(t.li,null,"Find the smallest distance in ",l.createElement(c.A,{text:"\\(D\\)"}),". Assume ",l.createElement(c.A,{text:"\\(d(x_1, x_2)\\)"})," is smallest, so merge ",l.createElement(c.A,{text:"\\(x_1\\)"})," and ",l.createElement(c.A,{text:"\\(x_2\\)"})," into cluster ",l.createElement(c.A,{text:"\\(C_{12}\\)"}),"."),"\n",l.createElement(t.li,null,"Update ",l.createElement(c.A,{text:"\\(D\\)"})," by removing rows/columns for ",l.createElement(c.A,{text:"\\(x_1\\)"})," and ",l.createElement(c.A,{text:"\\(x_2\\)"}),", and adding a row/column for ",l.createElement(c.A,{text:"\\(C_{12}\\)"}),". The distance between ",l.createElement(c.A,{text:"\\(C_{12}\\)"})," and other points or clusters depends on your linkage choice."),"\n",l.createElement(t.li,null,"Repeat: find the next smallest distance and merge the corresponding clusters."),"\n",l.createElement(t.li,null,"Stop once you have the desired number of clusters or a single final cluster."),"\n"),"\n",l.createElement(t.p,null,"A dendrogram can easily depict these merges visually: the height of each merge on the y-axis indicates the distance (or dissimilarity) at which the merge occurred. This bottom-up merging approach yields ",l.createElement(r.A,null,"a hierarchical representation")," of how clusters are built, which can be sliced at different heights to form final clusters."),"\n",l.createElement(t.h3,{id:"common-use-cases",style:{position:"relative"}},l.createElement(t.a,{href:"#common-use-cases","aria-label":"common use cases permalink",className:"anchor before"},l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Common use cases"),"\n",l.createElement(t.p,null,"Agglomerative hierarchical clustering is frequently applied in:"),"\n",l.createElement(t.ul,null,"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"Bioinformatics"),": For gene expression data, where each gene is initially in its own cluster. You can see how genes merge based on similarity of expression profiles."),"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"Natural language processing"),": In text clustering, especially if you want a hierarchy of topics or documents."),"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"Customer segmentation"),": When interpretability is paramount, and you want a dendrogram for marketing insights."),"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"Small to medium datasets"),": If you have up to a few thousand data points, you can handle a full distance matrix. Beyond that, specialized methods or approximate solutions may be needed."),"\n"),"\n",l.createElement(t.h2,{id:"divisive-clustering",style:{position:"relative"}},l.createElement(t.a,{href:"#divisive-clustering","aria-label":"divisive clustering permalink",className:"anchor before"},l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Divisive clustering"),"\n",l.createElement(t.p,null,"Divisive clustering, also known as top-down hierarchical clustering, starts with a single cluster containing all the data points. It then splits clusters iteratively until every point lies in its own cluster (or until a specific criterion is met)."),"\n",l.createElement(t.h3,{id:"basic-principle-1",style:{position:"relative"}},l.createElement(t.a,{href:"#basic-principle-1","aria-label":"basic principle 1 permalink",className:"anchor before"},l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Basic principle"),"\n",l.createElement(t.ol,null,"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"Initialization"),": Consider the entire dataset as a single cluster."),"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"Identify a split"),": Choose a cluster to split — for example, the cluster that is the largest or that has the highest internal dissimilarity."),"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"Partition the chosen cluster"),': You can use a "flat" clustering method like ',l.createElement(r.A,null,"k-means")," (with ",l.createElement(c.A,{text:"\\(k=2\\)"}),") to split the cluster into two subclusters, or you can apply other heuristics (e.g., searching for a pair of subclusters that minimize within-cluster distance)."),"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"Repeat"),": Continue subdividing until you reach a stopping criterion, such as a maximum number of clusters or a threshold for cluster quality."),"\n"),"\n",l.createElement(t.h3,{id:"comparing-agglomerative-and-divisive-methods",style:{position:"relative"}},l.createElement(t.a,{href:"#comparing-agglomerative-and-divisive-methods","aria-label":"comparing agglomerative and divisive methods permalink",className:"anchor before"},l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Comparing agglomerative and divisive methods"),"\n",l.createElement(t.ul,null,"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"Complexity"),": Divisive clustering can be more computationally intensive because repeated splitting might rely on multiple runs of a partition-based method that is itself ",l.createElement(c.A,{text:"\\(O(n \\times \\text{iterations} \\times \\text{dimensionality})\\)"}),". Agglomerative clustering, although often ",l.createElement(c.A,{text:"\\(O(n^2 \\log n)\\)"})," or ",l.createElement(c.A,{text:"\\(O(n^2)\\)"})," in naive implementations, can be simpler to implement."),"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"Global structure vs. local merges"),": Divisive clustering may capture global structure first, then refine clusters, which can sometimes discover meaningful top-level splits. Agglomerative clustering focuses on local merges, which might cause small groups or outliers to merge prematurely if not carefully controlled by the linkage criterion."),"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"Popularity"),": Agglomerative clustering is much more widely used in practice, partly because it is direct to implement and interpret, and because many statistical software libraries provide well-optimized routines for it."),"\n"),"\n",l.createElement(t.h2,{id:"building-and-visualizing-the-hierarchy",style:{position:"relative"}},l.createElement(t.a,{href:"#building-and-visualizing-the-hierarchy","aria-label":"building and visualizing the hierarchy permalink",className:"anchor before"},l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Building and visualizing the hierarchy"),"\n",l.createElement(t.p,null,"A key advantage of hierarchical clustering is that it yields a dendrogram, providing a bird's-eye view of merges (agglomerative) or splits (divisive) across the data. Let's look at how to interpret and use these dendrograms effectively."),"\n",l.createElement(t.h3,{id:"constructing-the-dendrogram",style:{position:"relative"}},l.createElement(t.a,{href:"#constructing-the-dendrogram","aria-label":"constructing the dendrogram permalink",className:"anchor before"},l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Constructing the dendrogram"),"\n",l.createElement(t.p,null,"The dendrogram is constructed by tracking the merges (or splits) at each step of the hierarchical clustering algorithm. In agglomerative clustering:"),"\n",l.createElement(t.ol,null,"\n",l.createElement(t.li,null,"When two clusters merge, you draw a horizontal line connecting their branches in the dendrogram."),"\n",l.createElement(t.li,null,"The height of this horizontal line indicates the distance at which the merge occurred."),"\n"),"\n",l.createElement(t.p,null,"This yields a bottom-up tree representation, with individual data points as leaves at the bottom, and merges ascending toward a single cluster that contains all points at the top."),"\n",l.createElement(n,{alt:"Example of a dendrogram illustrating hierarchical clustering merges",path:"",caption:"Dendrogram of a small dataset, showing how clusters merge at increasing distances",zoom:"false"}),"\n",l.createElement(t.h3,{id:"how-to-read-a-dendrogram",style:{position:"relative"}},l.createElement(t.a,{href:"#how-to-read-a-dendrogram","aria-label":"how to read a dendrogram permalink",className:"anchor before"},l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"How to read a dendrogram"),"\n",l.createElement(t.p,null,"Reading a dendrogram effectively requires following the merges from the bottom to the top (for agglomerative) or from top to bottom (for divisive). Each leaf node corresponds to an original data point, and each internal node (where branches combine) indicates a merge operation."),"\n",l.createElement(t.ul,null,"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"Branch distance"),": The y-axis typically shows the distance or dissimilarity. A higher branch means the clusters only merge at a larger dissimilarity threshold."),"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"Slicing the dendrogram"),': If you draw a horizontal line (a "cut") at a certain distance, every cluster whose internal merges are below that line forms one group in your final solution. This is how you extract clusters from the hierarchy.'),"\n"),"\n",l.createElement(t.h3,{id:"choosing-the-cut-height-for-clusters",style:{position:"relative"}},l.createElement(t.a,{href:"#choosing-the-cut-height-for-clusters","aria-label":"choosing the cut height for clusters permalink",className:"anchor before"},l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Choosing the cut height for clusters"),"\n",l.createElement(t.p,null,"Deciding where to cut the dendrogram can drastically change the number and composition of clusters. Strategies include:"),"\n",l.createElement(t.ul,null,"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"Elbow or silhouette heuristic"),": Scan different cut heights and measure how well the resulting partitions separate data."),"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"Maximum distance threshold"),": Select a distance threshold beyond which clusters should not be merged (useful if domain knowledge suggests that any pair of points beyond a certain distance are not related)."),"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"Domain-driven selection"),": Use real-world knowledge. For instance, if you know your data should be grouped into up to 5 categories, you choose a cut that yields 5 clusters."),"\n"),"\n",l.createElement(t.h2,{id:"birch-algorithm",style:{position:"relative"}},l.createElement(t.a,{href:"#birch-algorithm","aria-label":"birch algorithm permalink",className:"anchor before"},l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"BIRCH algorithm"),"\n",l.createElement(t.p,null,"Hierarchical clustering is often expensive for large datasets because it requires building and updating a large distance matrix. One solution for scaling hierarchical clustering to massive data is the ",l.createElement(r.A,null,"BIRCH"),' algorithm (Zhang and gang, SIGMOD 1996). The name stands for "Balanced Iterative Reducing and Clustering using Hierarchies."'),"\n",l.createElement(t.h3,{id:"core-concepts-behind-birch",style:{position:"relative"}},l.createElement(t.a,{href:"#core-concepts-behind-birch","aria-label":"core concepts behind birch permalink",className:"anchor before"},l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Core concepts behind BIRCH"),"\n",l.createElement(t.p,null,"The BIRCH algorithm is designed to cluster large datasets (possibly containing millions of points) without requiring all pairwise distances to be stored in memory. It incrementally processes data points and builds a tree structure (CF Tree) that summarizes cluster representations at different levels of granularity:"),"\n",l.createElement(t.ul,null,"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"Online/incremental"),": Data points arrive in a stream and are inserted into the CF Tree, which organizes them into subclusters."),"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"Refinement"),": BIRCH can condense the dataset into a more compact representation and then apply a clustering method (like hierarchical or partition-based) on these subclusters to get final clusters."),"\n"),"\n",l.createElement(t.h3,{id:"cf-tree-structure-and-operations",style:{position:"relative"}},l.createElement(t.a,{href:"#cf-tree-structure-and-operations","aria-label":"cf tree structure and operations permalink",className:"anchor before"},l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"CF tree structure and operations"),"\n",l.createElement(t.p,null,"A ",l.createElement(t.strong,null,"CF Tree")," consists of nodes that store ",l.createElement(t.strong,null,"Clustering Features (CFs)")," — typically, these are statistics like the number of points ",l.createElement(c.A,{text:"\\(N\\)"}),", the linear sum of points ",l.createElement(c.A,{text:"(\\sum \\mathbf{x}_i)"}),", and the sum of squares ",l.createElement(c.A,{text:"(\\sum \\mathbf{x}_i^2)"})," for points in that subcluster. Each node can have multiple entries (child subclusters), up to a branching factor ",l.createElement(c.A,{text:"\\(B\\)"}),". A threshold parameter ",l.createElement(c.A,{text:"\\(T\\)"})," controls how large the subclusters within a node can grow."),"\n",l.createElement(t.ul,null,"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"Insertion"),": When a new data point arrives, BIRCH navigates the tree to find the closest subcluster, checking if adding the point would exceed the threshold ",l.createElement(c.A,{text:"\\(T\\)"}),". If it does, BIRCH splits or creates a new subcluster."),"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"Merging"),": Subclusters that are very close can be merged, keeping the tree balanced and within the specified threshold."),"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"Condensation"),": By adjusting thresholds or rebalancing, BIRCH can refine the CF Tree to produce a more general or more detailed set of subclusters."),"\n"),"\n",l.createElement(t.p,null,"Once the dataset is summarized by the CF Tree, a more standard clustering method can be run on these final subclusters, dramatically reducing the computational burden compared to dealing with all data points explicitly."),"\n",l.createElement(t.h3,{id:"advantages-and-limitations",style:{position:"relative"}},l.createElement(t.a,{href:"#advantages-and-limitations","aria-label":"advantages and limitations permalink",className:"anchor before"},l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Advantages and limitations"),"\n",l.createElement(t.ul,null,"\n",l.createElement(t.li,null,"\n",l.createElement(t.p,null,l.createElement(t.strong,null,"Advantages")),"\n",l.createElement(t.ul,null,"\n",l.createElement(t.li,null,"Efficient for large datasets, potentially in streaming contexts."),"\n",l.createElement(t.li,null,"Incremental updates allow continuous refinement."),"\n",l.createElement(t.li,null,"Memory usage is controlled by the CF Tree structure, avoiding a full distance matrix."),"\n"),"\n"),"\n",l.createElement(t.li,null,"\n",l.createElement(t.p,null,l.createElement(t.strong,null,"Limitations")),"\n",l.createElement(t.ul,null,"\n",l.createElement(t.li,null,"Sensitive to the order of data insertion — early points can shape the tree structure in ways that might not be globally optimal."),"\n",l.createElement(t.li,null,"Requires careful tuning of parameters like threshold ",l.createElement(c.A,{text:"\\(T\\)"})," and branching factor ",l.createElement(c.A,{text:"\\(B\\)"}),"."),"\n",l.createElement(t.li,null,"Results can be suboptimal if the final set of subclusters does not capture the global structure well."),"\n"),"\n"),"\n"),"\n",l.createElement(t.h3,{id:"example-use-cases",style:{position:"relative"}},l.createElement(t.a,{href:"#example-use-cases","aria-label":"example use cases permalink",className:"anchor before"},l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Example use cases"),"\n",l.createElement(t.ul,null,"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"Online data stream clustering"),": In network traffic monitoring or real-time sensor data, BIRCH can handle incoming points efficiently."),"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"Data compression"),": Even if the data is not streaming, BIRCH can compress large datasets into a manageable number of subclusters before applying a more computationally expensive method."),"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"Real-time anomaly detection"),": If new points do not fit well into existing subclusters, they might be flagged as potential outliers."),"\n"),"\n",l.createElement(t.h2,{id:"implementation-details-and-practical-tips",style:{position:"relative"}},l.createElement(t.a,{href:"#implementation-details-and-practical-tips","aria-label":"implementation details and practical tips permalink",className:"anchor before"},l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Implementation details and practical tips"),"\n",l.createElement(t.p,null,"In real-world machine learning pipelines, it is crucial to adapt hierarchical clustering methods to your computational resources, data characteristics, and desired interpretability."),"\n",l.createElement(t.h3,{id:"data-preprocessing-scaling-dimensionality-reduction",style:{position:"relative"}},l.createElement(t.a,{href:"#data-preprocessing-scaling-dimensionality-reduction","aria-label":"data preprocessing scaling dimensionality reduction permalink",className:"anchor before"},l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Data preprocessing (scaling, dimensionality reduction)"),"\n",l.createElement(t.ul,null,"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"Feature scaling"),": If your dataset has attributes with vastly different scales, consider standardizing or normalizing them. For instance, standardization transforms each feature so that it has zero mean and unit variance:","\n",l.createElement(c.A,{text:"\\( x_i' = \\frac{x_i - \\mu_x}{\\sigma_x}\\)"}),"\n","This prevents attributes with larger numerical ranges from dominating distance computations."),"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"Dimensionality reduction"),": Techniques such as ",l.createElement(r.A,null,"PCA"),", ",l.createElement(r.A,null,"t-SNE"),", or ",l.createElement(r.A,null,"UMAP")," can make hierarchical clustering more tractable for high-dimensional data. Reducing dimensions not only speeds computation but can also enhance interpretability if the essential structure is preserved."),"\n"),"\n",l.createElement(t.h3,{id:"handling-large-datasets",style:{position:"relative"}},l.createElement(t.a,{href:"#handling-large-datasets","aria-label":"handling large datasets permalink",className:"anchor before"},l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Handling large datasets"),"\n",l.createElement(t.ul,null,"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"Sampling"),": For extremely large datasets, you might sample a subset of data points to build a dendrogram. If carefully done, sampling can reveal the overall structure with far less computational expense."),"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"Mini-batch approaches"),": Mini-batch schemes can approximate hierarchical clustering by merging micro-clusters incrementally, somewhat similar to BIRCH's philosophy."),"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"External libraries"),": Some frameworks, such as Spark's MLlib, provide approximate hierarchical clustering or allow distributed computations to handle big data effectively."),"\n"),"\n",l.createElement(t.h3,{id:"computational-complexity-considerations",style:{position:"relative"}},l.createElement(t.a,{href:"#computational-complexity-considerations","aria-label":"computational complexity considerations permalink",className:"anchor before"},l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Computational complexity considerations"),"\n",l.createElement(t.ul,null,"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"Naive agglomerative clustering"),": Typically ",l.createElement(c.A,{text:"\\(O(n^2 \\log n)\\)"})," or ",l.createElement(c.A,{text:"\\(O(n^2)\\)"})," in time, requiring ",l.createElement(c.A,{text:"\\(O(n^2)\\)"})," memory for the distance matrix."),"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"Divisive clustering"),": Potentially even more expensive if you use repeated runs of partition-based methods at each split."),"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"Optimized implementations"),": Some libraries use efficient data structures or specialized algorithms (e.g., SLINK for single linkage) to reduce complexity."),"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"BIRCH"),": Has lower complexity in practice for massive datasets, but results can depend on input order and parameter tuning."),"\n"),"\n",l.createElement(t.h3,{id:"software-packages-and-libraries",style:{position:"relative"}},l.createElement(t.a,{href:"#software-packages-and-libraries","aria-label":"software packages and libraries permalink",className:"anchor before"},l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Software packages and libraries"),"\n",l.createElement(t.ul,null,"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"Python"),"\n",l.createElement(t.ul,null,"\n",l.createElement(t.li,null,l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">scipy.cluster.hierarchy</code>'}}),": Offers linkage functions (single, complete, average, Ward's) and dendrogram plotting."),"\n",l.createElement(t.li,null,l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">sklearn.cluster</code>'}}),": Includes ",l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">AgglomerativeClustering</code>'}})," and ",l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">Birch</code>'}})," classes."),"\n"),"\n"),"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"R"),"\n",l.createElement(t.ul,null,"\n",l.createElement(t.li,null,l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">hclust</code>'}}),": Classic hierarchical clustering method; pairs well with the ",l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">dendextend</code>'}})," package for advanced visualization."),"\n"),"\n"),"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"MATLAB"),"\n",l.createElement(t.ul,null,"\n",l.createElement(t.li,null,l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">linkage</code>'}})," and ",l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">cluster</code>'}})," functions, similar to those in SciPy."),"\n"),"\n"),"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"Spark MLlib"),"\n",l.createElement(t.ul,null,"\n",l.createElement(t.li,null,"For large-scale data, though the library primarily focuses on approximate or distributed approaches."),"\n"),"\n"),"\n"),"\n",l.createElement(t.p,null,"Here is a simple Python snippet showing agglomerative clustering using scikit-learn:"),"\n",l.createElement(s.A,{text:'\nimport numpy as np\nfrom sklearn.cluster import AgglomerativeClustering\nfrom sklearn.metrics import silhouette_score\n\n# Example data: 2D points\nX = np.array([\n    [1, 2],\n    [1.5, 1.8],\n    [5, 8],\n    [8, 8],\n    [1, 0.6],\n    [9, 11]\n])\n\n# Perform agglomerative clustering\n# n_clusters=None means you might use distance_threshold to decide merges\nagg = AgglomerativeClustering(n_clusters=2, linkage=\'ward\')\nlabels = agg.fit_predict(X)\n\nprint("Cluster labels:", labels)\n\n# Evaluate with silhouette score (just as an example)\nscore = silhouette_score(X, labels)\nprint("Silhouette score:", score)\n'}),"\n",l.createElement(t.p,null,"In this code, ",l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">AgglomerativeClustering</code>'}})," merges clusters using Ward's linkage until it forms the specified number of clusters (2 in this example). If you want to see the hierarchical structure, you can manually compute the linkage using ",l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">scipy.linkage</code>'}})," and plot a dendrogram with ",l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">scipy.dendrogram</code>'}}),"."),"\n",l.createElement(t.h2,{id:"applications-and-real-world-scenarios",style:{position:"relative"}},l.createElement(t.a,{href:"#applications-and-real-world-scenarios","aria-label":"applications and real world scenarios permalink",className:"anchor before"},l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Applications and real-world scenarios"),"\n",l.createElement(t.p,null,"Hierarchical clustering's interpretability makes it a strong candidate in exploratory data analysis. Some typical applications include:"),"\n",l.createElement(t.ul,null,"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"Market segmentation"),": Grouping customers based on behaviors, demographics, or purchasing patterns. A dendrogram can suggest how customer subgroups naturally form at different levels of specificity."),"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"Image segmentation"),": In computer vision, you can cluster pixel intensities or feature representations. Although other specialized methods are common, hierarchical clustering can reveal multi-level structures."),"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"Genomic data analysis"),": Clustering of gene expression patterns. The dendrogram can reflect how genes group by function, regulation, or organism classification."),"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"Customer behavior analysis"),": Extending beyond basic segmentation, you could track how clusters evolve over time, highlighting changes in customer preferences or loyalty."),"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"Document clustering"),": Grouping text documents by similarity for topic discovery, search optimization, or recommendation. Hierarchical clustering can expose finer or coarser topical divisions depending on the dendrogram cut."),"\n"),"\n",l.createElement(t.h2,{id:"advanced-topics",style:{position:"relative"}},l.createElement(t.a,{href:"#advanced-topics","aria-label":"advanced topics permalink",className:"anchor before"},l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Advanced topics"),"\n",l.createElement(t.p,null,"While the foundational concepts cover much of typical usage, there are several advanced extensions and integrations that can enhance or complement hierarchical clustering."),"\n",l.createElement(t.h3,{id:"hybrid-clustering-methods",style:{position:"relative"}},l.createElement(t.a,{href:"#hybrid-clustering-methods","aria-label":"hybrid clustering methods permalink",className:"anchor before"},l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Hybrid clustering methods"),"\n",l.createElement(t.p,null,"Sometimes you can combine hierarchical and partition-based methods for better performance or more robust results:"),"\n",l.createElement(t.ul,null,"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"Hierarchical initialization of k-means"),": First cluster the data hierarchically and pick cluster centroids (or representative points) as initial seeds for k-means, which helps avoid random initialization pitfalls."),"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"Refinement via hierarchical clustering"),": You could run a quick partition-based method (e.g., k-means) to obtain an initial grouping, then apply a small-scale hierarchical clustering on cluster centroids or medoids for a more nuanced final structure."),"\n"),"\n",l.createElement(t.h3,{id:"clustering-validity-indices-and-internal-measures",style:{position:"relative"}},l.createElement(t.a,{href:"#clustering-validity-indices-and-internal-measures","aria-label":"clustering validity indices and internal measures permalink",className:"anchor before"},l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Clustering validity indices and internal measures"),"\n",l.createElement(t.p,null,"To decide how many clusters to extract from a dendrogram, or to compare different linkage methods, you can use:"),"\n",l.createElement(t.ul,null,"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"Silhouette coefficient"),": Measures how similar each point is to its own cluster compared to other clusters."),"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"Calinski-Harabasz index"),": Based on the ratio of between-cluster dispersion to within-cluster dispersion. Higher values indicate better separation."),"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"Davies-Bouldin index"),': Evaluates the average "similarity" between each cluster and its most similar cluster. Lower is better.'),"\n"),"\n",l.createElement(t.h3,{id:"combining-hierarchical-clustering-with-other-techniques",style:{position:"relative"}},l.createElement(t.a,{href:"#combining-hierarchical-clustering-with-other-techniques","aria-label":"combining hierarchical clustering with other techniques permalink",className:"anchor before"},l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Combining hierarchical clustering with other techniques"),"\n",l.createElement(t.ul,null,"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"Dimensionality reduction"),": Hierarchical clustering can be more effective after PCA or manifold learning. This is especially valuable in fields like text analysis, where thousands of features can degrade distance metrics."),"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"Outlier detection"),": By inspecting the dendrogram, you can spot outliers that merge at a very high distance. You might exclude or separately analyze those points."),"\n",l.createElement(t.li,null,l.createElement(t.strong,null,"Ensemble clustering"),": Combine results of multiple clustering methods (including hierarchical) to obtain a consensus that may be more robust to noise or parameter choices."),"\n"),"\n",l.createElement(t.h2,{id:"conclusion-and-future-directions",style:{position:"relative"}},l.createElement(t.a,{href:"#conclusion-and-future-directions","aria-label":"conclusion and future directions permalink",className:"anchor before"},l.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Conclusion and future directions"),"\n",l.createElement(t.p,null,"Hierarchical clustering provides a flexible and intuitive framework for exploring multilevel structures in data. You can start with an agglomerative or divisive approach, choose an appropriate distance metric and linkage method, and visualize the resulting dendrogram to uncover how your data might naturally group together. This approach is particularly attractive in settings where interpretability is essential, as you can pinpoint not only the final clusters but also the order in which points or clusters merge."),"\n",l.createElement(t.p,null,"In modern machine learning practice, hierarchical clustering remains popular in smaller or medium-scale scenarios, or in specialized large-scale situations tackled by algorithms like BIRCH. Researchers have developed GPU-accelerated implementations and approximate strategies (e.g., hierarchical mini-batch clustering) to cope with the computational demands of massive datasets. Additionally, the rise of deep learning and representation learning means that you can combine hierarchical clustering with learned embeddings to extract even richer insights, especially in fields like image, text, and speech analysis."),"\n",l.createElement(t.p,null,"When applying hierarchical clustering, I recommend you:"),"\n",l.createElement(t.ol,null,"\n",l.createElement(t.li,null,"Carefully choose distance metrics and linkage methods in line with domain requirements."),"\n",l.createElement(t.li,null,"Consider dimensionality reduction if the feature space is large."),"\n",l.createElement(t.li,null,"Use cluster validity indices (e.g., silhouette coefficient) to guide the choice of cut height in the dendrogram."),"\n",l.createElement(t.li,null,"For large datasets, investigate specialized or approximate algorithms like BIRCH, or rely on distributed frameworks that scale hierarchical methods."),"\n"),"\n",l.createElement(t.p,null,"The future of hierarchical clustering likely includes further optimizations for big data, deeper integration with representation learning, and new ways of merging or splitting clusters that incorporate domain knowledge or advanced probabilistic approaches. Even as new clustering algorithms emerge, the interpretability and conceptual simplicity of hierarchical clustering make it an enduring, powerful tool in data science."))}var h=function(e){void 0===e&&(e={});const{wrapper:t}=Object.assign({},(0,i.RP)(),e.components);return t?l.createElement(t,e,l.createElement(m,e)):m(e)};var u=n(36710),d=n(58481),g=n.n(d),p=n(36310),f=n(87245),v=n(27042),E=n(59849),y=n(5591),b=n(61122),w=n(9219),x=n(33203),S=n(95751),C=n(94328),H=n(80791),k=n(78137);const M=e=>{let{toc:t}=e;if(!t||!t.items)return null;return l.createElement("nav",{className:H.R},l.createElement("ul",null,t.items.map(((e,t)=>l.createElement("li",{key:t},l.createElement("a",{href:e.url,onClick:t=>((e,t)=>{e.preventDefault();const n=t.replace("#",""),a=document.getElementById(n);a&&a.scrollIntoView({behavior:"smooth",block:"start"})})(t,e.url)},e.title),e.items&&l.createElement(M,{toc:{items:e.items}}))))))};function z(e){let{data:{mdx:t,allMdx:r,allPostImages:s},children:c}=e;const{frontmatter:o,body:m,tableOfContents:h}=t,u=o.index,d=o.slug.split("/")[1],E=r.nodes.filter((e=>e.frontmatter.slug.includes(`/${d}/`))).sort(((e,t)=>e.frontmatter.index-t.frontmatter.index)),H=E.findIndex((e=>e.frontmatter.index===u)),z=E[H+1],A=E[H-1],I=o.slug.replace(/\/$/,""),T=/[^/]*$/.exec(I)[0],L=`posts/${d}/content/${T}/`,{0:_,1:N}=(0,l.useState)(o.flagWideLayoutByDefault),{0:B,1:j}=(0,l.useState)(!1);var D;(0,l.useEffect)((()=>{j(!0);const e=setTimeout((()=>j(!1)),340);return()=>clearTimeout(e)}),[_]),"adventures"===d?D=w.cb:"research"===d?D=w.Qh:"thoughts"===d&&(D=w.T6);const V=g()(m).replace(/import .*? from .*?;/g,"").replace(/<.*?>/g,"").replace(/\{\/\*[\s\S]*?\*\/\}/g,"").trim().split(/\s+/).length,P=function(e){if(e<=10)return"~10 min";if(e<=20)return"~20 min";if(e<=30)return"~30 min";if(e<=40)return"~40 min";if(e<=50)return"~50 min";if(e<=60)return"~1 h";const t=Math.floor(e/60),n=e%60;return n<=30?`~${t}${n>0?".5":""} h`:`~${t+1} h`}(Math.ceil(V/D)+(o.extraReadTimeMin||0)),O=[{flag:o.flagDraft,component:()=>Promise.all([n.e(3231),n.e(8809)]).then(n.bind(n,28809))},{flag:o.flagMindfuckery,component:()=>Promise.all([n.e(3231),n.e(2471)]).then(n.bind(n,67709))},{flag:o.flagRewrite,component:()=>Promise.all([n.e(3231),n.e(6764)]).then(n.bind(n,62002))},{flag:o.flagOffensive,component:()=>Promise.all([n.e(3231),n.e(2443)]).then(n.bind(n,17681))},{flag:o.flagProfane,component:()=>Promise.all([n.e(3231),n.e(8048)]).then(n.bind(n,53286))},{flag:o.flagMultilingual,component:()=>Promise.all([n.e(3231),n.e(4069)]).then(n.bind(n,78831))},{flag:o.flagUnreliably,component:()=>Promise.all([n.e(3231),n.e(3417)]).then(n.bind(n,8179))},{flag:o.flagPolitical,component:()=>Promise.all([n.e(3231),n.e(5195)]).then(n.bind(n,30433))},{flag:o.flagCognitohazard,component:()=>Promise.all([n.e(3231),n.e(3175)]).then(n.bind(n,8413))},{flag:o.flagHidden,component:()=>Promise.all([n.e(3231),n.e(9556)]).then(n.bind(n,14794))}],{0:R,1:F}=(0,l.useState)([]);return(0,l.useEffect)((()=>{O.forEach((e=>{let{flag:t,component:n}=e;t&&n().then((e=>{F((t=>[].concat((0,a.A)(t),[e.default])))}))}))}),[]),l.createElement(v.P.div,{initial:{opacity:0},animate:{opacity:1},exit:{opacity:0},transition:{duration:.15}},l.createElement(y.A,{postNumber:o.index,date:o.date,updated:o.updated,readTime:P,difficulty:o.difficultyLevel,title:o.title,desc:o.desc,banner:o.banner,section:d,postKey:T,isMindfuckery:o.flagMindfuckery,mainTag:o.mainTag}),l.createElement("div",{style:{display:"flex",justifyContent:"flex-end",flexWrap:"wrap",maxWidth:"75%",marginLeft:"auto",paddingRight:"1vw",marginTop:"-6vh",marginBottom:"4vh"}},o.otherTags.map(((e,t)=>l.createElement("span",{key:t,className:`noselect ${k.MW}`,style:{margin:"0 5px 5px 0"}},e)))),l.createElement("div",{className:"postBody"},l.createElement(M,{toc:h})),l.createElement("br"),l.createElement("div",{style:{margin:"0 10% -2vh 30%",textAlign:"right"}},l.createElement(v.P.button,{className:`noselect ${C.pb}`,id:C.xG,onClick:()=>{N(!_)},whileTap:{scale:.93}},l.createElement(v.P.div,{className:S.DJ,key:_,initial:{opacity:0},animate:{opacity:1},exit:{opacity:0},transition:{duration:.3,ease:"easeInOut"}},_?"Switch to default layout":"Switch to wide layout"))),l.createElement("br"),l.createElement("div",{className:"postBody",style:{margin:_?"0 -14%":"",maxWidth:_?"200%":"",transition:"margin 1s ease, max-width 1s ease, padding 1s ease"}},l.createElement("div",{className:`${C.P_} ${B?C.Xn:C.qG}`},R.map(((e,t)=>l.createElement(e,{key:t}))),o.indexCourse?l.createElement(x.A,{index:o.indexCourse,category:o.courseCategoryName}):"",l.createElement(p.Z.Provider,{value:{images:s.nodes,basePath:L.replace(/\/$/,"")+"/"}},l.createElement(i.xA,{components:{Image:f.A}},c)))),l.createElement(b.A,{nextPost:z,lastPost:A,keyCurrent:T,section:d}))}function A(e){return l.createElement(z,e,l.createElement(h,e))}function I(e){var t,n,a,i,r;let{data:s}=e;const{frontmatter:c}=s.mdx,o=c.titleSEO||c.title,m=c.titleOG||o,h=c.titleTwitter||o,d=c.descSEO||c.desc,g=c.descOG||d,p=c.descTwitter||d,f=c.schemaType||"BlogPosting",v=c.keywordsSEO,y=c.date,b=c.updated||y,w=c.imageOG||(null===(t=c.banner)||void 0===t||null===(n=t.childImageSharp)||void 0===n||null===(a=n.gatsbyImageData)||void 0===a||null===(i=a.images)||void 0===i||null===(r=i.fallback)||void 0===r?void 0:r.src),x=c.imageAltOG||g,S=c.imageTwitter||w,C=c.imageAltTwitter||p,H=c.canonicalURL,k=c.flagHidden||!1,M=c.mainTag||"Posts",z=c.slug.split("/")[1]||"posts",{siteUrl:A}=(0,u.Q)(),I={"@context":"https://schema.org","@type":"BreadcrumbList",itemListElement:[{"@type":"ListItem",position:1,name:"Home",item:A},{"@type":"ListItem",position:2,name:M,item:`${A}/${c.slug.split("/")[1]}`},{"@type":"ListItem",position:3,name:o,item:`${A}${c.slug}`}]};return l.createElement(E.A,{title:o+" - avrtt.blog",titleOG:m,titleTwitter:h,description:d,descriptionOG:g,descriptionTwitter:p,schemaType:f,keywords:v,datePublished:y,dateModified:b,imageOG:w,imageAltOG:x,imageTwitter:S,imageAltTwitter:C,canonicalUrl:H,flagHidden:k,mainTag:M,section:z,type:"article"},l.createElement("script",{type:"application/ld+json"},JSON.stringify(I)))}},66501:function(e,t,n){n.d(t,{A:function(){return r}});var a=n(96540),i=n(3962),l="styles-module--tooltiptext--a263b";var r=e=>{let{text:t,isBadge:n=!1}=e;const{0:r,1:s}=(0,a.useState)(!1),c=(0,a.useRef)(null);return(0,a.useEffect)((()=>{function e(e){c.current&&!c.current.contains(e.target)&&s(!1)}return document.addEventListener("click",e),()=>{document.removeEventListener("click",e)}}),[]),a.createElement("span",{className:"styles-module--tooltipWrapper--75ebf",ref:c},a.createElement("img",{id:n?"styles-module--infoBadge--e3d66":"styles-module--info--26c1f",src:i.A,alt:"info",onClick:e=>{e.stopPropagation(),s((e=>!e))}}),a.createElement("span",{className:r?`${l} styles-module--visible--c063c`:l},t))}},96098:function(e,t,n){var a=n(96540),i=n(7978);t.A=e=>{let{text:t}=e;return a.createElement(i.A,null,t)}}}]);
//# sourceMappingURL=component---src-templates-post-js-content-file-path-src-pages-posts-research-hierarchical-clustering-mdx-832aef1d437c27d066fa.js.map