"use strict";(self.webpackChunkavrtt_blog=self.webpackChunkavrtt_blog||[]).push([[3721],{78375:function(e,n,t){t.r(n),t.d(n,{Head:function(){return z},PostTemplate:function(){return k},default:function(){return C}});var a=t(28453),l=t(96540),i=(t(61992),t(62087),t(90548));function r(e){const n=Object.assign({p:"p",h3:"h3",a:"a",span:"span",ul:"ul",li:"li",strong:"strong",ol:"ol",h2:"h2",h4:"h4",br:"br",hr:"hr"},(0,a.RP)(),e.components),{Image:t}=n;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Image",!0),l.createElement(l.Fragment,null,"\n",l.createElement("br"),"\n","\n","\n",l.createElement(n.p,null,"Logic has been a centerpiece of human thought for millennia, guiding everything from the philosophical underpinnings of mathematics to the design of modern digital circuits. Within the field of artificial intelligence, logic occupies a similarly profound role: it provides a formal framework for representing, manipulating, and inferring knowledge in a way that aspires toward human-like reasoning. But logic in AI is not simply about replicating old-style rule-based systems from decades past. Rather, it encapsulates a vibrant interplay between symbolic representation, computational complexity, and modern trends that link knowledge-based reasoning with data-driven approaches. In this chapter, I will introduce the fundamentals of AI logic, emphasizing how core logical formalisms empower agents to reason rigorously and systematically about the world."),"\n",l.createElement(n.h3,{id:"core-concepts-of-logic-in-ai",style:{position:"relative"}},l.createElement(n.a,{href:"#core-concepts-of-logic-in-ai","aria-label":"core concepts of logic in ai permalink",className:"anchor before"},l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Core Concepts of Logic in AI"),"\n",l.createElement(n.p,null,"When we say 'logic' in an AI context, we are talking about a formal system of symbols and rules that describe how to construct well-formed statements — and how to derive new statements from existing ones. The 'symbolic' nature of logic in AI stands in contrast to 'sub-symbolic' methods, such as those found in many neural network approaches, where knowledge is often represented in high-dimensional vectors rather than explicit symbolic constructs."),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Syntax"),": The syntax of a logic defines the symbols and rules for forming well-structured expressions."),"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Semantics"),": The semantics attach meaning to those symbols and expressions, determining how their truth values (or other properties) are ascertained."),"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Inference"),": Inference rules lay out the procedure to derive new formulas from existing ones, often driven by a concept of proof or model checking."),"\n"),"\n",l.createElement(n.p,null,"By leveraging these formal components, an AI system can engage in deductive reasoning — a hallmark of human intelligence that is grounded in centuries of philosophical thought but has clear computational constraints and opportunities."),"\n",l.createElement(n.h3,{id:"definition-of-logic-within-an-ai-context",style:{position:"relative"}},l.createElement(n.a,{href:"#definition-of-logic-within-an-ai-context","aria-label":"definition of logic within an ai context permalink",className:"anchor before"},l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),'Definition of "logic" within an AI context'),"\n",l.createElement(n.p,null,'Broadly, logic in AI is the computational use of formal logical systems to encode knowledge about a domain and to perform automated reasoning over that domain. For instance, a system might store facts such as "All wumpuses are dangerous" and "Wumpus1 is a wumpus" and deduce "Wumpus1 is dangerous" by applying modus ponens — a canonical logical rule. Because logic is unambiguous and verifiable, it provides a powerful framework for AI systems that need robust, explainable decision-making processes.'),"\n",l.createElement(n.h3,{id:"importance-of-formal-reasoning-for-machine-intelligence",style:{position:"relative"}},l.createElement(n.a,{href:"#importance-of-formal-reasoning-for-machine-intelligence","aria-label":"importance of formal reasoning for machine intelligence permalink",className:"anchor before"},l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Importance of formal reasoning for machine intelligence"),"\n",l.createElement(n.p,null,"Formal reasoning is crucial for:"),"\n",l.createElement(n.ol,null,"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Explainability"),": Logical derivations can be traced, scrutinized, and explained, which is desirable in critical domains such as medicine, law, or finance."),"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Verification"),": Logical models allow for rigorous checking of correctness, especially in safety-critical systems where errors can be catastrophic."),"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Knowledge representation"),": Logic-based systems can represent complex relationships, constraints, and rules more transparently than many sub-symbolic approaches."),"\n"),"\n",l.createElement(n.p,null,"Such strengths have kept logic at the heart of AI research even amidst the dominance of data-driven machine learning in recent years. Novel hybrid systems often combine symbolic logic with neural networks, demonstrating that logic continues to shape cutting-edge research in areas like knowledge graphs, reasoning-based natural language processing, and reinforcement learning with symbolic constraints."),"\n",l.createElement(n.h3,{id:"overview-of-symbolic-vs-non-symbolic-ai-approaches",style:{position:"relative"}},l.createElement(n.a,{href:"#overview-of-symbolic-vs-non-symbolic-ai-approaches","aria-label":"overview of symbolic vs non symbolic ai approaches permalink",className:"anchor before"},l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Overview of symbolic vs. non-symbolic AI approaches"),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Symbolic (classical) AI"),": Relies on explicit rules, logic, and structured knowledge representation. Systems built this way can be more interpretable and reasoned about in a formal manner."),"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Sub-symbolic (non-symbolic) AI"),": Emphasizes representations such as neural network weights or latent vectors in large models. While often more scalable and robust for big data tasks, sub-symbolic approaches can be less immediately interpretable."),"\n"),"\n",l.createElement(n.p,null,"Many modern AI solutions combine these paradigms, seeking the best of both worlds: the interpretability, constraint handling, and rule-based reasoning from symbolic approaches, and the powerful pattern recognition and generalization abilities from subsymbolic methods. This synergy is often referred to as ",l.createElement(n.strong,null,"neural-symbolic AI"),"."),"\n",l.createElement(n.h3,{id:"historical-development-and-motivation",style:{position:"relative"}},l.createElement(n.a,{href:"#historical-development-and-motivation","aria-label":"historical development and motivation permalink",className:"anchor before"},l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Historical development and motivation"),"\n",l.createElement(n.p,null,"Centuries ago, Aristotle formulated syllogisms that epitomize the earliest formal approach to logic. Then, in the late 19th century, Gottlob Frege introduced predicate logic (also known as first-order logic), providing a foundation for many of the advanced frameworks we now see in formal AI reasoning. As mathematics and logic advanced through the 20th century — with achievements by thinkers such as Bertrand Russell, Alfred North Whitehead, Kurt Gödel, Alonzo Church, and Alan Turing — the possibility of mechanizing logical deduction gained momentum."),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"Key milestones")," in AI logic:"),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Logic Theorist (1956)")," by Allen Newell, Herbert Simon, and Cliff Shaw: Arguably the first AI program, which used logical rules to prove theorems in propositional calculus."),"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Prolog (1970s)"),": A logic programming language pioneered by Alain Colmerauer, Robert Kowalski, and others, which enabled a more direct expression of logical rules and queries."),"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Resolution principle (1965)")," by J. Alan Robinson: Provided a unifying framework for automated theorem proving in first-order logic."),"\n"),"\n",l.createElement(n.h3,{id:"why-logic-remains-relevant-in-modern-ai-research",style:{position:"relative"}},l.createElement(n.a,{href:"#why-logic-remains-relevant-in-modern-ai-research","aria-label":"why logic remains relevant in modern ai research permalink",className:"anchor before"},l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Why logic remains relevant in modern AI research"),"\n",l.createElement(n.p,null,"While purely rule-based AI has sometimes struggled with issues of brittleness and scalability, logic has sustained its importance. Modern AI research employs logic to ensure consistency, to handle rare or zero-shot scenarios via explicit knowledge representation, and to support interpretability in contexts where black-box solutions might be insufficient. For instance, 'knowledge graphs' used by major internet companies rely heavily on logical relationships between entities. Meanwhile, 'semantic web' standards also use description logics under the hood, and advanced 'knowledge-based' neural architectures often incorporate or are inspired by logical constraints."),"\n",l.createElement(n.p,null,"As an AI researcher, I see logic as a fundamental building block for building or analyzing systems that require more than just correlation-based pattern extraction — and the chapters that follow will illuminate how this is so."),"\n",l.createElement(n.h2,{id:"2-foundations-of-logical-agents-and-knowledge-based-systems",style:{position:"relative"}},l.createElement(n.a,{href:"#2-foundations-of-logical-agents-and-knowledge-based-systems","aria-label":"2 foundations of logical agents and knowledge based systems permalink",className:"anchor before"},l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"2. Foundations of logical agents and knowledge-based systems"),"\n",l.createElement(n.h3,{id:"defining-logical-agents",style:{position:"relative"}},l.createElement(n.a,{href:"#defining-logical-agents","aria-label":"defining logical agents permalink",className:"anchor before"},l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Defining logical agents"),"\n",l.createElement(n.p,null,"A ",l.createElement(n.strong,null,"logical agent")," is any autonomous entity that perceives its environment, holds an internal knowledge representation in a logical form, and uses logical inference to decide upon actions that further its goals or respond to external stimuli. At a high level:"),"\n",l.createElement(n.ol,null,"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Perception"),": The agent acquires information from the environment (e.g., via sensors)."),"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Knowledge representation"),": The agent maintains a knowledge base of facts, rules, and axioms."),"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Inference"),": The agent applies a logical inference procedure to derive new facts or check for the truth of existing facts."),"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Action"),": The agent acts based on conclusions from the inference process, then updates its knowledge base if necessary."),"\n"),"\n",l.createElement(n.h3,{id:"how-logical-agents-perceive-reason-and-act",style:{position:"relative"}},l.createElement(n.a,{href:"#how-logical-agents-perceive-reason-and-act","aria-label":"how logical agents perceive reason and act permalink",className:"anchor before"},l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"How logical agents perceive, reason, and act"),"\n",l.createElement(n.p,null,"In a typical cycle, a logical agent might observe new data or events, incorporate that information into its knowledge base, and then use an inference engine to assess which rules or plans are relevant. For instance, in a simplified 'smart home' scenario: if a sensor reading reveals that the temperature is below a certain threshold, the agent might recall a rule stating \"When the temperature is below 65°F, turn the heater on,\" and thus send a command to the heater. The chain of reasoning in such an agent is explicit and auditable, an attribute that fosters high trust in safety-critical applications."),"\n",l.createElement(n.h3,{id:"advantages-of-explicitly-representing-knowledge",style:{position:"relative"}},l.createElement(n.a,{href:"#advantages-of-explicitly-representing-knowledge","aria-label":"advantages of explicitly representing knowledge permalink",className:"anchor before"},l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Advantages of explicitly representing knowledge"),"\n",l.createElement(n.p,null,"Some prominent benefits:"),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Transparency"),": The reasoning chain (in the form of logical derivations) can be inspected."),"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Declarative specification"),": One can modify or add knowledge simply by updating logical formulas, without recoding large parts of the system."),"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Reusability"),": The same knowledge base can be used by different inference algorithms for different tasks (e.g., planning, diagnosis)."),"\n"),"\n",l.createElement(n.h3,{id:"common-architectures-for-logical-agents",style:{position:"relative"}},l.createElement(n.a,{href:"#common-architectures-for-logical-agents","aria-label":"common architectures for logical agents permalink",className:"anchor before"},l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Common architectures for logical agents"),"\n",l.createElement(n.p,null,"Logical agents can be implemented with architectures that separate the ",l.createElement(n.strong,null,"knowledge base")," from the ",l.createElement(n.strong,null,"inference engine"),". For instance:"),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,"A 'production system' architecture: Contains production rules (if-then rules) and a working memory that triggers these rules."),"\n",l.createElement(n.li,null,"A 'logic programming' architecture: Typically uses a resolution-based inference method (like Prolog) to answer queries by logically deriving solutions from a set of axioms and rules."),"\n"),"\n",l.createElement(n.h3,{id:"knowledge-based-agents",style:{position:"relative"}},l.createElement(n.a,{href:"#knowledge-based-agents","aria-label":"knowledge based agents permalink",className:"anchor before"},l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Knowledge-based agents"),"\n",l.createElement(n.p,null,"In many texts (cf. Russell and Norvig, 'Artificial Intelligence: A Modern Approach'), logical agents are often referred to as 'knowledge-based agents' when their main functionality revolves around storing and manipulating knowledge in a structured, logical form."),"\n",l.createElement(n.h4,{id:"the-concept-of-a-knowledge-base-kb-and-inference-engine",style:{position:"relative"}},l.createElement(n.a,{href:"#the-concept-of-a-knowledge-base-kb-and-inference-engine","aria-label":"the concept of a knowledge base kb and inference engine permalink",className:"anchor before"},l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"The concept of a knowledge base (KB) and inference engine"),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Knowledge base"),": A structured repository of facts, axioms, rules, and domain constraints. For example, in a medical expert system, the KB might contain statements about diseases, symptoms, tests, and potential treatments."),"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Inference engine"),": The 'brain' that processes the KB, applying inference rules to deduce new facts or check the consistency of existing facts."),"\n"),"\n",l.createElement(n.p,null,"The inference engine can use multiple reasoning strategies, such as forward chaining or backward chaining, described later in this article."),"\n",l.createElement(n.h4,{id:"steps-in-building-a-kb",style:{position:"relative"}},l.createElement(n.a,{href:"#steps-in-building-a-kb","aria-label":"steps in building a kb permalink",className:"anchor before"},l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Steps in building a KB"),"\n",l.createElement(n.ol,null,"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Knowledge acquisition"),": Gather domain information from experts, data sources, or automatic knowledge extraction tools."),"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Representation"),": Decide on the logic form (e.g., propositional, first-order, description logics) and encode the knowledge carefully."),"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Maintenance"),": Update the KB as domain knowledge evolves, or as new facts become available. Check for consistency and correctness."),"\n"),"\n",l.createElement(n.h4,{id:"trade-offs-expressiveness-vs-complexity",style:{position:"relative"}},l.createElement(n.a,{href:"#trade-offs-expressiveness-vs-complexity","aria-label":"trade offs expressiveness vs complexity permalink",className:"anchor before"},l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Trade-offs: expressiveness vs. complexity"),"\n",l.createElement(n.p,null,"A well-known tension in knowledge representation is that more expressive logics (like full first-order logic or higher-order logics) can encode more complex and nuanced statements about the world — but at the expense of computational tractability. Meanwhile, simpler logics (like propositional logic) allow for efficient reasoning but cannot capture the richer structures we might need for advanced applications."),"\n",l.createElement(n.h3,{id:"illustration-the-wumpus-world",style:{position:"relative"}},l.createElement(n.a,{href:"#illustration-the-wumpus-world","aria-label":"illustration the wumpus world permalink",className:"anchor before"},l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Illustration: The Wumpus World"),"\n",l.createElement(n.p,null,'The "Wumpus World" is a classic toy problem often used to illustrate how logical agents operate in uncertain, partially observable environments:'),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,"The agent explores a grid-based cave."),"\n",l.createElement(n.li,null,"Some cells contain pits, making them deadly if the agent enters them."),"\n",l.createElement(n.li,null,"One cell contains a fearsome 'Wumpus' creature, which is lethal if encountered."),"\n",l.createElement(n.li,null,"The agent receives small signals like breeze (if adjacent to a pit) or stench (if adjacent to the Wumpus) but does not know exactly where the hazards are from the outset."),"\n",l.createElement(n.li,null,"The goal is to find the hidden gold and exit safely."),"\n"),"\n",l.createElement(n.h4,{id:"why-it-is-a-classic-model-for-demonstrating-logical-reasoning",style:{position:"relative"}},l.createElement(n.a,{href:"#why-it-is-a-classic-model-for-demonstrating-logical-reasoning","aria-label":"why it is a classic model for demonstrating logical reasoning permalink",className:"anchor before"},l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Why it is a classic model for demonstrating logical reasoning"),"\n",l.createElement(n.ol,null,"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Partial Observability"),": The agent only senses local clues, but must infer global facts (e.g., the probable location of the Wumpus or pits)."),"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Uncertainty"),": The environment layout is unknown; logical reasoning helps reduce uncertainty as the agent gathers evidence."),"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Symbolic Representation"),": Each cell is described by propositional variables such as ",l.createElement(i.A,{text:"\\( P_{x,y} \\)"})," indicating a pit at coordinates ",l.createElement(i.A,{text:"\\((x,y)\\)"}),", or ",l.createElement(i.A,{text:"\\( W_{x,y} \\)"})," for a Wumpus. These are combined with rules about adjacency and detection."),"\n"),"\n",l.createElement(n.h4,{id:"key-insights-gained-from-the-wumpus-world-example",style:{position:"relative"}},l.createElement(n.a,{href:"#key-insights-gained-from-the-wumpus-world-example","aria-label":"key insights gained from the wumpus world example permalink",className:"anchor before"},l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Key insights gained from the Wumpus World example"),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,"Logical inference can handle incomplete information and systematically reduce uncertainty."),"\n",l.createElement(n.li,null,"Even a relatively simple environment can quickly explode in complexity without carefully chosen inference and representation mechanisms."),"\n",l.createElement(n.li,null,"Symbolic methods, such as propositional logic, illustrate a clear chain of reasoning, hence it is widely used in AI textbooks and courses."),"\n"),"\n",l.createElement(n.h2,{id:"3-propositional-logic",style:{position:"relative"}},l.createElement(n.a,{href:"#3-propositional-logic","aria-label":"3 propositional logic permalink",className:"anchor before"},l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"3. Propositional logic"),"\n",l.createElement(n.p,null,"Propositional logic is the most elementary form of logic, focusing on ",l.createElement(n.strong,null,"simple, atomic propositions")," that can be true or false, combined with logical connectives like AND, OR, NOT, and IMPLIES. It lacks the ability to express quantified statements such as 'for all x' or 'there exists an x', but it is straightforward to implement and reason about at small scales."),"\n",l.createElement(n.h3,{id:"syntax-and-semantics",style:{position:"relative"}},l.createElement(n.a,{href:"#syntax-and-semantics","aria-label":"syntax and semantics permalink",className:"anchor before"},l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Syntax and semantics"),"\n",l.createElement(n.ol,null,"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Atomic propositions"),": These are symbols such as ",l.createElement(i.A,{text:"\\( p \\)"}),", ",l.createElement(i.A,{text:"\\( q \\)"})," (or spelled-out statements like 'It is raining'), each can be true or false."),"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Connectives"),": ",l.createElement(i.A,{text:"\\( \\land \\)"})," (AND), ",l.createElement(i.A,{text:"\\( \\lor \\)"})," (OR), ",l.createElement(i.A,{text:"\\( \\lnot \\)"})," (NOT), ",l.createElement(i.A,{text:"\\( \\rightarrow \\)"})," (IMPLIES), ",l.createElement(i.A,{text:"\\( \\leftrightarrow \\)"})," (IF AND ONLY IF)."),"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Well-formed formulas"),": Constructed from atomic propositions by applying connectives, for example ",l.createElement(i.A,{text:"\\( (p \\land \\lnot q) \\rightarrow r \\)"}),"."),"\n"),"\n",l.createElement(n.h4,{id:"truth-tables-and-tautologies",style:{position:"relative"}},l.createElement(n.a,{href:"#truth-tables-and-tautologies","aria-label":"truth tables and tautologies permalink",className:"anchor before"},l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Truth tables and tautologies"),"\n",l.createElement(n.p,null,"The semantics of propositional logic revolve around assigning truth values (true or false) to atomic propositions, then computing the truth value of compound propositions via truth tables. A ",l.createElement(n.strong,null,"tautology")," is a formula that evaluates to true under every possible truth assignment to its variables. For example, ",l.createElement(i.A,{text:"\\( p \\lor \\lnot p \\)"})," is a tautology (the law of excluded middle)."),"\n",l.createElement(n.p,null,"A ",l.createElement(n.strong,null,"contradiction")," always evaluates to false, while a ",l.createElement(n.strong,null,"contingency")," is neither always true nor always false."),"\n",l.createElement(n.h3,{id:"theorem-proving-in-propositional-logic",style:{position:"relative"}},l.createElement(n.a,{href:"#theorem-proving-in-propositional-logic","aria-label":"theorem proving in propositional logic permalink",className:"anchor before"},l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Theorem proving in propositional logic"),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"Theorem proving")," in propositional logic is the process of checking whether a formula (or set of formulas) logically implies another formula, or verifying if a formula is always true given certain premises."),"\n",l.createElement(n.h4,{id:"core-algorithms-eg-dpll-sat-solvers",style:{position:"relative"}},l.createElement(n.a,{href:"#core-algorithms-eg-dpll-sat-solvers","aria-label":"core algorithms eg dpll sat solvers permalink",className:"anchor before"},l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Core algorithms (e.g., DPLL, SAT solvers)"),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"DPLL (Davis–Putnam–Logemann–Loveland)"),": A backtracking-based search algorithm that tries to incrementally assign truth values to variables and prune inconsistent assignments."),"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Modern SAT solvers"),": Extend DPLL with advanced heuristics and data structures (e.g., conflict-driven clause learning) that can solve extremely large SAT (satisfiability) problems efficiently. The success of these solvers has made propositional logic surprisingly scalable for certain real-world tasks, including software/hardware verification and planning."),"\n"),"\n",l.createElement(n.h4,{id:"practical-implications-for-small-vs-large-scale-problems",style:{position:"relative"}},l.createElement(n.a,{href:"#practical-implications-for-small-vs-large-scale-problems","aria-label":"practical implications for small vs large scale problems permalink",className:"anchor before"},l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Practical implications for small vs. large-scale problems"),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Small scale"),": Hand-constructed rules in propositional logic can be easy to debug and interpret, making them attractive for educational or controlled environments (like the Wumpus World)."),"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Large scale"),": While SAT solvers excel at certain classes of large Boolean problems, naive enumerations of all possible assignments are ",l.createElement(i.A,{text:"\\( \\mathcal{O}(2^n) \\)"})," in the worst case (where ",l.createElement(i.A,{text:"\\(n\\)"})," is the number of propositional variables), highlighting the importance of specialized algorithms and heuristics."),"\n"),"\n",l.createElement(n.h3,{id:"effective-propositional-model-checking",style:{position:"relative"}},l.createElement(n.a,{href:"#effective-propositional-model-checking","aria-label":"effective propositional model checking permalink",className:"anchor before"},l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Effective propositional model checking"),"\n",l.createElement(n.p,null,"Model checking is a technique for verifying if a system (often described as a finite state machine) meets a given specification (often a logical formula). In propositional model checking:"),"\n",l.createElement(n.ol,null,"\n",l.createElement(n.li,null,"The system states and transitions are enumerated in a structure such as a Kripke model."),"\n",l.createElement(n.li,null,"The specification might be given in a propositional temporal logic (though purely propositional model checking is simpler)."),"\n",l.createElement(n.li,null,"The tool verifies whether all possible paths through the system satisfy or violate the specification."),"\n"),"\n",l.createElement(n.h4,{id:"concepts-completeness-correctness-complexity",style:{position:"relative"}},l.createElement(n.a,{href:"#concepts-completeness-correctness-complexity","aria-label":"concepts completeness correctness complexity permalink",className:"anchor before"},l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Concepts: completeness, correctness, complexity"),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Completeness"),": A system or algorithm is 'complete' if it can derive any valid formula in the logic."),"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Correctness")," (soundness): No invalid formulas are derived."),"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Complexity"),": Even though propositional logic is less expressive than first-order logic, some tasks like SAT and certain model checking scenarios can still be NP-complete or harder."),"\n"),"\n",l.createElement(n.h3,{id:"building-agents-using-propositional-logic",style:{position:"relative"}},l.createElement(n.a,{href:"#building-agents-using-propositional-logic","aria-label":"building agents using propositional logic permalink",className:"anchor before"},l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Building agents using propositional logic"),"\n",l.createElement(n.h4,{id:"designing-rule-based-systems-for-simple-environments",style:{position:"relative"}},l.createElement(n.a,{href:"#designing-rule-based-systems-for-simple-environments","aria-label":"designing rule based systems for simple environments permalink",className:"anchor before"},l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Designing rule-based systems for simple environments"),"\n",l.createElement(n.p,null,"Propositional logic can be used directly to build a simple rule-based agent by enumerating relevant propositions (e.g., 'It is hot outside') and codifying rules that link these propositions to actions (e.g., 'If it is hot outside, turn on the air conditioning'). This can be quite effective for small or tightly constrained domains."),"\n",l.createElement(n.h4,{id:"strengths-clarity-simplicity",style:{position:"relative"}},l.createElement(n.a,{href:"#strengths-clarity-simplicity","aria-label":"strengths clarity simplicity permalink",className:"anchor before"},l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Strengths: clarity, simplicity"),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,"Easy to parse logically: You either have a proposition or you don't."),"\n",l.createElement(n.li,null,"Debugging is straightforward: Just evaluate truth assignments or check for contradictions."),"\n"),"\n",l.createElement(n.h4,{id:"limitations-lack-of-expressiveness-for-complex-domains",style:{position:"relative"}},l.createElement(n.a,{href:"#limitations-lack-of-expressiveness-for-complex-domains","aria-label":"limitations lack of expressiveness for complex domains permalink",className:"anchor before"},l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Limitations: lack of expressiveness for complex domains"),"\n",l.createElement(n.p,null,"Propositional logic cannot naturally represent statements involving objects, relations, or quantifiers. If you want to say 'All Wumpuses that are next to a pit are dangerous in the morning but not in the afternoon', propositional logic quickly becomes unwieldy, requiring you to create potentially thousands of propositions for each combination of conditions."),"\n",l.createElement(n.h2,{id:"4-first-order-logic",style:{position:"relative"}},l.createElement(n.a,{href:"#4-first-order-logic","aria-label":"4 first order logic permalink",className:"anchor before"},l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"4. First-order logic"),"\n",l.createElement(n.p,null,"First-order logic (FOL), also known as first-order predicate logic, extends propositional logic by adding ",l.createElement(n.strong,null,"quantifiers")," (",l.createElement(i.A,{text:"\\( \\forall \\)"})," and ",l.createElement(i.A,{text:"\\( \\exists \\)"}),"), ",l.createElement(n.strong,null,"variables"),", ",l.createElement(n.strong,null,"predicates"),", and ",l.createElement(n.strong,null,"functions"),". It is vastly more expressive, allowing AI systems to directly talk about objects and the relationships among them."),"\n",l.createElement(n.h3,{id:"expanded-representation-capabilities",style:{position:"relative"}},l.createElement(n.a,{href:"#expanded-representation-capabilities","aria-label":"expanded representation capabilities permalink",className:"anchor before"},l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Expanded representation capabilities"),"\n",l.createElement(n.h4,{id:"variables-quantifiers-and-predicates",style:{position:"relative"}},l.createElement(n.a,{href:"#variables-quantifiers-and-predicates","aria-label":"variables quantifiers and predicates permalink",className:"anchor before"},l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Variables, quantifiers, and predicates"),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Variables"),": Symbols like ",l.createElement(i.A,{text:"\\( x \\)"}),", ",l.createElement(i.A,{text:"\\( y \\)"})," that can refer to elements of a domain."),"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Quantifiers"),": ",l.createElement(i.A,{text:"\\( \\forall x \\)"})," (for all x) or ",l.createElement(i.A,{text:"\\( \\exists x \\)"})," (there exists an x)."),"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Predicates"),": Symbols like ",l.createElement(i.A,{text:"\\( Loves(x, y) \\)"}),", ",l.createElement(i.A,{text:"\\( IsDangerous(x) \\)"}),", that express relations or properties."),"\n"),"\n",l.createElement(n.p,null,"Rather than enumerating statements for each possible object, FOL's quantifiers allow you to declare general truths, e.g., ",l.createElement(i.A,{text:"\\( \\forall x: Pit(x) \\rightarrow Dangerous(x) \\)"}),", meaning 'All pits are dangerous'."),"\n",l.createElement(n.h3,{id:"syntax-and-semantics-of-fol",style:{position:"relative"}},l.createElement(n.a,{href:"#syntax-and-semantics-of-fol","aria-label":"syntax and semantics of fol permalink",className:"anchor before"},l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Syntax and semantics of FOL"),"\n",l.createElement(n.h4,{id:"formal-rules-governing-term-formation-and-well-formed-formulas",style:{position:"relative"}},l.createElement(n.a,{href:"#formal-rules-governing-term-formation-and-well-formed-formulas","aria-label":"formal rules governing term formation and well formed formulas permalink",className:"anchor before"},l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Formal rules governing term formation and well-formed formulas"),"\n",l.createElement(n.ol,null,"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Terms"),": Variables (",l.createElement(i.A,{text:"\\( x \\)"}),"), constants (",l.createElement(i.A,{text:"\\( a \\)"}),", ",l.createElement(i.A,{text:"\\( b \\)"}),"), or function applications (",l.createElement(i.A,{text:"\\( f(x) \\)"}),", ",l.createElement(i.A,{text:"\\( g(a, x) \\)"}),")."),"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Atomic formulas"),": Predicates applied to terms, e.g., ",l.createElement(i.A,{text:"\\( Loves(x, y) \\)"}),"."),"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Formulas"),": Built up from atomic formulas using logical connectives, quantifiers, etc."),"\n"),"\n",l.createElement(n.h4,{id:"domain-of-discourse-interpretation-and-models",style:{position:"relative"}},l.createElement(n.a,{href:"#domain-of-discourse-interpretation-and-models","aria-label":"domain of discourse interpretation and models permalink",className:"anchor before"},l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Domain of discourse, interpretation, and models"),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,"A ",l.createElement(n.strong,null,"domain of discourse")," is the set of all possible objects that variables can refer to (e.g., all people, all squares in the Wumpus World)."),"\n",l.createElement(n.li,null,"An ",l.createElement(n.strong,null,"interpretation")," assigns specific meanings to the predicate symbols, function symbols, and constants (e.g., ",l.createElement(i.A,{text:"\\( Loves \\)"})," might be interpreted as a relation over pairs of humans)."),"\n",l.createElement(n.li,null,"A formula is ",l.createElement(n.strong,null,"true in a model")," if, given the interpretation of symbols and the domain of discourse, the formula holds under standard logical semantics."),"\n"),"\n",l.createElement(n.h3,{id:"building-ai-systems-with-first-order-logic",style:{position:"relative"}},l.createElement(n.a,{href:"#building-ai-systems-with-first-order-logic","aria-label":"building ai systems with first order logic permalink",className:"anchor before"},l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Building AI systems with first-order logic"),"\n",l.createElement(n.h4,{id:"knowledge-engineering-and-domain-modeling",style:{position:"relative"}},l.createElement(n.a,{href:"#knowledge-engineering-and-domain-modeling","aria-label":"knowledge engineering and domain modeling permalink",className:"anchor before"},l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Knowledge engineering and domain modeling"),"\n",l.createElement(n.p,null,"Because first-order logic can express statements about classes of objects, it is widely employed in knowledge representation tasks such as ontologies or conceptual models in domains like biology, medicine, or even mathematics. Engineers can specify rules like:"),"\n",l.createElement(i.A,{text:"\\[\n\\forall person\\, \\forall object: (Owns(person, object) \\land Antique(object)) \\rightarrow Insurable(person, object).\n\\]"}),"\n",l.createElement(n.p,null,"Variables:"),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,l.createElement(i.A,{text:"\\(person\\)"}),": A human in the domain"),"\n",l.createElement(n.li,null,l.createElement(i.A,{text:"\\(object\\)"}),": A physical or conceptual item"),"\n"),"\n",l.createElement(n.p,null,"This states that if a person owns an antique object, then that person is insurable (in some context that might be relevant to the domain)."),"\n",l.createElement(n.h4,{id:"storage-and-manipulation-of-larger-more-nuanced-knowledge-bases",style:{position:"relative"}},l.createElement(n.a,{href:"#storage-and-manipulation-of-larger-more-nuanced-knowledge-bases","aria-label":"storage and manipulation of larger more nuanced knowledge bases permalink",className:"anchor before"},l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Storage and manipulation of larger, more nuanced knowledge bases"),"\n",l.createElement(n.p,null,"Systems like ",l.createElement(n.strong,null,"Prolog")," or ",l.createElement(n.strong,null,"description logic-based reasoners")," (like those for OWL ontologies) can store thousands or even millions of logical facts and rules. While large-scale FOL reasoning can be computationally challenging, specialized reasoners use advanced algorithms, caching, and partial compilation to keep inferences tractable."),"\n",l.createElement(n.h3,{id:"inference-mechanisms",style:{position:"relative"}},l.createElement(n.a,{href:"#inference-mechanisms","aria-label":"inference mechanisms permalink",className:"anchor before"},l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Inference mechanisms"),"\n",l.createElement(n.h4,{id:"unification-matching-predicates-with-variables",style:{position:"relative"}},l.createElement(n.a,{href:"#unification-matching-predicates-with-variables","aria-label":"unification matching predicates with variables permalink",className:"anchor before"},l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Unification: matching predicates with variables"),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"Unification")," is the process of finding a substitution for variables that makes two logical expressions identical. For example:"),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,"\n",l.createElement(i.A,{text:"\\( P(x, f(y)) \\)"}),"\n"),"\n",l.createElement(n.li,null,"\n",l.createElement(i.A,{text:"\\( P(g(z), f(z)) \\)"}),"\n"),"\n"),"\n",l.createElement(n.p,null,"Can unify if we find ",l.createElement(i.A,{text:"\\( x = g(z) \\)"})," and ",l.createElement(i.A,{text:"\\( y = z \\)"}),". This yields ",l.createElement(i.A,{text:"\\( P(g(z), f(z)) \\)"})," as the unified expression."),"\n",l.createElement(n.h4,{id:"resolution-refutation-based-proof-techniques",style:{position:"relative"}},l.createElement(n.a,{href:"#resolution-refutation-based-proof-techniques","aria-label":"resolution refutation based proof techniques permalink",className:"anchor before"},l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Resolution: refutation-based proof techniques"),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"Resolution")," is a fundamental rule of inference for first-order logic, building on unification. By converting formulas to ",l.createElement(n.strong,null,"conjunctive normal form")," (CNF) and applying resolution steps, an automated theorem prover can check whether adding the negation of a desired conclusion to a knowledge base produces a contradiction — if so, the original conclusion is entailed by the knowledge base. This is known as proof by refutation."),"\n",l.createElement(n.h4,{id:"forward-and-backward-chaining-in-fol-systems",style:{position:"relative"}},l.createElement(n.a,{href:"#forward-and-backward-chaining-in-fol-systems","aria-label":"forward and backward chaining in fol systems permalink",className:"anchor before"},l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Forward and backward chaining in FOL systems"),"\n",l.createElement(n.ol,null,"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Forward chaining"),": Starts with known facts, applies inference rules to produce new facts, repeating until the goal is found or no new inferences can be drawn. This is ",l.createElement(n.strong,null,"data-driven"),"."),"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Backward chaining"),": Starts from a goal (query) and recursively tries to prove any premises that would satisfy that goal. This is ",l.createElement(n.strong,null,"goal-driven")," and is the approach used by Prolog, which attempts to unify the query with known rules or facts and then tries to fulfill the resulting sub-goals."),"\n"),"\n",l.createElement(n.h3,{id:"practical-challenges",style:{position:"relative"}},l.createElement(n.a,{href:"#practical-challenges","aria-label":"practical challenges permalink",className:"anchor before"},l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Practical challenges"),"\n",l.createElement(n.h4,{id:"higher-computational-complexity-compared-to-propositional-logic",style:{position:"relative"}},l.createElement(n.a,{href:"#higher-computational-complexity-compared-to-propositional-logic","aria-label":"higher computational complexity compared to propositional logic permalink",className:"anchor before"},l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Higher computational complexity compared to propositional logic"),"\n",l.createElement(n.p,null,"First-order logic is semi-decidable in general. The problem of determining whether a set of FOL sentences entails a particular conclusion is ",l.createElement(n.strong,null,"undecidable")," in full generality. However, many restricted subsets of first-order logic are decidable, and practical heuristics often suffice for real-world tasks."),"\n",l.createElement(n.h4,{id:"handling-incomplete-or-inconsistent-information",style:{position:"relative"}},l.createElement(n.a,{href:"#handling-incomplete-or-inconsistent-information","aria-label":"handling incomplete or inconsistent information permalink",className:"anchor before"},l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Handling incomplete or inconsistent information"),"\n",l.createElement(n.p,null,"In the real world, knowledge bases may be incomplete (missing critical facts) or may contain contradictions (due to erroneous data). First-order logic typically assumes a closed-world scenario or consistent data. Handling real-world conditions often requires ",l.createElement(n.strong,null,"non-monotonic")," or ",l.createElement(n.strong,null,"uncertain")," extensions to classical logic (see later chapters)."),"\n",l.createElement(n.h2,{id:"5-propositional-vs-first-order-logic",style:{position:"relative"}},l.createElement(n.a,{href:"#5-propositional-vs-first-order-logic","aria-label":"5 propositional vs first order logic permalink",className:"anchor before"},l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"5. Propositional vs. first-order logic"),"\n",l.createElement(n.h3,{id:"expressiveness",style:{position:"relative"}},l.createElement(n.a,{href:"#expressiveness","aria-label":"expressiveness permalink",className:"anchor before"},l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Expressiveness"),"\n",l.createElement(n.ol,null,"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Propositional logic"),": Deals with simple statements (p, q, r) without internal structure."),"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"First-order logic"),": Encodes statements about objects, relations, and quantifiers, enabling it to express far more nuanced truths."),"\n"),"\n",l.createElement(n.p,null,"A knowledge engineer might choose propositional logic for smaller, well-structured problems (like a finite puzzle), but prefer first-order logic for complex domains with many objects and relationships."),"\n",l.createElement(n.h3,{id:"inference-process",style:{position:"relative"}},l.createElement(n.a,{href:"#inference-process","aria-label":"inference process permalink",className:"anchor before"},l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Inference process"),"\n",l.createElement(n.p,null,"Both formalisms can use resolution and other proof methods, but first-order logic requires ",l.createElement(n.strong,null,"unification")," to handle variables and predicates — significantly more involved than propositional logic's simpler matching of atomic propositions."),"\n",l.createElement(n.h3,{id:"performance-and-complexity",style:{position:"relative"}},l.createElement(n.a,{href:"#performance-and-complexity","aria-label":"performance and complexity permalink",className:"anchor before"},l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Performance and complexity"),"\n",l.createElement(n.p,null,"Because first-order logic is more expressive, it tends to be more difficult computationally. Many problems in FOL are in the realm of ",l.createElement(n.strong,null,"semi-decidability"),". Meanwhile, propositional logic tasks like SAT are NP-complete (still very challenging), but specialized SAT solvers have made large-scale propositional problem solving surprisingly feasible."),"\n",l.createElement(n.h3,{id:"scaling-and-efficiency-considerations-in-ai-systems",style:{position:"relative"}},l.createElement(n.a,{href:"#scaling-and-efficiency-considerations-in-ai-systems","aria-label":"scaling and efficiency considerations in ai systems permalink",className:"anchor before"},l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Scaling and efficiency considerations in AI systems"),"\n",l.createElement(n.p,null,"In practice, an AI system designer must weigh:"),"\n",l.createElement(n.ol,null,"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Domain complexity"),": Is the domain best described by objects, relations, and quantifiers?"),"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Performance constraints"),": Are we capable of running a first-order logic reasoner in the required time frame?"),"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Hybrid approaches"),": Could a portion of the problem be simplified to propositional logic while retaining essential expressiveness?"),"\n"),"\n",l.createElement(n.h2,{id:"6-advanced-inference-methods",style:{position:"relative"}},l.createElement(n.a,{href:"#6-advanced-inference-methods","aria-label":"6 advanced inference methods permalink",className:"anchor before"},l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"6. Advanced inference methods"),"\n",l.createElement(n.p,null,"In addition to the fundamental resolution procedure, AI logic includes a broad suite of inference approaches. These methods can be used alone or in combination for building sophisticated knowledge-based systems."),"\n",l.createElement(n.h3,{id:"forward-chaining",style:{position:"relative"}},l.createElement(n.a,{href:"#forward-chaining","aria-label":"forward chaining permalink",className:"anchor before"},l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Forward chaining"),"\n",l.createElement(n.h4,{id:"rule-based-progression-from-known-facts",style:{position:"relative"}},l.createElement(n.a,{href:"#rule-based-progression-from-known-facts","aria-label":"rule based progression from known facts permalink",className:"anchor before"},l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Rule-based progression from known facts"),"\n",l.createElement(n.p,null,"In forward chaining, you might store rules like:"),"\n",l.createElement(n.p,null,l.createElement(i.A,{text:"\\( A \\land B \\rightarrow C \\)"}),",",l.createElement(n.br),"\n",l.createElement(i.A,{text:"\\( C \\rightarrow D \\)"}),","),"\n",l.createElement(n.p,null,"and a knowledge base containing ",l.createElement(i.A,{text:"\\( A \\)"})," and ",l.createElement(i.A,{text:"\\( B \\)"}),". The system will notice that ",l.createElement(i.A,{text:"\\( A \\land B \\)"})," is satisfied and infer ",l.createElement(i.A,{text:"\\( C \\)"}),", then from ",l.createElement(i.A,{text:"\\( C \\)"})," infer ",l.createElement(i.A,{text:"\\( D \\)"}),". This approach is often used in ",l.createElement(n.strong,null,"production systems")," or ",l.createElement(n.strong,null,"expert systems"),", where the agent acts whenever new conclusions are deduced."),"\n",l.createElement(n.h4,{id:"best-suited-for-data-driven-or-reactive-systems",style:{position:"relative"}},l.createElement(n.a,{href:"#best-suited-for-data-driven-or-reactive-systems","aria-label":"best suited for data driven or reactive systems permalink",className:"anchor before"},l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Best suited for data-driven or reactive systems"),"\n",l.createElement(n.p,null,"Forward chaining excels when the environment continuously feeds data into the system, prompting immediate responses or updates. Expert systems (e.g., CLIPS) typically adopt forward chaining to keep the knowledge base updated with newly inferred facts as sensor data or user input arrives."),"\n",l.createElement(n.h4,{id:"example-domains-production-systems-expert-systems",style:{position:"relative"}},l.createElement(n.a,{href:"#example-domains-production-systems-expert-systems","aria-label":"example domains production systems expert systems permalink",className:"anchor before"},l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Example domains: production systems, expert systems"),"\n",l.createElement(n.p,null,"In manufacturing, a system might repeatedly check sensor data for anomalies in product lines; if certain conditions hold, it triggers immediate corrective actions. Similarly, in medical expert systems, forward chaining can accumulate symptom data leading to new diagnostic inferences."),"\n",l.createElement(n.h3,{id:"backward-chaining",style:{position:"relative"}},l.createElement(n.a,{href:"#backward-chaining","aria-label":"backward chaining permalink",className:"anchor before"},l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Backward chaining"),"\n",l.createElement(n.h4,{id:"goal-driven-approach",style:{position:"relative"}},l.createElement(n.a,{href:"#goal-driven-approach","aria-label":"goal driven approach permalink",className:"anchor before"},l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Goal-driven approach"),"\n",l.createElement(n.p,null,"By contrast, backward chaining begins with a query: 'Is ",l.createElement(i.A,{text:"\\( D \\)"})," true?' The system looks for rules that produce ",l.createElement(i.A,{text:"\\( D \\)"})," and checks if their premises are satisfied, recursively. This approach is well-suited for contexts where one wants to test or 'prove' specific hypotheses rather than gather all possible inferences."),"\n",l.createElement(n.h4,{id:"used-extensively-in-logic-programming-eg-prolog",style:{position:"relative"}},l.createElement(n.a,{href:"#used-extensively-in-logic-programming-eg-prolog","aria-label":"used extensively in logic programming eg prolog permalink",className:"anchor before"},l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Used extensively in logic programming (e.g., Prolog)"),"\n",l.createElement(n.p,null,"Prolog uses backward chaining plus unification. A query like:"),"\n",l.createElement(i.A,{text:"\\( ? - loves(X, Y). \\)"}),"\n",l.createElement(n.p,null,"attempts to find assignments for ",l.createElement(i.A,{text:"\\(X\\)"})," and ",l.createElement(i.A,{text:"\\(Y\\)"})," that satisfy any rule or fact in the knowledge base specifying 'loves(X, Y)'. The process is systematically guided by ",l.createElement(n.strong,null,"unification")," and ",l.createElement(n.strong,null,"backtracking"),"."),"\n",l.createElement(n.h4,{id:"comparative-strengths-and-typical-use-cases",style:{position:"relative"}},l.createElement(n.a,{href:"#comparative-strengths-and-typical-use-cases","aria-label":"comparative strengths and typical use cases permalink",className:"anchor before"},l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Comparative strengths and typical use cases"),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Forward chaining"),": Perfect for real-time or reactive tasks where data flows into the system."),"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Backward chaining"),": Ideal when we want to answer specific queries, particularly in a top-down manner."),"\n"),"\n",l.createElement(n.h3,{id:"resolution",style:{position:"relative"}},l.createElement(n.a,{href:"#resolution","aria-label":"resolution permalink",className:"anchor before"},l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Resolution"),"\n",l.createElement(n.h4,{id:"the-resolution-refutation-principle-as-a-unified-inference-method",style:{position:"relative"}},l.createElement(n.a,{href:"#the-resolution-refutation-principle-as-a-unified-inference-method","aria-label":"the resolution refutation principle as a unified inference method permalink",className:"anchor before"},l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"The resolution refutation principle as a unified inference method"),"\n",l.createElement(n.p,null,"Resolution can be seen as a single 'hammer' for both propositional and first-order logic (with suitable modifications for unification). The principle is:"),"\n",l.createElement(n.ol,null,"\n",l.createElement(n.li,null,"Convert all premises and the negation of the desired conclusion into CNF (a conjunction of disjunctions)."),"\n",l.createElement(n.li,null,"Repeatedly combine clauses via resolution, aiming to derive the empty clause (contradiction)."),"\n",l.createElement(n.li,null,"If a contradiction is found, the conclusion is proven valid under the premises."),"\n"),"\n",l.createElement(n.h4,{id:"clause-form-transformations-and-resolution-strategies",style:{position:"relative"}},l.createElement(n.a,{href:"#clause-form-transformations-and-resolution-strategies","aria-label":"clause form transformations and resolution strategies permalink",className:"anchor before"},l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Clause form transformations and resolution strategies"),"\n",l.createElement(n.p,null,"Converting formulas to CNF may require rewriting statements to remove implications, push negations inward, and standardize variables (known as ",l.createElement(n.strong,null,"Skolemization")," in first-order logic). Various strategies exist for applying resolution in an organized manner, e.g., ",l.createElement(n.strong,null,"linear resolution"),", ",l.createElement(n.strong,null,"input resolution"),", etc., each with trade-offs in performance and completeness."),"\n",l.createElement(n.h4,{id:"example-proofs-and-performance-considerations",style:{position:"relative"}},l.createElement(n.a,{href:"#example-proofs-and-performance-considerations","aria-label":"example proofs and performance considerations permalink",className:"anchor before"},l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Example proofs and performance considerations"),"\n",l.createElement(n.p,null,"A typical example is proving a statement from given premises:"),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,"Premise 1: ",l.createElement(i.A,{text:"\\( \\forall x (Cat(x) \\rightarrow Animal(x)) \\)"})),"\n",l.createElement(n.li,null,"Premise 2: ",l.createElement(i.A,{text:"\\( Cat(Tom) \\)"})),"\n",l.createElement(n.li,null,"Conclusion: ",l.createElement(i.A,{text:"\\( Animal(Tom) \\)"})),"\n"),"\n",l.createElement(n.p,null,"We can demonstrate resolution by introducing the negation of the conclusion, rewriting in CNF, and deriving a contradiction. While trivial for a small example, real-world resolution proofs can be massive. Many modern theorem provers (e.g., Vampire, E) implement sophisticated search heuristics to handle large knowledge bases."),"\n",l.createElement(n.h3,{id:"additional-techniques",style:{position:"relative"}},l.createElement(n.a,{href:"#additional-techniques","aria-label":"additional techniques permalink",className:"anchor before"},l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Additional techniques"),"\n",l.createElement(n.h4,{id:"tableaux-methods-and-natural-deduction",style:{position:"relative"}},l.createElement(n.a,{href:"#tableaux-methods-and-natural-deduction","aria-label":"tableaux methods and natural deduction permalink",className:"anchor before"},l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Tableaux methods and natural deduction"),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Tableaux"),": Build a tree of possible truth assignments or expansions of formulas, searching for contradictions."),"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Natural deduction"),": A set of inference rules (like introduction and elimination rules for connectives) that mirror standard mathematical proofs."),"\n"),"\n",l.createElement(n.h4,{id:"sequent-calculus-and-other-formal-proof-systems",style:{position:"relative"}},l.createElement(n.a,{href:"#sequent-calculus-and-other-formal-proof-systems","aria-label":"sequent calculus and other formal proof systems permalink",className:"anchor before"},l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Sequent calculus and other formal proof systems"),"\n",l.createElement(n.p,null,"Sequent calculus, introduced by Gerhard Gentzen, underpins many formal theorem-proving frameworks. While it is typically found in mathematical logic courses, some AI systems rely on it for structured proof derivation."),"\n",l.createElement(n.h4,{id:"hybrid-or-specialized-inference-engines",style:{position:"relative"}},l.createElement(n.a,{href:"#hybrid-or-specialized-inference-engines","aria-label":"hybrid or specialized inference engines permalink",className:"anchor before"},l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Hybrid or specialized inference engines"),"\n",l.createElement(n.p,null,"Some knowledge-based systems fuse multiple techniques: forward chaining for certain rule sets, resolution for more complex tasks, or specialized domain heuristics to prune search spaces. Hybrid systems can also integrate model checking for temporal or dynamic properties, bridging static facts with transitions over time."),"\n",l.createElement(n.h2,{id:"7-beyond-classical-logic",style:{position:"relative"}},l.createElement(n.a,{href:"#7-beyond-classical-logic","aria-label":"7 beyond classical logic permalink",className:"anchor before"},l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"7. Beyond classical logic"),"\n",l.createElement(n.p,null,"Classical logic, whether propositional or first-order, assumes that propositions are either true or false under some interpretation and that the set of axioms is consistent and complete for the domain. However, real-world AI contexts often stretch these assumptions, requiring alternative logics to handle knowledge about knowledge, time, uncertainty, or partial truth."),"\n",l.createElement(n.h3,{id:"modal-and-epistemic-logics",style:{position:"relative"}},l.createElement(n.a,{href:"#modal-and-epistemic-logics","aria-label":"modal and epistemic logics permalink",className:"anchor before"},l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Modal and epistemic logics"),"\n",l.createElement(n.p,null,"Modal logics extend classical logic with additional operators like ",l.createElement(n.strong,null,"necessarily")," (",l.createElement(i.A,{text:"\\( \\Box \\)"}),") and ",l.createElement(n.strong,null,"possibly")," (",l.createElement(i.A,{text:"\\( \\Diamond \\)"}),"). Epistemic logics focus on knowledge and belief operators, letting us write statements such as ",l.createElement(i.A,{text:"\\( K_{agent}(p) \\)"})," or ",l.createElement(i.A,{text:"\\( B_{agent}(p) \\)"}),", meaning 'the agent knows p' or 'the agent believes p'."),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Use cases"),": Multi-agent systems where each agent has different knowledge or beliefs. Example: 'Agent A knows that agent B does not know the location of the treasure.'"),"\n"),"\n",l.createElement(n.h3,{id:"temporal-logics",style:{position:"relative"}},l.createElement(n.a,{href:"#temporal-logics","aria-label":"temporal logics permalink",className:"anchor before"},l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Temporal logics"),"\n",l.createElement(n.p,null,"In many applications, we need to express properties that evolve over time — for instance, in planning, scheduling, or verifying state-based systems (like communication protocols)."),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Linear Temporal Logic (LTL)"),": Uses operators like ",l.createElement(n.strong,null,"eventually")," (",l.createElement(i.A,{text:"\\( F \\)"}),"), ",l.createElement(n.strong,null,"globally")," (",l.createElement(i.A,{text:"\\( G \\)"}),"), ",l.createElement(n.strong,null,"until")," (",l.createElement(i.A,{text:"\\( U \\)"}),") to describe how propositions hold over linear time."),"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Computational Tree Logic (CTL)"),": Views time as a branching tree of possible futures, allowing path quantifiers (e.g., for all possible paths, there exists a path)."),"\n"),"\n",l.createElement(n.p,null,"Temporal logics see heavy usage in ",l.createElement(n.strong,null,"model checking"),", verifying properties in hardware and software systems under dynamic conditions."),"\n",l.createElement(n.h3,{id:"description-logics",style:{position:"relative"}},l.createElement(n.a,{href:"#description-logics","aria-label":"description logics permalink",className:"anchor before"},l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Description logics"),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"Description logics (DL)")," are a family of formalisms that strike a balance between expressive power and decidability. They power the ",l.createElement(n.strong,null,"Semantic Web")," standards (OWL — Web Ontology Language) and are used for building ontologies in complex domains (medical, biological, industrial, etc.). DLs revolve around concepts (classes), roles (relationships), and individuals, offering constructs for stating class hierarchies, property restrictions, etc."),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Class hierarchies"),": e.g., 'Lion is a subclass of Cat, which is a subclass of Animal.'"),"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Property restrictions"),": e.g., 'A parent has at least one child.'"),"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Reasoning tasks"),": Subsumption checking (is one class a subclass of another?), instance checking, and concept satisfiability."),"\n"),"\n",l.createElement(n.h3,{id:"non-monotonic-reasoning-and-default-logic",style:{position:"relative"}},l.createElement(n.a,{href:"#non-monotonic-reasoning-and-default-logic","aria-label":"non monotonic reasoning and default logic permalink",className:"anchor before"},l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Non-monotonic reasoning and default logic"),"\n",l.createElement(n.p,null,"Classical logic is ",l.createElement(n.strong,null,"monotonic"),": once something is inferred, it remains inferred even if new premises appear. But humans often revise conclusions when new information arises (e.g., we adopt a 'default assumption' unless contradicted by new evidence)."),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Default logic"),": Formalizes reasoning with default rules that can be retracted if contradictory data is discovered."),"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Autoepistemic logic"),": Attempts to model an agent's own beliefs about its beliefs."),"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Common-sense reasoning"),": Non-monotonic formalisms are critical for capturing real-world knowledge that is typically incomplete and prone to exceptions."),"\n"),"\n",l.createElement(n.h3,{id:"probabilistic-logic",style:{position:"relative"}},l.createElement(n.a,{href:"#probabilistic-logic","aria-label":"probabilistic logic permalink",className:"anchor before"},l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Probabilistic logic"),"\n",l.createElement(n.p,null,"Combining logic with probability handles uncertainty about the truth of statements. Instead of 'Bird(x) implies Flies(x)', we might say 'Bird(x) implies Flies(x) with probability 0.95'."),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Bayesian networks"),": Graphical models that represent conditional dependencies among variables. They are not purely logic-based but revolve around structured relationships that can sometimes be integrated with logical constraints."),"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Markov Logic Networks (MLNs)"),": A powerful framework (Richardson and Domingos, 2006) that merges first-order logic with Markov random fields, weighting each formula to represent 'soft' constraints. Inferences become a matter of finding the most probable state of the world that satisfies or nearly satisfies the logical formulas."),"\n"),"\n",l.createElement(n.h2,{id:"8-practical-questions",style:{position:"relative"}},l.createElement(n.a,{href:"#8-practical-questions","aria-label":"8 practical questions permalink",className:"anchor before"},l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"8. Practical questions"),"\n",l.createElement(n.h3,{id:"scaling-logical-methods",style:{position:"relative"}},l.createElement(n.a,{href:"#scaling-logical-methods","aria-label":"scaling logical methods permalink",className:"anchor before"},l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Scaling logical methods"),"\n",l.createElement(n.h4,{id:"issues-with-exponential-complexity-as-domain-size-grows",style:{position:"relative"}},l.createElement(n.a,{href:"#issues-with-exponential-complexity-as-domain-size-grows","aria-label":"issues with exponential complexity as domain size grows permalink",className:"anchor before"},l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Issues with exponential complexity as domain size grows"),"\n",l.createElement(n.p,null,"Even seemingly trivial logic problems can blow up in complexity, demanding exponential resources in the worst case. As the domain grows larger or the number of facts and rules increases, naive reasoning can become intractable. This is why large logic-based systems often rely on specialized reasoners with advanced pruning and heuristics."),"\n",l.createElement(n.h4,{id:"approximation-methods-and-heuristic-search-strategies",style:{position:"relative"}},l.createElement(n.a,{href:"#approximation-methods-and-heuristic-search-strategies","aria-label":"approximation methods and heuristic search strategies permalink",className:"anchor before"},l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Approximation methods and heuristic search strategies"),"\n",l.createElement(n.p,null,"To keep pace with real-world demands, many reasoners adopt:"),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Heuristic search"),": Strategies to guide which clauses or rules to apply first during proof search, limiting the search space."),"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Approximate inference"),": Accepting partial or probabilistic answers that are 'good enough' in a resource-limited setting."),"\n"),"\n",l.createElement(n.h3,{id:"balancing-complexity-and-completeness",style:{position:"relative"}},l.createElement(n.a,{href:"#balancing-complexity-and-completeness","aria-label":"balancing complexity and completeness permalink",className:"anchor before"},l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Balancing complexity and completeness"),"\n",l.createElement(n.h4,{id:"when-to-prioritize-soundness-vs-when-to-allow-partial-solutions",style:{position:"relative"}},l.createElement(n.a,{href:"#when-to-prioritize-soundness-vs-when-to-allow-partial-solutions","aria-label":"when to prioritize soundness vs when to allow partial solutions permalink",className:"anchor before"},l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"When to prioritize soundness vs. when to allow partial solutions"),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Soundness"),": Never derive false conclusions from true premises. In some safety-critical systems, this is paramount."),"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Completeness"),": Derive all true conclusions from the premises. Some applications, like certain real-time systems, might forgo completeness in exchange for faster, albeit partial, solutions."),"\n"),"\n",l.createElement(n.h4,{id:"real-world-constraints-on-reasoning-time-and-resources",style:{position:"relative"}},l.createElement(n.a,{href:"#real-world-constraints-on-reasoning-time-and-resources","aria-label":"real world constraints on reasoning time and resources permalink",className:"anchor before"},l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Real-world constraints on reasoning time and resources"),"\n",l.createElement(n.p,null,"An autonomous vehicle, for example, might not have the luxury of exhaustive reasoning if it must decide how to avoid an obstacle in real-time. Designers might adopt simpler or approximate forms of logic or incorporate default reasoning that can quickly adapt as new sensor data arrives."),"\n",l.createElement(n.h3,{id:"integration-with-other-ai-approaches",style:{position:"relative"}},l.createElement(n.a,{href:"#integration-with-other-ai-approaches","aria-label":"integration with other ai approaches permalink",className:"anchor before"},l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Integration with other AI approaches"),"\n",l.createElement(n.h4,{id:"hybrid-symbolicsubsymbolic-systems-eg-neural-symbolic-ai",style:{position:"relative"}},l.createElement(n.a,{href:"#hybrid-symbolicsubsymbolic-systems-eg-neural-symbolic-ai","aria-label":"hybrid symbolicsubsymbolic systems eg neural symbolic ai permalink",className:"anchor before"},l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Hybrid symbolic–subsymbolic systems (e.g., neural-symbolic AI)"),"\n",l.createElement(n.p,null,"A fast-growing area of research is combining the interpretability of symbolic logic with the powerful function approximation of neural networks. For instance:"),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,"Using neural networks to extract possible facts from raw text or images, then feeding these facts into a symbolic reasoner."),"\n",l.createElement(n.li,null,"Guiding neural networks with logical constraints (like 'at most one true label among the set') to reduce errors or ensure logically consistent outputs."),"\n"),"\n",l.createElement(n.h4,{id:"complementing-rule-based-logic-with-machine-learning-and-data-mining",style:{position:"relative"}},l.createElement(n.a,{href:"#complementing-rule-based-logic-with-machine-learning-and-data-mining","aria-label":"complementing rule based logic with machine learning and data mining permalink",className:"anchor before"},l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Complementing rule-based logic with machine learning and data mining"),"\n",l.createElement(n.p,null,"Large data sets can be mined to find patterns or probable rules that might be turned into logical statements, bridging data-driven discovery and symbolic inference."),"\n",l.createElement(n.h4,{id:"evolving-trends-explainable-ai-knowledge-graphs-and-more",style:{position:"relative"}},l.createElement(n.a,{href:"#evolving-trends-explainable-ai-knowledge-graphs-and-more","aria-label":"evolving trends explainable ai knowledge graphs and more permalink",className:"anchor before"},l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Evolving trends: explainable AI, knowledge graphs, and more"),"\n",l.createElement(n.p,null,"Knowledge graphs, widely employed by major search engines and social media companies, are giant networks of entities and relationships. They often rely on logical or quasi-logical reasoning to surface consistent, relevant information. Explainable AI initiatives benefit from explicit statements of logic-based constraints, making system outputs more transparent."),"\n",l.createElement(n.h3,{id:"engineering-robust-logical-systems",style:{position:"relative"}},l.createElement(n.a,{href:"#engineering-robust-logical-systems","aria-label":"engineering robust logical systems permalink",className:"anchor before"},l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Engineering robust logical systems"),"\n",l.createElement(n.h4,{id:"best-practices-in-software-frameworks-for-ai-logic",style:{position:"relative"}},l.createElement(n.a,{href:"#best-practices-in-software-frameworks-for-ai-logic","aria-label":"best practices in software frameworks for ai logic permalink",className:"anchor before"},l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Best practices in software frameworks for AI logic"),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Prolog"),": A classic logic programming language, widely used in academia and certain commercial systems."),"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"CLIPS"),": A forward-chaining rule-based system originally developed at NASA."),"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"OWL reasoners"),": Tools like ",l.createElement(n.strong,null,"HermiT")," or ",l.createElement(n.strong,null,"Pellet")," for ontological reasoning under the Semantic Web stack."),"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Hybrid frameworks"),": Systems that incorporate logic modules with machine learning libraries (e.g., some research prototypes integrate PyTorch or TensorFlow with custom symbolic layers)."),"\n"),"\n",l.createElement(n.h4,{id:"maintenance-and-updating-of-large-knowledge-bases",style:{position:"relative"}},l.createElement(n.a,{href:"#maintenance-and-updating-of-large-knowledge-bases","aria-label":"maintenance and updating of large knowledge bases permalink",className:"anchor before"},l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Maintenance and updating of large knowledge bases"),"\n",l.createElement(n.p,null,"Large knowledge bases must handle:"),"\n",l.createElement(n.ol,null,"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Versioning"),": Tracking changes and ensuring backward compatibility."),"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Consistency checking"),": Quickly detecting contradictory statements."),"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Scalability"),": Efficiently indexing millions of logical facts or ontological axioms."),"\n"),"\n",l.createElement(n.h3,{id:"highlights-of-how-logic-underpins-ai-reasoning",style:{position:"relative"}},l.createElement(n.a,{href:"#highlights-of-how-logic-underpins-ai-reasoning","aria-label":"highlights of how logic underpins ai reasoning permalink",className:"anchor before"},l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Highlights of how logic underpins AI reasoning"),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Classical logic")," remains the starting point for conceptual clarity."),"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Propositional logic")," is simpler and often used for building toy models or specialized tasks solved by SAT solvers."),"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"First-order logic")," adds expressive power but raises computational challenges."),"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Beyond classical logic"),": For real-world scenarios involving dynamics, uncertainty, multi-agent knowledge, or incomplete data, AI practitioners turn to modal, temporal, description logics, non-monotonic reasoning, and probabilistic logic."),"\n"),"\n",l.createElement(n.h3,{id:"major-differences-between-propositional-and-first-order-methods",style:{position:"relative"}},l.createElement(n.a,{href:"#major-differences-between-propositional-and-first-order-methods","aria-label":"major differences between propositional and first order methods permalink",className:"anchor before"},l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Major differences between propositional and first-order methods"),"\n",l.createElement(n.p,null,"One of the most significant differences is the presence of ",l.createElement(n.strong,null,"quantifiers")," and ",l.createElement(n.strong,null,"variable unification")," in first-order logic. Propositional logic treats each proposition as an indivisible whole, making inference simpler but also more limited."),"\n",l.createElement(n.h3,{id:"emerging-trends-in-logic-based-ai",style:{position:"relative"}},l.createElement(n.a,{href:"#emerging-trends-in-logic-based-ai","aria-label":"emerging trends in logic based ai permalink",className:"anchor before"},l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Emerging trends in logic-based AI"),"\n",l.createElement(n.ol,null,"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Knowledge graphs")," and ",l.createElement(n.strong,null,"semantic technologies"),": Broad industry uptake means that logic-based reasoning about large ontologies is more relevant than ever."),"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Integration with deep learning"),": Neural-symbolic systems are gaining traction, aiming to combine the deep pattern recognition of neural nets with the interpretability and systematic reasoning of logic."),"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Formal verification in autonomous systems"),": As robots and self-driving cars become commonplace, ensuring correctness and safety via logic-based model checking is increasingly critical."),"\n"),"\n",l.createElement(n.h3,{id:"next-steps-for-continued-study",style:{position:"relative"}},l.createElement(n.a,{href:"#next-steps-for-continued-study","aria-label":"next steps for continued study permalink",className:"anchor before"},l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Next steps for continued study"),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Foundational textbooks"),': "Knowledge Representation and Reasoning" by Brachman and Levesque; "Artificial Intelligence: A Modern Approach" by Russell and Norvig.'),"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Academic papers"),": Read about Markov logic networks (Richardson and Domingos, 2006), neural theorem provers (Rocktäschel and gang, 2017), or other hybrid neural-symbolic methods."),"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Online courses"),": Many universities and platforms offer logic-based AI modules or entire courses on knowledge representation and reasoning."),"\n",l.createElement(n.li,null,l.createElement(n.strong,null,"Practical projects"),": Building a small Prolog knowledge base or setting up an OWL ontology with a reasoner can be an excellent way to ground your theoretical knowledge in real examples."),"\n"),"\n",l.createElement(n.p,null,"In conclusion, logic in AI is more than just a historical curiosity or a niche interest. It continues to provide essential tools for building systems that can reason explicitly, ensure correctness, and maintain interpretability. From propositional rule-based systems to expressive first-order logic, and further into modal, temporal, non-monotonic, and probabilistic logics, a thorough grounding in these techniques and frameworks is indispensable for any data scientist or ML engineer who seeks robust, verifiable, and transparent AI solutions."),"\n",l.createElement(n.hr),"\n",l.createElement(t,{alt:"Illustration of logical inference",path:"",caption:"An abstract illustration showing symbolic reasoning connections in AI logic. The nodes might represent propositions or predicates, linked by inference rules.",zoom:"false"}),"\n",l.createElement(n.p,null,"Below is a small Prolog snippet demonstrating backward chaining in a logic programming context. Notice how queries unify with rule heads to find solutions:"),"\n",l.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">&lt;Code text={`\n% Simple knowledge base\nparent(alice, bob).\nparent(bob, charlie).\n\n% A rule stating that a grandparent is a parent of a parent\ngrandparent(X, Y) :- parent(X, Z), parent(Z, Y).\n\n% Query:\n% ?- grandparent(alice, charlie).\n% Prolog searches for a chain of parent relationships that satisfy grandparent(X, Y).\n`}/></code></pre></div>'}}),"\n",l.createElement(n.p,null,"Such a knowledge base can be extended and refined to capture increasingly complex relationships, showcasing how logic-based systems scale from trivial demonstrations to powerful engines of inference in more advanced AI applications."))}var o=function(e){void 0===e&&(e={});const{wrapper:n}=Object.assign({},(0,a.RP)(),e.components);return n?l.createElement(n,e,l.createElement(r,e)):r(e)};var s=t(54506),c=t(88864),h=t(58481),m=t.n(h),d=t(5984),u=t(43672),g=t(27042),p=t(72031),f=t(81817),v=t(27105),b=t(17265),E=t(2043),y=t(95751),w=t(94328),S=t(80791),x=t(78137);const H=e=>{let{toc:n}=e;if(!n||!n.items)return null;return l.createElement("nav",{className:S.R},l.createElement("ul",null,n.items.map(((e,n)=>l.createElement("li",{key:n},l.createElement("a",{href:e.url,onClick:n=>((e,n)=>{e.preventDefault();const t=n.replace("#",""),a=document.getElementById(t);a&&a.scrollIntoView({behavior:"smooth",block:"start"})})(n,e.url)},e.title),e.items&&l.createElement(H,{toc:{items:e.items}}))))))};function k(e){let{data:{mdx:n,allMdx:i,allPostImages:r},children:o}=e;const{frontmatter:c,body:h,tableOfContents:p}=n,S=c.index,k=c.slug.split("/")[1],C=i.nodes.filter((e=>e.frontmatter.slug.includes(`/${k}/`))).sort(((e,n)=>e.frontmatter.index-n.frontmatter.index)),z=C.findIndex((e=>e.frontmatter.index===S)),M=C[z+1],A=C[z-1],I=c.slug.replace(/\/$/,""),T=/[^/]*$/.exec(I)[0],V=`posts/${k}/content/${T}/`,{0:_,1:L}=(0,l.useState)(c.flagWideLayoutByDefault),{0:B,1:N}=(0,l.useState)(!1);var P;(0,l.useEffect)((()=>{N(!0);const e=setTimeout((()=>N(!1)),340);return()=>clearTimeout(e)}),[_]),"adventures"===k?P=b.cb:"research"===k?P=b.Qh:"thoughts"===k&&(P=b.T6);const q=m()(h).replace(/import .*? from .*?;/g,"").replace(/<.*?>/g,"").replace(/\{\/\*[\s\S]*?\*\/\}/g,"").trim().split(/\s+/).length,F=function(e){if(e<=10)return"~10 min";if(e<=20)return"~20 min";if(e<=30)return"~30 min";if(e<=40)return"~40 min";if(e<=50)return"~50 min";if(e<=60)return"~1 h";const n=Math.floor(e/60),t=e%60;return t<=30?`~${n}${t>0?".5":""} h`:`~${n+1} h`}(Math.ceil(q/P)+(c.extraReadTimeMin||0)),W=[{flag:c.flagDraft,component:()=>Promise.all([t.e(5850),t.e(9833)]).then(t.bind(t,49833))},{flag:c.flagMindfuckery,component:()=>Promise.all([t.e(5850),t.e(7805)]).then(t.bind(t,27805))},{flag:c.flagRewrite,component:()=>Promise.all([t.e(5850),t.e(8916)]).then(t.bind(t,78916))},{flag:c.flagOffensive,component:()=>Promise.all([t.e(5850),t.e(6731)]).then(t.bind(t,49112))},{flag:c.flagProfane,component:()=>Promise.all([t.e(5850),t.e(3336)]).then(t.bind(t,83336))},{flag:c.flagMultilingual,component:()=>Promise.all([t.e(5850),t.e(2343)]).then(t.bind(t,62343))},{flag:c.flagUnreliably,component:()=>Promise.all([t.e(5850),t.e(6865)]).then(t.bind(t,11627))},{flag:c.flagPolitical,component:()=>Promise.all([t.e(5850),t.e(4417)]).then(t.bind(t,24417))},{flag:c.flagCognitohazard,component:()=>Promise.all([t.e(5850),t.e(8669)]).then(t.bind(t,18669))},{flag:c.flagHidden,component:()=>Promise.all([t.e(5850),t.e(8124)]).then(t.bind(t,48124))}],{0:O,1:D}=(0,l.useState)([]);return(0,l.useEffect)((()=>{W.forEach((e=>{let{flag:n,component:t}=e;n&&t().then((e=>{D((n=>[].concat((0,s.A)(n),[e.default])))}))}))}),[]),l.createElement(g.P.div,{initial:{opacity:0},animate:{opacity:1},exit:{opacity:0},transition:{duration:.15}},l.createElement(f.A,{postNumber:c.index,date:c.date,updated:c.updated,readTime:F,difficulty:c.difficultyLevel,title:c.title,desc:c.desc,banner:c.banner,section:k,postKey:T,isMindfuckery:c.flagMindfuckery,mainTag:c.mainTag}),l.createElement("div",{style:{display:"flex",justifyContent:"flex-end",flexWrap:"wrap",maxWidth:"75%",marginLeft:"auto",paddingRight:"1vw",marginTop:"-6vh",marginBottom:"4vh"}},c.otherTags.map(((e,n)=>l.createElement("span",{key:n,className:`noselect ${x.MW}`,style:{margin:"0 5px 5px 0"}},e)))),l.createElement("div",{className:"postBody"},l.createElement(H,{toc:p})),l.createElement("br",null),l.createElement("div",{style:{margin:"0 10% -2vh 30%",textAlign:"right"}},l.createElement(g.P.button,{className:`noselect ${w.pb}`,id:w.xG,onClick:()=>{L(!_)},whileTap:{scale:.93}},l.createElement(g.P.div,{className:y.DJ,key:_,initial:{opacity:0},animate:{opacity:1},exit:{opacity:0},transition:{duration:.3,ease:"easeInOut"}},_?"Switch to default layout":"Switch to wide layout"))),l.createElement("br",null),l.createElement("div",{className:"postBody",style:{margin:_?"0 -14%":"",maxWidth:_?"200%":"",transition:"margin 1s ease, max-width 1s ease, padding 1s ease"}},l.createElement("div",{className:`${w.P_} ${B?w.Xn:w.qG}`},O.map(((e,n)=>l.createElement(e,{key:n}))),c.indexCourse?l.createElement(E.A,{index:c.indexCourse,category:c.courseCategoryName}):"",l.createElement(d.Z.Provider,{value:{images:r.nodes,basePath:V.replace(/\/$/,"")+"/"}},l.createElement(a.xA,{components:{Image:u.A}},o)))),l.createElement(v.A,{nextPost:M,lastPost:A,keyCurrent:T,section:k}))}function C(e){return l.createElement(k,e,l.createElement(o,e))}function z(e){var n,t,a,i,r;let{data:o}=e;const{frontmatter:s}=o.mdx,h=s.titleSEO||s.title,m=s.titleOG||h,d=s.titleTwitter||h,u=s.descSEO||s.desc,g=s.descOG||u,f=s.descTwitter||u,v=s.schemaType||"BlogPosting",b=s.keywordsSEO,E=s.date,y=s.updated||E,w=s.imageOG||(null===(n=s.banner)||void 0===n||null===(t=n.childImageSharp)||void 0===t||null===(a=t.gatsbyImageData)||void 0===a||null===(i=a.images)||void 0===i||null===(r=i.fallback)||void 0===r?void 0:r.src),S=s.imageAltOG||g,x=s.imageTwitter||w,H=s.imageAltTwitter||f,k=s.canonicalURL,C=s.flagHidden||!1,z=s.mainTag||"Posts",M=s.slug.split("/")[1]||"posts",{siteUrl:A}=(0,c.Q)(),I={"@context":"https://schema.org","@type":"BreadcrumbList",itemListElement:[{"@type":"ListItem",position:1,name:"Home",item:A},{"@type":"ListItem",position:2,name:z,item:`${A}/${s.slug.split("/")[1]}`},{"@type":"ListItem",position:3,name:h,item:`${A}${s.slug}`}]};return l.createElement(p.A,{title:h+" - avrtt.blog",titleOG:m,titleTwitter:d,description:u,descriptionOG:g,descriptionTwitter:f,schemaType:v,keywords:b,datePublished:E,dateModified:y,imageOG:w,imageAltOG:S,imageTwitter:x,imageAltTwitter:H,canonicalUrl:k,flagHidden:C,mainTag:z,section:M,type:"article"},l.createElement("script",{type:"application/ld+json"},JSON.stringify(I)))}},90548:function(e,n,t){var a=t(96540),l=t(7978);n.A=e=>{let{text:n}=e;return a.createElement(l.A,null,n)}}}]);
//# sourceMappingURL=component---src-templates-post-tsx-content-file-path-src-pages-posts-research-ai-logic-mdx-3a2a1b786f06042ae9f8.js.map