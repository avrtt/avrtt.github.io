"use strict";(self.webpackChunkavrtt_blog=self.webpackChunkavrtt_blog||[]).push([[3060],{64036:function(e,t,n){n.r(t),n.d(t,{Head:function(){return T},PostTemplate:function(){return S},default:function(){return z}});var a=n(54506),i=n(28453),r=n(96540),l=(n(16886),n(46295),n(96098));function o(e){const t=Object.assign({p:"p",h3:"h3",a:"a",span:"span",ol:"ol",li:"li",strong:"strong",ul:"ul",h2:"h2",h4:"h4",em:"em",hr:"hr"},(0,i.RP)(),e.components),{Image:n}=t;return n||function(e,t){throw new Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Image",!0),r.createElement(r.Fragment,null,"\n",r.createElement("br"),"\n","\n","\n",r.createElement(t.p,null,'Large language models (LLMs) have rapidly emerged as powerful tools for a variety of language-based tasks — including summarization, code generation, question answering, and creative text production — due to their ability to learn complex patterns from massive unlabeled text corpora. However, these foundational models are not necessarily tailored to specific user goals or organizational needs out of the box. That gap is precisely where tuning comes into play. By "tuning", I am referring to the phase after the model\'s general pre-training — a period of specialized training that takes the broad capabilities learned during pre-training and steers them toward more concrete objectives, often guided by curated datasets, user preferences, or task-specific data.'),"\n",r.createElement(t.p,null,"Tuning an LLM is rarely a trivial process: it must balance making the model more aligned with user goals against the risk of significantly reducing its generalization power, or even inadvertently introducing undesirable behaviors. In many ways, this tension shapes the essence of LLM tuning. On the one hand, you want the model to behave helpfully, safely, and consistently when confronted with user prompts. On the other hand, you do not want to overly restrict or degrade its capacity for creative problem-solving or its ability to handle edge cases."),"\n",r.createElement(t.p,null,"In this chapter, I will present a broad overview of the LLM tuning pipeline, starting with how models generally transition from a purely self-supervised pre-training on unstructured text to more specialized forms of post-training. I will highlight the main goals we often seek during tuning, such as improved utility, reduced toxicity, domain adaptation, or task specialization. Finally, I will explain how the post-training stage differs from pre-training in terms of scale and data structure, focusing on the unique challenges and typical methods for these targeted improvements."),"\n",r.createElement(t.h3,{id:"11-overview-of-the-tuning-pipeline",style:{position:"relative"}},r.createElement(t.a,{href:"#11-overview-of-the-tuning-pipeline","aria-label":"11 overview of the tuning pipeline permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"1.1 overview of the tuning pipeline"),"\n",r.createElement(t.p,null,"For most modern large language models (such as GPT-type models, PaLM variants, and many others), the pipeline typically looks something like this:"),"\n",r.createElement(t.ol,null,"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Pre-training"),": The model is trained on a massive collection of unstructured text, relying on language modeling objectives — for instance, predicting the next token given the context (",r.createElement(l.A,{text:"\\(p(x_{t} \\mid x_{1}, \\ldots, x_{t-1})\\)"}),"). This is often done on multi-terabyte text corpora. The goal is to develop broad linguistic and world knowledge. This phase can be extremely computationally expensive, frequently employing hundreds or thousands of GPUs over extended periods of time."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Post-training"),": After pre-training, the model has learned the basic structure of language plus a wide range of facts and patterns. However, it has not been specifically tuned to follow instructions, adhere to certain constraints, or produce responses that align with particular guidelines. Post-training steps aim to address these gaps. Within post-training, there are usually two notable sub-phases:","\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Supervised Fine-Tuning (SFT)"),": The model is further trained on carefully curated examples of input–output pairs (or prompt–response pairs). This data can be instructions paired with the appropriate response that we desire the model to give."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Preference Alignment"),": After or in conjunction with SFT, the model can be made to produce multiple candidate responses and then receive signals about which candidate is better or worse. This can be done via direct preference data (where human annotators explicitly rank or choose the best response) or via a reward model that scores responses. Algorithms like Proximal Policy Optimization (PPO) are often used to optimize these preferences, a process sometimes referred to as Reinforcement Learning from Human Feedback (RLHF). Newer approaches like Direct Preference Optimization (DPO) or rejection sampling can also serve similar functions."),"\n"),"\n"),"\n"),"\n",r.createElement(t.p,null,"Because post-training is typically performed on a fraction of the data size used during pre-training, it is relatively more resource-friendly. Nonetheless, it remains non-trivial because the model's massive size can still make straightforward fine-tuning memory-intensive and slow — leading to widespread interest in parameter-efficient techniques like Low-Rank Adaptation (LoRA) or QLoRA."),"\n",r.createElement(t.h3,{id:"12-goals-of-tuning",style:{position:"relative"}},r.createElement(t.a,{href:"#12-goals-of-tuning","aria-label":"12 goals of tuning permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"1.2 goals of tuning"),"\n",r.createElement(t.p,null,"During the tuning phase, developers and researchers usually pursue one or more of the following goals:"),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Improving task usefulness"),': Models can become better at following instructions, providing more direct answers to prompts, and generating relevant and coherent content. This is often referred to as instruction tuning (such as the approach introduced by "Ouyang and gang, 2022" for InstructGPT) or domain tuning (if the focus is on a specific domain like legal or medical text).'),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Reducing toxicity or harmful outputs"),": LLMs can inadvertently produce offensive, biased, or harmful outputs, partly because their pre-training data may contain such content. Tuning data might include explicit examples of inappropriate outputs labeled as disallowed or undesirable, or special objective functions that penalize hateful or toxic language."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Personalizing or customizing"),": In enterprise settings, it may be desirable for the model's style, domain knowledge, or brand voice to be shaped according to the organization's needs. Personalized fine-tuning can also occur when the goal is to adapt to an individual user or a small user group's preferences."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Controllability"),": Tuning often includes strategies to ensure that the model's output is easily steerable via prompt engineering and that it consistently follows system-level instructions."),"\n"),"\n",r.createElement(t.p,null,"These broad objectives are not mutually exclusive. In many practical workflows, you might want to achieve improvements on multiple fronts: better instruction-following, fewer policy violations, and strong performance in a specialized domain."),"\n",r.createElement(t.h3,{id:"13-distinctions-from-pre-training",style:{position:"relative"}},r.createElement(t.a,{href:"#13-distinctions-from-pre-training","aria-label":"13 distinctions from pre training permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"1.3 distinctions from pre-training"),"\n",r.createElement(t.p,null,'Though the term "training" is used in both phases, pre-training and post-training differ in several key ways:'),"\n",r.createElement(t.ol,null,"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Data scale"),": Pre-training typically involves hundreds of billions or even trillions of tokens of diverse unstructured text. By contrast, post-training might only utilize hundreds of thousands or a few million tokens, often hand-picked or hand-annotated for quality."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Data structure"),": Pre-training data is mostly next-token prediction on continuous stretches of text (e.g., web pages, e-books). Post-training data often includes well-defined instructions, question–answer pairs, or conversation logs. This can introduce new complexities, such as multi-turn dialogue modeling, explicit user–assistant role labeling, or specialized tokens indicating how the conversation or instruction is structured."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Learning objectives"),": In pre-training, the objective is typically maximum likelihood estimation of the next token (",r.createElement(l.A,{text:"\\(p(x_{t} \\mid x_{1}, \\ldots, x_{t-1})\\)"}),"). Post-training can involve partially or entirely different losses, e.g., supervised cross-entropy on ground truth instructions/responses, or a reinforcement learning objective where a reward model or human annotator feedback shapes the gradient."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Computational requirements"),": Large-scale pre-training demands extreme computational resources. Post-training, while still expensive, typically consumes fewer resources (though still significant for very large models). Techniques like LoRA, QLoRA, or offloading some training components to specialized hardware reduce the resource burden even further."),"\n"),"\n",r.createElement(t.p,null,"By understanding these distinctions, practitioners can better plan their data collection efforts, select suitable hardware configurations, and design more efficient fine-tuning routines."),"\n",r.createElement(t.h2,{id:"2-pre-training-vs-post-training-data",style:{position:"relative"}},r.createElement(t.a,{href:"#2-pre-training-vs-post-training-data","aria-label":"2 pre training vs post training data permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"2. pre-training vs. post-training data"),"\n",r.createElement(t.p,null,"The second major piece of the puzzle is understanding how the nature of data changes between pre-training and post-training. The success of large language models in recent years is largely attributed to the availability of vast and diverse textual data. However, that same approach is not fully suitable for post-training, where structured instructions and high-quality user–assistant dialogues are essential."),"\n",r.createElement(t.h3,{id:"21-nature-of-pre-training-corpora",style:{position:"relative"}},r.createElement(t.a,{href:"#21-nature-of-pre-training-corpora","aria-label":"21 nature of pre training corpora permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"2.1 nature of pre-training corpora"),"\n",r.createElement(t.p,null,"Pre-training corpora are typically broad, diverse, and relatively unstructured. Models might be exposed to news articles, scientific papers, books, web pages, code repositories, forum conversations, social media texts, and countless other text sources. The key is simply to have enormous volumes of text so that the model can learn statistical patterns of language at scale."),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,"\n",r.createElement(t.p,null,r.createElement(t.strong,null,"Advantages"),":"),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,"The diversity of textual sources fosters generality: the model absorbs knowledge about different domains (e.g., biology, physics, pop culture) and language styles (e.g., formal academic writing, casual social media)."),"\n",r.createElement(t.li,null,"The approach is largely unsupervised: you only need raw text, which is easy to scrape at large scale."),"\n"),"\n"),"\n",r.createElement(t.li,null,"\n",r.createElement(t.p,null,r.createElement(t.strong,null,"Disadvantages"),":"),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,"No direct instruction-following signal is embedded in the data; the model just learns how to predict tokens in context, not necessarily how to follow user instructions or refrain from harmful behaviors."),"\n",r.createElement(t.li,null,"Potential presence of biases, toxicity, or misleading text from the raw web, which then becomes learned model behavior or knowledge."),"\n"),"\n"),"\n"),"\n",r.createElement(t.h3,{id:"22-importance-of-structured-instructions",style:{position:"relative"}},r.createElement(t.a,{href:"#22-importance-of-structured-instructions","aria-label":"22 importance of structured instructions permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"2.2 importance of structured instructions"),"\n",r.createElement(t.p,null,"By contrast, post-training data typically includes explicit instructions or conversation prompts and corresponding desired responses. This structure teaches the model how to parse user questions, interpret instructions, and produce coherent and helpful replies rather than simply continuing text as in next-token prediction."),"\n",r.createElement(t.p,null,'One critical insight from numerous studies (including "Ouyang and gang, 2022" and "Zhou and gang, 2023") is that a well-structured, instruction-based dataset can drastically improve the usability and safety of an LLM. For instance, if you have a list of specific tasks (translating text, summarizing documents, solving math problems, writing code snippets, extracting information from text, etc.) accompanied by examples of correct solutions, the model begins to learn how to follow instructions in a targeted way.'),"\n",r.createElement(t.h3,{id:"23-challenges-in-collecting-high-quality-examples",style:{position:"relative"}},r.createElement(t.a,{href:"#23-challenges-in-collecting-high-quality-examples","aria-label":"23 challenges in collecting high quality examples permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"2.3 challenges in collecting high-quality examples"),"\n",r.createElement(t.p,null,"While instructions and labeled responses are invaluable for post-training, collecting these data can be non-trivial and expensive:"),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Scalability"),": Manually annotating instruction–response pairs for many tasks can be time-consuming. Large-scale annotation campaigns or specialized annotation teams might be required."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Quality control"),": Even if you can gather human-labeled data, ensuring consistent guidelines and a uniformly high standard is challenging. Different annotators may label data inconsistently or interpret instructions differently."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Coverage"),": For a general-purpose chatbot, you need a very broad range of tasks, from factual Q&A to creative writing. For specialized tasks (legal, financial, medical), the data must reflect those domains accurately."),"\n"),"\n",r.createElement(t.p,null,"Due to these challenges, many organizations opt for synthetic or semi-synthetic approaches to expand smaller high-quality seed datasets, which I will detail in the following chapter."),"\n",r.createElement(t.h2,{id:"3-post-training-datasets",style:{position:"relative"}},r.createElement(t.a,{href:"#3-post-training-datasets","aria-label":"3 post training datasets permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"3. post-training datasets"),"\n",r.createElement(t.p,null,"After acknowledging the need for structured instructions and the complexities of collecting them, we arrive at the specifics of building and refining post-training datasets. These specialized datasets are the linchpins for ensuring the model will respond accurately, follow instructions reliably, and remain helpful across different scenarios."),"\n",r.createElement(t.h3,{id:"31-storage--chat-templates",style:{position:"relative"}},r.createElement(t.a,{href:"#31-storage--chat-templates","aria-label":"31 storage  chat templates permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"3.1 storage & chat templates"),"\n",r.createElement(t.p,null,'LLMs tuned for interactive modes (e.g., chatbots) often store conversation data in a structured manner that preserves the flow of back-and-forth exchanges. A common approach is to store each conversation as a JSON object with fields like "system prompt", "user prompt", and "assistant response", sometimes accompanied by references to the conversation\'s entire previous context.'),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"ShareGPT format"),": This is a JSON-based format storing entire chat sessions, often used for open-source fine-tuning of chat-like models. Each entry might include a conversation array, with each turn labeled by role (system, user, or assistant)."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"OpenAI/Hugging Face format"),': Conversational data or instruction–response pairs are frequently stored as JSON Lines (.jsonl), with each line containing something like { "prompt": "...", "response": "...", "metadata": {...} }.'),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Chat templates (ChatML, Alpaca, etc.)"),': Some frameworks adopt specialized templates. For instance, ChatML introduces special tokens or delimiters (like "<|system|>" or "<|user|>") to guide the model in attributing context to the right speaker. Alpaca format uses an instruction–input–output triple, where "input" is typically empty if not needed.'),"\n"),"\n",r.createElement(t.p,null,"These templates ensure the model can learn to differentiate between the user's question and the assistant's answer, as well as system-level instructions that define global behavior or constraints."),"\n",r.createElement(t.h3,{id:"32-synthetic-data-generation",style:{position:"relative"}},r.createElement(t.a,{href:"#32-synthetic-data-generation","aria-label":"32 synthetic data generation permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"3.2 synthetic data generation"),"\n",r.createElement(t.p,null,"Because manually creating huge amounts of instruction–response data is daunting, many projects leverage synthetic data generation. The basic idea is to use a very capable LLM (e.g., GPT-4) to generate pairs of instruction and response. Alternatively, you might only generate the instructions or prompts, then ask humans or another model to provide responses. Another approach is to let the advanced model generate both prompt and response, occasionally injecting complexity or random transformations."),"\n",r.createElement(t.ol,null,"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Seed tasks"),": Start with a smaller set of carefully curated tasks or instructions that you know are high-quality."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"System prompts"),": Instruct a powerful model (like GPT-4) with system prompts that detail the desired style, difficulty, or domain of the generated tasks."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Expansion"),": Generate thousands or millions of new instructions based on the seed tasks. This might involve paraphrasing existing tasks, adding more complexity, or combining tasks from multiple domains."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Response generation"),": Either the same advanced model or a different model (or humans) produce the solution or response to each generated instruction."),"\n"),"\n",r.createElement(t.p,null,"Although synthetic data can significantly expand coverage, it carries the risk of copying or amplifying weaknesses of the generative model. Quality control steps and filtering become essential."),"\n",r.createElement(t.h3,{id:"33-data-enhancement",style:{position:"relative"}},r.createElement(t.a,{href:"#33-data-enhancement","aria-label":"33 data enhancement permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"3.3 data enhancement"),"\n",r.createElement(t.p,null,"To push post-training data quality further, practitioners use several enhancement strategies:"),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Verified outputs (unit tests, solvers)"),": For tasks that involve code or math, the generated solution can be validated by running unit tests or using symbolic/math solvers, discarding any instruction–response pairs that fail."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Multiple answers with rejection sampling"),": Generate multiple responses per instruction from a strong model. Then keep only the best response(s) according to certain criteria, possibly judged by a separate reward model or by humans."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Auto-Evol"),": A technique where the conversation is iteratively refined. For instance, if the model's response is partially incorrect, the system prompt (or a second model) can propose modifications to the question or solution, leading to improved pairs over time."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Chain-of-Thought (CoT)"),": Encouraging the model to produce not just the final answer but also the reasoning steps. These intermediate reasoning steps can themselves be used to refine or verify correctness and can serve as valuable training data to teach the model systematic problem-solving."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Branch-Solve-Merge"),": Involves generating multiple distinct solution paths for the same prompt, then merging or voting on the final answer to reduce mistakes."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Personas"),": Customizing the output style by injecting persona-based instructions or examples. This is especially useful if you want your model to maintain a consistent style or speak as a specific character or brand voice."),"\n"),"\n",r.createElement(t.h3,{id:"34-quality-filtering",style:{position:"relative"}},r.createElement(t.a,{href:"#34-quality-filtering","aria-label":"34 quality filtering permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"3.4 quality filtering"),"\n",r.createElement(t.p,null,"Given the complex generation and enhancement stages, it is critical to filter the data rigorously:"),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Rule-based filtering"),": Implement heuristics or scripts that remove prompts or responses containing disallowed content (e.g., hateful language, personally identifiable information, extraneous text)."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Deduplication"),": Use methods like MinHash or embeddings-based similarity to detect and remove near-duplicate or identical pairs. This helps keep the dataset from becoming bloated with repetitive instructions."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"N-gram decontamination"),": Remove or mask sequences of tokens that appear in the original pre-training set to avoid data leakage or undesired duplication. For instance, if you want to ensure that your post-training data does not trivially contain test set solutions for tasks the model may later be evaluated on."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Advanced filtering with reward models or judge LLMs"),': A separate model (often called a "reward model") or a dedicated judge LLM can score each (prompt, response) pair. Pairs falling below a certain threshold can be discarded.'),"\n"),"\n",r.createElement(t.p,null,"The final result of these processes is a structured, curated, and high-quality dataset that the model can learn from during fine-tuning. This dataset is typically orders of magnitude smaller than the original pre-training corpus but is far more relevant to the desired usage scenario."),"\n",r.createElement(t.h2,{id:"4-supervised-fine-tuning-sft",style:{position:"relative"}},r.createElement(t.a,{href:"#4-supervised-fine-tuning-sft","aria-label":"4 supervised fine tuning sft permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"4. supervised fine-tuning (sft)"),"\n",r.createElement(t.p,null,'Supervised Fine-Tuning (SFT) is a crucial phase that often immediately follows dataset curation. In SFT, you explicitly train the language model on a set of (prompt, response) pairs, adjusting the model weights so that it is more likely to produce the given "gold" response when it sees the corresponding prompt. This approach might be used standalone or as a precursor to preference alignment via reinforcement learning.'),"\n",r.createElement(t.h3,{id:"41-training-techniques",style:{position:"relative"}},r.createElement(t.a,{href:"#41-training-techniques","aria-label":"41 training techniques permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"4.1 training techniques"),"\n",r.createElement(t.h4,{id:"411-full-fine-tuning",style:{position:"relative"}},r.createElement(t.a,{href:"#411-full-fine-tuning","aria-label":"411 full fine tuning permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"4.1.1 full fine-tuning"),"\n",r.createElement(t.p,null,"The traditional approach is to fine-tune all of the model's parameters using labeled data. This can be computationally expensive and memory-intensive, especially for LLMs with billions of parameters. Despite these costs, full fine-tuning has some advantages:"),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,"The model's entire capacity can adapt to the new instructions or tasks."),"\n",r.createElement(t.li,null,"Potentially higher final performance when there is sufficient data and the domain shift is large."),"\n"),"\n",r.createElement(t.p,null,"However, for extremely large models (tens or hundreds of billions of parameters), even a single fine-tuning pass might require GPU clusters with large amounts of memory and distributed training infrastructure."),"\n",r.createElement(t.h4,{id:"412-parameter-efficient-methods-lora-qlora",style:{position:"relative"}},r.createElement(t.a,{href:"#412-parameter-efficient-methods-lora-qlora","aria-label":"412 parameter efficient methods lora qlora permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"4.1.2 parameter-efficient methods (lora, qlora)"),"\n",r.createElement(t.p,null,"To address these challenges, parameter-efficient fine-tuning has gained popularity. Two notable methods are Low-Rank Adaptation (LoRA) and QLoRA:"),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"LoRA"),": Instead of updating all of the model parameters, LoRA injects trainable rank-decomposition matrices into each layer. That is, for a weight matrix ",r.createElement(l.A,{text:"\\(W \\in \\mathbb{R}^{d \\times k}\\)"}),", you represent its update as a low-rank product ",r.createElement(l.A,{text:"\\(A B^T\\)"})," with ",r.createElement(l.A,{text:"\\(\\text{rank}(A, B) \\ll \\min(d, k)\\)"}),". LoRA significantly reduces the number of parameters that need to be updated, allowing cheaper fine-tuning and facilitating quick domain or instruction shifts."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"QLoRA"),": This approach extends LoRA but also quantizes the model weights to 4-bit or 8-bit for memory efficiency. One approach uses 4-bit quantized base weights, plus LoRA's trainable low-rank updates in higher-precision. This method, introduced in part by research from Microsoft and Hugging Face in 2023, can drastically reduce GPU memory usage while retaining model performance close to full fine-tuning."),"\n"),"\n",r.createElement(t.p,null,'The parameter-efficient approach is often sufficient to achieve near state-of-the-art performance on many tasks without incurring the massive computational cost of updating the entire model. Additionally, these methods allow you to maintain multiple "adapters" for different tasks or domains, enabling quick switching of the model\'s specialization.'),"\n",r.createElement(t.h3,{id:"42-training-parameters",style:{position:"relative"}},r.createElement(t.a,{href:"#42-training-parameters","aria-label":"42 training parameters permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"4.2 training parameters"),"\n",r.createElement(t.p,null,"When fine-tuning an LLM in a supervised manner, you must choose the following hyperparameters carefully:"),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Learning rate"),": Common values might range from ",r.createElement(l.A,{text:"\\(1e-5\\)"})," to ",r.createElement(l.A,{text:"\\(1e-7\\)"})," for large models, though smaller or larger values are occasionally used. The ideal value depends on the number of model parameters, the size of the fine-tuning dataset, and whether you are using parameter-efficient methods."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Schedulers"),": Cosine decay, linear warmup, or other scheduling strategies can be used to gradually adjust the learning rate. A typical pattern is some steps of linear warmup (often 1–5% of the total training steps) followed by a decay to zero or a lower baseline."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Batch size & gradient accumulation"),": Large effective batch sizes (thousands of tokens) help with stable training but might not fit entirely into GPU memory. Gradient accumulation across multiple forward passes is often used to emulate a larger batch size."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Number of epochs"),": Post-training datasets are often smaller, so training for multiple epochs can be beneficial. Some projects run anywhere from 1 to 10 epochs, although overfitting can become a concern with extremely small datasets."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Optimizers"),": AdamW remains popular. In the post-training context, 8-bit AdamW (which reduces memory usage for optimizer states) is widely adopted."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Weight decay"),": Usually kept relatively small (e.g., ",r.createElement(l.A,{text:"\\(1e-2\\)"})," or ",r.createElement(l.A,{text:"\\(1e-3\\)"}),") or even zero, depending on empirical results."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Warmup steps"),": A short period of warmup is standard, especially for large models, to avoid large gradient steps at the beginning of training."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"LoRA-specific parameters"),": If using LoRA, you also choose the rank (the dimension of the low-rank matrices, e.g., 4, 8, 16) and ",r.createElement(l.A,{text:"\\(\\alpha\\)"})," (the initial scaling factor). If applying LoRA to a subset of modules (e.g., only key/query projection matrices in the attention blocks), you must specify which modules to adapt."),"\n"),"\n",r.createElement(t.h3,{id:"43-distributed-training",style:{position:"relative"}},r.createElement(t.a,{href:"#43-distributed-training","aria-label":"43 distributed training permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"4.3 distributed training"),"\n",r.createElement(t.p,null,"Because even post-training can be quite computationally demanding, distributed training techniques are often employed:"),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"DeepSpeed"),": Microsoft's DeepSpeed library provides easy scaling across many GPUs and implements memory-optimization features such as ZeRO (Zero Redundancy Optimizer) stages, enabling large model training with lower GPU memory footprints."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Fully Sharded Data Parallel (FSDP)"),": A PyTorch-native approach that shards model parameters and optimizer states across data-parallel workers, reducing memory usage."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Gradient checkpointing"),": Saves memory by recomputing certain intermediate activations during the backward pass. This trades additional compute time for a reduction in GPU memory usage."),"\n"),"\n",r.createElement(t.p,null,"The choice of distributed strategy depends on hardware availability and the complexity of the model. Many teams experiment with different setups to find an optimal balance between cost, training speed, and memory efficiency."),"\n",r.createElement(t.h3,{id:"44-monitoring",style:{position:"relative"}},r.createElement(t.a,{href:"#44-monitoring","aria-label":"44 monitoring permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"4.4 monitoring"),"\n",r.createElement(t.p,null,"Monitoring is essential in SFT because it allows you to spot issues early — such as overfitting, learning rate misconfiguration, or catastrophic forgetting of the model's previously acquired knowledge. Practitioners often track:"),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Training & validation loss curves"),": Monitoring the cross-entropy (CE) loss or perplexity on both the training set and a held-out validation set."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Learning rate schedules"),": Visualizing the learning rate over time to ensure it is decaying or ramping up as expected."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Gradient norms"),": Detecting gradient explosions or vanishing gradients."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Loss spikes"),": If you see sudden spikes in the loss, it might indicate a bad batch of data or an excessively high learning rate."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Performance consistency"),": Evaluating the model's performance on a separate set of tasks or prompts, ensuring you are not inadvertently harming general capabilities while you fine-tune for instruction compliance."),"\n"),"\n",r.createElement(t.p,null,"A variety of tools (TensorBoard, Weights & Biases, Neptune, Comet) can visualize these metrics in real time, making it easier to iterate on hyperparameters and detect anomalies."),"\n",r.createElement(t.h2,{id:"5-preference-alignment",style:{position:"relative"}},r.createElement(t.a,{href:"#5-preference-alignment","aria-label":"5 preference alignment permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"5. preference alignment"),"\n",r.createElement(t.p,null,'Beyond purely supervised fine-tuning — where the model is taught to produce a reference answer for a single correct response — there is a strong interest in aligning the model\'s behaviors with explicit preferences about what constitutes a "good" or "bad" answer. This more advanced phase of post-training can improve the model\'s output quality in subtle but impactful ways, often referred to as alignment with human values, policies, or domain-specific rules.'),"\n",r.createElement(t.h3,{id:"51-rejection-sampling",style:{position:"relative"}},r.createElement(t.a,{href:"#51-rejection-sampling","aria-label":"51 rejection sampling permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"5.1 rejection sampling"),"\n",r.createElement(t.p,null,"One relatively straightforward way to incorporate preference signals is through rejection sampling. In this approach:"),"\n",r.createElement(t.ol,null,"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Generate multiple responses"),": For each user prompt, you let the current model produce several candidate answers."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Human or model selection"),': A human annotator (or a specialized "judge" model) chooses the best response and labels the others as rejected.'),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Reinforcement through supervised data"),": You then create new training examples, labeling the chosen response as correct and the others as incorrect or suboptimal."),"\n"),"\n",r.createElement(t.p,null,"Rejection sampling works particularly well if your data collection pipeline includes humans in the loop. Over time, the model shifts toward producing answers that more frequently meet the acceptance criteria. However, the approach can be time-consuming if extensive human labeling is required."),"\n",r.createElement(t.h3,{id:"52-direct-preference-optimization-dpo",style:{position:"relative"}},r.createElement(t.a,{href:"#52-direct-preference-optimization-dpo","aria-label":"52 direct preference optimization dpo permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"5.2 direct preference optimization (dpo)"),"\n",r.createElement(t.p,null,"Direct Preference Optimization (DPO) emerged as an alternative that bypasses training a separate reward model. Instead, it uses pairs of chosen vs. rejected responses directly in a custom loss function that encourages the model to prefer the chosen response while penalizing the rejected ones."),"\n",r.createElement(t.p,null,"In a simplified sense, suppose you have for each prompt ",r.createElement(l.A,{text:"\\(x\\)"})," two candidate responses: the chosen response ",r.createElement(l.A,{text:"\\(y^{+}\\)"})," and the rejected response ",r.createElement(l.A,{text:"\\(y^{-}\\)"}),". DPO sets up an objective that maximizes the likelihood of ",r.createElement(l.A,{text:"\\(y^{+}\\)"})," while minimizing the likelihood of ",r.createElement(l.A,{text:"\\(y^{-}\\)"}),". Concretely, one can formulate a ratio:"),"\n",r.createElement(l.A,{text:"\\[\n\\mathcal{L}_{\\text{DPO}} = - \\log\\frac{p_\\theta(y^{+}\\mid x)}{p_\\theta(y^{-}\\mid x)}\n\\]"}),"\n",r.createElement(t.p,null,"where ",r.createElement(l.A,{text:"\\(p_\\theta\\)"})," is the model's distribution. By learning to increase ",r.createElement(l.A,{text:"\\(p_\\theta(y^{+}\\mid x)\\)"})," relative to ",r.createElement(l.A,{text:"\\(p_\\theta(y^{-}\\mid x)\\)"})," for the same prompt ",r.createElement(l.A,{text:"\\(x\\)"}),", the model is effectively aligning with the better response. DPO is often attractive because it avoids some complexities of reward modeling and direct policy gradient approaches. It still requires preference data (i.e., pairs of chosen vs. rejected responses), but it can be simpler to implement and stable to train."),"\n",r.createElement(t.h3,{id:"53-proximal-policy-optimization-ppo",style:{position:"relative"}},r.createElement(t.a,{href:"#53-proximal-policy-optimization-ppo","aria-label":"53 proximal policy optimization ppo permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"5.3 proximal policy optimization (ppo)"),"\n",r.createElement(t.p,null,'Proximal Policy Optimization (PPO) is the backbone of many RLHF systems, drawing on ideas from reinforcement learning to fine-tune policy networks (i.e., the language model). The typical pipeline (adapted from "Ziegler and gang, 2019") is:'),"\n",r.createElement(t.ol,null,"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Supervised baseline"),": Start from a supervised fine-tuned policy or from the original pretrained language model."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Reward model"),": Have a separate reward model (",r.createElement(l.A,{text:"\\(R_\\phi\\)"}),") that was trained to predict human preferences or to output a scalar score for how good a given response is."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Rollouts"),": For each prompt, the policy (i.e., the LLM) generates a response. The reward model then scores that response, producing a scalar reward ",r.createElement(l.A,{text:"\\(r\\)"}),"."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Policy gradient update"),": Update the policy parameters ",r.createElement(l.A,{text:"\\(\\theta\\)"})," with PPO, which modifies the log probabilities ",r.createElement(l.A,{text:"\\(\\log p_\\theta\\)"})," of the generated tokens, aiming to maximize the expected reward while avoiding drastic changes to the policy. The latter is enforced via a clipped objective that prevents large policy updates:","\n",r.createElement(l.A,{text:"\\[\n\\mathcal{L}_{\\text{PPO}}(\\theta) = \\mathbb{E}\\left[\\min\\left(r_t(\\theta) \\hat{A_t}, \\text{clip}(r_t(\\theta), 1-\\epsilon, 1+\\epsilon)\\hat{A_t}\\right)\\right]\n\\]"}),"\n","where ",r.createElement(l.A,{text:"\\(r_t(\\theta)\\)"})," is the ratio between the new and old policy probabilities for an action (token), and ",r.createElement(l.A,{text:"\\(\\hat{A_t}\\)"})," is an advantage estimate. ",r.createElement(l.A,{text:"\\(\\epsilon\\)"})," is a hyperparameter (clip range), typically around 0.1–0.2."),"\n"),"\n",r.createElement(t.p,null,"This iterative process eventually converges on a policy that better matches human preferences (as encoded by the reward model), while the clipping mechanism ensures training stability and discourages overfitting to the reward model."),"\n",r.createElement(t.h3,{id:"54-monitoring",style:{position:"relative"}},r.createElement(t.a,{href:"#54-monitoring","aria-label":"54 monitoring permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"5.4 monitoring"),"\n",r.createElement(t.p,null,"Preference alignment processes need careful monitoring to ensure that:"),"\n",r.createElement(t.ol,null,"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"The margin between chosen and rejected answers")," is growing: The final policy should consistently produce better answers than the rejected ones."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Accuracy or helpfulness")," on external tasks is improving: A well-aligned model should remain accurate or even gain accuracy by focusing on user-relevant answers."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Stability"),": Drastic updates can cause mode collapse or degenerate behaviors. Clipping in PPO or other techniques in DPO and rejection sampling aim to prevent big shifts that degrade performance."),"\n"),"\n",r.createElement(t.p,null,"It is also essential to track whether the reward model is inadvertently reinforcing undesirable behaviors, or if the model is gaming the reward function by producing superficially pleasing but incorrect answers."),"\n",r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">&lt;Code text={`\nimport torch\nfrom transformers import AutoTokenizer, AutoModelForCausalLM\n# This is a toy snippet showing the structure for preference data.\n\n# Suppose we have "pairs" of (prompt, chosen_response, rejected_response)\n# We\'ll do a simplified direct preference optimization update\n\ntokenizer = AutoTokenizer.from_pretrained("some-llm-checkpoint")\nmodel = AutoModelForCausalLM.from_pretrained("some-llm-checkpoint")\nmodel.train()\n\noptimizer = torch.optim.AdamW(model.parameters(), lr=1e-5)\n\n# Example data\nsamples = [\n    {\n        "prompt": "How to bake a chocolate cake?",\n        "chosen": "You can start by preheating the oven to 350F, mixing dry ingredients...",\n        "rejected": "Here\'s a random set of words not relevant to your question..."\n    },\n    # ...\n]\n\nfor epoch in range(num_epochs):\n    for sample in samples:\n        input_prompt = sample["prompt"]\n        chosen = sample["chosen"]\n        rejected = sample["rejected"]\n\n        # Tokenize\n        input_ids_prompt = tokenizer.encode(input_prompt, return_tensors="pt")\n        input_ids_chosen = tokenizer.encode(chosen, return_tensors="pt")\n        input_ids_rejected = tokenizer.encode(rejected, return_tensors="pt")\n\n        # Compute log probabilities\n        with torch.no_grad():\n            # Teacher forcing: model sees [prompt + chosen]\n            chosen_outputs = model(\n                torch.cat([input_ids_prompt, input_ids_chosen], dim=1),\n                labels=torch.cat([input_ids_prompt, input_ids_chosen], dim=1)\n            )\n            chosen_log_probs = chosen_outputs.loss * input_ids_chosen.size(1)\n\n            # Similarly for [prompt + rejected]\n            rejected_outputs = model(\n                torch.cat([input_ids_prompt, input_ids_rejected], dim=1),\n                labels=torch.cat([input_ids_prompt, input_ids_rejected], dim=1)\n            )\n            rejected_log_probs = rejected_outputs.loss * input_ids_rejected.size(1)\n\n        # Suppose a simplified DPO-like objective: \n        # L = -log( exp(-chosen_log_probs) / (exp(-chosen_log_probs) + exp(-rejected_log_probs)) )\n        #     = chosen_log_probs + log(1 + exp(-(rejected_log_probs - chosen_log_probs)))\n        # We\'ll do a gradient-based approach, so we need to re-run forward for grads:\n\n        # Re-run forward pass with requires_grad\n        chosen_outputs = model(\n            torch.cat([input_ids_prompt, input_ids_chosen], dim=1),\n            labels=torch.cat([input_ids_prompt, input_ids_chosen], dim=1)\n        )\n        rejected_outputs = model(\n            torch.cat([input_ids_prompt, input_ids_rejected], dim=1),\n            labels=torch.cat([input_ids_prompt, input_ids_rejected], dim=1)\n        )\n        chosen_log_probs = chosen_outputs.loss * input_ids_chosen.size(1)\n        rejected_log_probs = rejected_outputs.loss * input_ids_rejected.size(1)\n\n        # Compute the approximate DPO loss\n        loss = chosen_log_probs + torch.log1p(\n            torch.exp(-(rejected_log_probs - chosen_log_probs))\n        )\n\n        optimizer.zero_grad()\n        loss.backward()\n        optimizer.step()\n\nprint("Finished simplified preference alignment training.")\n`}/></code></pre></div>'}}),"\n",r.createElement(t.p,null,"Above, I've included a simplified pseudo-code snippet to show how one might implement a rough version of Direct Preference Optimization (DPO). The snippet is ",r.createElement(t.em,null,"not")," production-ready, but it conveys the idea of using pairs of (chosen, rejected) responses for the same prompt to shape the model's preferences. In reality, more sophisticated data loading, batching, and distributed training strategies would be used."),"\n",r.createElement(t.hr),"\n",r.createElement(t.p,null,"The end goal of these preference alignment strategies is to fine-tune the model so that it consistently produces high-quality, policy-compliant, and user-friendly outputs. By integrating SFT with preference alignment (in the form of rejection sampling, DPO, PPO, or other RL-based frameworks), developers can build large language models that provide practical and aligned responses across a wide range of tasks."),"\n",r.createElement(t.p,null,"These techniques are part of a rapidly evolving field of research, with new methods regularly introduced at top-tier conferences (e.g., NeurIPS, ICML). Continued experimentation with new data curation pipelines, advanced filtering strategies, and novel preference optimization objectives will likely remain an essential aspect of LLM development. For practitioners, it is important to stay up to date on these techniques, choosing the right combination of data, fine-tuning approach, and preference alignment strategy that best suits their use case and computational constraints."),"\n",r.createElement(n,{alt:"diagram of llm tuning pipeline from pre-training to supervised fine-tuning and preference alignment",path:"",caption:"A conceptual overview of how large language models transition from pre-training to specialized post-training steps.",zoom:"false"}),"\n",r.createElement(t.hr),"\n",r.createElement(t.p,null,"In practice, tuning large language models for real-world applications involves iterative experimentation, high-quality dataset curation, and a careful balancing act among improvements in safety, helpfulness, and factual correctness. By following best practices in data collection, supervised training, preference modeling, and monitoring, one can gradually mold a powerful but general LLM into a sophisticated assistant or domain expert that meets organizational needs — while still preserving the vast knowledge and linguistic fluency that made large language models so impactful in the first place."))}var s=function(e){void 0===e&&(e={});const{wrapper:t}=Object.assign({},(0,i.RP)(),e.components);return t?r.createElement(t,e,r.createElement(o,e)):o(e)};var c=n(36710),d=n(58481),m=n.n(d),h=n(36310),u=n(87245),p=n(27042),g=n(59849),f=n(5591),v=n(61122),y=n(9219),b=n(33203),E=n(95751),w=n(94328),x=n(80791),k=n(78137);const _=e=>{let{toc:t}=e;if(!t||!t.items)return null;return r.createElement("nav",{className:x.R},r.createElement("ul",null,t.items.map(((e,t)=>r.createElement("li",{key:t},r.createElement("a",{href:e.url,onClick:t=>((e,t)=>{e.preventDefault();const n=t.replace("#",""),a=document.getElementById(n);a&&a.scrollIntoView({behavior:"smooth",block:"start"})})(t,e.url)},e.title),e.items&&r.createElement(_,{toc:{items:e.items}}))))))};function S(e){let{data:{mdx:t,allMdx:l,allPostImages:o},children:s}=e;const{frontmatter:c,body:d,tableOfContents:g}=t,x=c.index,S=c.slug.split("/")[1],z=l.nodes.filter((e=>e.frontmatter.slug.includes(`/${S}/`))).sort(((e,t)=>e.frontmatter.index-t.frontmatter.index)),T=z.findIndex((e=>e.frontmatter.index===x)),H=z[T+1],L=z[T-1],A=c.slug.replace(/\/$/,""),P=/[^/]*$/.exec(A)[0],M=`posts/${S}/content/${P}/`,{0:C,1:j}=(0,r.useState)(c.flagWideLayoutByDefault),{0:I,1:q}=(0,r.useState)(!1);var O;(0,r.useEffect)((()=>{q(!0);const e=setTimeout((()=>q(!1)),340);return()=>clearTimeout(e)}),[C]),"adventures"===S?O=y.cb:"research"===S?O=y.Qh:"thoughts"===S&&(O=y.T6);const V=m()(d).replace(/import .*? from .*?;/g,"").replace(/<.*?>/g,"").replace(/\{\/\*[\s\S]*?\*\/\}/g,"").trim().split(/\s+/).length,B=function(e){if(e<=10)return"~10 min";if(e<=20)return"~20 min";if(e<=30)return"~30 min";if(e<=40)return"~40 min";if(e<=50)return"~50 min";if(e<=60)return"~1 h";const t=Math.floor(e/60),n=e%60;return n<=30?`~${t}${n>0?".5":""} h`:`~${t+1} h`}(Math.ceil(V/O)+(c.extraReadTimeMin||0)),N=[{flag:c.flagDraft,component:()=>Promise.all([n.e(3231),n.e(8809)]).then(n.bind(n,28809))},{flag:c.flagMindfuckery,component:()=>Promise.all([n.e(3231),n.e(2471)]).then(n.bind(n,67709))},{flag:c.flagRewrite,component:()=>Promise.all([n.e(3231),n.e(6764)]).then(n.bind(n,62002))},{flag:c.flagOffensive,component:()=>Promise.all([n.e(3231),n.e(2443)]).then(n.bind(n,17681))},{flag:c.flagProfane,component:()=>Promise.all([n.e(3231),n.e(8048)]).then(n.bind(n,53286))},{flag:c.flagMultilingual,component:()=>Promise.all([n.e(3231),n.e(4069)]).then(n.bind(n,78831))},{flag:c.flagUnreliably,component:()=>Promise.all([n.e(3231),n.e(3417)]).then(n.bind(n,8179))},{flag:c.flagPolitical,component:()=>Promise.all([n.e(3231),n.e(5195)]).then(n.bind(n,30433))},{flag:c.flagCognitohazard,component:()=>Promise.all([n.e(3231),n.e(3175)]).then(n.bind(n,8413))},{flag:c.flagHidden,component:()=>Promise.all([n.e(3231),n.e(9556)]).then(n.bind(n,14794))}],{0:R,1:D}=(0,r.useState)([]);return(0,r.useEffect)((()=>{N.forEach((e=>{let{flag:t,component:n}=e;t&&n().then((e=>{D((t=>[].concat((0,a.A)(t),[e.default])))}))}))}),[]),r.createElement(p.P.div,{initial:{opacity:0},animate:{opacity:1},exit:{opacity:0},transition:{duration:.15}},r.createElement(f.A,{postNumber:c.index,date:c.date,updated:c.updated,readTime:B,difficulty:c.difficultyLevel,title:c.title,desc:c.desc,banner:c.banner,section:S,postKey:P,isMindfuckery:c.flagMindfuckery,mainTag:c.mainTag}),r.createElement("div",{style:{display:"flex",justifyContent:"flex-end",flexWrap:"wrap",maxWidth:"75%",marginLeft:"auto",paddingRight:"1vw",marginTop:"-6vh",marginBottom:"4vh"}},c.otherTags.map(((e,t)=>r.createElement("span",{key:t,className:`noselect ${k.MW}`,style:{margin:"0 5px 5px 0"}},e)))),r.createElement("div",{class:"postBody"},r.createElement(_,{toc:g})),r.createElement("br"),r.createElement("div",{style:{margin:"0 10% -2vh 30%",textAlign:"right"}},r.createElement(p.P.button,{class:"noselect",className:w.pb,id:w.xG,onClick:()=>{j(!C)},whileTap:{scale:.93}},r.createElement(p.P.div,{className:E.DJ,key:C,initial:{opacity:0},animate:{opacity:1},exit:{opacity:0},transition:{duration:.3,ease:"easeInOut"}},C?"Switch to default layout":"Switch to wide layout"))),r.createElement("br"),r.createElement("div",{class:"postBody",style:{margin:C?"0 -14%":"",maxWidth:C?"200%":"",transition:"margin 1s ease, max-width 1s ease, padding 1s ease"}},r.createElement("div",{className:`${w.P_} ${I?w.Xn:w.qG}`},R.map(((e,t)=>r.createElement(e,{key:t}))),c.indexCourse?r.createElement(b.A,{index:c.indexCourse,category:c.courseCategoryName}):"",r.createElement(h.Z.Provider,{value:{images:o.nodes,basePath:M.replace(/\/$/,"")+"/"}},r.createElement(i.xA,{components:{Image:u.A}},s)))),r.createElement(v.A,{nextPost:H,lastPost:L,keyCurrent:P,section:S}))}function z(e){return r.createElement(S,e,r.createElement(s,e))}function T(e){var t,n,a,i,l;let{data:o}=e;const{frontmatter:s}=o.mdx,d=s.titleSEO||s.title,m=s.titleOG||d,h=s.titleTwitter||d,u=s.descSEO||s.desc,p=s.descOG||u,f=s.descTwitter||u,v=s.schemaType||"BlogPosting",y=s.keywordsSEO,b=s.date,E=s.updated||b,w=s.imageOG||(null===(t=s.banner)||void 0===t||null===(n=t.childImageSharp)||void 0===n||null===(a=n.gatsbyImageData)||void 0===a||null===(i=a.images)||void 0===i||null===(l=i.fallback)||void 0===l?void 0:l.src),x=s.imageAltOG||p,k=s.imageTwitter||w,_=s.imageAltTwitter||f,S=s.canonicalURL,z=s.flagHidden||!1,T=s.mainTag||"Posts",H=s.slug.split("/")[1]||"posts",{siteUrl:L}=(0,c.Q)(),A={"@context":"https://schema.org","@type":"BreadcrumbList",itemListElement:[{"@type":"ListItem",position:1,name:"Home",item:L},{"@type":"ListItem",position:2,name:T,item:`${L}/${s.slug.split("/")[1]}`},{"@type":"ListItem",position:3,name:d,item:`${L}${s.slug}`}]};return r.createElement(g.A,{title:d+" - avrtt.blog",titleOG:m,titleTwitter:h,description:u,descriptionOG:p,descriptionTwitter:f,schemaType:v,keywords:y,datePublished:b,dateModified:E,imageOG:w,imageAltOG:x,imageTwitter:k,imageAltTwitter:_,canonicalUrl:S,flagHidden:z,mainTag:T,section:H,type:"article"},r.createElement("script",{type:"application/ld+json"},JSON.stringify(A)))}},96098:function(e,t,n){var a=n(96540),i=n(7978);t.A=e=>{let{text:t}=e;return a.createElement(i.A,null,t)}}}]);
//# sourceMappingURL=component---src-templates-post-js-content-file-path-src-pages-posts-research-tuning-llms-mdx-f5ecae67380cc87581e5.js.map