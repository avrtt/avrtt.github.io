"use strict";(self.webpackChunkavrtt_blog=self.webpackChunkavrtt_blog||[]).push([[1668],{44328:function(e,t,a){a.r(t),a.d(t,{Head:function(){return z},PostTemplate:function(){return C},default:function(){return _}});var n=a(28453),i=a(96540),r=a(61992),l=a(62087),o=a(90548);function s(e){const t=Object.assign({p:"p",h3:"h3",a:"a",span:"span",br:"br",h2:"h2",ol:"ol",li:"li",strong:"strong"},(0,n.RP)(),e.components),{Image:a}=t;return a||function(e,t){throw new Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Image",!0),i.createElement(i.Fragment,null,"\n",i.createElement("br"),"\n","\n",i.createElement(t.p,null,'Dimensionality reduction stands as one of the foundational pillars of modern data analysis, serving myriad purposes that range from improved visualization of high-dimensional datasets to facilitating faster and more robust machine learning models. When one is confronted with datasets that have an overwhelming number of features — potentially in the hundreds, thousands, or even millions — performing certain types of computations or building effective predictive models can quickly become unwieldy. This phenomenon, often referred to as the "curse of dimensionality", motivates the creation of methods and algorithms to meaningfully reduce the dimension of the data space, preserving as much relevant information as possible.'),"\n",i.createElement(t.p,null,"Principal Component Analysis (PCA) is historically and practically one of the most widely used linear dimensionality reduction methods. Dating back to the work of Karl Pearson (Pearson, Philosophical Magazine, 1901) and further formalized by Harold Hotelling (Hotelling, 1933), PCA transforms the original features into new, uncorrelated features known as principal components, each of which captures a certain portion of the variance present in the data. These principal components, ordered by descending variance, provide a powerful way to discard noise and redundancy while capturing the main trends in the data."),"\n",i.createElement(t.p,null,"While PCA is linear in nature, it remains highly relevant in contemporary machine learning practices, not least because it is relatively straightforward to implement, computationally tractable (with the help of singular value decomposition implementations), and conceptually intuitive. In combination with more advanced or nonlinear dimensionality reduction algorithms, PCA continues to serve as a baseline technique, a pre-processing method, and a benchmark for comparing new approaches. In this article, I dive into the theoretical underpinnings of PCA, detail its uses, and chart a path through the broader landscape of dimensionality reduction. Along the way, I highlight practical implementation details, advanced modifications, and meaningful real-world applications."),"\n",i.createElement(t.h3,{id:"11-the-curse-of-dimensionality",style:{position:"relative"}},i.createElement(t.a,{href:"#11-the-curse-of-dimensionality","aria-label":"11 the curse of dimensionality permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"1.1 The curse of dimensionality"),"\n",i.createElement(t.p,null,'The phrase "curse of dimensionality" appears frequently in discussions about high-dimensional datasets. At an intuitive level, when the dimensionality of data grows, the volume of the space grows so fast that the available data become sparse, making many density- or distance-based methods lose their effectiveness. Points that seemed close in a couple of dimensions suddenly appear far apart, and classification boundaries might become more complex to discern. Neighborhood-based algorithms such as k-nearest neighbors tend to suffer severely from the curse of dimensionality, because every point is far from every other point in a very high-dimensional space.'),"\n",i.createElement(t.p,null,"Furthermore, a large number of features significantly increases the risk of overfitting. If you feed a machine learning model a massive number of features with limited data, the model can latch onto spurious correlations that do not generalize. Consequently, the need for methods to systematically reduce or select features, typically followed by robust forms of validation, becomes paramount."),"\n",i.createElement(t.h3,{id:"12-motivations-for-dimensionality-reduction-in-machine-learning",style:{position:"relative"}},i.createElement(t.a,{href:"#12-motivations-for-dimensionality-reduction-in-machine-learning","aria-label":"12 motivations for dimensionality reduction in machine learning permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"1.2 Motivations for dimensionality reduction in machine learning"),"\n",i.createElement(t.p,null,"Dimensionality reduction greatly simplifies downstream modeling tasks. By paring down the dataset into fewer and more expressive features, one can:"),"\n",i.createElement(t.p,null,"• Improve interpretability: Instead of analyzing hundreds or thousands of correlated features, a handful of principal components or factors may be easier to interpret or visualize.",i.createElement(t.br),"\n","• Reduce computational complexity: Many algorithms can have run times that scale poorly with the number of features.",i.createElement(t.br),"\n","• Mitigate overfitting: Fewer features often mean fewer parameters to learn, thus reducing the likelihood of memorizing noise.",i.createElement(t.br),"\n","• Aid in data visualization: Projecting the data into two- or three-dimensional space is one of the most straightforward ways to get a visual sense of structure, outliers, or regional clusters."),"\n",i.createElement(t.p,null,"With PCA specifically, the user obtains new axes — principal components — that are linear combinations of the original variables, orthogonal to each other and explaining progressively smaller portions of the total variance. PCA can be considered a stepping stone for many advanced methods in machine learning and data science, and it continues to influence subsequent techniques such as kernel PCA for nonlinear embeddings, manifold learning approaches, and even autoencoder structures in neural networks."),"\n",i.createElement(t.h2,{id:"2-the-conceptual-landscape-of-dimensionality-reduction",style:{position:"relative"}},i.createElement(t.a,{href:"#2-the-conceptual-landscape-of-dimensionality-reduction","aria-label":"2 the conceptual landscape of dimensionality reduction permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"2. The conceptual landscape of dimensionality reduction"),"\n",i.createElement(t.p,null,"Before diving into PCA's minute details, it is instructive to situate PCA within the broader context of dimensionality reduction methods. Although PCA is arguably the most popular technique, there exist many other approaches. Some focus on linear transformations and rely on matrix factorization, while others attempt to preserve local neighborhoods or manifold structures by means of sophisticated nonlinear embeddings."),"\n",i.createElement(t.h3,{id:"21-linear-vs-non-linear-approaches",style:{position:"relative"}},i.createElement(t.a,{href:"#21-linear-vs-non-linear-approaches","aria-label":"21 linear vs non linear approaches permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"2.1 Linear vs. non-linear approaches"),"\n",i.createElement(t.p,null,"Dimensionality reduction can be roughly categorized into linear and nonlinear methods:"),"\n",i.createElement(t.p,null,"• Linear techniques: These include PCA, Factor Analysis (FA), Linear Discriminant Analysis (LDA), and standard random projection methods. They transform the data using linear maps, typically manifested as matrix transformations.",i.createElement(t.br),"\n","• Nonlinear techniques: Algorithms such as kernel PCA, t-SNE (Maaten & Hinton, JMLR, 2008), UMAP, isomap, and locally linear embedding attempt to preserve manifold structures or distances in a more intricate fashion. By incorporating kernels or specialized distance metrics, these methods can capture more complex relationships that do not align with linear subspaces."),"\n",i.createElement(t.h3,{id:"22-feature-selection-vs-feature-extraction",style:{position:"relative"}},i.createElement(t.a,{href:"#22-feature-selection-vs-feature-extraction","aria-label":"22 feature selection vs feature extraction permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"2.2 Feature selection vs. feature extraction"),"\n",i.createElement(t.p,null,"It also helps to distinguish between feature selection and feature extraction:"),"\n",i.createElement(t.p,null,"• Feature selection: The technique of identifying and retaining a subset of the original features that hold the highest predictive or explanatory power, leaving them otherwise unchanged.",i.createElement(t.br),"\n","• Feature extraction: The practice of creating new features by combining existing ones, usually through a mathematically informed transformation such as PCA or autoencoders."),"\n",i.createElement(t.p,null,"This article focuses on feature extraction, specifically linear transformations based on covariance structure — i.e., PCA."),"\n",i.createElement(t.h3,{id:"23-manifold-learning-perspective",style:{position:"relative"}},i.createElement(t.a,{href:"#23-manifold-learning-perspective","aria-label":"23 manifold learning perspective permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"2.3 Manifold learning perspective"),"\n",i.createElement(t.p,null,'Modern viewpoints often treat high-dimensional data as lying (approximately) on or near low-dimensional manifolds. The idea is that, even if we have thousands of coordinates describing a single sample, the "intrinsic dimension" of that sample might actually be quite small. Manifold learning algorithms such as isomap or t-SNE attempt to uncover this lower-dimensional structure. PCA, as a linear method, can be seen as finding the best linear manifold — a plane, or hyperplane, spanning a subspace — that approximates the data under the assumption that linear relationships are a main driver of covariance.'),"\n",i.createElement(t.h2,{id:"3-the-theoretical-foundation-of-pca",style:{position:"relative"}},i.createElement(t.a,{href:"#3-the-theoretical-foundation-of-pca","aria-label":"3 the theoretical foundation of pca permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"3. The theoretical foundation of PCA"),"\n",i.createElement(t.p,null,"Principal Component Analysis can be introduced via at least three related perspectives:"),"\n",i.createElement(t.ol,null,"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Maximize variance"),": Find directions (vectors) in the feature space that possess maximal variance."),"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Minimize reconstruction error"),": Find the best rank-",i.createElement(o.A,{text:"\\(k\\)"})," linear subspace that allows you to reconstruct the original data."),"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Orthogonal transformation of the covariance matrix"),": Diagonalize the data's covariance matrix to obtain uncorrelated variables ordered by their variance."),"\n"),"\n",i.createElement(t.p,null,"These three interpretations all converge to the same mathematical machinery — the covariance matrix and its eigen-decomposition (or equivalently, the singular value decomposition of the data matrix)."),"\n",i.createElement(t.h3,{id:"31-covariance-matrix",style:{position:"relative"}},i.createElement(t.a,{href:"#31-covariance-matrix","aria-label":"31 covariance matrix permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"3.1 Covariance matrix"),"\n",i.createElement(t.p,null,"Consider a dataset of ",i.createElement(o.A,{text:"\\(N\\)"})," samples, each sample represented as a ",i.createElement(o.A,{text:"\\(d\\)"}),"-dimensional vector ",i.createElement(o.A,{text:"\\(x_i \\in \\mathbb{R}^d\\)"}),". Let ",i.createElement(o.A,{text:"\\(X\\)"})," be the ",i.createElement(o.A,{text:"\\(N \\times d\\)"})," data matrix, where each row corresponds to a sample. For simplicity, we assume the data matrix is mean-centered, such that each column has mean zero. Let ",i.createElement(o.A,{text:"\\(\\bar{x}\\)"})," be the sample mean."),"\n",i.createElement(t.p,null,"The covariance matrix ",i.createElement(o.A,{text:"\\( \\Sigma \\)"})," of the data is given by:"),"\n",i.createElement(o.A,{text:"\\[\n\\Sigma = \\frac{1}{N - 1}\\sum_{i=1}^{N} (x_i - \\bar{x})(x_i - \\bar{x})^\\top\n\\]"}),"\n",i.createElement(t.p,null,"In practice, if ",i.createElement(o.A,{text:"\\(X\\)"})," is already mean-centered, ",i.createElement(o.A,{text:"\\(\\Sigma\\)"})," can be estimated by the matrix multiplication:"),"\n",i.createElement(o.A,{text:"\\[\n\\Sigma = \\frac{1}{N - 1} X^\\top X.\n\\]"}),"\n",i.createElement(t.p,null,"Here, ",i.createElement(o.A,{text:"\\(N\\)"})," denotes the number of samples, ",i.createElement(o.A,{text:"\\(d\\)"})," the number of original features, ",i.createElement(o.A,{text:"\\(x_i\\)"})," the ",i.createElement(o.A,{text:"\\(i\\)"}),"-th sample vector, and ",i.createElement(o.A,{text:"\\(\\bar{x}\\)"})," the sample mean. The matrix ",i.createElement(o.A,{text:"\\(X\\)"})," has dimensions ",i.createElement(o.A,{text:"\\(N \\times d\\)"}),"; thus, ",i.createElement(o.A,{text:"\\(X^\\top\\)"})," is ",i.createElement(o.A,{text:"\\(d \\times N\\)"}),". Multiplying ",i.createElement(o.A,{text:"\\(X^\\top X\\)"})," yields a ",i.createElement(o.A,{text:"\\(d \\times d\\)"})," matrix."),"\n",i.createElement(t.h3,{id:"32-eigenvalues-and-eigenvectors",style:{position:"relative"}},i.createElement(t.a,{href:"#32-eigenvalues-and-eigenvectors","aria-label":"32 eigenvalues and eigenvectors permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"3.2 Eigenvalues and eigenvectors"),"\n",i.createElement(t.p,null,"Once ",i.createElement(o.A,{text:"\\(\\Sigma\\)"})," is computed, PCA seeks to find its eigenvalues and eigenvectors. We denote the eigenvalue–eigenvector pairs by ",i.createElement(o.A,{text:"\\((\\lambda_k, v_k)\\)"})," for ",i.createElement(o.A,{text:"\\(k = 1, 2, \\ldots, d\\)"}),". That is:"),"\n",i.createElement(o.A,{text:"\\[\n\\Sigma \\, v_k = \\lambda_k \\, v_k,\n\\]"}),"\n",i.createElement(t.p,null,"where ",i.createElement(o.A,{text:"\\(\\lambda_k\\)"})," is the ",i.createElement(o.A,{text:"\\(k\\)"}),"-th eigenvalue and ",i.createElement(o.A,{text:"\\(v_k\\)"})," is the corresponding eigenvector. The eigenvalues, which are non-negative because ",i.createElement(o.A,{text:"\\(\\Sigma\\)"})," is positive semi-definite, quantitatively indicate how much variance is captured in each principal component direction. We commonly rank the eigenvalues in descending order:"),"\n",i.createElement(o.A,{text:"\\( \\lambda_1 \\ge \\lambda_2 \\ge \\cdots \\ge \\lambda_d \\ge 0. \\)"}),"\n",i.createElement(t.p,null,"The eigenvector ",i.createElement(o.A,{text:"\\(v_1\\)"})," corresponding to the largest eigenvalue ",i.createElement(o.A,{text:"\\(\\lambda_1\\)"})," is the first principal component, and it aligns with the direction of greatest variance. The second principal component ",i.createElement(o.A,{text:"\\(v_2\\)"})," is then orthogonal to ",i.createElement(o.A,{text:"\\(v_1\\)"})," and aligns with the direction of the second greatest variance, and so on."),"\n",i.createElement(t.h3,{id:"33-svd-perspective",style:{position:"relative"}},i.createElement(t.a,{href:"#33-svd-perspective","aria-label":"33 svd perspective permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"3.3 SVD perspective"),"\n",i.createElement(t.p,null,"An alternative but equivalent approach uses Singular Value Decomposition (SVD) of ",i.createElement(o.A,{text:"\\(X\\)"}),". If ",i.createElement(o.A,{text:"\\(X\\)"})," is an ",i.createElement(o.A,{text:"\\(N \\times d\\)"})," mean-centered matrix, the SVD states:"),"\n",i.createElement(o.A,{text:"\\[\nX = U \\, S \\, V^\\top,\n\\]"}),"\n",i.createElement(t.p,null,"where",i.createElement(t.br),"\n","• ",i.createElement(o.A,{text:"\\(U\\)"})," is an ",i.createElement(o.A,{text:"\\(N \\times N\\)"})," orthonormal matrix,",i.createElement(t.br),"\n","• ",i.createElement(o.A,{text:"\\(S\\)"})," is an ",i.createElement(o.A,{text:"\\(N \\times d\\)"})," rectangular diagonal matrix (its diagonal entries are the singular values),",i.createElement(t.br),"\n","• ",i.createElement(o.A,{text:"\\(V\\)"})," is a ",i.createElement(o.A,{text:"\\(d \\times d\\)"})," orthonormal matrix."),"\n",i.createElement(t.p,null,"The columns of ",i.createElement(o.A,{text:"\\(V\\)"})," (or equivalently the rows of ",i.createElement(o.A,{text:"\\(V^\\top\\)"}),") correspond to the eigenvectors of ",i.createElement(o.A,{text:"\\(\\Sigma\\)"}),". For each singular value ",i.createElement(o.A,{text:"\\(\\sigma_k\\)"}),", we have:"),"\n",i.createElement(o.A,{text:"\\( \\sigma_k^2 = \\lambda_k. \\)"}),"\n",i.createElement(t.p,null,"Hence, the left singular vectors in ",i.createElement(o.A,{text:"\\(U\\)"})," form an orthonormal basis for the row space of ",i.createElement(o.A,{text:"\\(X\\)"}),", and the columns of ",i.createElement(o.A,{text:"\\(V\\)"})," form an orthonormal basis for the column space — precisely the directions corresponding to principal components. SVD-based implementations of PCA tend to be numerically stable and often favored in practice."),"\n",i.createElement(t.h3,{id:"34-geometric-interpretation-of-pca",style:{position:"relative"}},i.createElement(t.a,{href:"#34-geometric-interpretation-of-pca","aria-label":"34 geometric interpretation of pca permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"3.4 Geometric interpretation of PCA"),"\n",i.createElement(t.p,null,"In geometric terms, PCA can be seen as fitting a low-dimensional plane (a linear subspace) that best represents the data in terms of squared Euclidean distance. If one projects the data onto the first ",i.createElement(o.A,{text:"\\(k\\)"})," principal components, the resulting reconstruction error is minimized (in a least-squares sense) among all possible rank-",i.createElement(o.A,{text:"\\(k\\)"})," linear subspaces. This ties into another classic interpretation: PCA seeks the directions that capture the maximum variance, which also correspond to the singular vectors with the largest singular values."),"\n",i.createElement(t.h2,{id:"4-pca-algorithmic-steps",style:{position:"relative"}},i.createElement(t.a,{href:"#4-pca-algorithmic-steps","aria-label":"4 pca algorithmic steps permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"4. PCA algorithmic steps"),"\n",i.createElement(t.h3,{id:"41-data-centering",style:{position:"relative"}},i.createElement(t.a,{href:"#41-data-centering","aria-label":"41 data centering permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"4.1 Data centering"),"\n",i.createElement(t.p,null,"A key preparatory step for PCA is data centering, sometimes combined with feature scaling. Data centering subtracts the mean ",i.createElement(o.A,{text:"\\(\\bar{x}\\)"})," from each sample so that the resulting dataset has zero mean. Without this step, the covariance matrix does not accurately reflect directions of maximum variability around the origin. Additionally, some practitioners standardize each feature to have unit variance before PCA, depending on whether features are measured in different scales and the immediate goals of the analysis."),"\n",i.createElement(t.h3,{id:"42-computing-the-covariance-matrix",style:{position:"relative"}},i.createElement(t.a,{href:"#42-computing-the-covariance-matrix","aria-label":"42 computing the covariance matrix permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"4.2 Computing the covariance matrix"),"\n",i.createElement(t.p,null,"After centering, an easy route is to form the covariance matrix ",i.createElement(o.A,{text:"\\(\\Sigma\\)"})," by ",i.createElement(o.A,{text:"\\( (1/(N-1)) X^\\top X \\)"}),". For large ",i.createElement(o.A,{text:"\\(d\\)"}),", forming the full matrix might be expensive, but it remains conceptually straightforward. The cost of forming ",i.createElement(o.A,{text:"\\(\\Sigma\\)"})," is on the order of ",i.createElement(o.A,{text:"\\(O(N d^2)\\)"})," if done naively, because one must multiply a ",i.createElement(o.A,{text:"\\(d \\times N\\)"})," matrix with an ",i.createElement(o.A,{text:"\\(N \\times d\\)"})," matrix."),"\n",i.createElement(t.h3,{id:"43-eigen-decomposition-approach",style:{position:"relative"}},i.createElement(t.a,{href:"#43-eigen-decomposition-approach","aria-label":"43 eigen decomposition approach permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"4.3 Eigen decomposition approach"),"\n",i.createElement(t.p,null,"One can then compute the eigenvalues and eigenvectors of the covariance matrix:"),"\n",i.createElement(o.A,{text:"\\[\n\\Sigma v_k = \\lambda_k v_k, \\quad k = 1,\\dots,d.\n\\]"}),"\n",i.createElement(t.p,null,"The ",i.createElement(o.A,{text:"\\(k\\)"}),"-th principal component is the eigenvector ",i.createElement(o.A,{text:"\\(v_k\\)"})," corresponding to the ",i.createElement(o.A,{text:"\\(k\\)"}),"-th largest eigenvalue ",i.createElement(o.A,{text:"\\(\\lambda_k\\)"}),". If the objective is to retain only ",i.createElement(o.A,{text:"\\(k\\)"})," components, one extracts ",i.createElement(o.A,{text:"\\(\\{v_1, \\ldots, v_k\\}\\)"})," and the corresponding eigenvalues. This approach is direct but might be computationally prohibitive if ",i.createElement(o.A,{text:"\\(d\\)"})," is extremely large."),"\n",i.createElement(t.h3,{id:"44-svd-method",style:{position:"relative"}},i.createElement(t.a,{href:"#44-svd-method","aria-label":"44 svd method permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"4.4 SVD method"),"\n",i.createElement(t.p,null,"In practice, many PCA implementations revolve around performing an SVD on ",i.createElement(o.A,{text:"\\(X\\)"})," directly:"),"\n",i.createElement(o.A,{text:"\\[\nX = U \\, S \\, V^\\top.\n\\]"}),"\n",i.createElement(t.p,null,"Then the principal components are the columns of ",i.createElement(o.A,{text:"\\(V\\)"}),". The product ",i.createElement(o.A,{text:"\\(X \\, V\\)"})," yields a matrix whose columns are the projections of ",i.createElement(o.A,{text:"\\(X\\)"})," onto the principal components. The SVD approach can be more numerically stable and can be more efficient when ",i.createElement(o.A,{text:"\\(N < d\\)"}),"."),"\n",i.createElement(t.h3,{id:"45-completeness-conditions",style:{position:"relative"}},i.createElement(t.a,{href:"#45-completeness-conditions","aria-label":"45 completeness conditions permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"4.5 Completeness conditions"),"\n",i.createElement(t.p,null,"Because ",i.createElement(o.A,{text:"\\(\\Sigma\\)"})," is positive semi-definite, all its eigenvalues ",i.createElement(o.A,{text:"\\(\\lambda_k\\)"})," are ",i.createElement(o.A,{text:"\\(\\ge 0\\)"}),", meaning the total variance in the dataset is:"),"\n",i.createElement(o.A,{text:"\\[\n\\text{Var}_{\\text{total}} = \\sum_{k=1}^{d} \\lambda_k.\n\\]"}),"\n",i.createElement(t.p,null,"Thus, when one chooses to project onto the top ",i.createElement(o.A,{text:"\\(k\\)"})," components, the fraction of explained variance is:"),"\n",i.createElement(o.A,{text:"\\[\n\\frac{\\lambda_1 + \\cdots + \\lambda_k}{\\lambda_1 + \\cdots + \\lambda_d}.\n\\]"}),"\n",i.createElement(t.p,null,"These concepts form the bedrock of how one interprets PCA results in both theoretical and practical contexts."),"\n",i.createElement(t.h3,{id:"46-numerical-stability-and-computational-complexity",style:{position:"relative"}},i.createElement(t.a,{href:"#46-numerical-stability-and-computational-complexity","aria-label":"46 numerical stability and computational complexity permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"4.6 Numerical stability and computational complexity"),"\n",i.createElement(t.p,null,"For moderate sizes (",i.createElement(o.A,{text:"\\(d\\)"})," in the thousands or less, ",i.createElement(o.A,{text:"\\(N\\)"})," in the thousands or tens of thousands), PCA via standard SVD or eigen decomposition is typically tractable using optimized linear algebra libraries (e.g., LAPACK, BLAS, or vendor-optimized routines). However, for truly massive datasets — for instance, when ",i.createElement(o.A,{text:"\\(d\\)"})," can be in the tens or hundreds of thousands — specialized algorithms or approximations like randomized SVD (Halko and gang, SIAM Review, 2011) or incremental PCA become necessary to keep the computations feasible."),"\n",i.createElement(t.h2,{id:"5-implementation-considerations-in-practice",style:{position:"relative"}},i.createElement(t.a,{href:"#5-implementation-considerations-in-practice","aria-label":"5 implementation considerations in practice permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"5. Implementation considerations in practice"),"\n",i.createElement(t.h3,{id:"51-pca-using-scikit-learn",style:{position:"relative"}},i.createElement(t.a,{href:"#51-pca-using-scikit-learn","aria-label":"51 pca using scikit learn permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"5.1 PCA using scikit-learn"),"\n",i.createElement(t.p,null,"A highly popular approach in Python's data science stack is:"),"\n",i.createElement(l.A,{text:'\nimport numpy as np\nfrom sklearn.decomposition import PCA\n\n# Suppose X is an (N x d) NumPy array of training data\n# and we want top k components\nk = 2\npca = PCA(n_components=k)\nX_reduced = pca.fit_transform(X)\n\nprint("Explained variance ratio:", pca.explained_variance_ratio_)\nprint("Principal components shape:", X_reduced.shape)\n'}),"\n",i.createElement(t.p,null,"Here, ",i.createElement(r.A,null,"explained_variance_ratio_")," indicates, for each principal component, the fraction of the total variance captured. The result ",i.createElement(o.A,{text:"\\(X_{\\text{reduced}}\\)"})," is an ",i.createElement(o.A,{text:"\\(N \\times k\\)"})," matrix containing the coordinates of each sample in the reduced ",i.createElement(o.A,{text:"\\(k\\)"}),"-dimensional space."),"\n",i.createElement(t.h3,{id:"52-incremental-pca",style:{position:"relative"}},i.createElement(t.a,{href:"#52-incremental-pca","aria-label":"52 incremental pca permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"5.2 Incremental PCA"),"\n",i.createElement(t.p,null,"When ",i.createElement(o.A,{text:"\\(X\\)"})," is too large to fit in memory, or when data arrives in streams, incremental PCA processes the data in mini-batches. Each batch updates estimates of the principal components without requiring repeated decomposition of the full dataset. This approach, used frequently in big data contexts, is an important stepping stone toward streaming or online dimensionality reduction."),"\n",i.createElement(t.h3,{id:"53-randomized-pca",style:{position:"relative"}},i.createElement(t.a,{href:"#53-randomized-pca","aria-label":"53 randomized pca permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"5.3 Randomized PCA"),"\n",i.createElement(t.p,null,"Randomized PCA (Halko and gang, SIAM Review, 2011) is a technique that constructs a random projection of the data into a lower dimensional space. Then it refines this projection iteratively. In many high-dimensional situations, randomized PCA can yield approximate principal components at a fraction of the cost of a full SVD, with surprisingly small errors for many practical datasets. This technique can be crucial in large-scale natural language processing tasks where one might have enormous term-document matrices."),"\n",i.createElement(t.h3,{id:"54-gpu-accelerated-approaches",style:{position:"relative"}},i.createElement(t.a,{href:"#54-gpu-accelerated-approaches","aria-label":"54 gpu accelerated approaches permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"5.4 GPU-accelerated approaches"),"\n",i.createElement(t.p,null,"Libraries such as RAPIDS (NVIDIA) in Python or specialized HPC solutions implement GPU-accelerated PCA. By performing matrix multiplications on massively parallel architectures, one can handle very large ",i.createElement(o.A,{text:"\\(N\\)"})," or ",i.createElement(o.A,{text:"\\(d\\)"})," more quickly. The speedup can be significant, especially when synergy with other GPU-based data loading and preprocessing steps is realized."),"\n",i.createElement(t.h3,{id:"55-typical-pitfalls-and-data-preprocessing",style:{position:"relative"}},i.createElement(t.a,{href:"#55-typical-pitfalls-and-data-preprocessing","aria-label":"55 typical pitfalls and data preprocessing permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"5.5 Typical pitfalls and data preprocessing"),"\n",i.createElement(t.p,null,"In real-world projects, one must keep in mind the effect of outliers and the necessity of consistent preprocessing. Outliers can produce disproportionately large effects on covariance estimates. Hence, it may be beneficial to use robust PCA variants or transform the data (e.g., using logarithms when dealing with positive-only values). Additionally, if the features have different scales, standardizing columns to have standard deviation 1 (or to some robust scale measure) can prevent certain features from dominating the variance."),"\n",i.createElement(t.h2,{id:"6-interpreting-results-from-pca",style:{position:"relative"}},i.createElement(t.a,{href:"#6-interpreting-results-from-pca","aria-label":"6 interpreting results from pca permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"6. Interpreting results from PCA"),"\n",i.createElement(t.h3,{id:"61-variance-explained",style:{position:"relative"}},i.createElement(t.a,{href:"#61-variance-explained","aria-label":"61 variance explained permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"6.1 Variance explained"),"\n",i.createElement(t.p,null,"The primary quantity of interest from PCA is how much variance each principal component explains. That fraction of the variance, often graphed as a bar chart or line plot, helps the analyst decide how many components to retain. For instance, if the first two components explain 90% of the variance, that might be sufficiently high to use them alone for many tasks such as visualization or clustering."),"\n",i.createElement(t.h3,{id:"62-scree-plot",style:{position:"relative"}},i.createElement(t.a,{href:"#62-scree-plot","aria-label":"62 scree plot permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"6.2 Scree plot"),"\n",i.createElement(t.p,null,'A frequently used visual is the "scree plot", which plots ',i.createElement(o.A,{text:"\\(\\lambda_k\\)"})," — or the proportion of variance explained ",i.createElement(o.A,{text:"\\(\\lambda_k / \\sum_j \\lambda_j\\)"})," — as a function of the component index ",i.createElement(o.A,{text:"\\(k\\)"}),'. One typically looks for an "elbow" in the curve, a point beyond which additional components do not yield a marked improvement in explained variance.'),"\n",i.createElement(a,{alt:"Scree plot example",path:"",caption:"An example scree plot showing how consecutive principal components contribute to total variance.",zoom:"false"}),"\n",i.createElement(t.h3,{id:"63-choosing-the-number-of-components",style:{position:"relative"}},i.createElement(t.a,{href:"#63-choosing-the-number-of-components","aria-label":"63 choosing the number of components permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"6.3 Choosing the number of components"),"\n",i.createElement(t.p,null,"There is no universal formula for picking the correct number of principal components. Some heuristics:"),"\n",i.createElement(t.p,null,"• Retain all components needed to explain a certain threshold (e.g., 95%) of the variance.",i.createElement(t.br),"\n","• Identify the elbow in the scree plot.",i.createElement(t.br),"\n","• Cross-validate performance in downstream tasks (classification, regression) with subsets of components."),"\n",i.createElement(t.p,null,"In practice, the choice can be somewhat subjective, governed by domain knowledge and the sensitivity of the problem to small differences in explained variance."),"\n",i.createElement(t.h3,{id:"64-reconstructing-data-from-principal-components",style:{position:"relative"}},i.createElement(t.a,{href:"#64-reconstructing-data-from-principal-components","aria-label":"64 reconstructing data from principal components permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"6.4 Reconstructing data from principal components"),"\n",i.createElement(t.p,null,"It is also possible to approximately reconstruct the original data from a reduced set of principal components. Suppose you keep the top ",i.createElement(o.A,{text:"\\(k\\)"})," principal components ",i.createElement(o.A,{text:"\\(v_1, v_2, ..., v_k\\)"}),". The projected representation of a data vector ",i.createElement(o.A,{text:"\\(x\\)"})," is:"),"\n",i.createElement(o.A,{text:"\\[\nz = \\begin{bmatrix}\nv_1^\\top x \\\\\nv_2^\\top x \\\\\n\\vdots \\\\\nv_k^\\top x\n\\end{bmatrix}.\n\\]"}),"\n",i.createElement(t.p,null,"To reconstruct ",i.createElement(o.A,{text:"\\(x\\)"})," (approximately), one uses:"),"\n",i.createElement(o.A,{text:"\\[\n\\hat{x} = \\sum_{m=1}^k (v_m^\\top x)\\, v_m.\n\\]"}),"\n",i.createElement(t.p,null,"This reveals that by truncating to ",i.createElement(o.A,{text:"\\(k\\)"})," components, we are effectively discarding contributions from the remaining ",i.createElement(o.A,{text:"\\(d-k\\)"})," eigenvectors and hence losing some information (variance)."),"\n",i.createElement(t.h3,{id:"65-partial-interpretability",style:{position:"relative"}},i.createElement(t.a,{href:"#65-partial-interpretability","aria-label":"65 partial interpretability permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"6.5 Partial interpretability"),"\n",i.createElement(t.p,null,"Each principal component is a linear combination of the original features, so it is possible to interpret which original variables have the most weight in each principal component's direction. However, these combinations can be somewhat tricky to parse if many features have moderate loadings. Domain knowledge can aid in naming or describing principal components. For instance, in certain biological datasets, one might see that the first component corresponds to cell size or cell cycle effect, whereas subsequent ones might capture specific gene pathways."),"\n",i.createElement(t.h2,{id:"7-kernel-pca",style:{position:"relative"}},i.createElement(t.a,{href:"#7-kernel-pca","aria-label":"7 kernel pca permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"7. Kernel PCA"),"\n",i.createElement(t.p,null,'While PCA is purely linear, kernel PCA extends the basic approach by applying a "kernel trick", a concept widely used in support vector machines. One replaces the explicit features ',i.createElement(o.A,{text:"\\(x_i\\)"})," with implicit feature mappings ",i.createElement(o.A,{text:"\\(\\phi(x_i)\\)"})," in a high (or infinite) dimensional RKHS. Then, PCA is performed in that transformed (kernel) space."),"\n",i.createElement(t.h3,{id:"71-the-kernel-trick",style:{position:"relative"}},i.createElement(t.a,{href:"#71-the-kernel-trick","aria-label":"71 the kernel trick permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"7.1 The kernel trick"),"\n",i.createElement(t.p,null,"For a given kernel function ",i.createElement(o.A,{text:"\\(k(x_i, x_j) = \\langle \\phi(x_i), \\phi(x_j)\\rangle\\)"}),", we only need the kernel matrix ",i.createElement(o.A,{text:"\\(K\\)"}),", whose ",i.createElement(o.A,{text:"\\((i,j)\\)"}),"-entry is ",i.createElement(o.A,{text:"\\(k(x_i, x_j)\\)"}),". The entire machinery — covariance, eigen decomposition, and so forth — can then be carried out in that kernel space, albeit with additional constraints regarding centering the kernel matrix."),"\n",i.createElement(t.h3,{id:"72-rbf-kernel-polynomial-kernel-etc",style:{position:"relative"}},i.createElement(t.a,{href:"#72-rbf-kernel-polynomial-kernel-etc","aria-label":"72 rbf kernel polynomial kernel etc permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"7.2 RBF kernel, polynomial kernel, etc."),"\n",i.createElement(t.p,null,"Common kernels used in kernel PCA include the RBF (Gaussian) kernel ",i.createElement(o.A,{text:"\\( \\exp(-\\|x_i - x_j\\|^2 / (2\\sigma^2))\\)"}),", polynomial kernels ",i.createElement(o.A,{text:"\\((\\alpha \\, x_i^\\top x_j + c)^p\\)"}),", and others. By choosing different kernels, one can extract nonlinear structure that is not captured by standard linear PCA."),"\n",i.createElement(t.h3,{id:"73-computational-aspects",style:{position:"relative"}},i.createElement(t.a,{href:"#73-computational-aspects","aria-label":"73 computational aspects permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"7.3 Computational aspects"),"\n",i.createElement(t.p,null,"Kernel PCA requires storing and decomposing an ",i.createElement(o.A,{text:"\\(N \\times N\\)"})," kernel matrix, which becomes expensive for large ",i.createElement(o.A,{text:"\\(N\\)"}),". This is in sharp contrast to linear PCA, where one might only deal with a ",i.createElement(o.A,{text:"\\(d \\times d\\)"})," matrix. Research in approximate kernel methods has led to approaches such as the Nyström method to reduce the computational burden."),"\n",i.createElement(t.h3,{id:"74-limitations-of-kernel-pca",style:{position:"relative"}},i.createElement(t.a,{href:"#74-limitations-of-kernel-pca","aria-label":"74 limitations of kernel pca permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"7.4 Limitations of kernel PCA"),"\n",i.createElement(t.p,null,"Although kernel PCA can reveal nonlinear structures, it lacks some of the interpretability of linear PCA, since the resulting components exist in a high-dimensional feature space defined implicitly by the kernel. Also, out-of-sample extension (projecting new data points onto the learned components) becomes more complex and typically requires storing or recalculating kernel values with training points."),"\n",i.createElement(t.h2,{id:"8-advanced-transformations-and-related-methods",style:{position:"relative"}},i.createElement(t.a,{href:"#8-advanced-transformations-and-related-methods","aria-label":"8 advanced transformations and related methods permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"8. Advanced transformations and related methods"),"\n",i.createElement(t.p,null,"Though PCA is a powerful technique, it is by no means the only method. Depending on the structure of the data and the goals of the analysis, other algorithms may be more appropriate."),"\n",i.createElement(t.h3,{id:"81-lda-linear-discriminant-analysis",style:{position:"relative"}},i.createElement(t.a,{href:"#81-lda-linear-discriminant-analysis","aria-label":"81 lda linear discriminant analysis permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"8.1 LDA (Linear Discriminant Analysis)"),"\n",i.createElement(t.p,null,"Linear Discriminant Analysis (LDA) is sometimes viewed in the same category as PCA, but it optimizes a fundamentally different criterion: LDA seeks to maximize class separation for labeled data. If the dataset is supervised and the objective is classification, LDA can provide a subspace that makes classes more linearly separable, whereas PCA is purely unsupervised and does not consider class labels."),"\n",i.createElement(t.h3,{id:"82-factor-analysis",style:{position:"relative"}},i.createElement(t.a,{href:"#82-factor-analysis","aria-label":"82 factor analysis permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"8.2 Factor analysis"),"\n",i.createElement(t.p,null,"In factor analysis, the data are modeled as a linear combination of hidden factors plus noise. Parameters are estimated to capture covariances in a way that might be more interpretable in certain social sciences or psychological contexts, although in practice there is some conceptual overlap with PCA."),"\n",i.createElement(t.h3,{id:"83-ica-independent-component-analysis",style:{position:"relative"}},i.createElement(t.a,{href:"#83-ica-independent-component-analysis","aria-label":"83 ica independent component analysis permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"8.3 ICA (Independent Component Analysis)"),"\n",i.createElement(t.p,null,'Independent Component Analysis (ICA) is designed to separate mixed signals into statistically independent components. It is especially effective in blind source separation. For example, in the "cocktail party problem" scenario, ICA can separate multiple voices recorded by multiple microphones. Unlike PCA, which focuses on maximizing variance in orthogonal directions, ICA focuses on maximizing non-Gaussianity or measures of statistical independence.'),"\n",i.createElement(t.h3,{id:"84-manifold-learning-approaches",style:{position:"relative"}},i.createElement(t.a,{href:"#84-manifold-learning-approaches","aria-label":"84 manifold learning approaches permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"8.4 Manifold learning approaches"),"\n",i.createElement(t.p,null,"Algorithms such as isomap, locally linear embedding (LLE), and Laplacian eigenmaps attempt to learn low-dimensional manifolds while preserving local geometry. If data truly lie near a complex manifold, these methods can succeed where linear PCA fails to capture curved structures. However, they can be more fragile, sensitive to hyperparameters (like neighborhood sizes), and challenging to scale."),"\n",i.createElement(t.h3,{id:"85-t-sne",style:{position:"relative"}},i.createElement(t.a,{href:"#85-t-sne","aria-label":"85 t sne permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"8.5 t-SNE"),"\n",i.createElement(t.p,null,"Developed by Maaten & Hinton (JMLR, 2008), t-Distributed Stochastic Neighbor Embedding (t-SNE) is a nonlinear dimensionality reduction method especially popular for visualizing high-dimensional data in 2D or 3D. t-SNE places a strong emphasis on preserving local neighborhoods, often producing visually meaningful clusters. Its main drawback is that distances in the low-dimensional projection can be somewhat distorted between clusters, and the method can be quite computationally heavy for large datasets. Nonetheless, t-SNE remains widely used in biology, NLP, and other fields for producing intuitive scatter plot visualizations."),"\n",i.createElement(t.h3,{id:"86-umap",style:{position:"relative"}},i.createElement(t.a,{href:"#86-umap","aria-label":"86 umap permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"8.6 UMAP"),"\n",i.createElement(t.p,null,"UMAP (Uniform Manifold Approximation and Projection) is conceptually related to t-SNE but claims certain theoretical guarantees grounded in Riemannian geometry and fuzzy simplicial sets. It tends to be faster than t-SNE and can sometimes better preserve global structure."),"\n",i.createElement(t.h3,{id:"87-autoencoders-for-dimensionality-reduction",style:{position:"relative"}},i.createElement(t.a,{href:"#87-autoencoders-for-dimensionality-reduction","aria-label":"87 autoencoders for dimensionality reduction permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"8.7 Autoencoders for dimensionality reduction"),"\n",i.createElement(t.p,null,"Neural network-based autoencoders can perform nonlinear dimensionality reduction. An encoder network compresses data to a latent representation with reduced dimension, while a decoder network reconstructs the original data from that latent space. Techniques like variational autoencoders (VAEs) extend this approach into a probabilistic realm. Autoencoders can produce embeddings that capture complex variance not easily captured in standard PCA."),"\n",i.createElement(t.h2,{id:"9-data-visualization-with-pca",style:{position:"relative"}},i.createElement(t.a,{href:"#9-data-visualization-with-pca","aria-label":"9 data visualization with pca permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"9. Data visualization with PCA"),"\n",i.createElement(t.p,null,"PCA provides a convenient tool for visualization if we limit ourselves to two or three principal components."),"\n",i.createElement(t.h3,{id:"91-2d-and-3d-scatter-plots",style:{position:"relative"}},i.createElement(t.a,{href:"#91-2d-and-3d-scatter-plots","aria-label":"91 2d and 3d scatter plots permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"9.1 2D and 3D scatter plots"),"\n",i.createElement(t.p,null,"By projecting each ",i.createElement(o.A,{text:"\\(x_i\\)"})," onto the first two principal components, we obtain a 2D scatter plot that frequently reveals clusters or patterns in the data. If the data do not separate clearly in the first two components, exploring combinations like ",i.createElement(o.A,{text:"\\((v_1, v_3)\\)"})," or ",i.createElement(o.A,{text:"\\((v_2, v_3)\\)"})," might bring additional structures to light."),"\n",i.createElement(t.h3,{id:"92-color-coded-pca",style:{position:"relative"}},i.createElement(t.a,{href:"#92-color-coded-pca","aria-label":"92 color coded pca permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"9.2 Color-coded PCA"),"\n",i.createElement(t.p,null,"When the dataset comes with categorical labels, one can color the scatter plot points according to class membership. This approach provides a quick check of whether classes are separable in the first few components. Similarly, continuous variables (e.g., a measured response) can be shown through color gradients on the PCA plane to visualize correlation with principal component directions."),"\n",i.createElement(t.h3,{id:"93-synergy-with-cluster-analysis",style:{position:"relative"}},i.createElement(t.a,{href:"#93-synergy-with-cluster-analysis","aria-label":"93 synergy with cluster analysis permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"9.3 Synergy with cluster analysis"),"\n",i.createElement(t.p,null,"Sometimes, applying PCA as a pre-processing step followed by clustering (e.g., k-means) can yield simpler cluster boundaries or more intuitive groupings in fewer dimensions. Because PCA can remove noise and reduce complexity, clustering in a lower-dimensional subspace is often more stable."),"\n",i.createElement(a,{alt:"Cluster example",path:"",caption:"Clustering on PCA-reduced data can unveil simplified separation of points.",zoom:"false"}),"\n",i.createElement(t.h3,{id:"94-advanced-eda-with-pca",style:{position:"relative"}},i.createElement(t.a,{href:"#94-advanced-eda-with-pca","aria-label":"94 advanced eda with pca permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"9.4 Advanced EDA with PCA"),"\n",i.createElement(t.p,null,"In complex datasets, especially in fields like genomics, financial time series, or image-based data, plotting the first few principal components can yield significant insights. For instance, outliers often stand out immediately, or subpopulations might form distinct clusters. In these fields, PCA is frequently used for quick exploratory data analysis before diving into more specialized or nonlinear dimension reduction strategies."),"\n",i.createElement(t.h2,{id:"10-real-world-applications-and-concluding-remarks",style:{position:"relative"}},i.createElement(t.a,{href:"#10-real-world-applications-and-concluding-remarks","aria-label":"10 real world applications and concluding remarks permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"10. Real-world applications and concluding remarks"),"\n",i.createElement(t.h3,{id:"101-high-throughput-genomics-data",style:{position:"relative"}},i.createElement(t.a,{href:"#101-high-throughput-genomics-data","aria-label":"101 high throughput genomics data permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"10.1 High-throughput genomics data"),"\n",i.createElement(t.p,null,"PCA remains indispensable in modern computational biology. When dealing with thousands or even hundreds of thousands of measured variables (e.g., gene expression, single-cell RNA-seq data), PCA helps compress the data, remove noise, and highlight major sources of variation, such as different cell types or technical confounders like batch effects."),"\n",i.createElement(t.h3,{id:"102-image-compression",style:{position:"relative"}},i.createElement(t.a,{href:"#102-image-compression","aria-label":"102 image compression permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"10.2 Image compression"),"\n",i.createElement(t.p,null,"When images are vectorized into high-dimensional pixel spaces, PCA can reduce redundancy by discovering principal components that describe major patterns (edges, color gradients, etc.). One can store an image using fewer components and then reconstruct an approximation with acceptable fidelity. Although more specialized methods like JPEG or wavelets are used in practice, PCA-based compression is valuable for teaching the fundamentals of transform-based data compression."),"\n",i.createElement(t.h3,{id:"103-noise-reduction",style:{position:"relative"}},i.createElement(t.a,{href:"#103-noise-reduction","aria-label":"103 noise reduction permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"10.3 Noise reduction"),"\n",i.createElement(t.p,null,"Applying PCA to noisy signals often allows one to discard components corresponding to small eigenvalues (which often align with noise) and preserve the main structure. This principle can apply in signal processing, image denoising, or sensor fusion tasks, leading to a simpler, denoised version of the data."),"\n",i.createElement(t.h3,{id:"104-finance-time-series",style:{position:"relative"}},i.createElement(t.a,{href:"#104-finance-time-series","aria-label":"104 finance time series permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"10.4 Finance time series"),"\n",i.createElement(t.p,null,'In finance, large covariance matrices are common when analyzing the co-movements of hundreds of assets. PCA can be used to identify market factors: the first principal component often corresponds to an overall "market" movement, while subsequent components might capture sector-specific trends or other structural factors. This can guide portfolio construction or risk management by highlighting systematic vs. idiosyncratic risk components.'),"\n",i.createElement(t.h3,{id:"105-concluding-remarks",style:{position:"relative"}},i.createElement(t.a,{href:"#105-concluding-remarks","aria-label":"105 concluding remarks permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"10.5 Concluding remarks"),"\n",i.createElement(t.p,null,"Despite the proliferation of sophisticated manifold learning techniques and deep-learning-based compressions, PCA endures as the go-to reference method for dimensionality reduction. Its geometric clarity, ease of calculation, and interpretability in terms of variance explained make it a firmly entrenched staple of data science educational curricula and real-world pipelines. It also forms the basis for many expansions such as kernel PCA, incremental methods for large-scale problems, and preprocessing for advanced algorithms. Understanding PCA thoroughly — from its linear algebraic underpinnings to practical tips for usage — remains indispensable for any machine learning practitioner or researcher aiming to master data representation and compression."),"\n",i.createElement(t.p,null,"Such justification underscores why, more than a century after its progenitor's earliest insights, PCA remains an essential technique in the data science toolkit. When carefully deployed, it reveals hidden structure in high-dimensional datasets, aids in creating more efficient and robust models, and facilitates domain-specific insights that might otherwise remain obscured in a cloud of raw features."))}var c=function(e){void 0===e&&(e={});const{wrapper:t}=Object.assign({},(0,n.RP)(),e.components);return t?i.createElement(t,e,i.createElement(s,e)):s(e)};var h=a(54506),m=a(88864),d=a(58481),p=a.n(d),u=a(5984),f=a(43672),g=a(27042),v=a(72031),b=a(81817),y=a(27105),E=a(17265),x=a(2043),S=a(95751),w=a(94328),A=a(80791),k=a(78137);const H=e=>{let{toc:t}=e;if(!t||!t.items)return null;return i.createElement("nav",{className:A.R},i.createElement("ul",null,t.items.map(((e,t)=>i.createElement("li",{key:t},i.createElement("a",{href:e.url,onClick:t=>((e,t)=>{e.preventDefault();const a=t.replace("#",""),n=document.getElementById(a);n&&n.scrollIntoView({behavior:"smooth",block:"start"})})(t,e.url)},e.title),e.items&&i.createElement(H,{toc:{items:e.items}}))))))};function C(e){let{data:{mdx:t,allMdx:r,allPostImages:l},children:o}=e;const{frontmatter:s,body:c,tableOfContents:m}=t,d=s.index,v=s.slug.split("/")[1],A=r.nodes.filter((e=>e.frontmatter.slug.includes(`/${v}/`))).sort(((e,t)=>e.frontmatter.index-t.frontmatter.index)),C=A.findIndex((e=>e.frontmatter.index===d)),_=A[C+1],z=A[C-1],M=s.slug.replace(/\/$/,""),V=/[^/]*$/.exec(M)[0],P=`posts/${v}/content/${V}/`,{0:T,1:I}=(0,i.useState)(s.flagWideLayoutByDefault),{0:N,1:L}=(0,i.useState)(!1);var B;(0,i.useEffect)((()=>{L(!0);const e=setTimeout((()=>L(!1)),340);return()=>clearTimeout(e)}),[T]),"adventures"===v?B=E.cb:"research"===v?B=E.Qh:"thoughts"===v&&(B=E.T6);const D=p()(c).replace(/import .*? from .*?;/g,"").replace(/<.*?>/g,"").replace(/\{\/\*[\s\S]*?\*\/\}/g,"").trim().split(/\s+/).length,q=function(e){if(e<=10)return"~10 min";if(e<=20)return"~20 min";if(e<=30)return"~30 min";if(e<=40)return"~40 min";if(e<=50)return"~50 min";if(e<=60)return"~1 h";const t=Math.floor(e/60),a=e%60;return a<=30?`~${t}${a>0?".5":""} h`:`~${t+1} h`}(Math.ceil(D/B)+(s.extraReadTimeMin||0)),j=[{flag:s.flagDraft,component:()=>Promise.all([a.e(5850),a.e(9833)]).then(a.bind(a,49833))},{flag:s.flagMindfuckery,component:()=>Promise.all([a.e(5850),a.e(7805)]).then(a.bind(a,27805))},{flag:s.flagRewrite,component:()=>Promise.all([a.e(5850),a.e(8916)]).then(a.bind(a,78916))},{flag:s.flagOffensive,component:()=>Promise.all([a.e(5850),a.e(6731)]).then(a.bind(a,49112))},{flag:s.flagProfane,component:()=>Promise.all([a.e(5850),a.e(3336)]).then(a.bind(a,83336))},{flag:s.flagMultilingual,component:()=>Promise.all([a.e(5850),a.e(2343)]).then(a.bind(a,62343))},{flag:s.flagUnreliably,component:()=>Promise.all([a.e(5850),a.e(6865)]).then(a.bind(a,11627))},{flag:s.flagPolitical,component:()=>Promise.all([a.e(5850),a.e(4417)]).then(a.bind(a,24417))},{flag:s.flagCognitohazard,component:()=>Promise.all([a.e(5850),a.e(8669)]).then(a.bind(a,18669))},{flag:s.flagHidden,component:()=>Promise.all([a.e(5850),a.e(8124)]).then(a.bind(a,48124))}],{0:O,1:R}=(0,i.useState)([]);return(0,i.useEffect)((()=>{j.forEach((e=>{let{flag:t,component:a}=e;t&&a().then((e=>{R((t=>[].concat((0,h.A)(t),[e.default])))}))}))}),[]),i.createElement(g.P.div,{initial:{opacity:0},animate:{opacity:1},exit:{opacity:0},transition:{duration:.15}},i.createElement(b.A,{postNumber:s.index,date:s.date,updated:s.updated,readTime:q,difficulty:s.difficultyLevel,title:s.title,desc:s.desc,banner:s.banner,section:v,postKey:V,isMindfuckery:s.flagMindfuckery,mainTag:s.mainTag}),i.createElement("div",{style:{display:"flex",justifyContent:"flex-end",flexWrap:"wrap",maxWidth:"75%",marginLeft:"auto",paddingRight:"1vw",marginTop:"-6vh",marginBottom:"4vh"}},s.otherTags.map(((e,t)=>i.createElement("span",{key:t,className:`noselect ${k.MW}`,style:{margin:"0 5px 5px 0"}},e)))),i.createElement("div",{className:"postBody"},i.createElement(H,{toc:m})),i.createElement("br",null),i.createElement("div",{style:{margin:"0 10% -2vh 30%",textAlign:"right"}},i.createElement(g.P.button,{className:`noselect ${w.pb}`,id:w.xG,onClick:()=>{I(!T)},whileTap:{scale:.93}},i.createElement(g.P.div,{className:S.DJ,key:T,initial:{opacity:0},animate:{opacity:1},exit:{opacity:0},transition:{duration:.3,ease:"easeInOut"}},T?"Switch to default layout":"Switch to wide layout"))),i.createElement("br",null),i.createElement("div",{className:"postBody",style:{margin:T?"0 -14%":"",maxWidth:T?"200%":"",transition:"margin 1s ease, max-width 1s ease, padding 1s ease"}},i.createElement("div",{className:`${w.P_} ${N?w.Xn:w.qG}`},O.map(((e,t)=>i.createElement(e,{key:t}))),s.indexCourse?i.createElement(x.A,{index:s.indexCourse,category:s.courseCategoryName}):"",i.createElement(u.Z.Provider,{value:{images:l.nodes,basePath:P.replace(/\/$/,"")+"/"}},i.createElement(n.xA,{components:{Image:f.A}},o)))),i.createElement(y.A,{nextPost:_,lastPost:z,keyCurrent:V,section:v}))}function _(e){return i.createElement(C,e,i.createElement(c,e))}function z(e){var t,a,n,r,l;let{data:o}=e;const{frontmatter:s}=o.mdx,c=s.titleSEO||s.title,h=s.titleOG||c,d=s.titleTwitter||c,p=s.descSEO||s.desc,u=s.descOG||p,f=s.descTwitter||p,g=s.schemaType||"BlogPosting",b=s.keywordsSEO,y=s.date,E=s.updated||y,x=s.imageOG||(null===(t=s.banner)||void 0===t||null===(a=t.childImageSharp)||void 0===a||null===(n=a.gatsbyImageData)||void 0===n||null===(r=n.images)||void 0===r||null===(l=r.fallback)||void 0===l?void 0:l.src),S=s.imageAltOG||u,w=s.imageTwitter||x,A=s.imageAltTwitter||f,k=s.canonicalURL,H=s.flagHidden||!1,C=s.mainTag||"Posts",_=s.slug.split("/")[1]||"posts",{siteUrl:z}=(0,m.Q)(),M={"@context":"https://schema.org","@type":"BreadcrumbList",itemListElement:[{"@type":"ListItem",position:1,name:"Home",item:z},{"@type":"ListItem",position:2,name:C,item:`${z}/${s.slug.split("/")[1]}`},{"@type":"ListItem",position:3,name:c,item:`${z}${s.slug}`}]};return i.createElement(v.A,{title:c+" - avrtt.blog",titleOG:h,titleTwitter:d,description:p,descriptionOG:u,descriptionTwitter:f,schemaType:g,keywords:b,datePublished:y,dateModified:E,imageOG:x,imageAltOG:S,imageTwitter:w,imageAltTwitter:A,canonicalUrl:k,flagHidden:H,mainTag:C,section:_,type:"article"},i.createElement("script",{type:"application/ld+json"},JSON.stringify(M)))}},90548:function(e,t,a){var n=a(96540),i=a(7978);t.A=e=>{let{text:t}=e;return n.createElement(i.A,null,t)}}}]);
//# sourceMappingURL=component---src-templates-post-tsx-content-file-path-src-pages-posts-research-dimensionality-reduction-and-pca-mdx-3fa96ae73d8ee41f64f5.js.map