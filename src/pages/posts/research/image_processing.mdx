---
index: 27
indexCourse: 96
indexFavorites:
title: "Image processing"
titleDetailed: ""
titleSEO: ""
titleOG: ""
titleTwitter: ""
titleCourse: "Image processing"
courseCategoryName: "Computer vision"
desc: "Always useful to know"
descSEO: ""
descOG: ""
descTwitter: ""
date: "23.12.2022"
updated:
prioritySitemap: 0.6
changefreqSitemap: "monthly"
extraReadTimeMin: 30
difficultyLevel: 1
flagDraft: true
flagMindfuckery: false
flagRewrite: false
flagOffensive: false
flagProfane: false
flagMultilingual: false
flagUnreliably: false
flagPolitical: false
flagCognitohazard: false
flagHidden: false
flagWideLayoutByDefault: true
schemaType: "Article"
mainTag: ""
otherTags: [""]
keywordsSEO: [""]
banner: "../../../images/posts/research/banners/image_processing.jpg"
imageOG: ""
imageAltOG: ""
imageTwitter: ""
imageAltTwitter: ""
canonicalURL: "https://avrtt.github.io/research/image_processing"
slug: "/research/image_processing"
---

import Highlight from "../../../components/Highlight"
import Code from "../../../components/Code"
import Latex from "../../../components/Latex"


{/* *(intro: a quote, catchphrase, joke, etc.)* */}

<br/>


{/*

Colorization
https://www.youtube.com/watch?v=lRJJEMSD7kI&list=PLA0M1Bcd0w8yv0XGiF1wjerjSZVSrYbjh&index=20

*/}


{/*

1. Introduction  
   Importance in machine learning and data science    
2. Fundamentals
   Refresher for basic terminology: channels, digital images and color models (RGB, HSV, grayscale), image file formats and compression, etc.
3. Binarization techniques  
    Challenges and applications
    3.1 Global binarization  
    3.2 Local binarization  
    3.3 Common binarization methods  
    Otsu's method. Adaptive thresholding. Other threshold-based methods.  
4. Image enhancement and preprocessing  
    4.1 Noise reduction (filtering, smoothing)  
    4.2 Contrast and brightness adjustments  
    4.3 Histogram equalization  
    4.4 Morphological operations (erosion, dilation, opening, closing)  
    4.5 Edge detection and feature sharpening
5. Color processing and colorization  
    5.1 Color spaces (conversion, transformations)  
    5.2 Image colorization techniques  
    5.3 Applications of colorization in machine learning
6. Feature extraction and representation  
    6.1 Keypoint detectors and descriptors (SIFT, SURF, ORB)  
    6.2 Texture features (GLCM, LBP)  
    6.3 Shape features and region descriptors  
    6.4 Dimensionality reduction (PCA, t-SNE, UMAP)
7. Image segmentation and object detection  
    7.1 Threshold-based segmentation  
    7.2 Clustering-based segmentation (k-means, mean shift)  
    7.3 Region-based segmentation (watershed, region growing)  
    7.4 Object detection and localization (traditional vs. deep learning)
8. ML/DL integration  
    8.1 Image data preprocessing for machine learning  
    8.2 Classical ML algorithms for image classification  
    8.3 Transfer learning for image tasks  
    8.4 Data augmentation  
    8.5 Specific evaluation metrics (e.g., IoU)

*/}


Image processing is a cornerstone of modern machine learning and data science, especially in a world where multimedia data proliferates at breakneck speed. Working with images has become crucial for countless applications, including automated inspection, medical diagnostics, biometrics, robotics, document analysis, and advanced research topics like autonomous driving or human–machine collaboration. The capacity to process, enhance, and analyze images forms an essential pipeline for many sophisticated algorithms in computer vision. Whether using simple thresholding methods for quick feature extraction or building complex neural architectures to solve end-to-end vision problems, the domain of image processing offers an ever-expanding set of tools and theoretical frameworks.

Machine learning (ML) systems rely on well-prepared and high-quality data, and when that data is visual or multimedia, it almost invariably requires image preprocessing, segmentation, or transformation steps. Additionally, the synergy between image processing and deep learning has led to dramatic improvements in accuracy for tasks such as image classification, object detection, semantic segmentation, and more. Enormous volumes of images, from social media photos to satellite imagery, demand efficient and robust processing. Researchers (e.g., Zhang and gang, CVPR 2023; Ramesh and gang, NeurIPS 2022) have consistently identified that well-structured preprocessing pipelines lead to higher model performance and fewer training difficulties.

This article explores image processing in considerable detail, targeting a specialized readership: professionals and scientists with a strong background in machine learning, statistics, and data science who wish to solidify or expand their understanding of how image data can be transformed, enhanced, segmented, and ultimately used to power advanced machine learning pipelines. We will balance conceptual depth with an informal, learning-oriented voice, offering technical expansions on the fundamentals and advanced theoretical underpinnings of each concept. Although not a purely academic paper, we will reference relevant research from top conferences (like CVPR, ECCV, ICML, NeurIPS) and journals (like IEEE TPAMI, JMLR, and IJCV) whenever beneficial. 

This article adheres to the overall flow of the machine learning course outline, slotting in at section 27: "Image processing." However, we will make cross-references to relevant techniques covered in earlier or later sections (for example, references to cluster-based segmentation that appear again in chapter 21 on K-means, or connections to deep learning in chapters 48, 49, and 50 on neural network concepts).

Our goals are:

- Introduce essential image-processing terminology and principles.  
- Discuss binarization, focusing on both global and local thresholding techniques such as Otsu's method, Niblack's approach, Bernsen's local thresholding, and variations of them that address inhomogeneous lighting or noise.
- Examine the role of image enhancement through morphological operations, histogram equalization, and edge-detection methods.
- Illustrate color processing and colorization strategies, bridging them to color-based ML tasks.
- Describe key feature extraction methods (SIFT, SURF, ORB, etc.) and specialized feature descriptors.
- Examine segmentation algorithms (threshold-based, region-based, clustering-based, etc.) and introduce the integration with object detection and location.
- Discuss the synergy between traditional image processing techniques and modern machine learning and deep learning frameworks. 
- Highlight best practices for data augmentation and specialized evaluation metrics (e.g., Intersection over Union (IoU) for segmentation tasks).

By the end, you should gain not only a deeper understanding of theoretical principles underpinning image processing but also a stronger intuition for how these methods integrate into broader machine learning pipelines.


## Fundamentals

### Refresher for basic terminology

Images in digital form are typically represented as two-dimensional arrays (matrices) of pixel intensity values. Each pixel holds one or more components (also referred to as channels) that describe its color or intensity. A simple grayscale image has one channel, indicating the intensity at each spatial coordinate <Latex text="\( (x,y) \)"/>. Color images often have three channels in the RGB (Red, Green, Blue) model. Each channel is usually an integer in the range 0–255 (for 8-bit images), though higher bit depths and floating-point representations exist in more advanced systems.

An alternative representation includes <Highlight>multi-spectral</Highlight> or hyper-spectral images, where the number of channels can be in the dozens or even hundreds. Such representations appear in remote sensing, medical imaging, or advanced scientific domains. In these contexts, the fundamental principle remains the same: each pixel coordinate holds a vector of intensity/energy values.

#### Color models

- **RGB**: This is perhaps the most widely used model, especially for computer graphics and display. An RGB pixel is specified as a combination of Red, Green, and Blue intensities. 
- **HSV** (Hue, Saturation, Value): Often used in color manipulation tasks, HSV can make certain operations (e.g., changing color brightness or saturation) more intuitive.
- **Grayscale**: In grayscale images, each pixel is simply one scalar intensity, typically in the range 0–255 for 8-bit images. Grayscale conversion from an RGB image often follows a weighted formula such as <Latex text="\( I = 0.2989 \times R + 0.5870 \times G + 0.1140 \times B \)"/> or similar.
- **Other color spaces**: There are many others, such as YUV, YCbCr, LAB, etc. They can be more perceptually uniform or used in specific compression schemes (e.g., YUV in many video standards).

#### Image file formats and compression

Different storage formats abound, balancing ease of display, compression ratio, color precision, and metadata support. Examples include:

- **JPEG**: A lossy compression method widely used for photos. It exploits the limitations of human vision for high compression ratios but can introduce artifacts (blurriness or blockiness). 
- **PNG**: A lossless format, typically used for web images, icons, or images needing an alpha channel.  
- **TIFF**: Offers flexible color depth and is popular in professional photography and high-quality archiving. 
- **BMP**: An older format that stores uncompressed or lightly compressed data. 
- **GIF**: Historically used for animated images with a limited color palette.

In advanced machine learning systems, we frequently read images from these formats but process them in an internal uncompressed representation (e.g., in <Highlight>NumPy arrays</Highlight> or <Highlight>PyTorch tensors</Highlight>). This ensures pixel-level transformations can be performed rapidly and without repeated decompression overhead.

#### Channels and bit depth

When referring to an image with "channels," we mean the separate color or intensity planes stored in that image. An 8-bit RGB image has three channels, each an 8-bit layer. A 16-bit RGB image doubles the per-channel precision. Meanwhile, hyper-spectral images can have tens or hundreds of channels, used in geospatial or medical contexts. 

Bit depth is crucial for dynamic range. Many professional image pipelines (e.g., medical imaging) prefer 12-bit or 16-bit channels to capture subtle intensity variations without saturating. The trade-off, of course, is higher memory usage and potential computational overhead. In deep learning tasks, it is often beneficial to maintain higher precision in earlier pipeline stages if subtle variations matter for classification or detection.

### Additional remarks on image representation

Image data is sometimes stored in row-major or column-major order. Software frameworks like OpenCV or TensorFlow might store channels last or channels first. This can affect indexing (e.g., <Latex text="\( \text{(height, width, channels)} \)"/> vs. <Latex text="\( \text{(channels, height, width)} \)"/>). Always ensure you understand the memory layout, especially when bridging multiple libraries that each have different defaults.  


## Binarization techniques

Binarization is the process of mapping a multi-level or color image to a two-level representation — often black and white (0 and 1). It is sometimes referred to as "thresholding." One sets an intensity threshold <Latex text="\( t \)"/> and assigns pixels with intensities above <Latex text="\( t \)"/> to one class (e.g., white) and below <Latex text="\( t \)"/> to another class (e.g., black). While seemingly simple, thresholding is an important technique for tasks like document analysis, license plate extraction, and shape detection. 

### Challenges and applications

Binarization drastically reduces the information content of an image. A well-chosen threshold can make subsequent processing (e.g., connected components labeling, contour detection) simpler and more robust. However, a poorly chosen threshold can cause merges of distinct objects or fragmentation of single entities, thereby losing critical features.

Binarization is especially prevalent in **document processing**, where text can be extracted from a background. In that domain, global thresholding might suffice for images with uniform illumination. However, real-world conditions frequently lead to non-uniform backgrounds — shadows, highlights, or local variations in illumination — where local binarization methods become essential.

### Global binarization

A **global** threshold-based approach uses the same <Latex text="\( t \)"/> across the entire image. The simplest approach picks <Latex text="\( t \)"/> heuristically. For instance, one can set <Latex text="\( t \)"/> to half the maximum dynamic range (<Latex text="\(127 \)"/> for 8-bit grayscale) or derive it from statistical measures (e.g., using the mean or median intensity). A more robust approach is Otsu's method.

#### Otsu's method

Otsu's method (Otsu, IEEE TSMC 1979) searches for a threshold <Latex text="\( t \)"/> that minimizes intra-class variance or maximizes inter-class variance. Assume a grayscale image with intensities from <Latex text="\( 0 \)"/> to <Latex text="\( L-1 \)"/>. Let <Latex text="\( p(i) \)"/> be the normalized histogram count for intensity <Latex text="\( i \)"/>. Then the probability of two classes (background <Latex text="\( 0 \)"/> and foreground <Latex text="\( 1 \)"/>), for a threshold <Latex text="\( t \)"/>, is:

<Latex text="\[
\omega_0(t) = \sum_{i=0}^{t-1} p(i), 
\quad 
\omega_1(t) = \sum_{i=t}^{L-1} p(i).
\]"/>

The means of these classes (<Latex text="\( \mu_0(t) \)"/> and <Latex text="\( \mu_1(t) \)"/>) and the global mean (<Latex text="\( \mu_T \)"/>) are:

<Latex text="\[
\mu_0(t) = \frac{\sum_{i=0}^{t-1} i\, p(i)}{\omega_0(t)}, 
\quad
\mu_1(t) = \frac{\sum_{i=t}^{L-1} i\, p(i)}{\omega_1(t)},
\quad
\mu_T = \sum_{i=0}^{L-1} i\, p(i).
\]"/>

Otsu showed that maximizing the inter-class variance:

<Latex text="\[
\sigma_b^2(t) = \omega_0(t)\,\omega_1(t)\,[\mu_0(t) - \mu_1(t)]^2
\]"/>

is equivalent to minimizing the intra-class variance. The threshold that yields the largest <Latex text="\( \sigma_b^2(t) \)"/> is the Otsu threshold <Latex text="\( t^* \)"/>. He also proposed a multi-threshold extension and noted that the method is akin to a 1D discrete variant of Fisher's linear discriminant analysis (LDA).

While Otsu's method is elegant and often works well for images with a bimodal intensity distribution, it can fail on images with heavy noise, uneven illumination, or more complex intensity histograms (Lee and gang, CVGIP 1990). Variations like **two-dimensional Otsu** (Jianzhuang and gang, 1991) consider a joint distribution of pixel intensity and local average to handle noisy scenarios better, though they come with increased computational cost.  

Below is a Python example showcasing Otsu's thresholding using <Highlight>NumPy</Highlight>. This snippet uses a naive approach to find the threshold that maximizes inter-class variance:

<Code text={`
import numpy as np

def otsu_threshold_naive(image):
    """
    image: 2D NumPy array (grayscale)
    returns: threshold (int)
    """
    # Compute histogram
    hist, bin_edges = np.histogram(image, bins=256, range=(0, 256))
    total_pixels = image.size
    
    # Probabilities
    p = hist / total_pixels
    
    best_threshold = 0
    max_between_class_variance = -1
    
    # Precompute cumulative sums for faster iteration
    cumulative_sum = np.cumsum(p)
    cumulative_mean = np.cumsum(np.arange(256) * p)
    global_mean = cumulative_mean[-1]
    
    for t in range(1, 256):
        w0 = cumulative_sum[t-1]
        w1 = 1 - w0
        if w0 < 1e-6 or w1 < 1e-6:
            # avoid division by zero
            continue
        
        mu0 = cumulative_mean[t-1] / w0
        mu1 = (global_mean - cumulative_mean[t-1]) / w1
        
        # inter-class variance
        between_var = w0 * w1 * (mu0 - mu1)**2
        
        if between_var > max_between_class_variance:
            max_between_class_variance = between_var
            best_threshold = t
    
    return best_threshold
`}/>

This straightforward method can be replaced with optimized versions in OpenCV (<Highlight>cv2.threshold(image, 0, 255, cv2.THRESH_BINARY | cv2.THRESH_OTSU)</Highlight>) or scikit-image (<Highlight>skimage.filters.threshold_otsu</Highlight>).

### Local (adaptive) binarization

Real-world images often have non-uniform lighting: some areas are brighter, some are darker. A single threshold might not suffice. Local methods compute a threshold for each pixel based on its neighborhood. This approach is sometimes termed **adaptive** thresholding. Common local binarization methods include:

- **Adaptive Gaussian thresholding**: A threshold is computed per local region (often a block of size <Latex text="\(w \times w\)"/>). 
- **Bernsen's method**: In each local window, compute <Latex text="\( \text{min} \)"/> and <Latex text="\( \text{max} \)"/> intensities. The local threshold is <Latex text="\( ( \text{max} + \text{min} ) / 2 \)"/>. 
- **Niblack's method**: Threshold is <Latex text="\( \mu(x,y) + k \, s(x,y) \)"/>, where <Latex text="\( \mu(x,y) \)"/> is the mean intensity in a local window around <Latex text="\( (x,y) \)"/>, <Latex text="\( s(x,y) \)"/> is the standard deviation, and <Latex text="\( k \)"/> is an empirically chosen constant (e.g., -0.2 if the foreground is dark). 
- **Bradley–Roth**: Uses integral images to accelerate local summations. Each local threshold is the average intensity in a neighborhood minus some fraction (like 15%).

When combined with morphological filtering or denoising, local binarization can excel at tasks where simple global thresholding fails. However, local thresholding may introduce "artificial boundaries" or small gaps if the window size is ill-chosen for the scale of the object, or if the image is extremely textured. Tuning the local window size, overlap, and constants (like <Latex text="\( k \)"/> in Niblack's approach) becomes critical.

### Common binarization methods in practice

1. **Otsu's method**: The classical global approach, good for many well-lit or nearly bimodal images.  
2. **Adaptive thresholding** (mean or Gaussian): Often found in open-source libraries for images with moderate background variations.  
3. **Bernsen**: Simple to implement, but can produce "phantom" noise in uniform areas.  
4. **Niblack** and modifications (e.g., Sauvola, Wolf, NICK, Bradley–Roth): Very common in document processing pipelines, ID card scanning, or meter reading in low-light conditions.  

The local approaches make sense when the background or foreground distribution is not homogeneous across the image. They remain a vibrant area of research, as every new real-world scenario (high dynamic range, night-vision, glare, shadows) brings unique binarization challenges. 


## Image enhancement and preprocessing

In many computer vision tasks, images acquired from sensors can be noisy, low-contrast, blurred, or corrupted by external factors like lens distortion and lighting variations. Image enhancement attempts to improve image quality, making subsequent feature extraction or classification steps easier and more accurate.

### Noise reduction (filtering and smoothing)

Noise manifests in different ways: salt-and-pepper noise (random white or black pixels), Gaussian noise (arising from sensor electronics), speckle noise (in radar or ultrasound). Common noise reduction techniques include:

- **Averaging filter** or box filter: Each pixel is replaced by the average of a <Latex text="\( k \times k \)"/> neighborhood, effectively blurring the image. 
- **Gaussian filter**: A weighted average giving more weight to closer neighbors. 
- **Median filter**: Very effective at removing salt-and-pepper noise while preserving edges better than a box filter.  
- **Bilateral filter**: Preserves edges by also considering intensity differences between neighboring pixels. 
- **Non-local means** (Buades and gang, CVPR 2005): A more advanced technique that compares patches to reduce noise while maintaining structure.

Smoothing can remove small artifacts but must be used judiciously since oversmoothing can destroy sharp edges and degrade important structural details.  

Below is an example of applying a median filter in Python with OpenCV:

<Code text={`
import cv2
import numpy as np

def denoise_median(image, kernel_size=3):
    """
    Apply a median filter to remove salt-and-pepper noise.
    image: 2D or 3D NumPy array
    kernel_size: must be odd, e.g., 3, 5, 7
    """
    return cv2.medianBlur(image, kernel_size)
`}/>

### Contrast and brightness adjustments

Contrast affects how large the difference in intensity or color is between the darkest and brightest parts of an image. In machine learning workflows, it is often necessary to correct for under-exposure or over-exposure before features are extracted.

- **Linear transformations**: <Latex text="\( I_\text{new} = \alpha\,I_\text{old} + \beta \)"/>. The slope <Latex text="\( \alpha \)"/> modifies contrast, and the intercept <Latex text="\( \beta \)"/> modifies brightness.
- **Gamma correction**: <Latex text="\( I_\text{out} = I_\text{in}^{\gamma} \)"/>. Non-linear transformations are used to reduce or boost mid-intensity ranges.
- **CLAHE** (Contrast Limited Adaptive Histogram Equalization): A specialized technique that adaptively improves local contrast without amplifying noise excessively (Zuiderveld, 1994).

### Histogram equalization

Histogram equalization redistributes intensity values so they occupy a broader range. The transform <Latex text="\( T \)"/> is chosen such that the resulting histogram becomes (approximately) uniform. On a grayscale image <Latex text="\( f \)"/>, a common approach uses the cumulative distribution function (CDF) of the input intensities. In the discrete case, for a pixel intensity <Latex text="\( r \)"/>:

<Latex text="\[
T(r) = (L - 1)\sum_{i=0}^{r} p(i),
\]"/>

where <Latex text="\( L \)"/> is the number of possible intensity levels, and <Latex text="\( p(i) \)"/> is the PDF of intensities in <Latex text="\( f \)"/>. The result is that the intensities in the new image <Latex text="\( g \)"/> are more evenly spread. This technique can dramatically improve the visibility of details in a low-contrast image, though it may "wash out" certain regions or amplify noise in others. 

### Morphological operations (erosion, dilation, opening, closing)

Morphological filters originate from mathematical morphology, used extensively in binary images but applicable to grayscale and color. The primary morphological operations are:

- **Erosion**: Shrinks foreground regions by removing boundary pixels. This is done by sliding a structuring element (e.g., a 3×3 square) over the image; a pixel is kept only if all corresponding pixels under the structuring element are foreground. 
- **Dilation**: Grows foreground regions by adding pixels to object boundaries.
- **Opening**: An erosion followed by dilation. Used to remove small noise objects (foreground) while largely preserving the shape of bigger objects. 
- **Closing**: A dilation followed by erosion. Used to fill small holes in foreground objects.

For instance, an opening operation might be beneficial after binarization to remove specks of noise, while a closing might be used to smooth the boundaries of large text or shapes.

### Edge detection and feature sharpening

Edges represent discontinuities in intensity or color, signifying boundaries of objects in an image. Classical detectors include:

- **Sobel**: Computes horizontal and vertical gradients. 
- **Prewitt**: Similar principle to Sobel, slightly different kernels. 
- **Canny**: A multi-stage process that includes smoothing, gradient computation, non-maximum suppression, and hysteresis thresholding. Widely used for robust edge detection. 
- **Laplacian**: Computes the second derivative; often used in conjunction with Gaussian smoothing (LoG filter).

For sharpening, unsharp masking is a popular approach, generating a "mask" of edges via a high-pass filter and adding it back to the original image.

Combining these techniques yields powerful pre-processing pipelines for tasks like digit recognition on meter displays, medical image analysis (MRI, CT scans), or robust shape-based object detection.


## Color processing and colorization

Color can be an extremely informative feature for classification or segmentation. Color-based segmentation, for instance, might simplify detection of fruits in orchard images or lane markings on roads.

### Color spaces (conversion, transformations)

Beyond RGB, many color spaces exist to simplify certain tasks:

- **HSV**: Separates the color's hue (the "type" of color) from its saturation (purity) and value (brightness). To detect objects by color alone, focusing on hue can be easier than dealing with all three RGB channels.
- **Lab**: Often used where perceptual uniformity is important. Distances in Lab space can better approximate how the human eye perceives color differences.

Conversion among color spaces is typically handled with known transformations. For example, from RGB to HSV, each pixel transforms with a set of piecewise equations to determine hue (an angle in [0, 360)), saturation, and value.

### Image colorization techniques

**Image colorization** is the process of converting a grayscale image to a color image, typically by inferring plausible or context-relevant hues. In classical algorithms, colorization might be partially manual (e.g., scribble-based methods) or rely on user input for color hints. Modern deep learning approaches (e.g., Zhang and gang, ECCV 2016) treat colorization as a regression or classification problem in a color space such as Lab, training on large datasets of color images to learn plausible color assignments.

Colorization can be used to restore old black-and-white photos or highlight features in medical or scientific images. In machine learning, colorization is often approached as an **auxiliary self-supervised task**, where the network "learns to colorize" as a way of learning robust feature representations (Larsson and gang, ECCV 2016).

### Applications of colorization in machine learning

- **Data augmentation**: Synthetic recoloring can enrich training sets by simulating lighting conditions or object color variations.  
- **Self-supervised representation learning**: Large unlabeled image sets can train colorization networks. The learned representations can then be transferred to downstream tasks (e.g., classification).  
- **Artistic style transfer**: Combined with techniques from style transfer to produce novel color schemes (e.g., painting from one image's color palette onto another).


## Feature extraction and representation

Feature extraction is central to traditional computer vision pipelines. Before the era of deep learning's convolutional encoders, practitioners relied on carefully designed local descriptors or global features.

### Keypoint detectors and descriptors (SIFT, SURF, ORB)

- **SIFT** (Scale-Invariant Feature Transform; Lowe, IJCV 2004): Detects local keypoints in scale-space, robust to changes in scale, rotation, and moderate affine transformations. Each keypoint is described by a histogram of gradient orientations. 
- **SURF** (Speeded-Up Robust Features): A faster approximation of SIFT's operator, using integral images and a box-filter approach for the scale-space representation. 
- **ORB** (Oriented FAST and Rotated BRIEF; Rublee and gang, ICCV 2011): A fast keypoint descriptor that uses a corner detection approach (FAST) and a binary descriptor (BRIEF). Very efficient for real-time or embedded vision tasks.

Keypoints and descriptors remain relevant, especially for classical tasks like image matching, panorama stitching, or 3D reconstruction from multiple views. Even with deep features, SIFT-like methods can be simpler for certain geometry-based tasks.

### Texture features (GLCM, LBP)

Texture refers to repeating patterns, granularity, or local variations in intensity. Two common texture descriptors are:

- **GLCM** (Gray-Level Co-occurrence Matrix): Captures how often pairs of intensity values occur at certain spatial offsets. Common statistical measures (contrast, energy, homogeneity, correlation) quantify the texture.
- **LBP** (Local Binary Patterns): A pixel's neighborhood is thresholded around the central pixel, creating a binary pattern. Summarizing these binary patterns yields a compact descriptor for texture classification.

### Shape features and region descriptors

In shape-based tasks, we often extract contours or boundaries after binarization or segmentation. Then we can compute:

- **Hu moments**: Seven moment invariants that remain relatively stable under translation, rotation, and scale. 
- **Fourier descriptors**: A closed contour's shape can be approximated by a series expansion in the Fourier domain.
- **Region properties**: Eccentricity, circularity, aspect ratio, etc., derived from raw or segmented objects.  

### Dimensionality reduction (PCA, t-SNE, UMAP)

Once features are extracted (e.g., from SIFT or GLCM), we might want to reduce dimensionality to highlight discriminative aspects. This can help with visualization or reduce computational overhead in classification:

- **PCA** (Principal Component Analysis): Linear method that projects data onto directions of maximum variance. 
- **t-SNE** (t-Distributed Stochastic Neighbor Embedding): Non-linear method that preserves local distances and is often used for cluster visualization in 2D or 3D. 
- **UMAP** (Uniform Manifold Approximation and Projection): Another non-linear approach that preserves global structure better than t-SNE in some cases, while also offering faster performance.


## Image segmentation and object detection

Segmentation partitions an image into regions that share some similarity criterion (e.g., intensity, texture, color). Object detection locates and classifies instances of interest in the scene (e.g., bounding boxes of vehicles in a traffic camera feed).

### Threshold-based segmentation

When objects can be separated by intensity, thresholding alone may suffice. Multi-threshold methods can create multi-labeled segmentation results. In volumetric medical data, thresholding can highlight certain tissue densities. However, real-world images frequently require more sophisticated methods due to noise, variable illumination, or overlapping intensity distributions.

### Clustering-based segmentation (k-means, mean shift)

- **k-means**: You can treat each pixel's color or intensity as a vector in <Latex text="\( \mathbb{R}^d \)"/> (depending on the color space). The algorithm partitions the image into k clusters. Each cluster can be assigned a unique label, effectively segmenting. This approach is intuitive and easy to implement but can fail if k is poorly chosen or if the distribution of intensities is complex.
- **Mean shift**: Iteratively shifts each pixel toward the densest region of points within a kernel window. Regions that converge to the same density mode are clustered. <Highlight>Mean shift</Highlight> can adapt to complex, arbitrarily shaped clusters but can be computationally heavier.

### Region-based segmentation (watershed, region growing)

- **Watershed**: Imagines the image as a topographic surface. "Watersheds" form the boundaries between "catchment basins." The technique can over-segment unless you specify markers or use advanced modifications. 
- **Region growing**: Starts from seed points and merges pixels or regions that meet similarity criteria (e.g., intensity difference below a threshold). This can yield highly controllable segmentation but depends on good initial seeds.

### Object detection and localization (traditional vs. deep learning)

Traditional object detection methods often rely on carefully handcrafted features (e.g., HOG, Haar cascades) and sliding-window approaches. They are still used in embedded or real-time settings due to efficiency or interpretability. However, the modern wave of object detection relies heavily on convolutional neural networks:  

- **Faster R-CNN**: A region-proposal architecture that classifies bounding boxes.  
- **YOLO** (You Only Look Once) or **SSD** (Single Shot Detector): Predict bounding boxes directly from the feature maps.  
- **Transformers-based** object detectors (Carion and gang, ECCV 2020) leverage self-attention to refine bounding boxes in a more global context.

Even though we are primarily discussing image processing fundamentals here, it is crucial to note that many modern detection pipelines still integrate classical pre-processing steps: resizing, color normalization, sometimes morphological operations if the domain is specialized (e.g., medical images with specific tissue structures).


## ML/DL integration

### Image data preprocessing for machine learning

Most machine learning algorithms, especially classical ML (SVM, random forests, logistic regression), expect tabular or vector inputs. Images must be vectorized or have their features extracted. With deep learning, raw images can be fed into a neural network after minimal transformations (resizing, normalization). However, advanced practitioners still use image processing (e.g., noise removal, color space transforms) to reduce domain-specific artifacts or to unify lighting conditions.

### Classical ML algorithms for image classification

Before the deep learning boom, a pipeline might look like:  

1. **Preprocess** (denoise, normalize).  
2. **Extract features** (SIFT descriptors, color histograms, GLCM texture features, etc.).  
3. **Represent** them in a suitable dimensionality (possibly after PCA or LDA).  
4. **Train** a classifier (SVM, random forest).  

This remains entirely valid for smaller datasets or real-time applications where neural networks might be too large or slow. Tools like scikit-learn can handle these tasks efficiently.

### Transfer learning for image tasks

Deep convolutional networks pre-trained on large datasets (e.g., ImageNet) are frequently fine-tuned for new tasks. Even so, pre-processing like histogram equalization or color normalization can reduce domain gaps (e.g., a medical dataset might have different intensity distributions than ImageNet's natural images).

### Data augmentation

Augmenting training images with random transformations can significantly improve generalization:

- Geometric transformations: rotations, translations, flips, perspective warping.
- Color transformations: random brightness, contrast, saturation, or hue changes.
- Noise injection: additive Gaussian noise, salt-and-pepper. 
- Cutout or Mixup: advanced augmentation strategies that mask random portions or mix images at the pixel level.

For segmentation or detection tasks, these augmentations must be applied consistently to images and label maps (segmentation masks, bounding boxes, etc.).

### Specific evaluation metrics (e.g., IoU)

For tasks like segmentation, the Intersection over Union (IoU) or Jaccard Index is a standard measure:

<Latex text="\[
\text{IoU} = \frac{\text{Area of Overlap}}{\text{Area of Union}}
\]"/>

In classification tasks, accuracy or F1-score might suffice, but segmentation demands more region-based or pixel-based metrics. For object detection, metrics like mean Average Precision (mAP) at certain IoU thresholds are common.


## Extra considerations and deeper dives

### Advanced binarization research

Numerous specialized thresholding algorithms exist that incorporate gradient information, entropy-based thresholds, or region merging. For instance, methods relying on local gradient distribution first compute gradient magnitudes and then select thresholds based on the distribution of those gradients (sometimes integrated with Otsu-like cost functions). Another set of approaches uses entropy or mutual information as a measure for an optimal threshold (Kapur and gang, Computer Vision, Graphics, and Image Processing, 1985).

As documents or real-world scenes become more challenging (e.g., images with curved surfaces, extreme lighting, or partial occlusions), binarization research continuously evolves. Some newer approaches incorporate morphological scale-space analysis or even small neural networks that adapt thresholds locally, bridging classical image processing and deep learning.

### Integral images and fast local operations

The concept of **integral images** (also known as summed area tables) is key to accelerating many local operations (Viola & Jones, CVPR 2001). Instead of performing direct convolution or summation in each local region, integral images allow constant-time retrieval of sums within rectangular regions. This principle underpins fast local thresholding (Bradley–Roth binarization) and speeds up box-filtering in algorithms like SURF and many real-time object detection systems.

If an image is <Latex text="\( I(x,y) \)"/>, the integral image <Latex text="\( S(x,y) \)"/> is given by:

<Latex text="\[
S(x,y) = \sum_{i=0}^{x} \sum_{j=0}^{y} I(i,j).
\]"/>

One can compute it efficiently via a recursive relationship:

<Latex text="\[
S(x,y) = I(x,y) + S(x-1,y) + S(x,y-1) - S(x-1,y-1).
\]"/>

Then, the sum of a rectangular region <Latex text="\( (x_1,y_1) \)"/> to <Latex text="\( (x_2,y_2) \)"/> can be computed as:

<Latex text="\[
\text{Sum} = S(x_2,y_2) - S(x_1-1,y_2) - S(x_2,y_1-1) + S(x_1-1,y_1-1).
\]"/>

This reduces local summation from <Latex text="\( O(k^2) \)"/> to <Latex text="\( O(1) \)"/> after a single pass to build <Latex text="\( S(x,y) \)"/>. Bradley–Roth thresholding and many other adaptive methods leverage this for large performance gains.

### Hybrid methods and morphological binarization

Some pipelines combine local thresholding with morphological steps to "clean up" the result. For instance:

1. Estimate a local threshold using Bernsen's approach.  
2. Binarize the image.  
3. Apply an opening to remove tiny noise or separate close objects.  
4. Optionally apply a closing to fill small gaps in the objects of interest.  

Additionally, multi-stage morphological binarization can rely on connected components analysis to remove extraneous regions that do not meet size or shape criteria (e.g., in text detection, discard all connected components smaller than a minimum pixel area). 

### Connections with deep learning

While deep convolutional networks can learn filters and segmentation masks end-to-end, classical image processing remains relevant. Often, an <Highlight>ensemble approach</Highlight> combining classical methods and deep networks outperforms a purely neural approach when domain knowledge is strong (Cheng and gang, IEEE TMI 2020). For example, in certain forms of medical imaging:

- A pre-processing step might remove scanner artifacts or standardize intensities.  
- Classical morphological operations might isolate an anatomical region.  
- Then, a neural network is applied to classify or detect pathologies in that region.  

This multi-stage design can reduce spurious false positives and improve interpretability.


## Putting it all together

Building an end-to-end image processing pipeline for a real-world ML application might look like this:

1. **Data collection**: Gather images from cameras or other sensors. Possibly store them in a compressed format like PNG or JPEG. 
2. **Reading and conversions**: Load images into arrays, maybe convert from BGR to RGB or to grayscale if color is not essential. 
3. **Enhancement**: Remove noise (e.g., median filter or bilateral filter), adjust contrast or brightness if needed, or standardize the color distribution. 
4. **Segmentation or binarization**: Depending on the task (e.g., reading meter digits), use local thresholding (Niblack, Bernsen, Bradley–Roth) or advanced morphological methods. Possibly combine multiple thresholds for multi-region segmentation. 
5. **Feature extraction**: For classical ML, compute SIFT descriptors or GLCM-based texture features; for deep learning, maybe skip manual feature extraction or incorporate a basic morphological step first. 
6. **Model training/inference**: Train your classification, detection, or recognition model. In the deep learning approach, data augmentation is integrated here to ensure robust training. 
7. **Evaluation**: Use metrics like accuracy, F1-score for classification, IoU or mAP for segmentation/detection, etc. 
8. **Iteration**: Tweak your enhancement parameters or model architecture based on performance or domain constraints.

Beyond these fundamentals, advanced methods continue to emerge, especially at the intersection of classical image processing and deep learning. Techniques such as unsupervised denoising with autoencoders, or combining morphological operators with differentiable modules within a neural network, are active research fronts (e.g., Diamond and gang, NeurIPS 2017).

For industrial or large-scale data pipelines, keep an eye on computational efficiency. High-volume tasks might require GPU-accelerated morphological filters or specialized libraries. Tools like OpenCV, scikit-image, TorchVision, and GPU-based libraries (e.g., NVIDIA VPI) all help accelerate standard image processing operations.  

In summary, image processing remains a vibrant, foundational domain in machine learning. Although deep neural networks can learn end-to-end from raw images, an understanding of thresholding, morphological filtering, color transformations, and classical feature extraction remains essential for building robust real-world solutions. By integrating these image processing fundamentals with advanced ML algorithms, practitioners can craft pipelines that handle diverse and challenging visual tasks reliably and efficiently.

  
<Image alt="image-processing-flow" path="" caption="A conceptual diagram of an image processing pipeline, from reading raw data to applying morphological operations and advanced feature extraction." zoom="false" />

