"use strict";(self.webpackChunkavrtt_blog=self.webpackChunkavrtt_blog||[]).push([[4938],{3962:function(e,t){t.A="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iaXNvLTg4NTktMSI/Pgo8IS0tIEdlbmVyYXRvcjogQWRvYmUgSWxsdXN0cmF0b3IgMTYuMC4wLCBTVkcgRXhwb3J0IFBsdWctSW4gLiBTVkcgVmVyc2lvbjogNi4wMCBCdWlsZCAwKSAgLS0+CjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+CjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iQ2FwYV8xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4PSIwcHgiIHk9IjBweCIKCSB3aWR0aD0iNDE2Ljk3OXB4IiBoZWlnaHQ9IjQxNi45NzlweCIgdmlld0JveD0iMCAwIDQxNi45NzkgNDE2Ljk3OSIgc3R5bGU9ImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgNDE2Ljk3OSA0MTYuOTc5OyIKCSB4bWw6c3BhY2U9InByZXNlcnZlIj4KPGc+Cgk8cGF0aCBkPSJNMzU2LjAwNCw2MS4xNTZjLTgxLjM3LTgxLjQ3LTIxMy4zNzctODEuNTUxLTI5NC44NDgtMC4xODJjLTgxLjQ3LDgxLjM3MS04MS41NTIsMjEzLjM3OS0wLjE4MSwyOTQuODUKCQljODEuMzY5LDgxLjQ3LDIxMy4zNzgsODEuNTUxLDI5NC44NDksMC4xODFDNDM3LjI5MywyNzQuNjM2LDQzNy4zNzUsMTQyLjYyNiwzNTYuMDA0LDYxLjE1NnogTTIzNy42LDM0MC43ODYKCQljMCwzLjIxNy0yLjYwNyw1LjgyMi01LjgyMiw1LjgyMmgtNDYuNTc2Yy0zLjIxNSwwLTUuODIyLTIuNjA1LTUuODIyLTUuODIyVjE2Ny44ODVjMC0zLjIxNywyLjYwNy01LjgyMiw1LjgyMi01LjgyMmg0Ni41NzYKCQljMy4yMTUsMCw1LjgyMiwyLjYwNCw1LjgyMiw1LjgyMlYzNDAuNzg2eiBNMjA4LjQ5LDEzNy45MDFjLTE4LjYxOCwwLTMzLjc2Ni0xNS4xNDYtMzMuNzY2LTMzLjc2NQoJCWMwLTE4LjYxNywxNS4xNDctMzMuNzY2LDMzLjc2Ni0zMy43NjZjMTguNjE5LDAsMzMuNzY2LDE1LjE0OCwzMy43NjYsMzMuNzY2QzI0Mi4yNTYsMTIyLjc1NSwyMjcuMTA3LDEzNy45MDEsMjA4LjQ5LDEzNy45MDF6Ii8+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPC9zdmc+Cg=="},15920:function(e,t,n){n.r(t),n.d(t,{Head:function(){return P},PostTemplate:function(){return M},default:function(){return z}});var a=n(54506),r=n(28453),i=n(96540),o=n(66501),l=n(16886),s=n(46295),c=n(96098);function d(e){const t=Object.assign({p:"p",h3:"h3",a:"a",span:"span",h2:"h2",ul:"ul",li:"li",strong:"strong",ol:"ol",hr:"hr"},(0,r.RP)(),e.components),{Image:n}=t;return n||function(e,t){throw new Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Image",!0),i.createElement(i.Fragment,null,"\n",i.createElement("br"),"\n","\n","\n",i.createElement(t.p,null,"PyTorch, an open-source deep learning framework initially developed by researchers at Facebook AI Research (FAIR), has reshaped how scientists and engineers build, train, and deploy neural network models. When PyTorch was first released, it quickly gained popularity due to its dynamic computation graph mechanism and user-friendly interface that combined a Pythonic feel with high-performance automatic differentiation capabilities. This article aims to give you a thorough — yet accessible — deep dive into PyTorch, guiding you through its core concepts, major strengths, and practical applications in modern machine learning workflows."),"\n",i.createElement(t.p,null,"My goal here is to empower you with theoretical and hands-on knowledge of PyTorch so that, by the time you finish reading, you will be comfortable designing and training neural networks using the framework for both simple toy problems and advanced research tasks. While PyTorch supports an impressive breadth of features, such as distributed training, quantization, mobile deployment, and more, this article will focus primarily on the building blocks essential for constructing and training neural networks. With that said, I will also hint at advanced capabilities — for instance, transfer learning or mixed precision training — as these are now considered fairly standard in cutting-edge machine learning pipelines."),"\n",i.createElement(t.p,null,"In parallel, it is worth noting the research origin and context of PyTorch. The framework is built atop a C++ backend (ATen) and a Just-In-Time (JIT) compiler. It was showcased in several papers and utilized by many researchers in the machine learning community. For instance, Paszke and gang (NeurIPS 2019) introduced significant improvements in the library's performance and features such as TorchScript for production. If you think about the computational advantages conferred by using GPU-accelerated tensor operations — combined with PyTorch's hallmark dynamic graph creation approach — it is not surprising that PyTorch has become a standard tool in academic labs and at leading companies in data science and artificial intelligence."),"\n",i.createElement(t.h3,{id:"key-features-and-benefits-of-pytorch",style:{position:"relative"}},i.createElement(t.a,{href:"#key-features-and-benefits-of-pytorch","aria-label":"key features and benefits of pytorch permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"key features and benefits of pytorch"),"\n",i.createElement(t.p,null,"PyTorch's primary competitive edge is its intuitive, Pythonic design. In earlier frameworks, notably older versions of TensorFlow (before the eager execution era), one had to define a static graph of computations and then run that graph in a separate session. This static approach was often cumbersome to debug and somewhat less intuitive for developers who are used to Python's imperative style."),"\n",i.createElement(t.p,null,'By contrast, PyTorch constructs the graph dynamically, meaning the graph is defined "on the fly" during the forward pass. In code, this translates into a style of programming that feels closer to standard Python, with familiar control flows such as loops and conditional statements. When you write something like:'),"\n",i.createElement(s.A,{text:"\nimport torch\n\nx = torch.ones(5)\ny = torch.zeros(5)\nz = x + y  # dynamic creation of the computational graph\nprint(z)\n"}),"\n",i.createElement(t.p,null,'...the computational graph is built (and soon disposed of, if not needed further) with each operation call. This approach is known as "define-by-run" or dynamic computation graphs, and it allows for interactive debuggers or any real-time introspection you may want to do in your code.'),"\n",i.createElement(t.p,null,"Additionally, PyTorch has a built-in automatic differentiation mechanism called ",i.createElement(l.A,null,"autograd"),". You simply declare ",i.createElement(c.A,{text:"\\(x.requires\\_grad = True\\)"})," if you want to track gradients through ",i.createElement(c.A,{text:"\\(x\\)"}),". When your forward pass is computed, PyTorch remembers the sequence of operations and, by calling ",i.createElement(s.A,{text:"\nz.backward()\n"})," in code, it can traverse that chain of operations backward, computing derivatives of ",i.createElement(c.A,{text:"\\(z\\)"})," with respect to the original input(s)."),"\n",i.createElement(t.p,null,"Another crucial aspect is PyTorch's ",i.createElement(l.A,null,"nn")," module, which provides the building blocks for defining complex neural networks. On top of that, the ecosystem includes a host of utilities for data loading, transformations, and GPU management, making PyTorch a self-contained environment for deep learning."),"\n",i.createElement(t.p,null,"Beyond these fundamental features, PyTorch fosters a robust community and extensive documentation, including domain-specific libraries like ",i.createElement(l.A,null,"torchvision")," for computer vision, ",i.createElement(l.A,null,"torchaudio")," for audio processing, and ",i.createElement(l.A,null,"torchtext")," for NLP tasks. Thanks to these libraries, one can perform specialized transformations, load canonical datasets, and adopt pre-trained models right out of the box, speeding up experimentation and development cycles."),"\n",i.createElement(t.h3,{id:"difference-between-pytorch-and-tensorflow",style:{position:"relative"}},i.createElement(t.a,{href:"#difference-between-pytorch-and-tensorflow","aria-label":"difference between pytorch and tensorflow permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"difference between pytorch and tensorflow"),"\n",i.createElement(t.p,null,"The difference between PyTorch and TensorFlow can be contextualized along several dimensions: graph construction, user experience, deployment, and ecosystem. If you have read our other article covering TensorFlow, you already know that TensorFlow 2.x introduced \"eager execution\" to address the prior complexity of static graphs. This development brought TensorFlow more in line with PyTorch's dynamic approach. However, even with TensorFlow's improvements, many researchers still find PyTorch's immediate, imperative style more intuitive and more straightforward to debug."),"\n",i.createElement(t.p,null,"In terms of deployment and production-scale usage, TensorFlow has historically been considered the go-to tool, boasting the more mature TensorFlow Serving and TensorFlow Lite for mobile. PyTorch has more recently added TorchServe for production endpoints and has made strong progress in bridging that gap. Meanwhile, for large-scale projects that require distributed training across massive GPU clusters, both frameworks have robust solutions, though they differ slightly in implementation details. TensorFlow uses ",i.createElement(l.A,null,"tf.distribute")," strategies, whereas PyTorch provides ",i.createElement(l.A,null,"torch.distributed")," and ",i.createElement(l.A,null,"torch.nn.parallel")," modules."),"\n",i.createElement(t.p,null,"Finally, one major difference is the developer community: PyTorch's community has thrived in academic circles, whereas TensorFlow's adoption was initially stronger in the industry. By now, though, both have become widely used in both domains. As a practical note, it really comes down to personal preference or organization-level decisions; both frameworks, if used correctly, will serve you well in advanced machine learning applications."),"\n",i.createElement(t.h2,{id:"call-to-install-and-configure-it-yourself",style:{position:"relative"}},i.createElement(t.a,{href:"#call-to-install-and-configure-it-yourself","aria-label":"call to install and configure it yourself permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"call to install and configure it yourself"),"\n",i.createElement(t.p,null,"To follow along with the examples in this article or to experiment on your own, you should install PyTorch by visiting ",i.createElement(t.a,{href:"https://pytorch.org"},"pytorch.org")," and following the instructions for your operating system and CUDA version. You might choose to create a dedicated virtual environment and run a command such as ",i.createElement(s.A,{text:"\npip install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cu118\n"})," if you want GPU support. You can also install the CPU-only version by removing CUDA dependencies. As you progress into deeper projects, you may find that setting up your GPU drivers and verifying GPU usage are critical steps, but we will not cover these configuration details here. Just make sure you have a consistent environment to run PyTorch examples reliably."),"\n",i.createElement(t.h2,{id:"revisiting-tensors-and-autograd-mechanism",style:{position:"relative"}},i.createElement(t.a,{href:"#revisiting-tensors-and-autograd-mechanism","aria-label":"revisiting tensors and autograd mechanism permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"revisiting tensors and autograd mechanism"),"\n",i.createElement(t.p,null,"In your day-to-day use of PyTorch, you will be working with ",i.createElement(l.A,null,"tensors")," at nearly every step. A tensor is essentially a generalization of matrices to potentially higher dimensions. For instance, a three-dimensional tensor might represent a batch of images, or a four-dimensional tensor might represent a batch of 3D video frames. The key difference from a standard ",i.createElement(c.A,{text:"\\(numpy\\)"})," array is that PyTorch's ",i.createElement(c.A,{text:"\\(torch.Tensor\\)"})," objects can perform operations on the GPU with automatic differentiation turned on if required."),"\n",i.createElement(t.p,null,"Recall that once you set ",i.createElement(c.A,{text:"\\(requires\\_grad=True\\)"}),' on a tensor, PyTorch will begin tracking all operations on it. Underneath the hood, an internal structure known as a "tape" is formed, which records metadata about how each intermediate result was created. Then, when you call ',i.createElement(l.A,null,".backward()")," on the final output, PyTorch traverses this tape from the last operation back to the initial tensors, applying the chain rule to compute partial derivatives in an efficient manner."),"\n",i.createElement(t.p,null,"Mathematically, if you define a function ",i.createElement(c.A,{text:"\\(f(x) = x^2 + 3x + 5\\)"})," with ",i.createElement(c.A,{text:"\\(x\\)"})," as a ",i.createElement(l.A,null,"tensor")," that requires gradient, PyTorch can compute ",i.createElement(c.A,{text:"\\(\\frac{df}{dx}\\)"})," for you automatically:"),"\n",i.createElement(s.A,{text:"\nimport torch\n\nx = torch.tensor(2.0, requires_grad=True)\nf = x**2 + 3*x + 5  # 4 + 6 + 5 = 15 if x=2\nf.backward()        # compute gradients\nprint(x.grad)       # should print derivative at x=2, which is 2*x + 3 = 7\n"}),"\n",i.createElement(t.p,null,"This mechanism (which is akin to a tape-based autodiff as described in numerous research contexts like Baydin and gang (JMLR 2018)) liberates you from manually coding derivative logic. You can focus on building up complex neural networks layer by layer, safe in the knowledge that your gradients are accurately computed under the hood."),"\n",i.createElement(t.h2,{id:"building-neural-networks",style:{position:"relative"}},i.createElement(t.a,{href:"#building-neural-networks","aria-label":"building neural networks permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"building neural networks"),"\n",i.createElement(t.h3,{id:"the-nn-module",style:{position:"relative"}},i.createElement(t.a,{href:"#the-nn-module","aria-label":"the nn module permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"the nn module"),"\n",i.createElement(t.p,null,"The ",i.createElement(l.A,null,"torch.nn")," module is the cornerstone of neural network design in PyTorch. It provides an extensive set of classes and functions that facilitate defining layers, activation functions, and even sophisticated architectural components such as attention layers. The typical approach is to subclass ",i.createElement(l.A,null,"nn.Module"),", which represents a trainable model. Inside your subclass, you declare the layers (e.g., linear layers, convolutional layers) in the constructor, and then implement the ",i.createElement(l.A,null,"forward")," method to define how the data flows through these layers."),"\n",i.createElement(t.p,null,"Conceptually, ",i.createElement(l.A,null,"nn.Module")," helps organize parameters, so that you can easily inspect or update them through PyTorch's automatic gradient system. Once your custom network is defined as a subclass of ",i.createElement(l.A,null,"nn.Module"),", you can drop it into a training loop, pass data to it, and let ",i.createElement(l.A,null,"autograd")," handle gradient computations for you."),"\n",i.createElement(t.h3,{id:"creating-a-simple-feed-forward-network",style:{position:"relative"}},i.createElement(t.a,{href:"#creating-a-simple-feed-forward-network","aria-label":"creating a simple feed forward network permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"creating a simple feed-forward network"),"\n",i.createElement(t.p,null,"The simplest neural network you can build with PyTorch is often a feed-forward network or ",i.createElement(o.A,{text:"Multi-Layer Perceptron"})," that applies a series of linear transformations (fully connected layers) followed by nonlinear activations. Here is a conceptual example that uses ",i.createElement(l.A,null,"nn.Sequential")," for brevity, though you can also define a custom class for more flexibility:"),"\n",i.createElement(s.A,{text:"\nimport torch\nimport torch.nn as nn\n\n# Option A: Using nn.Sequential\nmodel = nn.Sequential(\n    nn.Linear(32, 64),   # input shape: 32 features\n    nn.ReLU(),          # activation\n    nn.Linear(64, 10)   # output shape: 10 classes\n)\n\n# Option B: Subclass nn.Module\nclass SimpleFeedForward(nn.Module):\n    def __init__(self):\n        super(SimpleFeedForward, self).__init__()\n        self.fc1 = nn.Linear(32, 64)\n        self.fc2 = nn.Linear(64, 10)\n        self.relu = nn.ReLU()\n    \n    def forward(self, x):\n        x = self.fc1(x)\n        x = self.relu(x)\n        x = self.fc2(x)\n        return x\n\nmodel_b = SimpleFeedForward()\n"}),"\n",i.createElement(t.p,null,"In either approach, the essential principle is that you define the shape of your input and output, and the network is composed of these building blocks. Whenever you pass data into ",i.createElement(l.A,null,"model"),", the forward pass is automatically constructed, and the required gradient logic is appended to PyTorch's internal tape. Then, when you compute your loss and call ",i.createElement(l.A,null,".backward()"),", the gradients flow back through ",i.createElement(l.A,null,"fc2"),", ",i.createElement(l.A,null,"fc1"),", and so on, updating all ",i.createElement(l.A,null,".weight")," and ",i.createElement(l.A,null,".bias")," parameters in each layer."),"\n",i.createElement(t.h3,{id:"activation-functions",style:{position:"relative"}},i.createElement(t.a,{href:"#activation-functions","aria-label":"activation functions permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"activation functions"),"\n",i.createElement(t.p,null,"Non-linear activation functions are critical in neural networks because they allow networks to approximate complex, non-linear mappings from inputs to outputs. The ",i.createElement(l.A,null,"nn")," module (and ",i.createElement(l.A,null,"torch")," functional modules) provide many standard activation functions:"),"\n",i.createElement(t.ul,null,"\n",i.createElement(t.li,null,"\n",i.createElement(l.A,null,"nn.ReLU"),"\n"),"\n",i.createElement(t.li,null,"\n",i.createElement(l.A,null,"nn.Sigmoid"),"\n"),"\n",i.createElement(t.li,null,"\n",i.createElement(l.A,null,"nn.Tanh"),"\n"),"\n",i.createElement(t.li,null,"\n",i.createElement(l.A,null,"nn.LeakyReLU"),"\n"),"\n",i.createElement(t.li,null,"\n",i.createElement(l.A,null,"nn.Softmax"),"\n"),"\n",i.createElement(t.li,null,"...and more."),"\n"),"\n",i.createElement(t.p,null,"If you recall from prior articles, an activation function like ReLU (",i.createElement(c.A,{text:"\\(ReLU(x) = \\max(0, x)\\)"}),") zeroes out negative values and keeps positive values unchanged. Sigmoid is commonly used in binary classification tasks, mapping real inputs to a range of ",i.createElement(c.A,{text:"\\( (0,1)\\)"}),"."),"\n",i.createElement(t.p,null,'From a gradient perspective, these functions each exhibit different properties. For instance, ReLU\'s gradient is either 1 for positive inputs or 0 for negative inputs, which can lead to the "dying ReLU" problem if many neurons become inactive. Meanwhile, the sigmoid function saturates at extremes, potentially causing issues with vanishing gradients. Understanding these quirks can help you pick the right activation function for your architecture and domain.'),"\n",i.createElement(t.h3,{id:"forward-and-backward-passes",style:{position:"relative"}},i.createElement(t.a,{href:"#forward-and-backward-passes","aria-label":"forward and backward passes permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"forward and backward passes"),"\n",i.createElement(t.p,null,"Recall that the forward pass is the process of feeding input data through the network to obtain predictions. In PyTorch, it is often just calling the model as if it were a function, e.g., ",i.createElement(s.A,{text:"\noutputs = model(inputs)\n"}),"."),"\n",i.createElement(t.p,null,"When you do that, PyTorch's ",i.createElement(l.A,null,"autograd")," system records all relevant operations. Next, you typically compute a loss. For instance, if you are working on a classification task, you might use ",i.createElement(l.A,null,"nn.CrossEntropyLoss"),", which implements the cross-entropy function typically used in multi-class classification. Something like:"),"\n",i.createElement(s.A,{text:"\ncriterion = nn.CrossEntropyLoss()\nloss = criterion(outputs, labels)\n"}),"\n",i.createElement(t.p,null,"Once you have the ",i.createElement(l.A,null,"loss"),", you call ",i.createElement(l.A,null,"loss.backward()")," to trigger the backward pass. This is where PyTorch applies the chain rule to compute the partial derivatives of ",i.createElement(l.A,null,"loss")," with respect to each parameter. The partial derivatives are stored in the ",i.createElement(l.A,null,".grad")," attribute of each parameter (i.e., each weight and bias matrix in the network)."),"\n",i.createElement(t.p,null,"While these steps might seem mechanical, they are the foundation of training in PyTorch. The forward pass is used to make predictions and compute a measure of error, and the backward pass is used to compute updates that will reduce that error during the next iteration. This approach is consistent with the fundamental gradient descent idea, which we have explored in detail in earlier articles of this course."),"\n",i.createElement(t.h2,{id:"data-handling",style:{position:"relative"}},i.createElement(t.a,{href:"#data-handling","aria-label":"data handling permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"data handling"),"\n",i.createElement(t.h3,{id:"dataset-and-dataloader",style:{position:"relative"}},i.createElement(t.a,{href:"#dataset-and-dataloader","aria-label":"dataset and dataloader permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"dataset and dataloader"),"\n",i.createElement(t.p,null,"Real-world data often does not come in neat ",i.createElement(c.A,{text:"\\(numpy\\)"})," arrays or ready-made PyTorch ",i.createElement(l.A,null,"tensors"),"; it may involve images in various folders, text logs, or sensor data streams. PyTorch addresses this challenge through the ",i.createElement(l.A,null,"torch.utils.data")," package, in particular the ",i.createElement(l.A,null,"Dataset")," and ",i.createElement(l.A,null,"DataLoader")," classes."),"\n",i.createElement(t.ul,null,"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Dataset"),": A blueprint for how to access and process your data. It might store references to your files (e.g., image paths), handle reading them from disk, and transform them into ",i.createElement(l.A,null,"tensors"),"."),"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"DataLoader"),": Wraps a Dataset and provides iteration over the data in mini-batches, typically with shuffling, parallel workers, and so on."),"\n"),"\n",i.createElement(t.p,null,"For example, if you want to load the MNIST dataset for digit classification, PyTorch's ",i.createElement(l.A,null,"torchvision")," library offers ",i.createElement(l.A,null,"torchvision.datasets.MNIST"),", which handles downloads, transformations, and the ",i.createElement(l.A,null,i.createElement(t.strong,null,"getitem"))," logic for you. You would then wrap that in a DataLoader:"),"\n",i.createElement(s.A,{text:"\nfrom torchvision import datasets, transforms\nfrom torch.utils.data import DataLoader\n\ntransform = transforms.ToTensor()\n\nmnist_train = datasets.MNIST(root='data', train=True, download=True, transform=transform)\nmnist_val = datasets.MNIST(root='data', train=False, download=True, transform=transform)\n\ntrain_loader = DataLoader(mnist_train, batch_size=64, shuffle=True)\nval_loader = DataLoader(mnist_val, batch_size=64, shuffle=False)\n"}),"\n",i.createElement(t.p,null,"Once this setup is done, you can loop over ",i.createElement(l.A,null,"train_loader")," in your training loop, retrieving mini-batches of data and labels."),"\n",i.createElement(t.h3,{id:"custom-datasets",style:{position:"relative"}},i.createElement(t.a,{href:"#custom-datasets","aria-label":"custom datasets permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"custom datasets"),"\n",i.createElement(t.p,null,"When your data is less standard, you can subclass ",i.createElement(l.A,null,"torch.utils.data.Dataset")," and implement two key methods:\n",i.createElement(l.A,null,i.createElement(t.strong,null,"len")),", which returns the size of your dataset, and\n",i.createElement(l.A,null,i.createElement(t.strong,null,"getitem")),", which returns the ",i.createElement(c.A,{text:"\\(i\\)"}),"-th data sample and label (or target). For example:"),"\n",i.createElement(s.A,{text:"\nfrom torch.utils.data import Dataset\n\nclass MyCustomDataset(Dataset):\n    def __init__(self, file_paths, labels, transform=None):\n        self.file_paths = file_paths\n        self.labels = labels\n        self.transform = transform\n    \n    def __len__(self):\n        return len(self.file_paths)\n    \n    def __getitem__(self, index):\n        # load data from file\n        data = load_data_file(self.file_paths[index])\n        label = self.labels[index]\n        if self.transform:\n            data = self.transform(data)\n        return data, label\n"}),"\n",i.createElement(t.p,null,"Here, ",i.createElement(s.A,{text:"\nload_data_file\n"})," is a hypothetical function that handles reading from disk or from a network location. This approach is flexible enough to manage any domain-specific data structure, from tabular data in CSV files to 3D point clouds."),"\n",i.createElement(t.h3,{id:"data-transformations-and-augmentation",style:{position:"relative"}},i.createElement(t.a,{href:"#data-transformations-and-augmentation","aria-label":"data transformations and augmentation permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"data transformations and augmentation"),"\n",i.createElement(t.p,null,"Data transformations can be handled in many ways, but ",i.createElement(l.A,null,"torchvision.transforms")," is one of the more popular modules for computer vision tasks. It provides operations like random cropping, resizing, flipping, etc. The notion of ",i.createElement(l.A,null,"augmentation")," is crucial in many deep learning applications, especially in computer vision, because it artificially increases the variety of your training data and can help mitigate overfitting."),"\n",i.createElement(t.p,null,"For example:"),"\n",i.createElement(s.A,{text:"\nimport torchvision.transforms as T\n\ntransform = T.Compose([\n    T.RandomHorizontalFlip(p=0.5),\n    T.RandomResizedCrop(size=224),\n    T.ColorJitter(brightness=0.1, contrast=0.1),\n    T.ToTensor()\n])\n"}),"\n",i.createElement(t.p,null,"In natural language processing or audio tasks, you have analogous transformations: tokenization, random time-shifts, pitch changes, and so on. The concept is the same — systematically modify the original data in ways that preserve the semantic meaning while giving the model more robust training signals."),"\n",i.createElement(n,{alt:"data-loading-process-diagram",path:"",caption:"A conceptual illustration of how data is loaded, transformed, and batched in PyTorch using DataLoader and Dataset.",zoom:"false"}),"\n",i.createElement(t.h2,{id:"model-training",style:{position:"relative"}},i.createElement(t.a,{href:"#model-training","aria-label":"model training permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"model training"),"\n",i.createElement(t.h3,{id:"defining-the-training-loop",style:{position:"relative"}},i.createElement(t.a,{href:"#defining-the-training-loop","aria-label":"defining the training loop permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"defining the training loop"),"\n",i.createElement(t.p,null,"The next step after constructing your model and data pipeline is to define a training loop. This loop orchestrates the forward pass, loss calculation, backward pass, and parameter updates over multiple epochs. Below is a conceptual skeleton in PyTorch:"),"\n",i.createElement(s.A,{text:'\nmodel = SimpleFeedForward()\ncriterion = nn.CrossEntropyLoss()\noptimizer = torch.optim.SGD(model.parameters(), lr=0.01)\n\nnum_epochs = 10\n\nfor epoch in range(num_epochs):\n    for batch_idx, (inputs, labels) in enumerate(train_loader):\n        \n        # 1. Zero the gradient buffers\n        optimizer.zero_grad()\n        \n        # 2. Forward pass\n        outputs = model(inputs)\n        loss = criterion(outputs, labels)\n        \n        # 3. Backward pass (compute grads)\n        loss.backward()\n        \n        # 4. Update parameters\n        optimizer.step()\n\n    print(f"Epoch {epoch+1} completed.")\n'}),"\n",i.createElement(t.p,null,"While this code is straightforward, there are many details that can be added or tweaked, including:"),"\n",i.createElement(t.ol,null,"\n",i.createElement(t.li,null,"Moving ",i.createElement(l.A,null,"inputs")," and ",i.createElement(l.A,null,"labels")," to a GPU device if available (i.e., ",i.createElement(l.A,null,"inputs = inputs.cuda()"),")."),"\n",i.createElement(t.li,null,"Accumulating statistics or metrics like accuracy within each batch to track progress."),"\n",i.createElement(t.li,null,"Managing learning rate schedules or other hyperparameter modifications through PyTorch's ",i.createElement(l.A,null,"torch.optim.lr_scheduler"),"."),"\n"),"\n",i.createElement(t.p,null,"Many advanced training scenarios revolve around this pattern. In large-scale contexts, you might rely on a distributed data parallel strategy to replicate this loop across multiple machines, each working on a subset of the data. Still, the fundamental logic remains the same."),"\n",i.createElement(t.h3,{id:"optimizers-and-loss-functions",style:{position:"relative"}},i.createElement(t.a,{href:"#optimizers-and-loss-functions","aria-label":"optimizers and loss functions permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"optimizers and loss functions"),"\n",i.createElement(t.p,null,"PyTorch provides a variety of optimizers through ",i.createElement(l.A,null,"torch.optim"),", from standard Gradient Descent (SGD) and Momentum to Adam (Kingma & Ba, ICLR 2015), RMSProp, Adagrad, etc. Each optimizer has its own set of hyperparameters, typically including a learning rate (",i.createElement(c.A,{text:"\\(lr\\)"}),") and momentum terms or ",i.createElement(c.A,{text:"\\(\\beta\\)"})," parameters, as in Adam. The general formula for updating parameters ",i.createElement(c.A,{text:"\\(w\\)"})," via gradient descent is:"),"\n",i.createElement(c.A,{text:"\\[\nw \\leftarrow w - \\eta \\nabla_w L(w)\n\\]"}),"\n",i.createElement(t.p,null,"Where ",i.createElement(c.A,{text:"\\(\\eta\\)"})," is the learning rate and ",i.createElement(c.A,{text:"\\(\\nabla_w L(w)\\)"})," is the gradient of the loss with respect to ",i.createElement(c.A,{text:"\\(w\\)"}),". More sophisticated optimizers incorporate momentum terms or adaptive learning rates."),"\n",i.createElement(t.p,null,"Loss functions are found in ",i.createElement(l.A,null,"torch.nn"),", with cross-entropy, mean squared error, L1 loss, and many others available. In classification tasks, ",i.createElement(l.A,null,"nn.CrossEntropyLoss")," is standard for multi-class problems, while ",i.createElement(l.A,null,"nn.BCELoss")," or ",i.createElement(l.A,null,"nn.BCEWithLogitsLoss")," is used for binary classification. For regression tasks, ",i.createElement(l.A,null,"nn.MSELoss")," or ",i.createElement(l.A,null,"nn.L1Loss")," are more common. One can also define custom losses by writing your own function that returns a scalar ",i.createElement(l.A,null,"tensor")," for which ",i.createElement(c.A,{text:"\\(requires\\_grad=True\\)"}),"."),"\n",i.createElement(t.h3,{id:"validation-and-testing",style:{position:"relative"}},i.createElement(t.a,{href:"#validation-and-testing","aria-label":"validation and testing permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"validation and testing"),"\n",i.createElement(t.p,null,"To ensure that your model is generalizing properly rather than memorizing training data, you should frequently measure validation performance. Often, one keeps aside a validation set (or uses cross-validation, as discussed in earlier articles). The typical pattern for validation in PyTorch might be:"),"\n",i.createElement(s.A,{text:'\nmodel.eval()  # put model in eval mode (e.g., disables dropout)\nval_loss = 0\nwith torch.no_grad():  # no need to compute gradients\n    for inputs, labels in val_loader:\n        outputs = model(inputs)\n        loss = criterion(outputs, labels)\n        val_loss += loss.item()\n\nval_loss /= len(val_loader)\nprint(f"Validation Loss: {val_loss}")\nmodel.train()  # back to training mode\n'}),"\n",i.createElement(t.p,null,"In ",i.createElement(l.A,null,"eval"),' mode, certain layers like dropout or batch normalization may behave differently than in training mode, ensuring consistent performance metrics. During actual "testing" or final evaluation, the procedure is analogous, though typically your test set is strictly held-out data from training.'),"\n",i.createElement(t.h2,{id:"other-techniques-transfer-learning-distributed-training-mixed-precision-training-saving-loading-etc",style:{position:"relative"}},i.createElement(t.a,{href:"#other-techniques-transfer-learning-distributed-training-mixed-precision-training-saving-loading-etc","aria-label":"other techniques transfer learning distributed training mixed precision training saving loading etc permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"other techniques: transfer learning, distributed training, mixed precision training, saving, loading, etc."),"\n",i.createElement(t.p,null,"Although the fundamentals of building neural networks with PyTorch involve the steps we have already covered — data loading, model definition, training loop, etc. — it is worth taking some time to acknowledge additional techniques that are essential in modern deep learning:"),"\n",i.createElement(t.ol,null,"\n",i.createElement(t.li,null,"\n",i.createElement(t.p,null,i.createElement(t.strong,null,"Transfer Learning"),": A powerful approach where you take a model pre-trained on a large dataset (e.g., ImageNet for vision tasks) and fine-tune it on your own dataset, typically with fewer training samples. PyTorch's ",i.createElement(l.A,null,"torchvision.models")," includes well-known architectures such as ResNet or VGG, which can be loaded with pre-trained weights. By freezing early layers or adjusting the final layer to match your custom dataset's number of classes, you can leverage transfer learning to achieve high performance with minimal training from scratch."),"\n"),"\n",i.createElement(t.li,null,"\n",i.createElement(t.p,null,i.createElement(t.strong,null,"Distributed Training"),": PyTorch's ",i.createElement(l.A,null,"torch.distributed")," or ",i.createElement(l.A,null,"DataParallel")," approach allows you to scale to multiple GPUs on a single machine or even multiple machines. This is crucial when training large models or dealing with massive datasets. In the ",i.createElement(l.A,null,"DistributedDataParallel")," model, each GPU sees a portion of the data, and gradients are synchronized across all workers after each batch. This distributed strategy is commonly used in both research and production contexts, especially for tasks like large-scale language models or vision transformers."),"\n"),"\n",i.createElement(t.li,null,"\n",i.createElement(t.p,null,i.createElement(t.strong,null,"Mixed Precision Training"),": Also known as half-precision training, or using ",i.createElement(c.A,{text:"\\(float16\\)"})," for specific operations to reduce memory usage and speed up computation on modern GPUs that support Tensor Cores. PyTorch provides ",i.createElement(l.A,null,"torch.cuda.amp"),", which enables automatic mixed precision. The concept behind this is to keep certain computations in higher precision to preserve numerical stability, while other computations can be performed in half precision for efficiency gains. Typically, mixed precision leads to faster training times while requiring less GPU memory, without sacrificing accuracy in most cases."),"\n"),"\n",i.createElement(t.li,null,"\n",i.createElement(t.p,null,i.createElement(t.strong,null,"Saving and Loading Models"),": It is very common to save model weights periodically during training for checkpointing purposes. In PyTorch, this is done with ",i.createElement(l.A,null,"torch.save")," for saving and ",i.createElement(l.A,null,"torch.load")," for loading:"),"\n",i.createElement(s.A,{text:'\n# Saving\ntorch.save(model.state_dict(), "model_weights.pth")\n\n# Loading\nmodel = SimpleFeedForward()\nmodel.load_state_dict(torch.load("model_weights.pth"))\n'}),"\n",i.createElement(t.p,null,"This approach (using ",i.createElement(l.A,null,"state_dict"),") is recommended over trying to save the entire ",i.createElement(l.A,null,"nn.Module")," object directly. The ",i.createElement(l.A,null,"state_dict")," only contains the model parameters and buffers, which is typically enough to reconstruct the model if you have the same code for your architecture."),"\n"),"\n",i.createElement(t.li,null,"\n",i.createElement(t.p,null,i.createElement(t.strong,null,"Model Checkpointing and Early Stopping"),": In real projects, you often do not want to wait until the end of training to see if the model overfits. Instead, you can regularly evaluate your validation set performance and store the best-performing weights. Early stopping is used when you notice the validation performance ceases to improve or starts to degrade, at which point continuing training might lead to overfitting or wasted compute resources."),"\n"),"\n",i.createElement(t.li,null,"\n",i.createElement(t.p,null,i.createElement(t.strong,null,"Integration with Ecosystem Tools"),": PyTorch works seamlessly with many other advanced libraries and frameworks. Examples include:"),"\n",i.createElement(t.ul,null,"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"PyTorch Lightning")," or ",i.createElement(t.strong,null,"fastai"),": Provide higher-level abstractions on top of pure PyTorch, simplifying or automating boilerplate code for training loops, logging, or checkpointing."),"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"TensorBoard")," or ",i.createElement(t.strong,null,"Weights & Biases"),": Tools for logging training metrics and visualizing them in real-time."),"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"ONNX"),": Open Neural Network Exchange for exporting models built in PyTorch to other runtimes."),"\n"),"\n"),"\n",i.createElement(t.li,null,"\n",i.createElement(t.p,null,i.createElement(t.strong,null,"Advanced Topics"),": If you venture even further, you may encounter JIT compilation via ",i.createElement(l.A,null,"torch.jit"),", quantization for edge deployment, or HPC-oriented solutions using NVIDIA's ",i.createElement(l.A,null,"APEX"),". Additionally, large language models (LLMs) use sophisticated distributed strategies like sharded gradients or model parallel approaches, all of which are available to some extent in PyTorch or third-party libraries built on top of it."),"\n"),"\n"),"\n",i.createElement(n,{alt:"distributed-training-diagram",path:"",caption:"Schematic depiction of distributed data parallel training with multiple GPUs.",zoom:"false"}),"\n",i.createElement(t.p,null,"All these capabilities make PyTorch not just a friendly tool for building your first neural network but also a robust, production-ready solution for the entire cycle of designing, training, and deploying advanced machine learning models. Indeed, the library is used in wide-ranging domains from classical image classification tasks to generative adversarial networks (GANs), from reinforcement learning to complex multi-modal architectures."),"\n",i.createElement(t.hr),"\n",i.createElement(t.p,null,"I encourage you to set up a small project using PyTorch. Download or generate a dataset, define a custom ",i.createElement(l.A,null,"Dataset"),", build a small feed-forward network, pick an optimizer, and train. Experiment with different hyperparameters — for instance, changing the learning rate or trying out different optimizers — to see how it influences your results. From there, you can move on to more sophisticated architectures, incorporate advanced data augmentations, or even try distributed training if you have the resources."),"\n",i.createElement(t.p,null,"PyTorch is a vast ecosystem, and what we covered here represents only the core fundamentals that every data scientist or machine learning engineer should know. As you progress, you may find yourself diving deeper into specialized tasks like computer vision (with ",i.createElement(l.A,null,"torchvision"),"), NLP (with ",i.createElement(l.A,null,"torchtext")," or Hugging Face Transformers), or audio (with ",i.createElement(l.A,null,"torchaudio"),"). Each domain has unique challenges, but PyTorch's consistent API and dynamic graph approach make the learning curve more manageable."),"\n",i.createElement(t.p,null,"If you keep building upon the fundamental knowledge from this article, you will be well-prepared to tackle the more advanced topics in neural network design, distributed strategies, or domain-specific applications that are introduced in subsequent articles of this course. Above all, remember that PyTorch's design philosophy is about flexibility, immediacy, and readability — that is, you should feel empowered to experiment quickly, debug in real time, and adapt your code to novel research ideas or production constraints without wrestling with a difficult workflow."),"\n",i.createElement(t.hr),"\n",i.createElement(t.p,null,"That concludes the overview and deep dive on PyTorch, covering everything from the basics of dynamic computation graphs and tensor-based data loading to advanced references on distributed training and model saving/loading. I look forward to seeing how you combine these principles and techniques in your future machine learning ventures!"))}var m=function(e){void 0===e&&(e={});const{wrapper:t}=Object.assign({},(0,r.RP)(),e.components);return t?i.createElement(t,e,i.createElement(d,e)):d(e)};var h=n(36710),u=n(58481),p=n.n(u),g=n(36310),f=n(87245),y=n(27042),v=n(59849),w=n(5591),E=n(61122),b=n(9219),T=n(33203),x=n(95751),k=n(94328),A=n(80791),S=n(78137);const L=e=>{let{toc:t}=e;if(!t||!t.items)return null;return i.createElement("nav",{className:A.R},i.createElement("ul",null,t.items.map(((e,t)=>i.createElement("li",{key:t},i.createElement("a",{href:e.url,onClick:t=>((e,t)=>{e.preventDefault();const n=t.replace("#",""),a=document.getElementById(n);a&&a.scrollIntoView({behavior:"smooth",block:"start"})})(t,e.url)},e.title),e.items&&i.createElement(L,{toc:{items:e.items}}))))))};function M(e){let{data:{mdx:t,allMdx:o,allPostImages:l},children:s}=e;const{frontmatter:c,body:d,tableOfContents:m}=t,h=c.index,u=c.slug.split("/")[1],v=o.nodes.filter((e=>e.frontmatter.slug.includes(`/${u}/`))).sort(((e,t)=>e.frontmatter.index-t.frontmatter.index)),A=v.findIndex((e=>e.frontmatter.index===h)),M=v[A+1],z=v[A-1],P=c.slug.replace(/\/$/,""),I=/[^/]*$/.exec(P)[0],C=`posts/${u}/content/${I}/`,{0:N,1:_}=(0,i.useState)(c.flagWideLayoutByDefault),{0:j,1:H}=(0,i.useState)(!1);var D;(0,i.useEffect)((()=>{H(!0);const e=setTimeout((()=>H(!1)),340);return()=>clearTimeout(e)}),[N]),"adventures"===u?D=b.cb:"research"===u?D=b.Qh:"thoughts"===u&&(D=b.T6);const B=p()(d).replace(/import .*? from .*?;/g,"").replace(/<.*?>/g,"").replace(/\{\/\*[\s\S]*?\*\/\}/g,"").trim().split(/\s+/).length,V=function(e){if(e<=10)return"~10 min";if(e<=20)return"~20 min";if(e<=30)return"~30 min";if(e<=40)return"~40 min";if(e<=50)return"~50 min";if(e<=60)return"~1 h";const t=Math.floor(e/60),n=e%60;return n<=30?`~${t}${n>0?".5":""} h`:`~${t+1} h`}(Math.ceil(B/D)+(c.extraReadTimeMin||0)),F=[{flag:c.flagDraft,component:()=>Promise.all([n.e(3231),n.e(8809)]).then(n.bind(n,28809))},{flag:c.flagMindfuckery,component:()=>Promise.all([n.e(3231),n.e(2471)]).then(n.bind(n,67709))},{flag:c.flagRewrite,component:()=>Promise.all([n.e(3231),n.e(6764)]).then(n.bind(n,62002))},{flag:c.flagOffensive,component:()=>Promise.all([n.e(3231),n.e(2443)]).then(n.bind(n,17681))},{flag:c.flagProfane,component:()=>Promise.all([n.e(3231),n.e(8048)]).then(n.bind(n,53286))},{flag:c.flagMultilingual,component:()=>Promise.all([n.e(3231),n.e(4069)]).then(n.bind(n,78831))},{flag:c.flagUnreliably,component:()=>Promise.all([n.e(3231),n.e(3417)]).then(n.bind(n,8179))},{flag:c.flagPolitical,component:()=>Promise.all([n.e(3231),n.e(5195)]).then(n.bind(n,30433))},{flag:c.flagCognitohazard,component:()=>Promise.all([n.e(3231),n.e(3175)]).then(n.bind(n,8413))},{flag:c.flagHidden,component:()=>Promise.all([n.e(3231),n.e(9556)]).then(n.bind(n,14794))}],{0:O,1:G}=(0,i.useState)([]);return(0,i.useEffect)((()=>{F.forEach((e=>{let{flag:t,component:n}=e;t&&n().then((e=>{G((t=>[].concat((0,a.A)(t),[e.default])))}))}))}),[]),i.createElement(y.P.div,{initial:{opacity:0},animate:{opacity:1},exit:{opacity:0},transition:{duration:.15}},i.createElement(w.A,{postNumber:c.index,date:c.date,updated:c.updated,readTime:V,difficulty:c.difficultyLevel,title:c.title,desc:c.desc,banner:c.banner,section:u,postKey:I,isMindfuckery:c.flagMindfuckery,mainTag:c.mainTag}),i.createElement("div",{style:{display:"flex",justifyContent:"flex-end",flexWrap:"wrap",maxWidth:"75%",marginLeft:"auto",paddingRight:"1vw",marginTop:"-6vh",marginBottom:"4vh"}},c.otherTags.map(((e,t)=>i.createElement("span",{key:t,className:`noselect ${S.MW}`,style:{margin:"0 5px 5px 0"}},e)))),i.createElement("div",{class:"postBody"},i.createElement(L,{toc:m})),i.createElement("br"),i.createElement("div",{style:{margin:"0 10% -2vh 30%",textAlign:"right"}},i.createElement(y.P.button,{class:"noselect",className:k.pb,id:k.xG,onClick:()=>{_(!N)},whileTap:{scale:.93}},i.createElement(y.P.div,{className:x.DJ,key:N,initial:{opacity:0},animate:{opacity:1},exit:{opacity:0},transition:{duration:.3,ease:"easeInOut"}},N?"Switch to default layout":"Switch to wide layout"))),i.createElement("br"),i.createElement("div",{class:"postBody",style:{margin:N?"0 -14%":"",maxWidth:N?"200%":"",transition:"margin 1s ease, max-width 1s ease, padding 1s ease"}},i.createElement("div",{className:`${k.P_} ${j?k.Xn:k.qG}`},O.map(((e,t)=>i.createElement(e,{key:t}))),c.indexCourse?i.createElement(T.A,{index:c.indexCourse,category:c.courseCategoryName}):"",i.createElement(g.Z.Provider,{value:{images:l.nodes,basePath:C.replace(/\/$/,"")+"/"}},i.createElement(r.xA,{components:{Image:f.A}},s)))),i.createElement(E.A,{nextPost:M,lastPost:z,keyCurrent:I,section:u}))}function z(e){return i.createElement(M,e,i.createElement(m,e))}function P(e){var t,n,a,r,o;let{data:l}=e;const{frontmatter:s}=l.mdx,c=s.titleSEO||s.title,d=s.titleOG||c,m=s.titleTwitter||c,u=s.descSEO||s.desc,p=s.descOG||u,g=s.descTwitter||u,f=s.schemaType||"BlogPosting",y=s.keywordsSEO,w=s.date,E=s.updated||w,b=s.imageOG||(null===(t=s.banner)||void 0===t||null===(n=t.childImageSharp)||void 0===n||null===(a=n.gatsbyImageData)||void 0===a||null===(r=a.images)||void 0===r||null===(o=r.fallback)||void 0===o?void 0:o.src),T=s.imageAltOG||p,x=s.imageTwitter||b,k=s.imageAltTwitter||g,A=s.canonicalURL,S=s.flagHidden||!1,L=s.mainTag||"Posts",M=s.slug.split("/")[1]||"posts",{siteUrl:z}=(0,h.Q)(),P={"@context":"https://schema.org","@type":"BreadcrumbList",itemListElement:[{"@type":"ListItem",position:1,name:"Home",item:z},{"@type":"ListItem",position:2,name:L,item:`${z}/${s.slug.split("/")[1]}`},{"@type":"ListItem",position:3,name:c,item:`${z}${s.slug}`}]};return i.createElement(v.A,{title:c+" - avrtt.blog",titleOG:d,titleTwitter:m,description:u,descriptionOG:p,descriptionTwitter:g,schemaType:f,keywords:y,datePublished:w,dateModified:E,imageOG:b,imageAltOG:T,imageTwitter:x,imageAltTwitter:k,canonicalUrl:A,flagHidden:S,mainTag:L,section:M,type:"article"},i.createElement("script",{type:"application/ld+json"},JSON.stringify(P)))}},66501:function(e,t,n){n.d(t,{A:function(){return o}});var a=n(96540),r=n(3962),i="styles-module--tooltiptext--a263b";var o=e=>{let{text:t,isBadge:n=!1}=e;const{0:o,1:l}=(0,a.useState)(!1),s=(0,a.useRef)(null);return(0,a.useEffect)((()=>{function e(e){s.current&&!s.current.contains(e.target)&&l(!1)}return document.addEventListener("click",e),()=>{document.removeEventListener("click",e)}}),[]),a.createElement("span",{className:"styles-module--tooltipWrapper--75ebf",ref:s},a.createElement("img",{id:n?"styles-module--infoBadge--e3d66":"styles-module--info--26c1f",src:r.A,alt:"info",onClick:e=>{e.stopPropagation(),l((e=>!e))}}),a.createElement("span",{className:o?`${i} styles-module--visible--c063c`:i},t))}},96098:function(e,t,n){var a=n(96540),r=n(7978);t.A=e=>{let{text:t}=e;return a.createElement(r.A,null,t)}}}]);
//# sourceMappingURL=component---src-templates-post-js-content-file-path-src-pages-posts-research-intro-to-pytorch-mdx-59ebf5e86d594baedeab.js.map