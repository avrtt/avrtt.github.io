"use strict";(self.webpackChunkavrtt_blog=self.webpackChunkavrtt_blog||[]).push([[1288],{66015:function(e,t,n){n.r(t),n.d(t,{Head:function(){return z},PostTemplate:function(){return C},default:function(){return M}});var a=n(54506),i=n(28453),r=n(96540),o=n(16886),s=n(46295),l=n(96098);function c(e){const t=Object.assign({p:"p",em:"em",h3:"h3",a:"a",span:"span",hr:"hr",h2:"h2",ul:"ul",li:"li",strong:"strong",ol:"ol",h1:"h1"},(0,i.RP)(),e.components),{Image:n}=t;return n||function(e,t){throw new Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Image",!0),r.createElement(r.Fragment,null,r.createElement(t.p,null,r.createElement(t.em,null,"A computer vision researcher is like an artist (always starving).")),"\n",r.createElement("br"),"\n","\n","\n",r.createElement(t.p,null,"Geometry and its associated concepts have long played a pivotal role in the history of computer science, shaping how we represent and interpret the world in computational systems. The interplay between geometry and algorithmic thinking dates back to the earliest eras of computational geometry, when researchers studied methods for polygon clipping, line intersection, and triangulation to solve basic problems in computer graphics and geographical information systems. In the 1960s and 1970s, as computer graphics technology gradually matured, the demand for faster and more efficient geometric algorithms grew, leading to the formal inception of computational geometry as a discipline — defined primarily by the rigorous study of algorithms for geometric problems."),"\n",r.createElement(t.p,null,"By the 1980s, geometry started becoming central to robotics, computer vision, and pattern recognition research, where tasks such as object localization and shape matching required robust geometric transformations (translation, rotation, and scaling) to be handled computationally. Simultaneously, the rise of personal computing and the gaming industry fueled an interest in 3D rendering and real-time graphics, triggering a cascade of research in geometric modeling, hidden surface removal, and advanced rendering pipelines. As machine learning evolved from statistical pattern recognition, geometry found further relevance — particularly in the representation of high-dimensional data and the extraction of meaningful, lower-dimensional structures to facilitate classification or regression tasks."),"\n",r.createElement(t.p,null,"Pioneering works in the 1990s, such as those by Hartley, Zisserman, and others, established the theoretical and algorithmic bedrock for geometric computer vision (epipolar geometry, projective transformations, and camera calibration). These breakthroughs allowed accurate 3D reconstruction from images and fostered robust methodologies for tasks like stereo vision and structure-from-motion. With these developments, geometry became a unifying theme across multiple branches of AI research: it related the abstract notion of an object in the world to pixel intensities in an image, bridging the gap between raw sensory input and 3D scene understanding."),"\n",r.createElement(t.h3,{id:"modern-motivations",style:{position:"relative"}},r.createElement(t.a,{href:"#modern-motivations","aria-label":"modern motivations permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Modern motivations"),"\n",r.createElement(t.p,null,"Today, geometry underpins numerous modern and emerging applications in machine learning and data science. Autonomous driving systems, for instance, rely on real-time geometry estimation from LiDAR point clouds and camera feeds to detect obstacles and estimate motion trajectories. In augmented reality (AR) and virtual reality (VR), accurate understanding of 3D scene geometry is essential for projecting or blending virtual objects into real-world scenes in a photorealistic and geometrically consistent manner. Moreover, in robotics, geometry informs navigation, mapping (e.g., SLAM — Simultaneous Localization and Mapping), and manipulation tasks that enable robots to interact intelligently with their environment."),"\n",r.createElement(t.p,null,"In the realm of deep learning, geometry has become indispensable: network architectures increasingly incorporate geometric priors to handle 3D data, from point-based networks that process unstructured point clouds (e.g., PointNet, PointNet++), to mesh-based learning for shape analysis and segmentation, to 3D convolutional neural networks for volumetric data. There is also a fast-growing body of research on neural implicit representations for 3D reconstruction, such as neural radiance fields (NeRF), which estimate scenes by modeling continuous implicit functions. These advanced methods highlight how geometry is no longer just an afterthought in learning-based pipelines; it is integral to how modern systems interpret, represent, and manipulate the world around them."),"\n",r.createElement(t.h3,{id:"overview-of-key-challenges-in-integrating-geometric-knowledge-into-machine-learning-workflows",style:{position:"relative"}},r.createElement(t.a,{href:"#overview-of-key-challenges-in-integrating-geometric-knowledge-into-machine-learning-workflows","aria-label":"overview of key challenges in integrating geometric knowledge into machine learning workflows permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Overview of key challenges in integrating geometric knowledge into machine learning workflows"),"\n",r.createElement(t.p,null,"Despite geometry's importance, incorporating geometric knowledge into machine learning workflows remains challenging. First, real-world data can be extremely noisy, incomplete, or unstructured, leading to substantial difficulties in stable estimation of geometric parameters. For example, sensor data from LiDAR or depth cameras often contain missing regions and partial occlusions. Handling such imperfection requires robust, noise-tolerant algorithms."),"\n",r.createElement(t.p,null,"Second, many of the common machine learning approaches — particularly standard fully connected or convolutional neural networks — are well-suited for images (2D pixel arrays) or sequential data, but are less trivial to adapt to geometric data structures like point clouds or meshes that do not share regular topologies. Designing architectures that preserve rotational or translational invariances, while still learning powerful representations, is an ongoing research endeavor."),"\n",r.createElement(t.p,null,"Furthermore, bridging Euclidean geometry with modern deep networks often requires advanced losses, metrics, or optimization techniques. Simply using Euclidean distance in high-dimensional latent spaces can be insufficient for capturing the manifold structure of complex geometric objects. Researchers therefore explore geodesic distances on manifolds, graph-based adjacency representations for meshes, or specialized distance metrics (e.g., Chamfer distance, Earth Mover's Distance) that account for the unique properties of geometric data."),"\n",r.createElement(t.p,null,"Finally, geometry in machine learning often involves dealing with transformations: pose estimation, calibration, or alignment. Solving transformation parameters typically involves iterative optimization or specialized algorithms such as RANSAC for robust estimation. These tasks can be computationally intensive, especially at scale or in real-time applications like robotics and self-driving cars. The quest to unify geometric rigor, computational efficiency, and machine learning performance remains a key frontier for researchers and practitioners alike."),"\n",r.createElement(t.p,null,"With these motivations and challenges in mind, I will now dive into the fundamental principles and tools that drive geometry estimation in machine learning contexts, beginning with a look at the basic definitions and concepts that connect geometry and data representation."),"\n",r.createElement(t.hr),"\n",r.createElement(t.h2,{id:"2-fundamentals-of-geometry-in-machine-learning",style:{position:"relative"}},r.createElement(t.a,{href:"#2-fundamentals-of-geometry-in-machine-learning","aria-label":"2 fundamentals of geometry in machine learning permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"2. Fundamentals of geometry in machine learning"),"\n",r.createElement(t.h3,{id:"euclidean-vs-non-euclidean-spaces-their-relevance-in-ml",style:{position:"relative"}},r.createElement(t.a,{href:"#euclidean-vs-non-euclidean-spaces-their-relevance-in-ml","aria-label":"euclidean vs non euclidean spaces their relevance in ml permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Euclidean vs. non-Euclidean spaces: their relevance in ML"),"\n",r.createElement(t.p,null,"The starting point for studying geometry in machine learning is to understand the spaces in which data resides. A ",r.createElement(o.A,null,"Euclidean space")," is a flat, n-dimensional space where distances and angles follow the well-known Euclidean norm. For instance, 2D and 3D coordinate systems used in classical geometry are typical Euclidean spaces, and much of the standard ML repertoire — like linear regression or standard neural networks — implicitly assumes data in such a space."),"\n",r.createElement(t.p,null,"However, real-world data can often lie on manifolds that do not conform strictly to Euclidean geometry. These ",r.createElement(o.A,null,"non-Euclidean spaces")," can have curvature, complex topological structures, or adjacency relationships that make them better described by Riemannian geometry or graph-based representations. Applications such as analyzing social networks, analyzing meshes for 3D object surfaces, or modeling spherical data (like Earth geodesics) need to break free from purely Euclidean assumptions. This has led to the development of specialized frameworks — like geometric deep learning (e.g., GCNs, graph neural networks) — that respect the underlying structure of non-Euclidean data."),"\n",r.createElement(t.h3,{id:"role-of-geometry-in-data-understanding-embedding-data-in-low-dimensional-manifolds-shape-analysis-and-object-representation",style:{position:"relative"}},r.createElement(t.a,{href:"#role-of-geometry-in-data-understanding-embedding-data-in-low-dimensional-manifolds-shape-analysis-and-object-representation","aria-label":"role of geometry in data understanding embedding data in low dimensional manifolds shape analysis and object representation permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Role of geometry in data understanding: embedding data in low-dimensional manifolds, shape analysis, and object representation"),"\n",r.createElement(t.p,null,"Machine learning often involves mapping high-dimensional data to lower-dimensional representations, a process sometimes referred to as ",r.createElement(o.A,null,"embedding"),". Techniques like principal component analysis (PCA), manifold learning (e.g., Locally Linear Embedding, t-SNE, UMAP), and autoencoders exemplify how geometry helps us discover the underlying low-dimensional structure in data."),"\n",r.createElement(t.p,null,"In 3D shape analysis, geometry is crucial in capturing intrinsic properties such as curvature or topological features. For instance, shape descriptors derived from curvature or geodesics can be used to classify objects in a 3D dataset. Object representation methods — like point clouds, meshes, or implicit surfaces — are all essentially geometric encodings that aim to preserve shape information. The type of representation chosen can drastically affect the performance of subsequent learning tasks such as classification or segmentation."),"\n",r.createElement(t.h3,{id:"geometry-in-various-ml-tasks-classification-segmentation-reconstruction-and-retrieval",style:{position:"relative"}},r.createElement(t.a,{href:"#geometry-in-various-ml-tasks-classification-segmentation-reconstruction-and-retrieval","aria-label":"geometry in various ml tasks classification segmentation reconstruction and retrieval permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Geometry in various ML tasks: classification, segmentation, reconstruction, and retrieval"),"\n",r.createElement(t.p,null,"Geometry plays a direct role in various ML tasks:"),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Classification"),": 3D object classification can benefit from geometric features (e.g., shape descriptors) or from specialized networks that process 3D data."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Segmentation"),": Geometric cues help identify boundaries and regions on surfaces or volumes, separating an object's parts meaningfully."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Reconstruction"),": Inferring a full geometry (e.g., reconstructing a complete 3D shape from partial sensor scans) demands robust modeling that respects the inherent geometric constraints of objects."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Retrieval"),": Retrieving similar shapes or images from a database often involves computing shape distances or descriptors that are robust to noise, partial occlusions, or transformations."),"\n"),"\n",r.createElement(t.h3,{id:"relationship-between-geometry-and-deep-learning-embeddings-and-shape-representations",style:{position:"relative"}},r.createElement(t.a,{href:"#relationship-between-geometry-and-deep-learning-embeddings-and-shape-representations","aria-label":"relationship between geometry and deep learning embeddings and shape representations permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Relationship between geometry and deep learning: embeddings and shape representations"),"\n",r.createElement(t.p,null,"The integration of geometry into deep learning manifests in different ways. One popular approach is to define ",r.createElement(o.A,null,"geometric deep learning")," architectures that accept graph-structured data or manifold-structured data as input, preserving adjacency information. Another approach is to incorporate geometry into the loss function — like the Chamfer distance or Earth Mover's Distance for shape matching — ensuring that the network output is penalized in a way that truly reflects geometric (rather than purely pixelwise or coordinatewise) deviations."),"\n",r.createElement(t.p,null,"In shape representation learning, networks may implicitly learn geometry, such as in implicit neural representations, where a neural network function ",r.createElement(l.A,{text:"\\(f(\\mathbf{x})\\)"})," indicates occupancy or signed distance for each point ",r.createElement(l.A,{text:"\\(\\mathbf{x}\\)"})," in space. By learning this continuous function, the geometry is represented in the network weights themselves. This approach has yielded state-of-the-art results in tasks like shape completion and novel view synthesis."),"\n",r.createElement(t.h3,{id:"definitions-of-geometry-in-a-machine-learning-context",style:{position:"relative"}},r.createElement(t.a,{href:"#definitions-of-geometry-in-a-machine-learning-context","aria-label":"definitions of geometry in a machine learning context permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Definitions of geometry in a machine learning context"),"\n",r.createElement(t.p,null,"In a machine learning context, geometry usually refers to the study of:"),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Spaces"),": Euclidean, Riemannian, manifold-based, etc."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Transformations"),": Rigid (rotation, translation), affine (scaling, shear), or projective transformations."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Metrics"),": Distances or similarity measures that reflect geometric relationships between data points or shapes."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Representations"),": Discrete (point clouds, meshes, graphs) or continuous (implicit functions) ways of expressing objects or datasets."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Optimization"),": Methods to estimate parameters (e.g., pose, shape) that minimize or maximize a geometric objective function."),"\n"),"\n",r.createElement(t.p,null,"Understanding these definitions is the first step toward applying geometry in real-world machine learning pipelines."),"\n",r.createElement(t.hr),"\n",r.createElement(t.h2,{id:"3-linear-algebra-for-3d-data",style:{position:"relative"}},r.createElement(t.a,{href:"#3-linear-algebra-for-3d-data","aria-label":"3 linear algebra for 3d data permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"3. Linear algebra for 3D data"),"\n",r.createElement(t.h3,{id:"vector-and-matrix-transformations-foundation-for-geometric-computations",style:{position:"relative"}},r.createElement(t.a,{href:"#vector-and-matrix-transformations-foundation-for-geometric-computations","aria-label":"vector and matrix transformations foundation for geometric computations permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Vector and matrix transformations: foundation for geometric computations"),"\n",r.createElement(t.p,null,"Linear algebra provides the fundamental language of geometry in many machine learning applications, especially when dealing with 3D data. Vectors represent points or directions in ",r.createElement(l.A,{text:"\\(\\mathbb{R}^3\\)"}),", while matrices encode transformations such as rotation, scaling, or reflection. A rotation matrix ",r.createElement(l.A,{text:"\\(R\\)"}),", for example, is an orthonormal ",r.createElement(l.A,{text:"\\(3 \\times 3\\)"})," matrix with determinant 1. When we multiply a vector ",r.createElement(l.A,{text:"\\(\\mathbf{v} \\in \\mathbb{R}^3\\)"})," by ",r.createElement(l.A,{text:"\\(R\\)"}),", we effectively rotate ",r.createElement(l.A,{text:"\\(\\mathbf{v}\\)"})," around the origin by a certain angle and axis determined by ",r.createElement(l.A,{text:"\\(R\\)"}),"."),"\n",r.createElement(t.p,null,"Translation is not linear in the strict sense — adding a constant offset to a vector is an affine transformation — so it is often handled in a homogeneous coordinate system of dimension 4. In homogeneous coordinates, a 4D matrix can represent combined operations like rotation, translation, and scaling in a single framework, making it extremely convenient for camera transformations and object manipulations."),"\n",r.createElement(t.h3,{id:"eigenvalues-and-eigenvectors-their-role-in-principal-component-analysis-pca-and-shape-alignment",style:{position:"relative"}},r.createElement(t.a,{href:"#eigenvalues-and-eigenvectors-their-role-in-principal-component-analysis-pca-and-shape-alignment","aria-label":"eigenvalues and eigenvectors their role in principal component analysis pca and shape alignment permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Eigenvalues and eigenvectors: their role in principal component analysis (PCA) and shape alignment"),"\n",r.createElement(t.p,null,"Eigenvalues and eigenvectors are central to many geometry-related tasks. If we have a covariance matrix ",r.createElement(l.A,{text:"\\(\\Sigma\\)"})," describing the distribution of points in ",r.createElement(l.A,{text:"\\(\\mathbb{R}^3\\)"}),", the eigenvectors of ",r.createElement(l.A,{text:"\\(\\Sigma\\)"})," give the principal axes of variation, and the eigenvalues indicate how much variance exists along these axes. This is the cornerstone of PCA, which can reduce dimensionality or align shapes."),"\n",r.createElement(t.p,null,"For instance, in shape alignment, one might compute the centroid of a set of 3D points, subtract this centroid from all points, and then compute the covariance. The dominant eigenvector indicates the direction of greatest variance, which can serve as a reference axis for aligning that shape to a canonical orientation."),"\n",r.createElement(t.h3,{id:"singular-value-decomposition-svd-and-its-applications-in-3d-data-processing",style:{position:"relative"}},r.createElement(t.a,{href:"#singular-value-decomposition-svd-and-its-applications-in-3d-data-processing","aria-label":"singular value decomposition svd and its applications in 3d data processing permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Singular Value Decomposition (SVD) and its applications in 3D data processing"),"\n",r.createElement(t.p,null,"The ",r.createElement(o.A,null,"Singular Value Decomposition (SVD)")," is a powerful tool for working with matrices in geometry. Given a matrix ",r.createElement(l.A,{text:"\\(M\\)"}),", SVD factors it as:"),"\n",r.createElement(l.A,{text:"\\[\nM = U \\Sigma V^T,\n\\]"}),"\n",r.createElement(t.p,null,"where:"),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,r.createElement(l.A,{text:"\\(U\\)"})," and ",r.createElement(l.A,{text:"\\(V\\)"})," are orthonormal matrices."),"\n",r.createElement(t.li,null,r.createElement(l.A,{text:"\\(\\Sigma\\)"})," is a diagonal matrix (with possibly rectangular shape if ",r.createElement(l.A,{text:"\\(M\\)"})," is not square) containing the singular values."),"\n"),"\n",r.createElement(t.p,null,"In 3D data processing, SVD often appears in shape alignment problems. For example, if we want to find the rotation ",r.createElement(l.A,{text:"\\(R\\)"})," that best aligns two point sets ",r.createElement(l.A,{text:"\\(\\{ \\mathbf{x}_i \\}\\)"})," and ",r.createElement(l.A,{text:"\\(\\{ \\mathbf{y}_i \\}\\)"})," (assuming zero-centered data), we might form a correlation matrix ",r.createElement(l.A,{text:"\\(H = \\sum_i \\mathbf{y}_i \\mathbf{x}_i^T\\)"}),". Then we can compute the SVD of ",r.createElement(l.A,{text:"\\(H\\)"}),":"),"\n",r.createElement(l.A,{text:"\\[\nH = U \\Sigma V^T,\n\\]"}),"\n",r.createElement(t.p,null,"and set:"),"\n",r.createElement(l.A,{text:"\\( R = V U^T \\)"}),"\n",r.createElement(t.p,null,"(if ",r.createElement(l.A,{text:"\\(\\det(V U^T) < 0\\)"}),", we correct for reflection by flipping one column in ",r.createElement(l.A,{text:"\\(V\\)"}),"). This yields the optimal rotation that minimizes the sum of squared distances between corresponding points ",r.createElement(l.A,{text:"\\(\\mathbf{x}_i\\)"})," and ",r.createElement(l.A,{text:"\\(\\mathbf{y}_i\\)"}),"."),"\n",r.createElement(t.p,null,"Below is a quick code snippet in Python illustrating how one might use SVD for a simple alignment of two 3D point clouds:"),"\n",r.createElement(s.A,{text:'\nimport numpy as np\n\ndef align_point_clouds(X, Y):\n    """\n    Aligns point cloud X to point cloud Y via least squares\n    rotation and translation. X, Y: (N, 3) arrays.\n    Returns rotation matrix R and translation vector t\n    such that R@X + t ~ Y.\n    """\n    # 1. Compute centroids\n    centroid_X = np.mean(X, axis=0)\n    centroid_Y = np.mean(Y, axis=0)\n    \n    # 2. Center the clouds\n    X_centered = X - centroid_X\n    Y_centered = Y - centroid_Y\n    \n    # 3. Compute correlation matrix\n    H = X_centered.T @ Y_centered\n    \n    # 4. SVD\n    U, S, Vt = np.linalg.svd(H)\n    R = Vt.T @ U.T\n    \n    # Ensure a proper rotation (det(R) should be +1)\n    if np.linalg.det(R) < 0:\n        Vt[2, :] *= -1\n        R = Vt.T @ U.T\n    \n    # 5. Compute translation\n    t = centroid_Y - R @ centroid_X\n    \n    return R, t\n'}),"\n",r.createElement(t.p,null,"This simple routine demonstrates how linear algebra is deeply intertwined with geometry estimation tasks in 3D data processing."),"\n",r.createElement(t.hr),"\n",r.createElement(t.h2,{id:"4-basic-geometric-concepts",style:{position:"relative"}},r.createElement(t.a,{href:"#4-basic-geometric-concepts","aria-label":"4 basic geometric concepts permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"4. Basic geometric concepts"),"\n",r.createElement(t.h3,{id:"curves-and-surfaces-discrete-vs-continuous-representations",style:{position:"relative"}},r.createElement(t.a,{href:"#curves-and-surfaces-discrete-vs-continuous-representations","aria-label":"curves and surfaces discrete vs continuous representations permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Curves and surfaces: discrete vs. continuous representations"),"\n",r.createElement(t.p,null,"From a purely mathematical viewpoint, curves and surfaces exist in a continuous domain. However, in computational systems, we typically represent them discretely — e.g., a parametric curve sampled at many points, or a surface represented as a mesh (with vertices and faces). Translating continuous geometry into discrete form introduces potential approximations, since we can only store a finite amount of data."),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Curves"),": A curve in ",r.createElement(l.A,{text:"\\(\\mathbb{R}^2\\)"})," or ",r.createElement(l.A,{text:"\\(\\mathbb{R}^3\\)"})," can be parameterized by a function ",r.createElement(l.A,{text:"\\(\\mathbf{r}(t)\\)"})," for ",r.createElement(l.A,{text:"\\(t\\)"})," in some interval. In practice, we might store only a set of sampled points ",r.createElement(l.A,{text:"\\(\\{\\mathbf{r}(t_i)\\}\\)"}),"."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Surfaces"),": A surface in ",r.createElement(l.A,{text:"\\(\\mathbb{R}^3\\)"})," can be described by a parameterization ",r.createElement(l.A,{text:"\\(\\mathbf{R}(u,v)\\)"}),". Discretely, we might store a mesh or point cloud approximation."),"\n"),"\n",r.createElement(t.h3,{id:"transformations-translations-rotations-scaling-reflections-and-shearing",style:{position:"relative"}},r.createElement(t.a,{href:"#transformations-translations-rotations-scaling-reflections-and-shearing","aria-label":"transformations translations rotations scaling reflections and shearing permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Transformations: translations, rotations, scaling, reflections, and shearing"),"\n",r.createElement(t.p,null,"These ",r.createElement(o.A,null,"geometric transformations")," can drastically change the appearance or orientation of an object, but they preserve certain geometric properties:"),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Translation"),": Shifts an object by a constant vector ",r.createElement(l.A,{text:"\\(\\mathbf{t}\\)"}),"."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Rotation"),": Pivots an object around some axis by an angle ",r.createElement(l.A,{text:"\\(\\theta\\)"}),", using a rotation matrix ",r.createElement(l.A,{text:"\\(R\\)"}),"."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Scaling"),": Changes the size of an object, uniformly or anisotropically, with a scaling matrix ",r.createElement(l.A,{text:"\\(S\\)"}),"."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Reflection"),": Mirrors an object across a plane or line, using a reflection matrix (determinant -1)."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Shearing"),": Skews the coordinate axes, preserving volume for small transformations but distorting angles."),"\n"),"\n",r.createElement(t.p,null,"In many shape analysis tasks, we try to factor out these transformations when comparing shapes, ensuring that the comparison metric is invariant under rigid transformations (translation, rotation) and possibly scale. Reflection invariance may or may not be desirable, depending on the context (e.g., chirality or left-right symmetry might be relevant for certain objects)."),"\n",r.createElement(t.h3,{id:"point-clouds-advantages-and-drawbacks-in-representing-3d-shapes",style:{position:"relative"}},r.createElement(t.a,{href:"#point-clouds-advantages-and-drawbacks-in-representing-3d-shapes","aria-label":"point clouds advantages and drawbacks in representing 3d shapes permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Point clouds: advantages and drawbacks in representing 3D shapes"),"\n",r.createElement(t.p,null,"A ",r.createElement(o.A,null,"point cloud")," is a set of points in ",r.createElement(l.A,{text:"\\(\\mathbb{R}^3\\)"})," representing the surface or volume of an object. Point clouds are often directly obtained from sensors such as LiDAR or depth cameras. They are simple to store (just a list of coordinates) and easy to capture, but they have some drawbacks:"),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"No explicit connectivity"),": Adjacent points in space are not explicitly linked, complicating the extraction of surfaces or meshes."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Sensitivity to sampling density"),": Different regions of an object may have different densities, leading to potential holes or redundancy."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Difficult to compute curvature or topology")," without additional processing or local neighborhood searches."),"\n"),"\n",r.createElement(t.p,null,"Despite these issues, point clouds are widely used because they are the most direct representation from many depth sensors and are supported by specialized deep learning architectures (e.g., PointNet, PointNet++)."),"\n",r.createElement(t.h3,{id:"meshes-vertices-edges-and-faces-for-surface-representation",style:{position:"relative"}},r.createElement(t.a,{href:"#meshes-vertices-edges-and-faces-for-surface-representation","aria-label":"meshes vertices edges and faces for surface representation permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Meshes: vertices, edges, and faces for surface representation"),"\n",r.createElement(t.p,null,"A ",r.createElement(o.A,null,"mesh")," is a structured representation of a surface using a set of vertices ",r.createElement(l.A,{text:"\\(\\{v_i\\}\\)"}),", edges ",r.createElement(l.A,{text:"\\(\\{e_i\\}\\)"}),", and faces ",r.createElement(l.A,{text:"\\(\\{f_i\\}\\)"}),". The most common form is a triangular mesh, where each face is a triangle. Meshes explicitly encode connectivity: which vertices are neighbors and how faces are arranged. This allows more sophisticated geometric computations, such as curvature estimation, collision detection, and advanced rendering algorithms. However, generating a good-quality mesh from raw data might require complex post-processing steps (e.g., surface reconstruction from point clouds)."),"\n",r.createElement(t.h3,{id:"voxels-volumetric-representation-for-occupancy-grids-and-3d-cnns",style:{position:"relative"}},r.createElement(t.a,{href:"#voxels-volumetric-representation-for-occupancy-grids-and-3d-cnns","aria-label":"voxels volumetric representation for occupancy grids and 3d cnns permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Voxels: volumetric representation for occupancy grids and 3D CNNs"),"\n",r.createElement(t.p,null,r.createElement(o.A,null,"Voxels")," are the 3D analog of pixels: small cubic units that partition a volume. A voxel grid is a 3D array where each cell can store occupancy information (is it inside or outside the object?), color, or other attributes. Voxels are extremely intuitive for certain tasks (like occupancy grids in robotics), and 3D convolutional neural networks can process voxel data similarly to how 2D CNNs process images. However, voxel representations can be memory-intensive for high-resolution grids, and they may also require interpolation or downsampling to fit into computational constraints."),"\n",r.createElement(t.h3,{id:"parametric-surfaces-and-implicit-functions-alternative-representations-for-complex-geometries",style:{position:"relative"}},r.createElement(t.a,{href:"#parametric-surfaces-and-implicit-functions-alternative-representations-for-complex-geometries","aria-label":"parametric surfaces and implicit functions alternative representations for complex geometries permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Parametric surfaces and implicit functions: alternative representations for complex geometries"),"\n",r.createElement(t.p,null,"More advanced representations can capture complex geometries efficiently:"),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Parametric surfaces"),": Define surfaces by a function ",r.createElement(l.A,{text:"\\(\\mathbf{R}(u,v)\\)"})," with ",r.createElement(l.A,{text:"\\((u,v)\\)"})," in a parameter domain, enabling direct control over shape. Examples include Bézier surfaces, NURBS, and spline models frequently used in computer-aided design."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Implicit functions"),": Define a surface as the zero-level set of a function ",r.createElement(l.A,{text:"\\(f(\\mathbf{x})\\)"}),". For instance, a signed distance function (SDF) encodes how far (and inside/outside) a point ",r.createElement(l.A,{text:"\\(\\mathbf{x}\\)"})," is from the surface. Neural implicit representations (e.g., DeepSDF, NeRF) leverage neural networks to model these continuous functions across space, often achieving excellent reconstruction detail."),"\n"),"\n",r.createElement(t.p,null,"Each representation has unique strengths and challenges, and the choice often depends on the application's requirements regarding memory, precision, and ease of manipulation."),"\n",r.createElement(t.hr),"\n",r.createElement(t.h2,{id:"5-camera-models-and-perspective-geometry",style:{position:"relative"}},r.createElement(t.a,{href:"#5-camera-models-and-perspective-geometry","aria-label":"5 camera models and perspective geometry permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"5. Camera models and perspective geometry"),"\n",r.createElement(t.h3,{id:"pinhole-camera-model-projection-of-3d-points-into-2d-images",style:{position:"relative"}},r.createElement(t.a,{href:"#pinhole-camera-model-projection-of-3d-points-into-2d-images","aria-label":"pinhole camera model projection of 3d points into 2d images permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Pinhole camera model: projection of 3D points into 2D images"),"\n",r.createElement(t.p,null,"In computer vision, perhaps the most fundamental geometric model is the pinhole camera. It describes how 3D points in the scene get projected onto a 2D image plane. If a 3D point is given by ",r.createElement(l.A,{text:"\\( \\mathbf{X} = (X, Y, Z) \\)"}),", the pinhole camera model says that the corresponding 2D point ",r.createElement(l.A,{text:"\\( \\mathbf{x} = (x, y) \\)"})," on the image plane is found via perspective projection:"),"\n",r.createElement(l.A,{text:"\\[\n\\begin{pmatrix}\nx \\\\\ny \\\\\n1\n\\end{pmatrix}\n= K \\left[ R \\mid \\mathbf{t} \\right]\n\\begin{pmatrix}\nX \\\\\nY \\\\\nZ \\\\\n1\n\\end{pmatrix},\n\\]"}),"\n",r.createElement(t.p,null,"where:"),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,r.createElement(l.A,{text:"\\(K\\)"})," is the ",r.createElement(o.A,null,"intrinsic camera matrix"),", encoding focal length and principal point."),"\n",r.createElement(t.li,null,r.createElement(l.A,{text:"\\([R \\mid \\mathbf{t}]\\)"})," is the ",r.createElement(o.A,null,"extrinsic parameters")," matrix, describing the rotation ",r.createElement(l.A,{text:"\\(R\\)"})," and translation ",r.createElement(l.A,{text:"\\(\\mathbf{t}\\)"})," of the camera relative to the world coordinate system."),"\n"),"\n",r.createElement(t.p,null,"This model can explain much of the perspective geometry we observe: objects farther away from the camera project to smaller image footprints, and parallel lines in 3D appear to converge in the image (vanishing points)."),"\n",r.createElement(t.h3,{id:"intrinsic-and-extrinsic-camera-parameters-calibration-and-transformations",style:{position:"relative"}},r.createElement(t.a,{href:"#intrinsic-and-extrinsic-camera-parameters-calibration-and-transformations","aria-label":"intrinsic and extrinsic camera parameters calibration and transformations permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Intrinsic and extrinsic camera parameters: calibration and transformations"),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Intrinsic parameters"),": These include the focal lengths ",r.createElement(l.A,{text:"\\((f_x, f_y)\\)"}),", the optical center or principal point ",r.createElement(l.A,{text:"\\((c_x, c_y)\\)"}),", and possibly skew or aspect ratio parameters (often negligible in well-designed cameras). They define how 3D rays map to the 2D image plane inside the camera."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Extrinsic parameters"),": These define the camera's orientation (rotation) and position (translation) in the world. Together, they form a transformation that carries points from a global or object coordinate frame into the camera coordinate frame."),"\n"),"\n",r.createElement(t.p,null,r.createElement(o.A,null,"Camera calibration")," is the process of determining ",r.createElement(l.A,{text:"\\(K\\)"})," and ",r.createElement(l.A,{text:"\\([R \\mid \\mathbf{t}]\\)"}),". Calibration often involves taking pictures of known calibration objects (like checkerboard patterns) and solving for these parameters through optimization. In multi-camera setups, extrinsic calibrations between cameras must also be estimated to combine data consistently."),"\n",r.createElement(t.h3,{id:"distortion-models-radial-and-tangential-distortions-in-real-world-lenses",style:{position:"relative"}},r.createElement(t.a,{href:"#distortion-models-radial-and-tangential-distortions-in-real-world-lenses","aria-label":"distortion models radial and tangential distortions in real world lenses permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Distortion models: radial and tangential distortions in real-world lenses"),"\n",r.createElement(t.p,null,"Real lenses introduce distortions that deviate from the ideal pinhole model. Two common types:"),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Radial distortion"),": Arises because lens magnification changes with distance from the optical center. Straight lines in 3D might appear curved in the image. This is typically modeled with coefficients ",r.createElement(l.A,{text:"\\(k_1, k_2, k_3\\)"})," in polynomial expansions."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Tangential distortion"),": Occurs when the lens is not perfectly parallel to the imaging plane, modeled with parameters ",r.createElement(l.A,{text:"\\(p_1, p_2\\)"}),". These distortions shift the image points slightly in tangential directions, causing asymmetrical warping."),"\n"),"\n",r.createElement(t.p,null,"Correcting distortion is crucial for accurate geometric measurements from images, especially in robotics and 3D reconstruction tasks, where small calibration errors can lead to large reprojection errors in 3D."),"\n",r.createElement(t.hr),"\n",r.createElement(t.h2,{id:"6-representations-of-3d-data",style:{position:"relative"}},r.createElement(t.a,{href:"#6-representations-of-3d-data","aria-label":"6 representations of 3d data permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"6. Representations of 3D data"),"\n",r.createElement(t.p,null,"(This section somewhat overlaps with earlier content on point clouds, meshes, voxels. I will use this chapter to dive more deeply into the trade-offs and best use cases.)"),"\n",r.createElement(t.h3,{id:"point-clouds-advantages-and-limitations",style:{position:"relative"}},r.createElement(t.a,{href:"#point-clouds-advantages-and-limitations","aria-label":"point clouds advantages and limitations permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Point clouds: advantages and limitations"),"\n",r.createElement(t.p,null,"Point clouds represent a set of 3D points ",r.createElement(l.A,{text:"\\(\\{\\mathbf{p}_i\\}\\)"}),". As mentioned, they are easy to capture directly from LiDAR or structured-light sensors. They work well in real-time tasks where speed is paramount, such as collision detection or quick environment scanning. However, point clouds do not carry explicit connectivity or adjacency, and their sampling density can vary widely. This complicates computations that rely on surface normals or curvature. Researchers often approximate local geometry by building a neighborhood graph or using a K-d tree to locate nearest neighbors for each point."),"\n",r.createElement(t.h3,{id:"meshes-topological-structure-and-connectivity",style:{position:"relative"}},r.createElement(t.a,{href:"#meshes-topological-structure-and-connectivity","aria-label":"meshes topological structure and connectivity permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Meshes: topological structure and connectivity"),"\n",r.createElement(t.p,null,"Meshes remain the gold standard when we need a well-defined surface. For instance, many high-level operations — like texture mapping, advanced rendering, or finite element analysis — depend on a clean mesh. Nonetheless, generating a clean mesh from sensor data can be non-trivial. In advanced machine learning tasks (e.g., 3D shape generation or segmentation), specialized neural networks can output mesh vertices and faces directly, but this typically requires a more complex pipeline than point cloud or voxel-based methods."),"\n",r.createElement(t.h3,{id:"voxels-volumetric-representation-and-memory-efficiency",style:{position:"relative"}},r.createElement(t.a,{href:"#voxels-volumetric-representation-and-memory-efficiency","aria-label":"voxels volumetric representation and memory efficiency permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Voxels: volumetric representation and memory efficiency"),"\n",r.createElement(t.p,null,"Voxel grids have an intuitive analogy with images, enabling the use of 3D CNN architectures for tasks like 3D object classification or segmentation. However, naive voxelization at high resolution consumes enormous memory, limiting real-time use on large scenes or requiring coarse resolution that might lose detail. Techniques like octrees or hierarchical voxel grids mitigate memory use, storing finer resolution only where needed. If the data's bounding volume is known and not too large, voxels offer a straightforward solution."),"\n",r.createElement(t.h3,{id:"implicit-representations-signed-distance-functions-sdfs-and-neural-implicit-models",style:{position:"relative"}},r.createElement(t.a,{href:"#implicit-representations-signed-distance-functions-sdfs-and-neural-implicit-models","aria-label":"implicit representations signed distance functions sdfs and neural implicit models permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Implicit representations: signed distance functions (SDFs) and neural implicit models"),"\n",r.createElement(t.p,null,"One of the most revolutionary developments in recent years has been the use of neural networks to represent geometric shapes implicitly. For instance, a neural network ",r.createElement(l.A,{text:"\\(f_\\theta(\\mathbf{x})\\)"})," might take as input a 3D coordinate ",r.createElement(l.A,{text:"\\(\\mathbf{x}\\)"})," and output the signed distance to the shape surface. Wherever ",r.createElement(l.A,{text:"\\(f_\\theta(\\mathbf{x}) = 0\\)"}),", we are on the surface. This approach can achieve high fidelity reconstructions while using less memory than a dense voxel grid, because the function is parameterized by the network's weights, not by a discretized grid."),"\n",r.createElement(t.p,null,"Neural Radiance Fields (NeRF), while not exactly an SDF, is a closely related approach that encodes radiance and density in a neural network. It has shown remarkable results for novel view synthesis. The theme is consistent: an implicit neural representation can store a lot of shape and appearance information in a compact form, providing a continuous, high-resolution geometry that can be sampled at arbitrary points in space."),"\n",r.createElement(t.hr),"\n",r.createElement(t.h2,{id:"7-coordinate-systems-transformations-and-projections",style:{position:"relative"}},r.createElement(t.a,{href:"#7-coordinate-systems-transformations-and-projections","aria-label":"7 coordinate systems transformations and projections permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"7. Coordinate systems, transformations, and projections"),"\n",r.createElement(t.h3,{id:"cartesian-polar-and-spherical-coordinates-when-and-why-each-is-used",style:{position:"relative"}},r.createElement(t.a,{href:"#cartesian-polar-and-spherical-coordinates-when-and-why-each-is-used","aria-label":"cartesian polar and spherical coordinates when and why each is used permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Cartesian, polar, and spherical coordinates: when and why each is used"),"\n",r.createElement(t.p,null,"Different applications benefit from different coordinate systems:"),"\n",r.createElement(t.ol,null,"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Cartesian coordinates")," ",r.createElement(l.A,{text:"\\((x,y,z)\\)"}),": Straightforward and universal; used by default in many machine learning methods due to matrix-based linear algebra."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Polar (2D) or cylindrical (3D) coordinates")," ",r.createElement(l.A,{text:"\\((r, \\theta)\\)"})," or ",r.createElement(l.A,{text:"\\((r, \\theta, z)\\)"}),": Useful for rotationally symmetric situations or for analyzing radial features."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Spherical coordinates")," ",r.createElement(l.A,{text:"\\((\\rho, \\phi, \\theta)\\)"}),": Handy when dealing with all-round radial symmetries or spherical data (like geospatial or astronomy data)."),"\n"),"\n",r.createElement(t.p,null,"While transformations between these systems are standard, the choice of coordinate system can simplify or complicate computations. For instance, analyzing rings in a radial domain might be easier in polar or spherical coordinates, but typical ML frameworks expect Cartesian data arrays."),"\n",r.createElement(t.h3,{id:"homogeneous-coordinates-and-projective-transformations-their-applications-eg-camera-calibration",style:{position:"relative"}},r.createElement(t.a,{href:"#homogeneous-coordinates-and-projective-transformations-their-applications-eg-camera-calibration","aria-label":"homogeneous coordinates and projective transformations their applications eg camera calibration permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Homogeneous coordinates and projective transformations; their applications (e.g., camera calibration)"),"\n",r.createElement(t.p,null,r.createElement(o.A,null,"Homogeneous coordinates")," embed ",r.createElement(l.A,{text:"\\(\\mathbb{R}^n\\)"})," in ",r.createElement(l.A,{text:"\\(\\mathbb{R}^{n+1}\\)"}),", allowing translation to be expressed via matrix multiplication. A point ",r.createElement(l.A,{text:"\\(\\mathbf{x} \\in \\mathbb{R}^3\\)"})," is represented as ",r.createElement(l.A,{text:"\\((x, y, z, 1)\\)"})," in homogeneous form. This representation also paves the way for ",r.createElement(o.A,null,"projective transformations"),", which can model perspective effects, camera intrinsics, and other advanced transformations with a single ",r.createElement(l.A,{text:"\\(4 \\times 4\\)"})," matrix in 3D."),"\n",r.createElement(t.p,null,"Camera calibration heavily relies on homogeneous coordinates because it unifies rotation, translation, and projection into one linear framework. For instance, a point in world coordinates is multiplied by the extrinsic matrix (rotation + translation) to get the camera coordinate, then multiplied by the intrinsic matrix to map to the 2D image plane, all in a homogeneous formulation."),"\n",r.createElement(t.h3,{id:"projection-methods-orthographic-vs-perspective-impact-on-geometric-interpretation-in-vision-tasks",style:{position:"relative"}},r.createElement(t.a,{href:"#projection-methods-orthographic-vs-perspective-impact-on-geometric-interpretation-in-vision-tasks","aria-label":"projection methods orthographic vs perspective impact on geometric interpretation in vision tasks permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Projection methods (orthographic vs. perspective): impact on geometric interpretation in vision tasks"),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Orthographic projection")," assumes parallel projection rays, ignoring perspective foreshortening. It is simple but less realistic, and it's sometimes used for tasks that require a dimensionally consistent view (e.g., technical drawings or analyzing distant objects)."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Perspective projection")," is the real-world model where rays converge at the camera center. Objects further from the camera appear smaller. This is more accurate but also more complex to handle analytically."),"\n"),"\n",r.createElement(t.p,null,"In machine learning tasks, perspective projection is typically used when dealing with real image data or 3D reconstruction from cameras. Orthographic projection might be suitable for specialized tasks, such as medical imaging slices or certain engineering applications."),"\n",r.createElement(t.hr),"\n",r.createElement(t.h2,{id:"8-graph-representations-for-geometric-data",style:{position:"relative"}},r.createElement(t.a,{href:"#8-graph-representations-for-geometric-data","aria-label":"8 graph representations for geometric data permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"8. Graph representations for geometric data"),"\n",r.createElement(t.h3,{id:"graph-structures-for-representing-meshes-skeletons-and-connectivity-using-graphs-to-represent-relationships-among-points-or-mesh-vertices",style:{position:"relative"}},r.createElement(t.a,{href:"#graph-structures-for-representing-meshes-skeletons-and-connectivity-using-graphs-to-represent-relationships-among-points-or-mesh-vertices","aria-label":"graph structures for representing meshes skeletons and connectivity using graphs to represent relationships among points or mesh vertices permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Graph structures for representing meshes, skeletons, and connectivity; using graphs to represent relationships among points or mesh vertices"),"\n",r.createElement(t.p,null,"A mesh can be interpreted as a graph whose vertices are mesh points and whose edges represent adjacency. Beyond meshes, graphs are widely used to represent skeletons (e.g., for human pose estimation, connecting joints with edges) or even point clouds, by building a nearest-neighbor graph. This allows leveraging graph-based algorithms — like graph searches or shortest paths — and advanced spectral tools (e.g., the graph Laplacian)."),"\n",r.createElement(t.h3,{id:"adjacency-matrices-graph-laplacians-and-spectral-representations-capturing-local-and-global-structural-information",style:{position:"relative"}},r.createElement(t.a,{href:"#adjacency-matrices-graph-laplacians-and-spectral-representations-capturing-local-and-global-structural-information","aria-label":"adjacency matrices graph laplacians and spectral representations capturing local and global structural information permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Adjacency matrices, graph Laplacians, and spectral representations; capturing local and global structural information"),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Adjacency matrix ",r.createElement(l.A,{text:"\\(A\\)"})),": A square matrix where ",r.createElement(l.A,{text:"\\(A_{ij}=1\\)"})," if vertices ",r.createElement(l.A,{text:"\\(i\\)"})," and ",r.createElement(l.A,{text:"\\(j\\)"})," are connected, and 0 otherwise. This is a direct way to encode graph connectivity, but it can be memory heavy for large graphs."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Graph Laplacian ",r.createElement(l.A,{text:"\\(L\\)"})),": Defined as ",r.createElement(l.A,{text:"\\(D - A\\)"})," where ",r.createElement(l.A,{text:"\\(D\\)"})," is the diagonal degree matrix. The Laplacian's eigenvalues and eigenvectors reveal structural properties of the graph, like connected components or smoothness. In geometry processing, the Laplacian can approximate curvature on a mesh."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Spectral representations"),": Many algorithms exploit the eigen-decomposition of ",r.createElement(l.A,{text:"\\(L\\)"})," to define ",r.createElement(o.A,null,"spectral filtering")," or ",r.createElement(o.A,null,"spectral embeddings"),". For instance, in manifold learning, one might use the first few eigenvectors of ",r.createElement(l.A,{text:"\\(L\\)"})," to parameterize a manifold in a lower-dimensional space."),"\n"),"\n",r.createElement(t.h3,{id:"graph-based-learning-techniques-for-3d-object-recognition",style:{position:"relative"}},r.createElement(t.a,{href:"#graph-based-learning-techniques-for-3d-object-recognition","aria-label":"graph based learning techniques for 3d object recognition permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Graph-based learning techniques for 3D object recognition"),"\n",r.createElement(t.p,null,r.createElement(o.A,null,"Geometric deep learning")," has spawned a variety of graph neural network (GNN) architectures (e.g., Graph Convolutional Networks, Graph Attention Networks, MeshCNN). These methods propagate information along edges in the graph, allowing each vertex's representation to be updated based on its neighbors. For 3D object recognition, this can incorporate local geometric features while preserving global connectivity. In tasks like mesh segmentation, each face or vertex is classified into object parts by iteratively aggregating local context from neighbors in the graph."),"\n",r.createElement(t.h3,{id:"challenges-with-irregular-data-structures-and-strategies-to-address-them",style:{position:"relative"}},r.createElement(t.a,{href:"#challenges-with-irregular-data-structures-and-strategies-to-address-them","aria-label":"challenges with irregular data structures and strategies to address them permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Challenges with irregular data structures and strategies to address them"),"\n",r.createElement(t.p,null,"Unlike images (which are structured grids), meshes and point clouds yield ",r.createElement(o.A,null,"irregular data structures")," with no uniform connectivity. This complicates standard CNN-based approaches that rely on consistent 2D arrays. Researchers address these challenges by:"),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Graph-based layers")," that handle irregular neighborhoods explicitly."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Spatial partitioning")," like K-nearest neighbors or octrees to impose local organization."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Parameterization")," of surfaces onto planar patches (e.g., UV mapping) to enable partial 2D processing."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Mixed approaches")," that integrate point-based or voxel-based preprocessing, bridging the gap between structured and unstructured data."),"\n"),"\n",r.createElement(t.hr),"\n",r.createElement(t.h2,{id:"9-metrics-and-measurements-in-geometry",style:{position:"relative"}},r.createElement(t.a,{href:"#9-metrics-and-measurements-in-geometry","aria-label":"9 metrics and measurements in geometry permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"9. Metrics and measurements in geometry"),"\n",r.createElement(t.h3,{id:"distance-metrics-euclidean-geodesic-manhattan-mahalanobis-etc",style:{position:"relative"}},r.createElement(t.a,{href:"#distance-metrics-euclidean-geodesic-manhattan-mahalanobis-etc","aria-label":"distance metrics euclidean geodesic manhattan mahalanobis etc permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Distance metrics: Euclidean, geodesic, Manhattan, Mahalanobis, etc."),"\n",r.createElement(t.p,null,"Choosing an appropriate distance metric can drastically affect ML performance on geometric tasks:"),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Euclidean distance"),": The standard metric in ",r.createElement(l.A,{text:"\\(\\mathbb{R}^n\\)"}),". Computed as ",r.createElement(l.A,{text:"\\(\\sqrt{(x_1 - x_2)^2 + \\dots}\\)"}),"."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Manhattan distance"),": Sums absolute differences in coordinates. Sometimes used for grid-like data."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Mahalanobis distance"),": Incorporates covariance structure, making it more robust to correlated dimensions."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Geodesic distance"),": The shortest path on a manifold or surface. On a mesh, geodesic distance can be approximated by shortest paths in the graph sense. This matters if you want to measure surface-based distances instead of straight-line (through space) distances."),"\n"),"\n",r.createElement(t.h3,{id:"curvature-estimation-gaussian-mean-and-principal-curvature",style:{position:"relative"}},r.createElement(t.a,{href:"#curvature-estimation-gaussian-mean-and-principal-curvature","aria-label":"curvature estimation gaussian mean and principal curvature permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Curvature estimation: Gaussian, mean, and principal curvature"),"\n",r.createElement(t.p,null,"Curvature characterizes how a surface bends."),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Gaussian curvature")," is the product of the principal curvatures. It indicates how the surface bends in orthogonal directions."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Mean curvature")," is the average of the principal curvatures."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Principal curvatures")," are the eigenvalues of the shape operator, revealing maximum and minimum bending directions."),"\n"),"\n",r.createElement(t.p,null,"Accurately estimating curvature from discrete data (meshes, point clouds) can be challenging, requiring robust neighborhood fitting or specialized operators (e.g., discrete Laplacian operators)."),"\n",r.createElement(t.h3,{id:"area-volume-and-surface-integral-properties-in-discrete-geometric-representations-measuring-2d-and-3d-shapes-in-continuous-and-discrete-settings",style:{position:"relative"}},r.createElement(t.a,{href:"#area-volume-and-surface-integral-properties-in-discrete-geometric-representations-measuring-2d-and-3d-shapes-in-continuous-and-discrete-settings","aria-label":"area volume and surface integral properties in discrete geometric representations measuring 2d and 3d shapes in continuous and discrete settings permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Area, volume, and surface integral properties in discrete geometric representations; measuring 2D and 3D shapes in continuous and discrete settings"),"\n",r.createElement(t.p,null,"Measuring geometric properties like area or volume is straightforward in the continuous setting with integrals. Discretely, we approximate integrals by summing over polygonal faces or volumetric cells:"),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Polygonal mesh area"),": Sum the areas of all faces."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Volumetric grids"),": Count or sum the occupied voxels, multiplied by voxel volume."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Hybrid approaches"),": Use Monte Carlo integration methods where random points are sampled, and one checks whether they lie inside or outside the shape (often feasible in high dimensions)."),"\n"),"\n",r.createElement(t.p,null,"In real-world machine learning tasks — like medical image segmentation — computing organ volume from segmentation masks is exactly an area + slice thickness or voxel counting problem. Accuracy depends heavily on resolution and the fidelity of the segmentation."),"\n",r.createElement(t.hr),"\n",r.createElement(t.h2,{id:"10-geometry-estimation-techniques",style:{position:"relative"}},r.createElement(t.a,{href:"#10-geometry-estimation-techniques","aria-label":"10 geometry estimation techniques permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"10. Geometry estimation techniques"),"\n",r.createElement(t.h3,{id:"least-squares-methods-solving-overdetermined-systems-for-geometric-fitting-linear-and-non-linear-least-squares-for-fitting-geometric-models",style:{position:"relative"}},r.createElement(t.a,{href:"#least-squares-methods-solving-overdetermined-systems-for-geometric-fitting-linear-and-non-linear-least-squares-for-fitting-geometric-models","aria-label":"least squares methods solving overdetermined systems for geometric fitting linear and non linear least squares for fitting geometric models permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Least squares methods: solving overdetermined systems for geometric fitting; linear and non-linear least squares for fitting geometric models"),"\n",r.createElement(t.p,null,r.createElement(o.A,null,"Least squares")," is the fundamental technique for fitting a model to data by minimizing the sum of squared residuals. In geometry, one might fit a line, plane, circle, or polynomial surface to a set of points."),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,"A ",r.createElement(o.A,null,"linear least squares")," example is plane fitting: If you want a plane ",r.createElement(l.A,{text:"\\(ax + by + c = z\\)"}),", and you have points ",r.createElement(l.A,{text:"\\((x_i, y_i, z_i)\\)"}),", you can solve for ",r.createElement(l.A,{text:"\\(a, b, c\\)"})," by forming a design matrix and using normal equations or SVD."),"\n",r.createElement(t.li,null,r.createElement(o.A,null,"Non-linear least squares")," arises for fitting circles, spheres, or more complex surfaces. One typically uses iterative solvers (e.g., Gauss-Newton, Levenberg-Marquardt) to refine parameters."),"\n"),"\n",r.createElement(t.h3,{id:"iterative-approaches-icp-iterative-closest-point-for-shape-alignment",style:{position:"relative"}},r.createElement(t.a,{href:"#iterative-approaches-icp-iterative-closest-point-for-shape-alignment","aria-label":"iterative approaches icp iterative closest point for shape alignment permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Iterative approaches: ICP (Iterative Closest Point) for shape alignment"),"\n",r.createElement(t.p,null,"The ",r.createElement(o.A,null,"Iterative Closest Point (ICP)")," algorithm is a workhorse for aligning two shapes (often in point cloud form). The algorithm:"),"\n",r.createElement(t.ol,null,"\n",r.createElement(t.li,null,"Computes correspondences between points in the source and target sets (e.g., the closest points)."),"\n",r.createElement(t.li,null,"Estimates a transformation (rigid or affine) that minimizes distances between corresponding points."),"\n",r.createElement(t.li,null,"Applies the transformation to the source and repeats until convergence."),"\n"),"\n",r.createElement(t.p,null,"ICP can handle partial overlaps and noise but may converge to local minima if the initial alignment is too far off. Variants exist to speed up convergence or improve outlier resistance."),"\n",r.createElement(t.h3,{id:"analytical-solutions-vs-numerical-optimization-for-different-geometric-problems",style:{position:"relative"}},r.createElement(t.a,{href:"#analytical-solutions-vs-numerical-optimization-for-different-geometric-problems","aria-label":"analytical solutions vs numerical optimization for different geometric problems permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Analytical solutions vs. numerical optimization for different geometric problems"),"\n",r.createElement(t.p,null,"Some geometry estimation problems (e.g., a 2D line fit or a rigid alignment using SVD) have closed-form solutions. Others (e.g., multi-view reconstruction with bundle adjustment) require iterative optimization. Analytical solutions tend to be faster and are guaranteed to find the global optimum (if the assumptions hold). Numerical optimizations, while more flexible, may require careful initialization and can be prone to local minima."),"\n",r.createElement(t.h3,{id:"the-notion-of-fitting-geometric-primitives-lines-planes-circles-to-data",style:{position:"relative"}},r.createElement(t.a,{href:"#the-notion-of-fitting-geometric-primitives-lines-planes-circles-to-data","aria-label":"the notion of fitting geometric primitives lines planes circles to data permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"The notion of fitting geometric primitives (lines, planes, circles) to data"),"\n",r.createElement(t.p,null,"Fitting primitives is often the first step in a geometry pipeline — detecting lines in images, planes in point clouds, or circles in 2D data. This might be used for structural recognition in CAD models, urban scenes (walls, floors), or basic object detection (cylinders, spheres). Even deep learning pipelines can incorporate these modules: for instance, a network might segment a scene into planar regions, and then a geometric module fits planes to those regions."),"\n",r.createElement(t.h3,{id:"importance-of-noise-handling-and-outlier-robustness-in-geometric-tasks",style:{position:"relative"}},r.createElement(t.a,{href:"#importance-of-noise-handling-and-outlier-robustness-in-geometric-tasks","aria-label":"importance of noise handling and outlier robustness in geometric tasks permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Importance of noise handling and outlier robustness in geometric tasks"),"\n",r.createElement(t.p,null,"Real-world data invariably includes noise and outliers (e.g., spurious points from sensor artifacts). Traditional least squares is sensitive to outliers, leading to large errors in the final fit. Robust methods — like RANSAC — are often used to handle outliers by ignoring them in the fitting step. Another approach is to use robust cost functions (e.g., Huber loss) that reduce the influence of large residuals."),"\n",r.createElement(t.h3,{id:"trade-offs-between-computational-complexity-and-estimation-accuracy",style:{position:"relative"}},r.createElement(t.a,{href:"#trade-offs-between-computational-complexity-and-estimation-accuracy","aria-label":"trade offs between computational complexity and estimation accuracy permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Trade-offs between computational complexity and estimation accuracy"),"\n",r.createElement(t.p,null,"Accurate geometry estimation may require iterative methods that are computationally expensive. In time-critical applications (autonomous driving, robotics), real-time performance constraints can force simpler or approximate solutions. Hence, each domain balances speed, robustness, and accuracy according to its needs. For large-scale offline tasks (like building a 3D map from thousands of images), one might invest heavily in a large iterative optimization (e.g., bundle adjustment) to achieve high accuracy."),"\n",r.createElement(t.hr),"\n",r.createElement(t.h2,{id:"11-robust-estimation-techniques-ransac-and-variants",style:{position:"relative"}},r.createElement(t.a,{href:"#11-robust-estimation-techniques-ransac-and-variants","aria-label":"11 robust estimation techniques ransac and variants permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"11. Robust estimation techniques (RANSAC and variants)"),"\n",r.createElement(t.h3,{id:"robust-estimation-techniques-handling-noise-and-outliers",style:{position:"relative"}},r.createElement(t.a,{href:"#robust-estimation-techniques-handling-noise-and-outliers","aria-label":"robust estimation techniques handling noise and outliers permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Robust estimation techniques: handling noise and outliers"),"\n",r.createElement(t.p,null,"In geometric tasks, outliers can appear for many reasons — sensor dropouts, reflective surfaces, dynamic objects in the environment, or erroneous keypoint matches in images. ",r.createElement(o.A,null,"Robust estimation techniques")," aim to find model parameters that fit the majority of the data, ignoring outliers."),"\n",r.createElement(t.h3,{id:"ransac-random-sampling-to-find-inliers-in-noisy-data",style:{position:"relative"}},r.createElement(t.a,{href:"#ransac-random-sampling-to-find-inliers-in-noisy-data","aria-label":"ransac random sampling to find inliers in noisy data permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"RANSAC: random sampling to find inliers in noisy data"),"\n",r.createElement(t.p,null,r.createElement(o.A,null,"RANSAC")," (RANdom SAmple Consensus) is a classic algorithm:"),"\n",r.createElement(t.ol,null,"\n",r.createElement(t.li,null,"Randomly pick a minimal subset of points sufficient to fit the desired model (e.g., two points for a line, three points for a plane)."),"\n",r.createElement(t.li,null,"Estimate model parameters from this subset."),"\n",r.createElement(t.li,null,"Count how many points in the entire dataset fit this model within a threshold (the inliers)."),"\n",r.createElement(t.li,null,"Repeat many times; keep the model with the best inlier count."),"\n",r.createElement(t.li,null,"Optionally refine with a final least squares fit on all inliers."),"\n"),"\n",r.createElement(t.p,null,"RANSAC excels when the fraction of outliers is not too large and is widely used in computer vision tasks like homography estimation (for image stitching), fundamental matrix estimation (for stereo vision), or plane detection in point clouds."),"\n",r.createElement(t.h3,{id:"extensions-of-ransac-mlesac-msac-prosac-increasing-robustness-and-computational-efficiency",style:{position:"relative"}},r.createElement(t.a,{href:"#extensions-of-ransac-mlesac-msac-prosac-increasing-robustness-and-computational-efficiency","aria-label":"extensions of ransac mlesac msac prosac increasing robustness and computational efficiency permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Extensions of RANSAC (MLESAC, MSAC, PROSAC): increasing robustness and computational efficiency"),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"MLESAC"),": Uses a maximum-likelihood approach for scoring the fit, rather than a simple inlier count."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"MSAC"),": A modification that better penalizes outliers."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"PROSAC"),": Prioritized RANSAC uses prior probabilities for each data point's membership, sampling more likely inliers first to speed up convergence."),"\n"),"\n",r.createElement(t.p,null,"These extensions demonstrate how robust estimation has evolved to handle increasingly complex data distributions, large outlier rates, or real-time constraints."),"\n",r.createElement(t.h3,{id:"use-cases-in-computer-vision-homography-estimation-fundamental-matrix-estimation-and-more",style:{position:"relative"}},r.createElement(t.a,{href:"#use-cases-in-computer-vision-homography-estimation-fundamental-matrix-estimation-and-more","aria-label":"use cases in computer vision homography estimation fundamental matrix estimation and more permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Use cases in computer vision: homography estimation, fundamental matrix estimation, and more"),"\n",r.createElement(t.p,null,"RANSAC and its variants are essential in structure-from-motion and multi-view geometry. For example:"),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Homography estimation"),": If two images depict the same planar surface from different viewpoints, a homography transforms points from one image to the other. RANSAC can robustly find this transformation from matched keypoints (like SIFT or ORB features)."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Fundamental matrix estimation"),": In stereo vision or epipolar geometry, the fundamental matrix relates matched points in two images. Again, RANSAC helps separate inliers (correct matches) from outliers (mismatches)."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Pose estimation"),": Estimating camera pose from 3D-2D correspondences also benefits from robust sampling schemes."),"\n"),"\n",r.createElement(t.hr),"\n",r.createElement(t.h2,{id:"12-machine-learning-based-geometry-estimation",style:{position:"relative"}},r.createElement(t.a,{href:"#12-machine-learning-based-geometry-estimation","aria-label":"12 machine learning based geometry estimation permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"12. Machine learning-based geometry estimation"),"\n",r.createElement(t.h3,{id:"regression-models-for-geometric-predictions-predicting-2d3d-landmarks-or-transformations",style:{position:"relative"}},r.createElement(t.a,{href:"#regression-models-for-geometric-predictions-predicting-2d3d-landmarks-or-transformations","aria-label":"regression models for geometric predictions predicting 2d3d landmarks or transformations permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Regression models for geometric predictions; predicting 2D/3D landmarks or transformations"),"\n",r.createElement(t.p,null,"Sometimes geometry estimation can be framed as a direct regression problem: a neural network might predict the coordinates of facial landmarks, the 3D pose of an object, or the transformation parameters that align one shape to another. For instance, a network might output the Euler angles ",r.createElement(l.A,{text:"\\(\\alpha, \\beta, \\gamma\\)"})," for rotation and the translation ",r.createElement(l.A,{text:"\\(\\mathbf{t}\\)"})," in ",r.createElement(l.A,{text:"\\(\\mathbb{R}^3\\)"}),". The main challenge is dealing with the cyclical nature of angles (i.e., ",r.createElement(l.A,{text:"\\(\\alpha\\)"})," and ",r.createElement(l.A,{text:"\\(\\alpha + 2\\pi\\)"})," represent the same rotation) and ensuring the predicted transformations remain valid."),"\n",r.createElement(t.h3,{id:"deep-learning-based-estimators-learning-transformations-depth-pose-and-surface-normals",style:{position:"relative"}},r.createElement(t.a,{href:"#deep-learning-based-estimators-learning-transformations-depth-pose-and-surface-normals","aria-label":"deep learning based estimators learning transformations depth pose and surface normals permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Deep learning-based estimators: learning transformations, depth, pose and surface normals"),"\n",r.createElement(t.p,null,r.createElement(o.A,null,"Deep learning")," can go beyond standard regression by incorporating specialized layers or losses:"),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Depth estimation"),": Networks can learn to output a dense depth map for every pixel in an image, effectively performing geometry estimation from a single image or multiple views."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Pose estimation"),": In object or camera pose estimation, architectures combine convolutional layers for feature extraction with fully connected layers (or specialized transformations) for predicting 6-DoF pose."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Surface normals"),": Another key geometric attribute for each pixel or point can be learned directly by a network. This is relevant in tasks like photometric stereo or shape-from-shading."),"\n"),"\n",r.createElement(t.h3,{id:"loss-functions-tailored-to-geometric-data-chamfer-distance-earth-movers-distance",style:{position:"relative"}},r.createElement(t.a,{href:"#loss-functions-tailored-to-geometric-data-chamfer-distance-earth-movers-distance","aria-label":"loss functions tailored to geometric data chamfer distance earth movers distance permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Loss functions tailored to geometric data: Chamfer distance, Earth Mover's Distance"),"\n",r.createElement(t.p,null,"Standard L2 or L1 losses might not fully capture the geometry between shapes or point sets. Specialized distances are used:"),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Chamfer distance"),": For two point sets ",r.createElement(l.A,{text:"\\(P\\)"})," and ",r.createElement(l.A,{text:"\\(Q\\)"}),", the Chamfer distance sums the distance from each point in ",r.createElement(l.A,{text:"\\(P\\)"})," to its nearest neighbor in ",r.createElement(l.A,{text:"\\(Q\\)"})," and vice versa."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Earth Mover's Distance (EMD)"),": Interprets point sets as distributions, measuring the minimal cost of transporting mass from one distribution to match the other. Often yields better shape alignment but is more expensive to compute."),"\n"),"\n",r.createElement(l.A,{text:"\\[\n\\text{Chamfer}(P, Q) = \\sum_{\\mathbf{p} \\in P} \\min_{\\mathbf{q} \\in Q} \\|\\mathbf{p} - \\mathbf{q}\\|^2 + \\sum_{\\mathbf{q} \\in Q} \\min_{\\mathbf{p} \\in P} \\|\\mathbf{p} - \\mathbf{q}\\|^2\n\\]"}),"\n",r.createElement(t.p,null,"EMD can be expressed via an optimal matching problem between points in ",r.createElement(l.A,{text:"\\(P\\)"})," and ",r.createElement(l.A,{text:"\\(Q\\)"}),"."),"\n",r.createElement(t.h3,{id:"role-of-regularization-and-loss-functions-tailored-to-geometric-constraints",style:{position:"relative"}},r.createElement(t.a,{href:"#role-of-regularization-and-loss-functions-tailored-to-geometric-constraints","aria-label":"role of regularization and loss functions tailored to geometric constraints permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Role of regularization and loss functions tailored to geometric constraints"),"\n",r.createElement(t.p,null,"In geometry estimation, we often want to enforce constraints like smoothness, symmetry, or manifold continuity. ",r.createElement(o.A,null,"Regularization")," terms in the loss function can encode these priors. For instance, a shape reconstruction network might incorporate a Laplacian smoothness term on a mesh to discourage spiky edges, or a normal consistency term to maintain consistent surfaces. These constraints lead to more physically or geometrically plausible outputs, especially when the training data is noisy or incomplete."),"\n",r.createElement(t.hr),"\n",r.createElement(t.h2,{id:"13-evaluation-metrics-for-geometry-estimation",style:{position:"relative"}},r.createElement(t.a,{href:"#13-evaluation-metrics-for-geometry-estimation","aria-label":"13 evaluation metrics for geometry estimation permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"13. Evaluation metrics for geometry estimation"),"\n",r.createElement(t.h3,{id:"mean-squared-error-mse-in-geometric-contexts-pros-and-cons-in-geometric-settings",style:{position:"relative"}},r.createElement(t.a,{href:"#mean-squared-error-mse-in-geometric-contexts-pros-and-cons-in-geometric-settings","aria-label":"mean squared error mse in geometric contexts pros and cons in geometric settings permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Mean squared error (MSE) in geometric contexts; pros and cons in geometric settings"),"\n",r.createElement(t.p,null,r.createElement(o.A,null,"MSE")," is the simplest metric to measure the average squared difference between predicted coordinates and ground-truth coordinates. While easy to compute and interpret, it does not always reflect perceptual or geometric fidelity, especially if shapes are misaligned or topologically different. MSE also heavily penalizes outliers, which might not be desired in certain tasks."),"\n",r.createElement(t.h3,{id:"chamfer-distance-measuring-point-cloud-similarity-measuring-shape-similarity-for-point-clouds-or-meshes",style:{position:"relative"}},r.createElement(t.a,{href:"#chamfer-distance-measuring-point-cloud-similarity-measuring-shape-similarity-for-point-clouds-or-meshes","aria-label":"chamfer distance measuring point cloud similarity measuring shape similarity for point clouds or meshes permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Chamfer distance: measuring point cloud similarity; measuring shape similarity for point clouds or meshes"),"\n",r.createElement(t.p,null,"As introduced, the ",r.createElement(o.A,null,"Chamfer distance")," is a popular metric for shape comparison. It's relatively straightforward to compute but can sometimes fail to capture fine-grained differences in shape distribution if points are scattered. Still, for many point-based reconstruction tasks, Chamfer distance provides a robust measure that aligns well with the geometry of the data."),"\n",r.createElement(t.h3,{id:"earth-movers-distance-emd-comparing-3d-distributions-a-more-precise-metric-for-matching-distributions-of-points",style:{position:"relative"}},r.createElement(t.a,{href:"#earth-movers-distance-emd-comparing-3d-distributions-a-more-precise-metric-for-matching-distributions-of-points","aria-label":"earth movers distance emd comparing 3d distributions a more precise metric for matching distributions of points permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Earth Mover's Distance (EMD): comparing 3D distributions; a more precise metric for matching distributions of points"),"\n",r.createElement(t.p,null,r.createElement(o.A,null,"EMD")," is a more accurate reflection of how one shape can be transformed into another by a transport plan. It typically yields better alignment than Chamfer distance, but the linear assignment or flow optimization can be expensive for large point sets. Nevertheless, EMD is often considered superior for tasks where we truly care about point-to-point correspondences and distribution shapes."),"\n",r.createElement(t.hr),"\n",r.createElement(t.h2,{id:"14-introduction-to-stereo-vision",style:{position:"relative"}},r.createElement(t.a,{href:"#14-introduction-to-stereo-vision","aria-label":"14 introduction to stereo vision permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"14. Introduction to stereo vision"),"\n",r.createElement(t.h3,{id:"binocular-vision-fundamentals-of-disparity-and-depth-perception",style:{position:"relative"}},r.createElement(t.a,{href:"#binocular-vision-fundamentals-of-disparity-and-depth-perception","aria-label":"binocular vision fundamentals of disparity and depth perception permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Binocular vision: fundamentals of disparity and depth perception"),"\n",r.createElement(t.p,null,r.createElement(o.A,null,"Stereo vision")," mimics human binocular vision. By observing the same scene from two slightly different viewpoints, we can recover depth information from the ",r.createElement(o.A,null,"disparity")," of corresponding points in the two images. Disparity is inversely related to depth — the larger the shift between matching pixels, the closer the object."),"\n",r.createElement(t.h3,{id:"epipolar-geometry-fundamental-matrix-essential-matrix-and-rectification",style:{position:"relative"}},r.createElement(t.a,{href:"#epipolar-geometry-fundamental-matrix-essential-matrix-and-rectification","aria-label":"epipolar geometry fundamental matrix essential matrix and rectification permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Epipolar geometry: fundamental matrix, essential matrix, and rectification"),"\n",r.createElement(t.p,null,r.createElement(o.A,null,"Epipolar geometry")," underlies stereo vision. For a pair of cameras, each point in 3D space projects to two points on the image planes. The lines connecting these projections with the camera centers intersect in the epipoles. The fundamental matrix ",r.createElement(l.A,{text:"\\(F\\)"})," encapsulates the relationship between matched points ",r.createElement(l.A,{text:"\\((x_1, x_2)\\)"})," in the two images:"),"\n",r.createElement(l.A,{text:"\\[\nx_2^T F \\, x_1 = 0.\n\\]"}),"\n",r.createElement(t.p,null,"For calibrated cameras (with known intrinsics), we use the essential matrix ",r.createElement(l.A,{text:"\\(E\\)"})," instead, which is related to ",r.createElement(l.A,{text:"\\(F\\)"})," by the intrinsics. ",r.createElement(o.A,null,"Rectification")," reprojects the images so that epipolar lines align horizontally, making stereo matching simpler."),"\n",r.createElement(t.h3,{id:"stereo-matching-algorithms-traditional-and-learning-based-approaches",style:{position:"relative"}},r.createElement(t.a,{href:"#stereo-matching-algorithms-traditional-and-learning-based-approaches","aria-label":"stereo matching algorithms traditional and learning based approaches permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Stereo matching algorithms: traditional and learning-based approaches"),"\n",r.createElement(t.p,null,"Traditional stereo matching involves:"),"\n",r.createElement(t.ol,null,"\n",r.createElement(t.li,null,"Computing a cost function (e.g., sum of absolute differences in a window around each pixel)."),"\n",r.createElement(t.li,null,"Searching for the best matching point in the other image along the epipolar line."),"\n",r.createElement(t.li,null,"Optionally using global optimization to ensure smoothness."),"\n"),"\n",r.createElement(t.p,null,"Deep learning has transformed stereo matching by using CNNs or GNNs to compute matching costs at each pixel, leading to more robust and accurate disparity maps. Some architectures (e.g., GCNet, PSMNet) incorporate 3D convolution on the cost volume, capturing global context. More recent methods integrate attention mechanisms or end-to-end learning with robust outlier handling."),"\n",r.createElement(t.hr),"\n",r.createElement(t.h2,{id:"15-geometric-feature-learning",style:{position:"relative"}},r.createElement(t.a,{href:"#15-geometric-feature-learning","aria-label":"15 geometric feature learning permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"15. Geometric feature learning"),"\n",r.createElement(t.h3,{id:"definition-of-geometric-features-curvature-based-descriptors-shape-contexts-keypoints",style:{position:"relative"}},r.createElement(t.a,{href:"#definition-of-geometric-features-curvature-based-descriptors-shape-contexts-keypoints","aria-label":"definition of geometric features curvature based descriptors shape contexts keypoints permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Definition of geometric features: curvature-based descriptors, shape contexts, keypoints"),"\n",r.createElement(t.p,null,r.createElement(o.A,null,"Geometric features")," capture local or global shape attributes that remain relatively invariant under transformations. Examples include:"),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Curvature-based descriptors"),": For surfaces, local curvature at each vertex or point can characterize shape bending."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Shape contexts"),": A 2D or 3D histogram that captures how neighboring points are distributed around a reference point, used for shape matching."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Keypoints"),": Distinctive points that are repeatably detectable (e.g., corners or high-curvature regions). 3D keypoints can be used like SIFT in 2D images for establishing correspondences."),"\n"),"\n",r.createElement(t.h3,{id:"hand-crafted-vs-learned-features-advantages-limitations-and-historical-evolution",style:{position:"relative"}},r.createElement(t.a,{href:"#hand-crafted-vs-learned-features-advantages-limitations-and-historical-evolution","aria-label":"hand crafted vs learned features advantages limitations and historical evolution permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Hand-crafted vs. learned features: advantages, limitations, and historical evolution"),"\n",r.createElement(t.p,null,"Historically, geometric features (e.g., SIFT-3D, curvature histograms) were ",r.createElement(o.A,null,"hand-crafted")," by domain experts. They often performed well in carefully controlled applications but lacked adaptability. The modern trend is to learn features from data with deep networks (e.g., PointNet++). Learned features typically outperform hand-crafted ones in large-scale tasks, but they require big labeled datasets and careful architecture design to capture geometric invariances."),"\n",r.createElement(t.h3,{id:"common-applications-of-geometric-features-object-recognition-matching-and-registration",style:{position:"relative"}},r.createElement(t.a,{href:"#common-applications-of-geometric-features-object-recognition-matching-and-registration","aria-label":"common applications of geometric features object recognition matching and registration permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Common applications of geometric features: object recognition, matching, and registration"),"\n",r.createElement(t.p,null,"By capturing shape-specific signatures, geometric features enable:"),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Recognition"),": Distinguish objects by their geometry, even under occlusion or partial views."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Matching"),": Align different scans of the same object or scene by matching local keypoints."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Registration"),": Combine partial scans or multi-view images into a coherent 3D model via geometric correspondences."),"\n"),"\n",r.createElement(t.h3,{id:"benefits-of-learning-geometric-features",style:{position:"relative"}},r.createElement(t.a,{href:"#benefits-of-learning-geometric-features","aria-label":"benefits of learning geometric features permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Benefits of learning geometric features"),"\n",r.createElement(t.p,null,"Networks trained on 3D data can learn robust, discriminative representations that handle variations in sampling, noise, or partial visibility. They can also combine geometry with color or texture if available (multimodal). This synergy often leads to more robust performance across diverse tasks in robotics, AR/VR, and object recognition."),"\n",r.createElement(t.h3,{id:"overview-of-feature-extraction-methods",style:{position:"relative"}},r.createElement(t.a,{href:"#overview-of-feature-extraction-methods","aria-label":"overview of feature extraction methods permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Overview of feature extraction methods"),"\n",r.createElement(t.p,null,"Modern ",r.createElement(o.A,null,"feature extraction")," can be as simple as applying a point-based network (like PointNet) to each local patch or as elaborate as constructing a graph-based approach that propagates contextual features across vertices or edges. Mesh-based CNNs can define convolution operators over the mesh faces, while voxel-based methods can apply standard 3D convolutions. The choice depends on the nature of the input data, the desired computational efficiency, and the end task."),"\n",r.createElement(t.hr),"\n",r.createElement(t.h1,{id:"extra-notes-and-recommended-reading",style:{position:"relative"}},r.createElement(t.a,{href:"#extra-notes-and-recommended-reading","aria-label":"extra notes and recommended reading permalink",className:"anchor before"},r.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Extra notes and recommended reading"),"\n",r.createElement(t.p,null,"Below, I list some further reading suggestions and references for those who want to dive deeper into cutting-edge research on geometry estimation in ML and computer vision:"),"\n",r.createElement(t.ul,null,"\n",r.createElement(t.li,null,r.createElement(t.strong,null,'Hartley and Zisserman ("Multiple View Geometry in Computer Vision")'),". This classic text formalizes epipolar geometry, camera calibration, and 3D reconstruction from images."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,"Besl and McKay (1992)"),'. The original ICP paper, titled "A Method for Registration of 3-D Shapes".'),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,'Zachary Teed and Jia Deng, "DeepV2D" (ICCV 2019)'),". Demonstrates learning-based stereo (and multi-view) depth estimation with deep networks."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,'Qi and gang, "PointNet" (CVPR 2017) and "PointNet++" (NeurIPS 2017)'),". Seminal works for deep learning directly on point clouds."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,'Mescheder and gang, "Occupancy Networks" (CVPR 2019)')," and ",r.createElement(t.strong,null,'Park and gang, "DeepSDF" (CVPR 2019)'),". Key references for implicit neural representations."),"\n",r.createElement(t.li,null,r.createElement(t.strong,null,'Mildenhall and gang, "NeRF" (ECCV 2020)'),". Landmark paper for neural radiance fields, bridging geometry and view synthesis."),"\n"),"\n",r.createElement(t.p,null,r.createElement(o.A,null,"I hope this first part of our exploration into geometry estimation sets the stage for deeper dives into 3D reconstruction, motion estimation, photogrammetry, and advanced geometric deep learning techniques.")," Throughout this article, I've tried to highlight both the historical roots and the modern frontiers of geometry in machine learning. As the field progresses, geometric insights will likely remain central to bridging the gap between raw sensor data and rich, structured understandings of the 3D world."),"\n",r.createElement(n,{alt:"3D point cloud example",path:"",caption:"An example of a 3D point cloud representation of an object, showing unstructured points in space",zoom:"false"}),"\n",r.createElement(n,{alt:"Mesh representation",path:"",caption:"A mesh representation of the same object, illustrating vertices, edges, and faces",zoom:"false"}),"\n",r.createElement(n,{alt:"Camera model diagram",path:"",caption:"A pinhole camera model showing how 3D points are projected onto a 2D image plane",zoom:"false"}),"\n",r.createElement(n,{alt:"Stereo vision setup",path:"",caption:"A simplified stereo vision setup with two cameras capturing a scene from slightly different viewpoints",zoom:"false"}),"\n",r.createElement(n,{alt:"Geometric transformations",path:"",caption:"Visual depiction of transformations like rotation, translation, and scaling applied to a shape",zoom:"false"}),"\n",r.createElement(t.p,null,"Such illustrations and the above text together create a more intuitive comprehension of the fundamental geometric principles that underpin many advanced machine learning applications."))}var m=function(e){void 0===e&&(e={});const{wrapper:t}=Object.assign({},(0,i.RP)(),e.components);return t?r.createElement(t,e,r.createElement(c,e)):c(e)};var h=n(36710),d=n(58481),p=n.n(d),u=n(36310),g=n(87245),f=n(27042),v=n(59849),y=n(5591),b=n(61122),E=n(9219),w=n(33203),S=n(95751),x=n(94328),H=n(80791),k=n(78137);const A=e=>{let{toc:t}=e;if(!t||!t.items)return null;return r.createElement("nav",{className:H.R},r.createElement("ul",null,t.items.map(((e,t)=>r.createElement("li",{key:t},r.createElement("a",{href:e.url,onClick:t=>((e,t)=>{e.preventDefault();const n=t.replace("#",""),a=document.getElementById(n);a&&a.scrollIntoView({behavior:"smooth",block:"start"})})(t,e.url)},e.title),e.items&&r.createElement(A,{toc:{items:e.items}}))))))};function C(e){let{data:{mdx:t,allMdx:o,allPostImages:s},children:l}=e;const{frontmatter:c,body:m,tableOfContents:h}=t,d=c.index,v=c.slug.split("/")[1],H=o.nodes.filter((e=>e.frontmatter.slug.includes(`/${v}/`))).sort(((e,t)=>e.frontmatter.index-t.frontmatter.index)),C=H.findIndex((e=>e.frontmatter.index===d)),M=H[C+1],z=H[C-1],_=c.slug.replace(/\/$/,""),V=/[^/]*$/.exec(_)[0],T=`posts/${v}/content/${V}/`,{0:D,1:I}=(0,r.useState)(c.flagWideLayoutByDefault),{0:N,1:L}=(0,r.useState)(!1);var j;(0,r.useEffect)((()=>{L(!0);const e=setTimeout((()=>L(!1)),340);return()=>clearTimeout(e)}),[D]),"adventures"===v?j=E.cb:"research"===v?j=E.Qh:"thoughts"===v&&(j=E.T6);const R=p()(m).replace(/import .*? from .*?;/g,"").replace(/<.*?>/g,"").replace(/\{\/\*[\s\S]*?\*\/\}/g,"").trim().split(/\s+/).length,B=function(e){if(e<=10)return"~10 min";if(e<=20)return"~20 min";if(e<=30)return"~30 min";if(e<=40)return"~40 min";if(e<=50)return"~50 min";if(e<=60)return"~1 h";const t=Math.floor(e/60),n=e%60;return n<=30?`~${t}${n>0?".5":""} h`:`~${t+1} h`}(Math.ceil(R/j)+(c.extraReadTimeMin||0)),P=[{flag:c.flagDraft,component:()=>Promise.all([n.e(3231),n.e(8809)]).then(n.bind(n,28809))},{flag:c.flagMindfuckery,component:()=>Promise.all([n.e(3231),n.e(2471)]).then(n.bind(n,67709))},{flag:c.flagRewrite,component:()=>Promise.all([n.e(3231),n.e(6764)]).then(n.bind(n,62002))},{flag:c.flagOffensive,component:()=>Promise.all([n.e(3231),n.e(2443)]).then(n.bind(n,17681))},{flag:c.flagProfane,component:()=>Promise.all([n.e(3231),n.e(8048)]).then(n.bind(n,53286))},{flag:c.flagMultilingual,component:()=>Promise.all([n.e(3231),n.e(4069)]).then(n.bind(n,78831))},{flag:c.flagUnreliably,component:()=>Promise.all([n.e(3231),n.e(3417)]).then(n.bind(n,8179))},{flag:c.flagPolitical,component:()=>Promise.all([n.e(3231),n.e(5195)]).then(n.bind(n,30433))},{flag:c.flagCognitohazard,component:()=>Promise.all([n.e(3231),n.e(3175)]).then(n.bind(n,8413))},{flag:c.flagHidden,component:()=>Promise.all([n.e(3231),n.e(9556)]).then(n.bind(n,14794))}],{0:q,1:F}=(0,r.useState)([]);return(0,r.useEffect)((()=>{P.forEach((e=>{let{flag:t,component:n}=e;t&&n().then((e=>{F((t=>[].concat((0,a.A)(t),[e.default])))}))}))}),[]),r.createElement(f.P.div,{initial:{opacity:0},animate:{opacity:1},exit:{opacity:0},transition:{duration:.15}},r.createElement(y.A,{postNumber:c.index,date:c.date,updated:c.updated,readTime:B,difficulty:c.difficultyLevel,title:c.title,desc:c.desc,banner:c.banner,section:v,postKey:V,isMindfuckery:c.flagMindfuckery,mainTag:c.mainTag}),r.createElement("div",{style:{display:"flex",justifyContent:"flex-end",flexWrap:"wrap",maxWidth:"75%",marginLeft:"auto",paddingRight:"1vw",marginTop:"-6vh",marginBottom:"4vh"}},c.otherTags.map(((e,t)=>r.createElement("span",{key:t,className:`noselect ${k.MW}`,style:{margin:"0 5px 5px 0"}},e)))),r.createElement("div",{class:"postBody"},r.createElement(A,{toc:h})),r.createElement("br"),r.createElement("div",{style:{margin:"0 10% -2vh 30%",textAlign:"right"}},r.createElement(f.P.button,{class:"noselect",className:x.pb,id:x.xG,onClick:()=>{I(!D)},whileTap:{scale:.93}},r.createElement(f.P.div,{className:S.DJ,key:D,initial:{opacity:0},animate:{opacity:1},exit:{opacity:0},transition:{duration:.3,ease:"easeInOut"}},D?"Switch to default layout":"Switch to wide layout"))),r.createElement("br"),r.createElement("div",{class:"postBody",style:{margin:D?"0 -14%":"",maxWidth:D?"200%":"",transition:"margin 1s ease, max-width 1s ease, padding 1s ease"}},r.createElement("div",{className:`${x.P_} ${N?x.Xn:x.qG}`},q.map(((e,t)=>r.createElement(e,{key:t}))),c.indexCourse?r.createElement(w.A,{index:c.indexCourse,category:c.courseCategoryName}):"",r.createElement(u.Z.Provider,{value:{images:s.nodes,basePath:T.replace(/\/$/,"")+"/"}},r.createElement(i.xA,{components:{Image:g.A}},l)))),r.createElement(b.A,{nextPost:M,lastPost:z,keyCurrent:V,section:v}))}function M(e){return r.createElement(C,e,r.createElement(m,e))}function z(e){var t,n,a,i,o;let{data:s}=e;const{frontmatter:l}=s.mdx,c=l.titleSEO||l.title,m=l.titleOG||c,d=l.titleTwitter||c,p=l.descSEO||l.desc,u=l.descOG||p,g=l.descTwitter||p,f=l.schemaType||"BlogPosting",y=l.keywordsSEO,b=l.date,E=l.updated||b,w=l.imageOG||(null===(t=l.banner)||void 0===t||null===(n=t.childImageSharp)||void 0===n||null===(a=n.gatsbyImageData)||void 0===a||null===(i=a.images)||void 0===i||null===(o=i.fallback)||void 0===o?void 0:o.src),S=l.imageAltOG||u,x=l.imageTwitter||w,H=l.imageAltTwitter||g,k=l.canonicalURL,A=l.flagHidden||!1,C=l.mainTag||"Posts",M=l.slug.split("/")[1]||"posts",{siteUrl:z}=(0,h.Q)(),_={"@context":"https://schema.org","@type":"BreadcrumbList",itemListElement:[{"@type":"ListItem",position:1,name:"Home",item:z},{"@type":"ListItem",position:2,name:C,item:`${z}/${l.slug.split("/")[1]}`},{"@type":"ListItem",position:3,name:c,item:`${z}${l.slug}`}]};return r.createElement(v.A,{title:c+" - avrtt.blog",titleOG:m,titleTwitter:d,description:p,descriptionOG:u,descriptionTwitter:g,schemaType:f,keywords:y,datePublished:b,dateModified:E,imageOG:w,imageAltOG:S,imageTwitter:x,imageAltTwitter:H,canonicalUrl:k,flagHidden:A,mainTag:C,section:M,type:"article"},r.createElement("script",{type:"application/ld+json"},JSON.stringify(_)))}},96098:function(e,t,n){var a=n(96540),i=n(7978);t.A=e=>{let{text:t}=e;return a.createElement(i.A,null,t)}}}]);
//# sourceMappingURL=component---src-templates-post-js-content-file-path-src-pages-posts-research-geometry-estimation-mdx-8b3373e3f1100210c7f2.js.map