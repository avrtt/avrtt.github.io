"use strict";(self.webpackChunkavrtt_blog=self.webpackChunkavrtt_blog||[]).push([[475],{57510:function(e,n,t){t.r(n),t.d(n,{Head:function(){return T},PostTemplate:function(){return H},default:function(){return I}});var a=t(28453),r=t(96540),i=t(61992),l=t(62087),o=t(90548);function s(e){const n=Object.assign({p:"p",h3:"h3",a:"a",span:"span",ol:"ol",li:"li",h4:"h4",ul:"ul",br:"br",strong:"strong"},(0,a.RP)(),e.components);return r.createElement(r.Fragment,null,"\n",r.createElement("br"),"\n","\n",r.createElement(n.p,null,"Retrieval-Augmented Generation (RAG) has emerged as one of the most compelling strategies for enhancing the factual grounding and contextual relevance of large language models (LLMs). The rapid growth in the capabilities of LLMs—such as GPT-based models, BERT derivatives, and other transformer-based architectures—has spurred research into strategies that leverage external knowledge sources. RAG is at the forefront of these efforts. By combining information retrieval with generative modeling, RAG can draw upon an external corpus (e.g., a vector database, knowledge graph, or curated document store) to supplement an LLM's internal learned representation. Hence, RAG helps LLMs produce answers that are not only fluent, coherent, and contextually holistic, but also significantly more factual and grounded in the latest knowledge."),"\n",r.createElement(n.p,null,"In this article, I will explore the theoretical foundations of RAG, dive into the architectural components that constitute RAG-based pipelines, demonstrate step-by-step implementations (including various advanced techniques), discuss relevant open-source frameworks and state-of-the-art research, and compare RAG to other common approaches such as fine-tuning or knowledge distillation. My goal is to give you an in-depth, PhD-level understanding of RAG, covering everything from embedding-based retrieval algorithms to orchestrating multi-step interactions with large language models."),"\n",r.createElement(n.p,null,"The core principle behind RAG is straightforward in theory: a large language model directly leverages external documents or data for context, instead of relying solely on the capacity of its internal parameters. But the actual implementation details can be quite intricate and require a deep understanding of vector databases, indexing, approximate nearest neighbor (ANN) search, chunking or segmentation of documents, and real-time orchestration with generative models."),"\n",r.createElement(n.p,null,"Throughout this article, I will approach RAG from both theoretical and practical angles. On the theoretical side, I will examine how similarity measures in embedding spaces connect to the idea of retrieving semantically relevant pieces of information for the generative model. On the practical side, I will show typical code snippets in Python, referencing popular libraries and frameworks that implement RAG pipelines. I will also introduce advanced strategies like multi-query retrieval, memory augmentation, and specialized re-ranking methods, as well as discuss the potential pitfalls (e.g., hallucinations, mismatch in domain-specific embeddings, privacy or latency constraints) and how to mitigate them."),"\n",r.createElement(n.h3,{id:"background-and-context",style:{position:"relative"}},r.createElement(n.a,{href:"#background-and-context","aria-label":"background and context permalink",className:"anchor before"},r.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Background And Context"),"\n",r.createElement(n.p,null,"Before diving deeper, let me contextualize RAG's origins. Patrick Lewis and gang (2020) introduced the concept of retrieval-augmented generation to tackle knowledge-intensive NLP tasks. Their paper demonstrated that bridging retrieval techniques with generative models can outperform purely parametric approaches, including fully fine-tuned BERT and GPT variations, when the tasks demand factual accuracy and context. Since then, many follow-up works have expanded on RAG, exploring topics such as knowledge-grounded question answering, open-domain dialogue generation, or multi-turn reasoning."),"\n",r.createElement(n.p,null,"The principle of RAG can be summarized as follows:"),"\n",r.createElement(n.ol,null,"\n",r.createElement(n.li,null,"User issues a query or prompt."),"\n",r.createElement(n.li,null,"The system converts this query into an embedding using a dedicated or pretrained encoder."),"\n",r.createElement(n.li,null,"A retrieval component (often an approximate nearest neighbor system) searches for relevant documents, text chunks, or knowledge items based on similarity to the query embedding."),"\n",r.createElement(n.li,null,"The top-k retrieved items are appended (or fed in as separate structured context) to the prompt or model input."),"\n",r.createElement(n.li,null,"The generative language model draws on both the provided context and its learned knowledge to generate a coherent answer."),"\n"),"\n",r.createElement(n.p,null,"By reusing or updating the external knowledge source, the system retains continuous access to new or changing information, which significantly reduces the need for frequent re-training or fine-tuning. This property is immensely beneficial in dynamic domains—like finance, e-commerce, news monitoring, or corporate knowledge bases—where the underlying information can change rapidly."),"\n",r.createElement(n.h3,{id:"theoretical-foundation-of-retrieval-augmented-generation",style:{position:"relative"}},r.createElement(n.a,{href:"#theoretical-foundation-of-retrieval-augmented-generation","aria-label":"theoretical foundation of retrieval augmented generation permalink",className:"anchor before"},r.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Theoretical Foundation Of Retrieval-Augmented Generation"),"\n",r.createElement(n.h4,{id:"linking-retrieval-and-generation",style:{position:"relative"}},r.createElement(n.a,{href:"#linking-retrieval-and-generation","aria-label":"linking retrieval and generation permalink",className:"anchor before"},r.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Linking Retrieval And Generation"),"\n",r.createElement(n.p,null,"RAG's theoretical structure hinges on the composition of two principal modules: a retriever ",r.createElement(o.A,{text:"\\( R \\)"})," and a generator ",r.createElement(o.A,{text:"\\( G \\)"}),". Formally, let ",r.createElement(o.A,{text:"\\( q \\)"})," be the user query. The retriever ",r.createElement(o.A,{text:"\\( R(q) \\)"})," produces a set of relevant documents or passages ",r.createElement(o.A,{text:"\\( \\{d_1, d_2, ..., d_k\\} \\)"}),". The generator ",r.createElement(o.A,{text:"\\( G(q, \\{d_i\\}) \\)"})," is then tasked with producing a response ",r.createElement(o.A,{text:"\\( a \\)"}),". Thus, we can define the process as:"),"\n",r.createElement(o.A,{text:"\\[\na = \\arg\\max_{a} p_G(a \\mid q, d_1, d_2, \\ldots, d_k)\n\\]"}),"\n",r.createElement(n.p,null,"Here, ",r.createElement(o.A,{text:"\\( p_G \\)"})," indicates the probability distribution induced by the generative model."),"\n",r.createElement(n.p,null,"The retrieved documents ",r.createElement(o.A,{text:"\\( \\{d_i\\} \\)"})," constitute external knowledge that augments the internal representation of the language model's parameters. Conceptually, best results arise when the retrieval subsystem is tightly coupled to the generative subsystem, such that the retrieved knowledge directly supports the generation process (Lewis and gang, 2020)."),"\n",r.createElement(n.h4,{id:"embedding-space-and-similarity-metrics",style:{position:"relative"}},r.createElement(n.a,{href:"#embedding-space-and-similarity-metrics","aria-label":"embedding space and similarity metrics permalink",className:"anchor before"},r.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Embedding Space And Similarity Metrics"),"\n",r.createElement(n.p,null,"Key to RAG is the idea that both queries and documents live in a (typically high-dimensional) embedding space where dot product, cosine similarity, or other distance metrics reflect semantic closeness. Let ",r.createElement(o.A,{text:"\\( x \\)"})," be a text fragment (which could be a user query or a chunk of a document). An embedding model ",r.createElement(o.A,{text:"\\( E(\\cdot) \\)"})," maps ",r.createElement(o.A,{text:"\\( x \\)"})," into a vector ",r.createElement(o.A,{text:"\\( \\mathbf{v} \\in \\mathbb{R}^n \\)"}),". For example,"),"\n",r.createElement(o.A,{text:"\\[\n\\mathbf{v} = E(x),\n\\]"}),"\n",r.createElement(n.p,null,"where ",r.createElement(o.A,{text:"\\( n \\)"})," could be on the order of hundreds or thousands, depending on the embedding model."),"\n",r.createElement(n.p,null,"The retrieval step typically relies on searching among these vectors for the ",r.createElement(o.A,{text:"\\( k \\)"})," closest neighbors to the query's embedding ",r.createElement(o.A,{text:"\\( \\mathbf{v_q} = E(q) \\)"}),". If ",r.createElement(o.A,{text:"\\( \\mathbf{v_d} \\)"})," is the embedding for a document chunk ",r.createElement(o.A,{text:"\\( d \\)"}),", the similarity might be measured by the cosine similarity ",r.createElement(o.A,{text:"\\( \\cos(\\mathbf{v_q}, \\mathbf{v_d}) \\)"})," or the inner product ",r.createElement(o.A,{text:"\\( \\mathbf{v_q}^\\top \\mathbf{v_d} \\)"}),". Across large corpora (potentially billions of documents), approximate nearest neighbor search algorithms (like Hierarchical Navigable Small World graphs, or product quantization methods) are vital in making retrieval at scale computationally tractable."),"\n",r.createElement(n.h4,{id:"probabilistic-modeling",style:{position:"relative"}},r.createElement(n.a,{href:"#probabilistic-modeling","aria-label":"probabilistic modeling permalink",className:"anchor before"},r.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Probabilistic Modeling"),"\n",r.createElement(n.p,null,"From a probabilistic standpoint, one might consider ",r.createElement(o.A,{text:"\\( p(d \\mid q) \\)"})," as the probability that a document ",r.createElement(o.A,{text:"\\( d \\)"})," is relevant to query ",r.createElement(o.A,{text:"\\( q \\)"}),". In many RAG systems, ",r.createElement(o.A,{text:"\\( p(d \\mid q) \\)"})," is approximated by a function of the vector similarity ",r.createElement(o.A,{text:"\\( \\mathrm{sim}( E(q), E(d) ) \\)"}),". Then, the final generation is shaped by:"),"\n",r.createElement(o.A,{text:"\\[\np(a \\mid q) = \\sum_{d \\in \\mathcal{D}} p_G(a \\mid q, d) \\, p(d \\mid q)\n\\]"}),"\n",r.createElement(n.p,null,"where ",r.createElement(o.A,{text:"\\( \\mathcal{D} \\)"})," is the entire document corpus. Implementing this sum explicitly is infeasible for large corpora, but approximate top-k retrieval picks out the most probable (or relevant) documents to reduce the search space."),"\n",r.createElement(n.h3,{id:"key-components-of-a-rag-pipeline",style:{position:"relative"}},r.createElement(n.a,{href:"#key-components-of-a-rag-pipeline","aria-label":"key components of a rag pipeline permalink",className:"anchor before"},r.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Key Components Of A RAG Pipeline"),"\n",r.createElement(n.h4,{id:"retriever",style:{position:"relative"}},r.createElement(n.a,{href:"#retriever","aria-label":"retriever permalink",className:"anchor before"},r.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Retriever"),"\n",r.createElement(n.p,null,"At the heart of RAG resides the retriever, which surfaces the most relevant documents from a large corpus given a query. Typically, a retriever is built on an embedding model plus a vector database that indexes these embeddings. Some well-known vector databases include:"),"\n",r.createElement(n.ul,null,"\n",r.createElement(n.li,null,"FAISS (Facebook AI Similarity Search)"),"\n",r.createElement(n.li,null,"ScaNN (Scalable Nearest Neighbors by Google)"),"\n",r.createElement(n.li,null,"Annoy (Approximate Nearest Neighbors Oh Yeah)"),"\n",r.createElement(n.li,null,"Milvus"),"\n",r.createElement(n.li,null,"Pinecone"),"\n",r.createElement(n.li,null,"Chroma"),"\n"),"\n",r.createElement(n.p,null,"Each of these solutions provides different trade-offs in terms of CPU/GPU usage, indexing speed, memory requirements, and query latency."),"\n",r.createElement(n.p,null,"Because the retriever is critical for final performance, one often invests in specialized training or fine-tuning for the retrieval module. For instance, models like DPR (Karpukhin and gang, 2020) or Contriever can yield advanced retrieval performance when dealing with domain-specific corpora."),"\n",r.createElement(n.h4,{id:"generator",style:{position:"relative"}},r.createElement(n.a,{href:"#generator","aria-label":"generator permalink",className:"anchor before"},r.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Generator"),"\n",r.createElement(n.p,null,"The generator is a large language model—for instance, a GPT-based architecture or T5—that takes not only the user's query but also the retrieved text chunks as context to produce a response. The generator typically has a limited context window (e.g., a few thousand tokens in GPT-style models), so thorough control of how the retrieved documents are appended, summarized, or re-encoded is crucial."),"\n",r.createElement(n.p,null,"The generator might also rely on specialized input formatting. For instance, a prompt could look like:"),"\n",r.createElement(n.p,null,'"User query: [Q]',r.createElement(n.br),"\n","Context: [D1] [D2] [D3]",r.createElement(n.br),"\n",'Answer: …"'),"\n",r.createElement(n.p,null,"Advanced frameworks like LangChain or LlamaIndex handle this prompt concatenation automatically, but if you are implementing RAG from scratch, you must be strategic about how you pass context to the model to avoid exceeding token limits or losing important details."),"\n",r.createElement(n.h4,{id:"chunking-document-splitting",style:{position:"relative"}},r.createElement(n.a,{href:"#chunking-document-splitting","aria-label":"chunking document splitting permalink",className:"anchor before"},r.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Chunking (Document Splitting)"),"\n",r.createElement(n.p,null,"Because documents can be very large and exceed typical context windows, the pipeline usually splits each document into smaller chunks of text. For instance, each chunk might be 200–500 words or tokens. Each chunk is then embedded independently, so that retrieval can be more fine-grained."),"\n",r.createElement(n.p,null,"Chunking strategies vary. One might use:"),"\n",r.createElement(n.ul,null,"\n",r.createElement(n.li,null,"Simple fixed-size segments (e.g., 256-token windows)."),"\n",r.createElement(n.li,null,"Semantic segmentation based on headings or paragraphs."),"\n",r.createElement(n.li,null,"Recursive character/paragraph splitters that break text at logical boundaries."),"\n"),"\n",r.createElement(n.p,null,"The chunk size profoundly impacts retrieval performance. Overly large chunks might reduce the precision of retrieval, while overly small chunks could lose context."),"\n",r.createElement(n.h4,{id:"vector-database-indexing-and-search",style:{position:"relative"}},r.createElement(n.a,{href:"#vector-database-indexing-and-search","aria-label":"vector database indexing and search permalink",className:"anchor before"},r.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Vector Database (Indexing And Search)"),"\n",r.createElement(n.p,null,"A vector database stores all the chunk embeddings and allows fast approximate nearest neighbor queries. Internally, it may employ indexing structures such as an inverted file system, a k-means-based product quantization, or HNSW-type graphs to achieve sub-linear search times."),"\n",r.createElement(n.p,null,"When building a vector storage, the general steps are:"),"\n",r.createElement(n.ol,null,"\n",r.createElement(n.li,null,"Ingest documents."),"\n",r.createElement(n.li,null,"Split them into chunks."),"\n",r.createElement(n.li,null,"Embed each chunk."),"\n",r.createElement(n.li,null,"Insert these embeddings into a vector database, typically with metadata (e.g., chunk ID, source document, page number)."),"\n"),"\n",r.createElement(n.p,null,"At query time:"),"\n",r.createElement(n.ol,null,"\n",r.createElement(n.li,null,"The query is embedded."),"\n",r.createElement(n.li,null,"The database returns the top-k most similar chunks."),"\n",r.createElement(n.li,null,"Those chunks are fed into the generator model."),"\n"),"\n",r.createElement(n.h4,{id:"orchestration-encapsulation-and-workflow",style:{position:"relative"}},r.createElement(n.a,{href:"#orchestration-encapsulation-and-workflow","aria-label":"orchestration encapsulation and workflow permalink",className:"anchor before"},r.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Orchestration: Encapsulation And Workflow"),"\n",r.createElement(n.p,null,"In a complete pipeline, the RAG steps need to be orchestrated. This can be done manually (by chaining together embedding, vector search, and generation calls in your code) or by using frameworks like:"),"\n",r.createElement(n.ul,null,"\n",r.createElement(n.li,null,"\n",r.createElement(i.A,null,"LangChain"),"\n"),"\n",r.createElement(n.li,null,"LlamaIndex"),"\n",r.createElement(n.li,null,"FastRAG"),"\n",r.createElement(n.li,null,"Haystack"),"\n"),"\n",r.createElement(n.p,null,"These frameworks integrate data ingestion, chunking, embedding, retrieval, and generation steps under a uniform API, helping you quickly stand up RAG-based applications. They also offer convenient modules for memory (capturing conversation history), caching, tool usage (e.g. calling external APIs before generation), and advanced QA chaining."),"\n",r.createElement(n.h3,{id:"implementation-details",style:{position:"relative"}},r.createElement(n.a,{href:"#implementation-details","aria-label":"implementation details permalink",className:"anchor before"},r.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Implementation Details"),"\n",r.createElement(n.h4,{id:"building-a-minimal-rag-pipeline",style:{position:"relative"}},r.createElement(n.a,{href:"#building-a-minimal-rag-pipeline","aria-label":"building a minimal rag pipeline permalink",className:"anchor before"},r.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Building A Minimal RAG Pipeline"),"\n",r.createElement(n.p,null,"To illustrate the general structure of a RAG pipeline, I will now provide an example snippet in Python. This example uses a hypothetical embedding model (like OpenAI's embeddings API) and a vector database interface (like FAISS or Pinecone)."),"\n",r.createElement(l.A,{text:'\nimport os\nimport openai\nimport numpy as np\n\n# Hypothetical vector DB client, e.g. pinecone\nimport pinecone\n\n# Step 1: Chunking \ndef split_document_into_chunks(document, chunk_size=300):\n    words = document.split()\n    chunks = []\n    current_chunk = []\n    for word in words:\n        current_chunk.append(word)\n        if len(current_chunk) >= chunk_size:\n            chunks.append(" ".join(current_chunk))\n            current_chunk = []\n    if current_chunk:\n        chunks.append(" ".join(current_chunk))\n    return chunks\n\n# Step 2: Generating embeddings\n# We\'ll use OpenAI\'s embedding endpoint for demonstration\ndef get_embedding(text):\n    # This call requires your OpenAI API key to be set in openai.api_key\n    # e.g. openai.api_key = "YOUR_KEY"\n    response = openai.Embedding.create(\n        input=[text],\n        model="text-embedding-ada-002"\n    )\n    vector = response[\'data\'][0][\'embedding\']\n    return vector\n\n# Step 3: Indexing chunks in a vector store\ndef index_in_pinecone(chunks, index_name="my_index"):\n    # Initialize Pinecone\n    pinecone.init(api_key="YOUR_API_KEY", environment="us-east1-gcp")\n    \n    # Create index if it doesn\'t exist\n    if index_name not in pinecone.list_indexes():\n        pinecone.create_index(index_name, dimension=1536)\n    \n    index = pinecone.Index(index_name)\n    \n    upserts = []\n    for i, chunk in enumerate(chunks):\n        chunk_vector = get_embedding(chunk)\n        upserts.append((str(i), chunk_vector, {"text": chunk}))\n    \n    index.upsert(vectors=upserts)\n\n# Step 4: Retrieval\ndef retrieve_chunks_from_pinecone(query, index_name="my_index", top_k=3):\n    index = pinecone.Index(index_name)\n    query_vector = get_embedding(query)\n    results = index.query(vector=query_vector, top_k=top_k, include_metadata=True)\n    return [match["metadata"]["text"] for match in results["matches"]]\n\n# Step 5: Generation with retrieved context\ndef generate_answer(query):\n    # 1. Retrieve\n    relevant_chunks = retrieve_chunks_from_pinecone(query)\n    # 2. Form prompt\n    prompt = f"User query: {query}\\nContext: {relevant_chunks}\\nAnswer:"\n    \n    # 3. Use GPT for generation\n    completion = openai.Completion.create(\n        engine="text-davinci-003",\n        prompt=prompt,\n        max_tokens=150\n    )\n    return completion.choices[0].text.strip()\n\n# Putting it all together:\nif __name__ == "__main__":\n    sample_document = "Here is a long text about advanced machine learning, ...\n                       We also discuss concepts like RAG, MLOps, and so forth."\n    chunks = split_document_into_chunks(sample_document)\n    index_in_pinecone(chunks)\n    \n    user_query = "What is RAG in the context of LLMs?"\n    answer = generate_answer(user_query)\n    print(answer)\n'}),"\n",r.createElement(n.p,null,"In this dummy example, I have illustrated how you might chunk a document, embed the chunks, store them in Pinecone, retrieve the top few matches for a query, and pass them into a GPT-based model. In a real production environment, you would likely refine each step, such as:"),"\n",r.createElement(n.ul,null,"\n",r.createElement(n.li,null,"Using more sophisticated chunk splitting (by sentence or headings)."),"\n",r.createElement(n.li,null,"Caching embeddings so that you don't re-encode the same text repeatedly."),"\n",r.createElement(n.li,null,"Performing additional logic to format or re-rank retrieved chunks."),"\n"),"\n",r.createElement(n.p,null,"Nevertheless, this general pattern is representative of many RAG systems."),"\n",r.createElement(n.h4,{id:"multi-hop-retrieval-and-re-ranking",style:{position:"relative"}},r.createElement(n.a,{href:"#multi-hop-retrieval-and-re-ranking","aria-label":"multi hop retrieval and re ranking permalink",className:"anchor before"},r.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Multi-Hop Retrieval And Re-Ranking"),"\n",r.createElement(n.p,null,"An advanced technique called multi-hop retrieval can address queries that require multiple reasoning steps or combining information from multiple chunks. In multi-hop retrieval, the system iteratively refines the query or expands the set of candidate documents. The newly retrieved documents at each step are used to formulate a subsequent query."),"\n",r.createElement(n.p,null,"You can also incorporate re-ranking steps (similar to how cross-encoders function) to reorder the retrieved documents based on deeper semantic checks. Approaches like ColBERT or re-rankers fine-tuned on question-answer pairs might significantly improve retrieval precision."),"\n",r.createElement(n.h3,{id:"orchestration-frameworks",style:{position:"relative"}},r.createElement(n.a,{href:"#orchestration-frameworks","aria-label":"orchestration frameworks permalink",className:"anchor before"},r.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Orchestration Frameworks"),"\n",r.createElement(n.h4,{id:"langchain",style:{position:"relative"}},r.createElement(n.a,{href:"#langchain","aria-label":"langchain permalink",className:"anchor before"},r.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"LangChain"),"\n",r.createElement(n.p,null,"LangChain is one of the most popular frameworks for building end-to-end RAG pipelines. It allows you to define “chains” of prompts and connect them with broader retrieval or question-answer modules. It also integrates conversation “memory,” tool usage (including external APIs), and advanced prompting techniques."),"\n",r.createElement(n.p,null,"LangChain's advantage lies in packaging many best practices for LLM usage into a single cohesive library. For instance, you can define a chain that first rewrites the user query to enhance retrieval, fetches top-k documents, and calls a second chain for summarization or final answer generation."),"\n",r.createElement(n.h4,{id:"llamaindex",style:{position:"relative"}},r.createElement(n.a,{href:"#llamaindex","aria-label":"llamaindex permalink",className:"anchor before"},r.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"LlamaIndex"),"\n",r.createElement(n.p,null,"LlamaIndex (formerly GPT Index) is similarly oriented toward retrieval-augmented tasks, but focuses heavily on indexing and building hierarchical or graph-based structures on top of your data. It can be used with a variety of LLMs and vector databases. LlamaIndex covers chunking, embedding, retrieval, and generation while still allowing you to customize each step."),"\n",r.createElement(n.h4,{id:"fastrag",style:{position:"relative"}},r.createElement(n.a,{href:"#fastrag","aria-label":"fastrag permalink",className:"anchor before"},r.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"FastRAG"),"\n",r.createElement(n.p,null,"FastRAG is an emerging library (Intel Labs) that emphasizes optimizing the retrieval-augmented pipeline for low-latency response times, employing advanced caching and model acceleration."),"\n",r.createElement(n.h3,{id:"rag-versus-fine-tuning",style:{position:"relative"}},r.createElement(n.a,{href:"#rag-versus-fine-tuning","aria-label":"rag versus fine tuning permalink",className:"anchor before"},r.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"RAG Versus Fine-Tuning"),"\n",r.createElement(n.p,null,"RAG is often contrasted with the more traditional approach of ",r.createElement(i.A,null,"fine-tuning"),", in which a language model is updated (via gradient-based training) on a domain-specific corpus or a given dataset. The difference can be summarized as follows:"),"\n",r.createElement(n.ul,null,"\n",r.createElement(n.li,null,"\n",r.createElement(i.A,null,"Fine-Tuning:"),"\n",r.createElement(n.ol,null,"\n",r.createElement(n.li,null,"You effectively bake domain knowledge into the model's parameters."),"\n",r.createElement(n.li,null,"The approach can yield excellent domain-specific results but tends to be static—once trained, the knowledge is frozen until a new fine-tuning round."),"\n",r.createElement(n.li,null,"Can be expensive or infeasible for extremely large LLMs."),"\n"),"\n"),"\n",r.createElement(n.li,null,"\n",r.createElement(i.A,null,"RAG:"),"\n",r.createElement(n.ol,null,"\n",r.createElement(n.li,null,"You keep the model's parameters fixed, but attach an external knowledge base or vector database."),"\n",r.createElement(n.li,null,"Ensures up-to-date knowledge is always available, as you can update the external data store regularly without retraining the model."),"\n",r.createElement(n.li,null,"May require well-engineered retrieval index structures to keep latency manageable."),"\n"),"\n"),"\n"),"\n",r.createElement(n.p,null,"In many real-world scenarios, RAG is a more flexible approach: if your knowledge base changes frequently or must incorporate multiple data sources, it's usually more practical to retrieve from an updatable store than to re-train or fine-tune a large model from scratch."),"\n",r.createElement(n.h3,{id:"use-cases-and-applications",style:{position:"relative"}},r.createElement(n.a,{href:"#use-cases-and-applications","aria-label":"use cases and applications permalink",className:"anchor before"},r.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Use Cases And Applications"),"\n",r.createElement(n.ol,null,"\n",r.createElement(n.li,null,"\n",r.createElement(n.p,null,r.createElement(n.strong,null,"Open-Domain Question Answering"),": RAG enables robust QA in scenarios where the answer to a question may lie in a large text corpus or website. As changes occur in the corpus, the system remains accurate without retraining."),"\n"),"\n",r.createElement(n.li,null,"\n",r.createElement(n.p,null,r.createElement(n.strong,null,"Customer Support Chatbots"),": A RAG-based system can retrieve relevant knowledge base content (FAQs, policy documents, troubleshooting guides) and base its answers on up-to-date references, drastically reducing the risk of providing outdated information."),"\n"),"\n",r.createElement(n.li,null,"\n",r.createElement(n.p,null,r.createElement(n.strong,null,"Enterprise Knowledge Management"),": In an enterprise setting, RAG can serve as a dynamic interface to large volumes of documents—memos, wikis, policy docs—without requiring elaborate data wrangling each time."),"\n"),"\n",r.createElement(n.li,null,"\n",r.createElement(n.p,null,r.createElement(n.strong,null,"Scientific Literature Search"),": Researchers can query a database of academic papers by embedding user queries and retrieving relevant sections, prompting the language model to summarize or highlight key points."),"\n"),"\n",r.createElement(n.li,null,"\n",r.createElement(n.p,null,r.createElement(n.strong,null,"News And Trend Monitoring"),": Journalists or data analysts can retrieve the most relevant news fragments to unify them into a coherent storyline for real-time analysis."),"\n"),"\n",r.createElement(n.li,null,"\n",r.createElement(n.p,null,r.createElement(n.strong,null,"Educational Applications"),": RAG-based tutoring systems can retrieve relevant textbooks or reference materials in real time, augmenting the knowledge of a base language model."),"\n"),"\n"),"\n",r.createElement(n.h3,{id:"evaluating-rag-based-systems",style:{position:"relative"}},r.createElement(n.a,{href:"#evaluating-rag-based-systems","aria-label":"evaluating rag based systems permalink",className:"anchor before"},r.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Evaluating RAG-Based Systems"),"\n",r.createElement(n.h4,{id:"retrieval-metrics",style:{position:"relative"}},r.createElement(n.a,{href:"#retrieval-metrics","aria-label":"retrieval metrics permalink",className:"anchor before"},r.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Retrieval Metrics"),"\n",r.createElement(n.p,null,"One part of evaluation focuses on retrieval quality. Common retrieval metrics include:"),"\n",r.createElement(n.ul,null,"\n",r.createElement(n.li,null,"Recall@k: fraction of queries for which a relevant document is among the top-k retrieved results."),"\n",r.createElement(n.li,null,"MRR (Mean Reciprocal Rank): measures how high in the ranking the first relevant document appears."),"\n",r.createElement(n.li,null,"nDCG (Normalized Discounted Cumulative Gain): accounts for multiple relevance levels in ranking."),"\n"),"\n",r.createElement(n.p,null,"For advanced domain-specific tasks, a manual annotation or gold-labeled set might be needed to measure how well retrieval is performing."),"\n",r.createElement(n.h4,{id:"generation-metrics",style:{position:"relative"}},r.createElement(n.a,{href:"#generation-metrics","aria-label":"generation metrics permalink",className:"anchor before"},r.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Generation Metrics"),"\n",r.createElement(n.p,null,"Once relevant documents are retrieved, the language model's generation is evaluated with metrics like:"),"\n",r.createElement(n.ul,null,"\n",r.createElement(n.li,null,"Perplexity: how well the model predicts the observed text, though less common for open-ended tasks."),"\n",r.createElement(n.li,null,"ROUGE/BLEU: measure textual overlap with a reference answer (used in summarization or QA)."),"\n",r.createElement(n.li,null,"Factual accuracy: specialized to check correctness of the produced statements (can be done partially with retrieval-based cross-checking)."),"\n"),"\n",r.createElement(n.p,null,"In knowledge-intensive tasks, human evaluation or specialized QA metrics often remain the gold standard to measure the “usefulness” and correctness of generated answers."),"\n",r.createElement(n.h4,{id:"holistic-end-to-end-evaluation",style:{position:"relative"}},r.createElement(n.a,{href:"#holistic-end-to-end-evaluation","aria-label":"holistic end to end evaluation permalink",className:"anchor before"},r.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Holistic End-To-End Evaluation"),"\n",r.createElement(n.p,null,"It is often practical to adopt pipeline-level metrics. For instance, a question-answering system can be scored on whether the final answer is correct, ignoring the intermediate question of which documents were retrieved. Tools like Ragas or DeepEval allow direct end-to-end QA evaluation and help diagnose where errors occur (retriever or generator)."),"\n",r.createElement(n.h3,{id:"potential-pitfalls-and-future-directions",style:{position:"relative"}},r.createElement(n.a,{href:"#potential-pitfalls-and-future-directions","aria-label":"potential pitfalls and future directions permalink",className:"anchor before"},r.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Potential Pitfalls And Future Directions"),"\n",r.createElement(n.ol,null,"\n",r.createElement(n.li,null,"\n",r.createElement(n.p,null,r.createElement(n.strong,null,"Hallucinations"),": Even if relevant documents are retrieved, LLMs sometimes hallucinate or fabricate details. Careful prompt engineering and chain-of-thought checking can reduce but not eliminate this issue."),"\n"),"\n",r.createElement(n.li,null,"\n",r.createElement(n.p,null,r.createElement(n.strong,null,"Domain-Specific Embeddings"),": If your corpus is domain-specific (e.g., legal texts, chemical patents), pretrained generalist embeddings may fail to accurately capture domain concepts. Fine-tuning or specialized embedding models can improve retrieval performance."),"\n"),"\n",r.createElement(n.li,null,"\n",r.createElement(n.p,null,r.createElement(n.strong,null,"Latency And Scalability"),": Large corpora plus big LLMs can cause response delays. Strategies such as quantization, distillation, caching, and approximate nearest neighbor indexing are crucial for real-world viability."),"\n"),"\n",r.createElement(n.li,null,"\n",r.createElement(n.p,null,r.createElement(n.strong,null,"Security And Privacy"),": Many RAG pipelines rely on external APIs for embedding or generation. Sensitive data might need to remain on-premises, prompting the search for private embedding models or self-hosted solutions."),"\n"),"\n",r.createElement(n.li,null,"\n",r.createElement(n.p,null,r.createElement(n.strong,null,"Multilingual Retrieval"),": Substantial progress is still needed on multilingual RAG, where queries and documents may appear in multiple languages. Cross-lingual embedding approaches, such as LaBSE or multilingual MiniLM, can help unify the retrieval space."),"\n"),"\n",r.createElement(n.li,null,"\n",r.createElement(n.p,null,r.createElement(n.strong,null,"Knowledge Graphs Integration"),": Some pipelines integrate knowledge graphs or relational data with embeddings for schema-aware retrieval. This approach can provide structured knowledge and improve interpretability, but requires more sophisticated indexing and retrieval logic."),"\n"),"\n",r.createElement(n.li,null,"\n",r.createElement(n.p,null,r.createElement(n.strong,null,"Advanced Re-Ranking And Fusion Techniques"),": Future research is exploring how an LLM can dynamically re-rank or fuse multiple retrieved pieces of text, especially for multi-hop reasoning."),"\n"),"\n"),"\n",r.createElement(n.h3,{id:"example-code-snippets-for-advanced-features",style:{position:"relative"}},r.createElement(n.a,{href:"#example-code-snippets-for-advanced-features","aria-label":"example code snippets for advanced features permalink",className:"anchor before"},r.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Example Code Snippets For Advanced Features"),"\n",r.createElement(n.h4,{id:"multi-query-retrieval",style:{position:"relative"}},r.createElement(n.a,{href:"#multi-query-retrieval","aria-label":"multi query retrieval permalink",className:"anchor before"},r.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Multi-Query Retrieval"),"\n",r.createElement(n.p,null,"In multi-query retrieval, the system might reformulate the user's original query multiple times to capture different facets of the question. Below is a simplified demonstration:"),"\n",r.createElement(l.A,{text:'\ndef multi_query_retrieval(query, times=3):\n    # Step 1: Generate expansions or reformulations\n    # For domain-specific tasks, you might use a specialized LLM or rules\n    expansions = []\n    for i in range(times):\n        expansion_prompt = f"Rephrase the query in a different way:\nOriginal query: {query}\nAlternative version #{i+1}:"\n        completion = openai.Completion.create(engine="text-davinci-003", prompt=expansion_prompt, max_tokens=50)\n        expansions.append(completion.choices[0].text.strip())\n    \n    # Step 2: Retrieve for each expansion\n    all_retrieved_chunks = []\n    for eq in expansions:\n        eq_chunks = retrieve_chunks_from_pinecone(eq, top_k=2)\n        all_retrieved_chunks.extend(eq_chunks)\n    \n    # De-duplicate or re-rank final chunks\n    unique_chunks = list(set(all_retrieved_chunks))\n    # Optionally run a re-ranking step\n    # ...\n    return unique_chunks\n'}),"\n",r.createElement(n.p,null,"Here, I generate multiple expansions of the query. Each expansion is used to retrieve top-k results, and then all the retrieved chunks are merged and re-ranked. This approach sometimes unearths relevant documents that would be missed by a single retrieval query."),"\n",r.createElement(n.h4,{id:"integrating-summaries-or-distillation",style:{position:"relative"}},r.createElement(n.a,{href:"#integrating-summaries-or-distillation","aria-label":"integrating summaries or distillation permalink",className:"anchor before"},r.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Integrating Summaries Or Distillation"),"\n",r.createElement(n.p,null,"Instead of passing raw retrieved text to the generator, you can compress or summarize each chunk before final usage, especially when chunk sizes are large."),"\n",r.createElement(l.A,{text:'\ndef summarize_chunk(chunk):\n    prompt = f"Summarize this text in a concise paragraph:\n{chunk}\nSummary:"\n    summary = openai.Completion.create(engine="text-davinci-003", prompt=prompt, max_tokens=80)\n    return summary.choices[0].text.strip()\n\ndef retrieve_and_summarize(query, top_k=3):\n    chunks = retrieve_chunks_from_pinecone(query, top_k=top_k)\n    summaries = [summarize_chunk(ch) for ch in chunks]\n    return summaries\n'}),"\n",r.createElement(n.p,null,"This ensures your final prompt to the LLM has more relevant coverage of multiple retrieved chunks while staying within the model's context window. Summarization can be performed through smaller or specialized language models to reduce cost and latency."),"\n",r.createElement(n.h3,{id:"conclusion",style:{position:"relative"}},r.createElement(n.a,{href:"#conclusion","aria-label":"conclusion permalink",className:"anchor before"},r.createElement(n.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Conclusion"),"\n",r.createElement(n.p,null,"Retrieval-Augmented Generation is an exciting, powerful paradigm for bridging the gap between massive language models and real-world knowledge. By harnessing vector embeddings, sophisticated indexing structures, and generative AI, RAG can provide accurate, context-aware, and up-to-date responses in domains where knowledge changes frequently. The synergy of retrieval and generation reduces the need for repeated fine-tuning, offers dynamic knowledge updates, and can significantly improve the reliability and factual grounding of LLM outputs."),"\n",r.createElement(n.p,null,"From a theoretical perspective, RAG thrives on well-structured retrieval probabilities, advanced embedding models, and carefully orchestrated multi-step generation. In practical terms, developers face a suite of engineering challenges regarding text chunking, metadata management, latency, cost optimization, and data governance. Nonetheless, the ecosystem supporting RAG—from open-source frameworks like LangChain and LlamaIndex to commercial vector databases and HPC-optimized pipelines—is rapidly maturing."),"\n",r.createElement(n.p,null,"Whether you are building enterprise chatbots, knowledge-driven question-answering systems, scientific literature discovery tools, or real-time data analysis platforms, RAG can be a cornerstone of a robust, future-proof solution. By leveraging RAG, I believe you can design LLM-powered services that truly reflect the latest information and deliver domain-specific insights with precision, clarity, and trustworthiness."),"\n",r.createElement(n.p,null,"If you are keen to expand these ideas further, consider exploring next-generation retrieval systems (e.g., dense passage retrieval with domain adaptation, knowledge graphs, or retrieval with advanced re-ranking), investigating advanced multi-hop or multi-turn retrieval strategies, or experimenting with specialized hardware acceleration for large-scale deployments. RAG stands at the intersection of cutting-edge NLP, IR (Information Retrieval), and knowledge management—a nexus that I expect will continue evolving swiftly in the coming years."),"\n",r.createElement(n.p,null,"I encourage you to experiment with the code snippets, adapt them to your domain, and keep a close eye on new developments in the broader IR and generative AI research communities. Bringing retrieval augmentation fully into the LLM workflow can unlock unprecedented potential for real-time knowledge assimilation, bridging the gap between static parametric knowledge and the ever-changing world of information."))}var c=function(e){void 0===e&&(e={});const{wrapper:n}=Object.assign({},(0,a.RP)(),e.components);return n?r.createElement(n,e,r.createElement(s,e)):s(e)},d=t(54506),m=t(88864),h=t(58481),u=t.n(h),p=t(5984),g=t(43672),f=t(27042),v=t(72031),y=t(81817),b=t(27105),E=t(17265),w=t(2043),k=t(95751),x=t(94328),S=t(80791),_=t(78137);const A=e=>{let{toc:n}=e;if(!n||!n.items)return null;return r.createElement("nav",{className:S.R},r.createElement("ul",null,n.items.map(((e,n)=>r.createElement("li",{key:n},r.createElement("a",{href:e.url,onClick:n=>((e,n)=>{e.preventDefault();const t=n.replace("#",""),a=document.getElementById(t);a&&a.scrollIntoView({behavior:"smooth",block:"start"})})(n,e.url)},e.title),e.items&&r.createElement(A,{toc:{items:e.items}}))))))};function H(e){let{data:{mdx:n,allMdx:i,allPostImages:l},children:o}=e;const{frontmatter:s,body:c,tableOfContents:m}=n,h=s.index,v=s.slug.split("/")[1],S=i.nodes.filter((e=>e.frontmatter.slug.includes(`/${v}/`))).sort(((e,n)=>e.frontmatter.index-n.frontmatter.index)),H=S.findIndex((e=>e.frontmatter.index===h)),I=S[H+1],T=S[H-1],C=s.slug.replace(/\/$/,""),M=/[^/]*$/.exec(C)[0],q=`posts/${v}/content/${M}/`,{0:z,1:L}=(0,r.useState)(s.flagWideLayoutByDefault),{0:R,1:G}=(0,r.useState)(!1);var P;(0,r.useEffect)((()=>{G(!0);const e=setTimeout((()=>G(!1)),340);return()=>clearTimeout(e)}),[z]),"adventures"===v?P=E.cb:"research"===v?P=E.Qh:"thoughts"===v&&(P=E.T6);const V=u()(c).replace(/import .*? from .*?;/g,"").replace(/<.*?>/g,"").replace(/\{\/\*[\s\S]*?\*\/\}/g,"").trim().split(/\s+/).length,B=function(e){if(e<=10)return"~10 min";if(e<=20)return"~20 min";if(e<=30)return"~30 min";if(e<=40)return"~40 min";if(e<=50)return"~50 min";if(e<=60)return"~1 h";const n=Math.floor(e/60),t=e%60;return t<=30?`~${n}${t>0?".5":""} h`:`~${n+1} h`}(Math.ceil(V/P)+(s.extraReadTimeMin||0)),N=[{flag:s.flagDraft,component:()=>Promise.all([t.e(5850),t.e(9833)]).then(t.bind(t,49833))},{flag:s.flagMindfuckery,component:()=>Promise.all([t.e(5850),t.e(7805)]).then(t.bind(t,27805))},{flag:s.flagRewrite,component:()=>Promise.all([t.e(5850),t.e(8916)]).then(t.bind(t,78916))},{flag:s.flagOffensive,component:()=>Promise.all([t.e(5850),t.e(6731)]).then(t.bind(t,49112))},{flag:s.flagProfane,component:()=>Promise.all([t.e(5850),t.e(3336)]).then(t.bind(t,83336))},{flag:s.flagMultilingual,component:()=>Promise.all([t.e(5850),t.e(2343)]).then(t.bind(t,62343))},{flag:s.flagUnreliably,component:()=>Promise.all([t.e(5850),t.e(6865)]).then(t.bind(t,11627))},{flag:s.flagPolitical,component:()=>Promise.all([t.e(5850),t.e(4417)]).then(t.bind(t,24417))},{flag:s.flagCognitohazard,component:()=>Promise.all([t.e(5850),t.e(8669)]).then(t.bind(t,18669))},{flag:s.flagHidden,component:()=>Promise.all([t.e(5850),t.e(8124)]).then(t.bind(t,48124))}],{0:O,1:F}=(0,r.useState)([]);return(0,r.useEffect)((()=>{N.forEach((e=>{let{flag:n,component:t}=e;n&&t().then((e=>{F((n=>[].concat((0,d.A)(n),[e.default])))}))}))}),[]),r.createElement(f.P.div,{initial:{opacity:0},animate:{opacity:1},exit:{opacity:0},transition:{duration:.15}},r.createElement(y.A,{postNumber:s.index,date:s.date,updated:s.updated,readTime:B,difficulty:s.difficultyLevel,title:s.title,desc:s.desc,banner:s.banner,section:v,postKey:M,isMindfuckery:s.flagMindfuckery,mainTag:s.mainTag}),r.createElement("div",{style:{display:"flex",justifyContent:"flex-end",flexWrap:"wrap",maxWidth:"75%",marginLeft:"auto",paddingRight:"1vw",marginTop:"-6vh",marginBottom:"4vh"}},s.otherTags.map(((e,n)=>r.createElement("span",{key:n,className:`noselect ${_.MW}`,style:{margin:"0 5px 5px 0"}},e)))),r.createElement("div",{className:"postBody"},r.createElement(A,{toc:m})),r.createElement("br",null),r.createElement("div",{style:{margin:"0 10% -2vh 30%",textAlign:"right"}},r.createElement(f.P.button,{className:`noselect ${x.pb}`,id:x.xG,onClick:()=>{L(!z)},whileTap:{scale:.93}},r.createElement(f.P.div,{className:k.DJ,key:z,initial:{opacity:0},animate:{opacity:1},exit:{opacity:0},transition:{duration:.3,ease:"easeInOut"}},z?"Switch to default layout":"Switch to wide layout"))),r.createElement("br",null),r.createElement("div",{className:"postBody",style:{margin:z?"0 -14%":"",maxWidth:z?"200%":"",transition:"margin 1s ease, max-width 1s ease, padding 1s ease"}},r.createElement("div",{className:`${x.P_} ${R?x.Xn:x.qG}`},O.map(((e,n)=>r.createElement(e,{key:n}))),s.indexCourse?r.createElement(w.A,{index:s.indexCourse,category:s.courseCategoryName}):"",r.createElement(p.Z.Provider,{value:{images:l.nodes,basePath:q.replace(/\/$/,"")+"/"}},r.createElement(a.xA,{components:{Image:g.A}},o)))),r.createElement(b.A,{nextPost:I,lastPost:T,keyCurrent:M,section:v}))}function I(e){return r.createElement(H,e,r.createElement(c,e))}function T(e){var n,t,a,i,l;let{data:o}=e;const{frontmatter:s}=o.mdx,c=s.titleSEO||s.title,d=s.titleOG||c,h=s.titleTwitter||c,u=s.descSEO||s.desc,p=s.descOG||u,g=s.descTwitter||u,f=s.schemaType||"BlogPosting",y=s.keywordsSEO,b=s.date,E=s.updated||b,w=s.imageOG||(null===(n=s.banner)||void 0===n||null===(t=n.childImageSharp)||void 0===t||null===(a=t.gatsbyImageData)||void 0===a||null===(i=a.images)||void 0===i||null===(l=i.fallback)||void 0===l?void 0:l.src),k=s.imageAltOG||p,x=s.imageTwitter||w,S=s.imageAltTwitter||g,_=s.canonicalURL,A=s.flagHidden||!1,H=s.mainTag||"Posts",I=s.slug.split("/")[1]||"posts",{siteUrl:T}=(0,m.Q)(),C={"@context":"https://schema.org","@type":"BreadcrumbList",itemListElement:[{"@type":"ListItem",position:1,name:"Home",item:T},{"@type":"ListItem",position:2,name:H,item:`${T}/${s.slug.split("/")[1]}`},{"@type":"ListItem",position:3,name:c,item:`${T}${s.slug}`}]};return r.createElement(v.A,{title:c+" - avrtt.blog",titleOG:d,titleTwitter:h,description:u,descriptionOG:p,descriptionTwitter:g,schemaType:f,keywords:y,datePublished:b,dateModified:E,imageOG:w,imageAltOG:k,imageTwitter:x,imageAltTwitter:S,canonicalUrl:_,flagHidden:A,mainTag:H,section:I,type:"article"},r.createElement("script",{type:"application/ld+json"},JSON.stringify(C)))}},90548:function(e,n,t){var a=t(96540),r=t(7978);n.A=e=>{let{text:n}=e;return a.createElement(r.A,null,n)}}}]);
//# sourceMappingURL=component---src-templates-post-tsx-content-file-path-src-pages-posts-research-rag-for-llms-mdx-ea71b4b2ce12cbcda959.js.map