"use strict";(self.webpackChunkavrtt_blog=self.webpackChunkavrtt_blog||[]).push([[7724],{32593:function(e,t,n){n.r(t),n.d(t,{Head:function(){return A},PostTemplate:function(){return _},default:function(){return z}});var a=n(54506),l=n(28453),i=n(96540),r=(n(16886),n(46295)),o=n(96098);function s(e){const t=Object.assign({h2:"h2",a:"a",span:"span",h3:"h3",p:"p",ol:"ol",li:"li",strong:"strong",ul:"ul",hr:"hr"},(0,l.RP)(),e.components),{Image:n}=t;return n||function(e,t){throw new Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Image",!0),i.createElement(i.Fragment,null,"\n",i.createElement("br"),"\n","\n","\n",i.createElement(t.h2,{id:"lenet",style:{position:"relative"}},i.createElement(t.a,{href:"#lenet","aria-label":"lenet permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"LeNet"),"\n",i.createElement(t.h3,{id:"details-and-architecture-of-lenet",style:{position:"relative"}},i.createElement(t.a,{href:"#details-and-architecture-of-lenet","aria-label":"details and architecture of lenet permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Details and architecture of lenet"),"\n",i.createElement(t.p,null,"LeNet is considered one of the earliest successful convolutional neural network architectures, introduced by Yann LeCun and colleagues in the late 1980s and early 1990s (LeCun and gang, Proceedings of the IEEE, 1998). Although the original design has undergone multiple revisions and naming conventions (e.g., LeNet-1, LeNet-4, LeNet-5), the commonly referenced and most canonical form is LeNet-5. This network was originally devised to perform handwritten digit recognition on the MNIST dataset, which is a staple benchmark for image classification tasks in machine learning education."),"\n",i.createElement(t.p,null,"The fundamental idea behind LeNet rests on the fact that images (especially handwritten digits) have locally correlated features, and employing specialized layers that exploit these local features — namely convolution and subsampling (pooling) — can yield robust representations that are more invariant to shifts and distortions than a generic, fully connected network. The architecture is substantially simpler compared to more modern networks such as AlexNet or VGG, but the same key building blocks introduced by LeNet, like convolution, pooling, and fully connected layers at the output, remain cornerstones of today's CNNs."),"\n",i.createElement(t.p,null,"A typical LeNet-5 architecture is comprised of:"),"\n",i.createElement(t.ol,null,"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Input layer"),": Accepts the input image, commonly 32<times32 pixels, although the actual images in the MNIST dataset are 28<times28. Often, zero-padding or other transformations are used to fit the input dimension."),"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Convolutional layer (C1)"),": Learns local features by sliding filters (or kernels) across the spatial dimension of the image."),"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Subsampling layer (S2)"),": Often referred to as a pooling layer, typically using average pooling or max pooling to reduce spatial dimensions and thus reduce the number of parameters, while retaining the most important information. Pooling also makes the representation somewhat invariant to small translations."),"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Convolutional layer (C3)"),": Learns higher-level features."),"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Subsampling layer (S4)"),": Another pooling step to further reduce dimensionality."),"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Fully connected layers (F5, output layer)"),": The extracted feature maps are flattened and passed to fully connected layers to produce the final classification probabilities."),"\n"),"\n",i.createElement(t.p,null,"Unlike some more recent designs, LeNet commonly uses fewer channels, smaller filter sizes, and simpler activation functions (historically, tanh rather than ReLU). A typical LeNet-5 design uses ",i.createElement(o.A,{text:"\\(5 \\times 5\\)"})," filters in the convolutional layers, with around 6 to 16 filters in earlier versions, though these numbers can vary slightly across different retellings and expansions of the architecture."),"\n",i.createElement(t.p,null,"Below is a high-level illustration that captures the essence of LeNet:"),"\n",i.createElement(n,{alt:"LeNet architecture diagram",path:"",caption:"A high-level schematic of the LeNet architecture. Notice the alternating convolution and pooling layers, culminating in fully connected layers.",zoom:"false"}),"\n",i.createElement(t.p,null,"In formal terms, the 2D convolution operation performed by a kernel ",i.createElement(o.A,{text:"\\(K\\)"})," on an image (or feature map) ",i.createElement(o.A,{text:"\\(I\\)"})," at location ",i.createElement(o.A,{text:"\\((x, y)\\)"})," can be expressed as:"),"\n",i.createElement(o.A,{text:"\\[\n(\\text{Conv}(I, K))(x, y) = \\sum_{a=-\\alpha}^{\\alpha} \\sum_{b=-\\beta}^{\\beta} I(x+a, y+b)\\,K(a, b),\n\\]"}),"\n",i.createElement(t.p,null,"where ",i.createElement(o.A,{text:"\\(2\\alpha+1\\)"})," and ",i.createElement(o.A,{text:"\\(2\\beta+1\\)"})," are the filter dimensions (for a ",i.createElement(o.A,{text:"\\(5 \\times 5\\)"})," kernel, ",i.createElement(o.A,{text:"\\(\\alpha = 2\\)"})," and ",i.createElement(o.A,{text:"\\(\\beta = 2\\)"}),"). Each such convolutional filter effectively extracts a certain type of local pattern. Pooling (subsampling) is often defined as either an average or maximum over a local neighborhood, for instance:"),"\n",i.createElement(o.A,{text:"\\[\n(\\text{Pool}_{\\text{avg}}(M))(x, y) = \\frac{1}{k^2} \\sum_{a=0}^{k-1}\\sum_{b=0}^{k-1} M(x \\times k + a, y \\times k + b),\n\\]"}),"\n",i.createElement(t.p,null,"if you are using average pooling with a pool size ",i.createElement(o.A,{text:"\\(k \\times k\\)"}),"."),"\n",i.createElement(t.h3,{id:"use-cases",style:{position:"relative"}},i.createElement(t.a,{href:"#use-cases","aria-label":"use cases permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Use cases"),"\n",i.createElement(t.p,null,"Initially, LeNet was proposed for character recognition tasks. Specifically, it was used to read digits on bank checks, which was a major application of early CNNs in the 1990s. Although modern tasks commonly deal with more complex data with higher resolution, LeNet (especially in the form of LeNet-5) remains a standard introductory example due to its simplicity and relatively small number of parameters. Typical uses include:"),"\n",i.createElement(t.ul,null,"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Handwritten digit recognition")," (MNIST, USPS datasets)."),"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Introductory labs")," in courses that teach fundamental CNN concepts, because the network is easy to train on a CPU and converges quickly."),"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Proof-of-concept")," tasks, where one wants to experiment with a minimal CNN architecture before scaling up."),"\n"),"\n",i.createElement(t.h3,{id:"advantages-and-disadvantages-of-lenet",style:{position:"relative"}},i.createElement(t.a,{href:"#advantages-and-disadvantages-of-lenet","aria-label":"advantages and disadvantages of lenet permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Advantages and disadvantages of lenet"),"\n",i.createElement(t.p,null,i.createElement(t.strong,null,"Advantages")),"\n",i.createElement(t.ul,null,"\n",i.createElement(t.li,null,"Straightforward design: Easy to implement and interpret."),"\n",i.createElement(t.li,null,"Low computational cost: Suitable for low-end hardware or demonstration purposes."),"\n",i.createElement(t.li,null,"Historically significant: A great model to illustrate the basic mechanics of CNNs."),"\n"),"\n",i.createElement(t.p,null,i.createElement(t.strong,null,"Disadvantages")),"\n",i.createElement(t.ul,null,"\n",i.createElement(t.li,null,"Limited capacity: Not well-suited for large-scale, high-resolution image classification tasks."),"\n",i.createElement(t.li,null,"Outdated design: Modern activation functions (like ReLU) and deeper networks (with significantly more layers) often provide superior performance for more complex tasks."),"\n",i.createElement(t.li,null,"Not flexible: The network's dimension assumptions can make it less straightforward to adapt to varying input sizes without modifications."),"\n"),"\n",i.createElement(t.h3,{id:"step-by-step-implementation-of-lenet-tensorflowkeras",style:{position:"relative"}},i.createElement(t.a,{href:"#step-by-step-implementation-of-lenet-tensorflowkeras","aria-label":"step by step implementation of lenet tensorflowkeras permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Step-by-step implementation of lenet (tensorflow/keras)"),"\n",i.createElement(t.p,null,"Below is a minimal example of how one might implement a LeNet-like architecture in TensorFlow/Keras. The code is simplified for educational purposes, but it captures the core structure of LeNet-5:"),"\n",i.createElement(r.A,{text:"\nimport tensorflow as tf\nfrom tensorflow.keras import layers, models\n\ndef create_lenet(input_shape=(32, 32, 1), num_classes=10):\n    # Initialize a sequential model\n    model = models.Sequential()\n\n    # First convolutional layer (6 filters, 5x5 kernel, tanh activation historically, \n    # but often replaced with ReLU in modern variants)\n    model.add(layers.Conv2D(filters=6, kernel_size=(5, 5), activation='tanh', \n                            input_shape=input_shape, padding='valid'))\n    \n    # Subsampling layer (average pooling or max pooling)\n    model.add(layers.AveragePooling2D(pool_size=(2, 2)))\n    \n    # Second convolutional layer (16 filters, 5x5 kernel, tanh activation)\n    model.add(layers.Conv2D(filters=16, kernel_size=(5, 5), activation='tanh'))\n    \n    # Another subsampling layer\n    model.add(layers.AveragePooling2D(pool_size=(2, 2)))\n    \n    # Flatten the feature maps before passing to fully connected layers\n    model.add(layers.Flatten())\n    \n    # Fully connected layer (120 units)\n    model.add(layers.Dense(120, activation='tanh'))\n    \n    # Another fully connected layer (84 units)\n    model.add(layers.Dense(84, activation='tanh'))\n    \n    # Output layer with softmax activation for classification\n    model.add(layers.Dense(num_classes, activation='softmax'))\n    \n    return model\n\n# Example usage:\nif __name__ == '__main__':\n    lenet_model = create_lenet()\n    lenet_model.compile(\n        optimizer=tf.keras.optimizers.Adam(learning_rate=0.001),\n        loss='sparse_categorical_crossentropy',\n        metrics=['accuracy']\n    )\n    lenet_model.summary()\n"}),"\n",i.createElement(t.p,null,"In the snippet above, I have preserved the spirit of LeNet by choosing tanh activations and average pooling. Nonetheless, one can replace tanh with ReLU or average pooling with max pooling to obtain a slightly more contemporary variant. The fundamental structure, however, remains quintessentially LeNet."),"\n",i.createElement(t.hr),"\n",i.createElement(t.h2,{id:"alexnet",style:{position:"relative"}},i.createElement(t.a,{href:"#alexnet","aria-label":"alexnet permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"AlexNet"),"\n",i.createElement(t.h3,{id:"details-and-architecture-of-alexnet",style:{position:"relative"}},i.createElement(t.a,{href:"#details-and-architecture-of-alexnet","aria-label":"details and architecture of alexnet permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Details and architecture of alexnet"),"\n",i.createElement(t.p,null,"AlexNet, introduced by Krizhevsky and gang (NIPS 2012), was a groundbreaking network architecture that revitalized interest in deep learning for computer vision tasks. Trained on the large-scale ImageNet dataset, which contains over a million labeled images across 1,000 categories, AlexNet demonstrated a substantial performance leap compared to traditional computer vision pipelines or shallower neural networks."),"\n",i.createElement(t.p,null,"Key insights that made AlexNet a breakthrough model include:"),"\n",i.createElement(t.ol,null,"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Deeper architecture"),": AlexNet has more layers and many more parameters than earlier CNNs like LeNet. This contributes to its capacity to learn complex patterns."),"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"ReLU activation"),": The network extensively uses the rectified linear unit (ReLU), ",i.createElement(o.A,{text:"\\( \\text{ReLU}(x) = \\max(0, x) \\)"}),", which helps mitigate vanishing gradients, accelerating convergence."),"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"GPU training"),": The authors leveraged two GPUs in parallel to train the model more efficiently. This was one of the earliest demonstrations that GPU acceleration could handle large-scale deep networks."),"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Local response normalization (LRN)"),": At the time, LRN was used to help the network generalize better, though subsequent architectures often replaced LRN with batch normalization or removed it entirely."),"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Overlapping pooling"),": Instead of using disjoint pooling regions, AlexNet used overlapping windows, which sometimes yields better performance."),"\n"),"\n",i.createElement(t.p,null,"A typical AlexNet architecture consists of:"),"\n",i.createElement(t.ul,null,"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Input layer")," for 224<times224 RGB images."),"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Convolutional layers"),": Five convolutional layers in total, often with some grouped convolutions due to GPU memory constraints at the time."),"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Normalization layers (LRN)"),": Inserted after the first and second convolutional layers in the original design."),"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Pooling layers"),": Max pooling layers after certain convolutions."),"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Fully connected layers"),": Three large fully connected layers (FC6, FC7, FC8), culminating in a 1000-way softmax for ImageNet classification."),"\n"),"\n",i.createElement(t.p,null,"Below is a simplified illustration:"),"\n",i.createElement(n,{alt:"AlexNet architecture diagram",path:"",caption:"An overview of the AlexNet architecture for ImageNet classification.",zoom:"false"}),"\n",i.createElement(t.h3,{id:"use-cases-1",style:{position:"relative"}},i.createElement(t.a,{href:"#use-cases-1","aria-label":"use cases 1 permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Use cases"),"\n",i.createElement(t.p,null,"AlexNet shines in:"),"\n",i.createElement(t.ul,null,"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Large-scale image classification"),": Designed for ImageNet-sized tasks (1,000 classes, ~1.2M training images)."),"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Feature extraction"),": Early layers of AlexNet can be used to extract generic features from images, applicable to tasks beyond classification (e.g., transfer learning)."),"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Computer vision research"),": Provided a baseline that future architectures improved upon (e.g., VGG, Inception, ResNet)."),"\n"),"\n",i.createElement(t.p,null,"In modern practice, AlexNet is no longer considered state-of-the-art. However, it remains historically significant, and it's a valuable stepping stone for those learning about the evolution of CNN architectures."),"\n",i.createElement(t.h3,{id:"advantages-and-disadvantages-of-alexnet",style:{position:"relative"}},i.createElement(t.a,{href:"#advantages-and-disadvantages-of-alexnet","aria-label":"advantages and disadvantages of alexnet permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Advantages and disadvantages of alexnet"),"\n",i.createElement(t.p,null,i.createElement(t.strong,null,"Advantages")),"\n",i.createElement(t.ul,null,"\n",i.createElement(t.li,null,"Pioneered deep CNN success on large-scale datasets."),"\n",i.createElement(t.li,null,"Demonstrated the effectiveness of ReLU activations and GPU-based training."),"\n",i.createElement(t.li,null,"Provided an architecture that was relatively easy to adapt for other tasks."),"\n"),"\n",i.createElement(t.p,null,i.createElement(t.strong,null,"Disadvantages")),"\n",i.createElement(t.ul,null,"\n",i.createElement(t.li,null,"Very large model: Over 60 million parameters, making it memory-intensive."),"\n",i.createElement(t.li,null,"Convolutions in the first layers used large kernels (often 11<times11, or 7<times7 in some revised versions), which might not be as parameter-efficient by today's standards."),"\n",i.createElement(t.li,null,"LRN is rarely used now, and the architecture doesn't incorporate modern best practices like batch normalization."),"\n"),"\n",i.createElement(t.h3,{id:"step-by-step-implementation-of-alexnet-tensorflowkeras",style:{position:"relative"}},i.createElement(t.a,{href:"#step-by-step-implementation-of-alexnet-tensorflowkeras","aria-label":"step by step implementation of alexnet tensorflowkeras permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Step-by-step implementation of alexnet (tensorflow/keras)"),"\n",i.createElement(t.p,null,"Below is a Keras example that captures the general flow of AlexNet-like architectures. It does not strictly replicate the original two-GPU setup or the exact grouping mechanism, but it serves as a demonstration."),"\n",i.createElement(r.A,{text:"\nimport tensorflow as tf\nfrom tensorflow.keras import layers, models\n\ndef create_alexnet(input_shape=(224, 224, 3), num_classes=1000):\n    model = models.Sequential()\n\n    # First convolutional layer \n    # Original paper: 96 filters of size 11x11, stride = 4, with ReLU activation\n    model.add(layers.Conv2D(filters=96, kernel_size=(11, 11), strides=(4, 4), \n                            activation='relu', input_shape=input_shape, padding='valid'))\n    # LRN or batch normalization can be used; here we omit for simplicity\n    # model.add(layers.Lambda(...))  # This can represent LRN if you decide to implement it\n\n    model.add(layers.MaxPooling2D(pool_size=(3, 3), strides=(2, 2)))\n\n    # Second convolutional layer\n    model.add(layers.Conv2D(filters=256, kernel_size=(5, 5), padding='same', activation='relu'))\n    model.add(layers.MaxPooling2D(pool_size=(3, 3), strides=(2, 2)))\n\n    # Third convolutional layer\n    model.add(layers.Conv2D(filters=384, kernel_size=(3, 3), padding='same', activation='relu'))\n\n    # Fourth convolutional layer\n    model.add(layers.Conv2D(filters=384, kernel_size=(3, 3), padding='same', activation='relu'))\n\n    # Fifth convolutional layer\n    model.add(layers.Conv2D(filters=256, kernel_size=(3, 3), padding='same', activation='relu'))\n    model.add(layers.MaxPooling2D(pool_size=(3, 3), strides=(2, 2)))\n\n    # Flatten\n    model.add(layers.Flatten())\n\n    # Fully connected layers\n    model.add(layers.Dense(4096, activation='relu'))\n    model.add(layers.Dense(4096, activation='relu'))\n    model.add(layers.Dense(num_classes, activation='softmax'))\n    \n    return model\n\nif __name__ == '__main__':\n    alexnet_model = create_alexnet()\n    alexnet_model.compile(\n        optimizer=tf.keras.optimizers.SGD(learning_rate=0.01, momentum=0.9),\n        loss='categorical_crossentropy',\n        metrics=['accuracy']\n    )\n    alexnet_model.summary()\n"}),"\n",i.createElement(t.p,null,"When training such a model on ImageNet or similarly large data sets, you'll need significant computational power (GPUs or TPUs) and a robust training strategy (e.g., data augmentation, learning rate scheduling). Modern frameworks would typically incorporate batch normalization and advanced regularization to yield improved performance compared to the original AlexNet design."),"\n",i.createElement(t.hr),"\n",i.createElement(t.h2,{id:"vggnet",style:{position:"relative"}},i.createElement(t.a,{href:"#vggnet","aria-label":"vggnet permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"VGGNet"),"\n",i.createElement(t.h3,{id:"details-and-architecture-of-vggnet",style:{position:"relative"}},i.createElement(t.a,{href:"#details-and-architecture-of-vggnet","aria-label":"details and architecture of vggnet permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Details and architecture of vggnet"),"\n",i.createElement(t.p,null,"VGGNet (Simonyan and Zisserman, ICLR 2015) builds on the success of AlexNet by emphasizing architectural simplicity: it uses very small ",i.createElement(o.A,{text:"\\(3 \\times 3\\)"})," convolution filters stacked in increasing depths. The key architectural principle behind VGG is that sequences of small convolutions can simulate larger effective receptive fields with fewer parameters and better performance."),"\n",i.createElement(t.p,null,"The hallmark design pattern of a VGGNet is a series of blocks. Each block consists of:"),"\n",i.createElement(t.ul,null,"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Convolution layers"),": Each with ",i.createElement(o.A,{text:"\\(3 \\times 3\\)"})," kernels, stride of 1, and padding of 1 to maintain spatial resolution."),"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"ReLU activation"),": After each convolution."),"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Pooling layer"),": Typically max pooling ",i.createElement(o.A,{text:"\\(2 \\times 2\\)"})," with stride 2 at the end of each block to reduce spatial dimensions."),"\n"),"\n",i.createElement(t.p,null,"By systematically doubling the number of filters after each block (e.g., 64 -> 128 -> 256 -> 512 -> 512), VGGNet can learn a deep hierarchy of features while still being fairly straightforward in structure. However, the deeper variants (VGG-16, VGG-19) can have hundreds of millions of parameters, making them quite large for practical deployment without specialized hardware or compression techniques."),"\n",i.createElement(t.p,null,"Below is a basic blueprint of the VGGNet approach:"),"\n",i.createElement(n,{alt:"VGGNet block diagram",path:"",caption:"A conceptual look at VGGNet blocks. Each block has multiple Conv+ReLU layers followed by a pooling layer, culminating in fully connected layers and an output.",zoom:"false"}),"\n",i.createElement(t.h3,{id:"use-cases-2",style:{position:"relative"}},i.createElement(t.a,{href:"#use-cases-2","aria-label":"use cases 2 permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Use cases"),"\n",i.createElement(t.p,null,"VGGNet is extremely popular for:"),"\n",i.createElement(t.ul,null,"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Transfer learning"),": Pretrained versions of VGG-16 or VGG-19 often serve as feature extractors for various tasks (e.g., object detection, semantic segmentation, style transfer)."),"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Academic research"),": Its simplicity makes it an easy baseline for investigating new ideas like new activation functions, normalization layers, or layer initialization methods."),"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Benchmarking hardware"),": Because VGG requires extensive computations, it has often been used to benchmark GPUs and other accelerators."),"\n"),"\n",i.createElement(t.h3,{id:"advantages-and-disadvantages-of-vggnet",style:{position:"relative"}},i.createElement(t.a,{href:"#advantages-and-disadvantages-of-vggnet","aria-label":"advantages and disadvantages of vggnet permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Advantages and disadvantages of vggnet"),"\n",i.createElement(t.p,null,i.createElement(t.strong,null,"Advantages")),"\n",i.createElement(t.ul,null,"\n",i.createElement(t.li,null,"Simple, systematic design: Very easy to interpret or adapt."),"\n",i.createElement(t.li,null,"Strong baseline: Often outperforms older architectures like AlexNet on a variety of tasks."),"\n",i.createElement(t.li,null,"Transfer learning usage: The robust feature hierarchy makes VGGNet a powerful generic feature extractor."),"\n"),"\n",i.createElement(t.p,null,i.createElement(t.strong,null,"Disadvantages")),"\n",i.createElement(t.ul,null,"\n",i.createElement(t.li,null,"Very large in terms of parameters: VGG-16 has around 138 million parameters. This can make training and inference expensive."),"\n",i.createElement(t.li,null,"Memory-intensive: Storing intermediate activations for deeper variants can be prohibitive if you have limited GPU memory."),"\n",i.createElement(t.li,null,"Slower inference compared to more modern lightweight architectures (e.g., MobileNet)."),"\n"),"\n",i.createElement(t.h3,{id:"vgg-16-vgg-19",style:{position:"relative"}},i.createElement(t.a,{href:"#vgg-16-vgg-19","aria-label":"vgg 16 vgg 19 permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"VGG-16, VGG-19"),"\n",i.createElement(t.p,null,"Both VGG-16 and VGG-19 differ primarily in the number of convolutional layers in their deepest block configurations:"),"\n",i.createElement(t.ul,null,"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"VGG-16"),": 13 convolution layers + 3 fully connected layers = 16 total layers."),"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"VGG-19"),": 16 convolution layers + 3 fully connected layers = 19 total layers."),"\n"),"\n",i.createElement(t.p,null,"They both share the same architecture pattern:"),"\n",i.createElement(t.ol,null,"\n",i.createElement(t.li,null,"Convolution block (64 filters) repeated."),"\n",i.createElement(t.li,null,"Pooling."),"\n",i.createElement(t.li,null,"Convolution block (128 filters) repeated."),"\n",i.createElement(t.li,null,"Pooling."),"\n",i.createElement(t.li,null,"Convolution block (256 filters) repeated."),"\n",i.createElement(t.li,null,"Pooling."),"\n",i.createElement(t.li,null,"Convolution block (512 filters) repeated."),"\n",i.createElement(t.li,null,"Pooling."),"\n",i.createElement(t.li,null,"Convolution block (512 filters) repeated."),"\n",i.createElement(t.li,null,"Pooling, flatten, fully connected, output."),"\n"),"\n",i.createElement(t.h3,{id:"step-by-step-implementation-of-vggnet-tensorflowkeras",style:{position:"relative"}},i.createElement(t.a,{href:"#step-by-step-implementation-of-vggnet-tensorflowkeras","aria-label":"step by step implementation of vggnet tensorflowkeras permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Step-by-step implementation of vggnet (tensorflow/keras)"),"\n",i.createElement(t.p,null,"Below is an example of implementing a simplified VGG-16-like model in TensorFlow/Keras:"),"\n",i.createElement(r.A,{text:"\nimport tensorflow as tf\nfrom tensorflow.keras import layers, models\n\ndef create_vgg16(input_shape=(224, 224, 3), num_classes=1000):\n    model = models.Sequential()\n\n    # Block 1\n    model.add(layers.Conv2D(64, (3, 3), activation='relu', padding='same', \n                            input_shape=input_shape))\n    model.add(layers.Conv2D(64, (3, 3), activation='relu', padding='same'))\n    model.add(layers.MaxPooling2D(pool_size=(2, 2), strides=(2, 2)))\n\n    # Block 2\n    model.add(layers.Conv2D(128, (3, 3), activation='relu', padding='same'))\n    model.add(layers.Conv2D(128, (3, 3), activation='relu', padding='same'))\n    model.add(layers.MaxPooling2D(pool_size=(2, 2), strides=(2, 2)))\n\n    # Block 3\n    model.add(layers.Conv2D(256, (3, 3), activation='relu', padding='same'))\n    model.add(layers.Conv2D(256, (3, 3), activation='relu', padding='same'))\n    model.add(layers.Conv2D(256, (3, 3), activation='relu', padding='same'))\n    model.add(layers.MaxPooling2D(pool_size=(2, 2), strides=(2, 2)))\n\n    # Block 4\n    model.add(layers.Conv2D(512, (3, 3), activation='relu', padding='same'))\n    model.add(layers.Conv2D(512, (3, 3), activation='relu', padding='same'))\n    model.add(layers.Conv2D(512, (3, 3), activation='relu', padding='same'))\n    model.add(layers.MaxPooling2D(pool_size=(2, 2), strides=(2, 2)))\n\n    # Block 5\n    model.add(layers.Conv2D(512, (3, 3), activation='relu', padding='same'))\n    model.add(layers.Conv2D(512, (3, 3), activation='relu', padding='same'))\n    model.add(layers.Conv2D(512, (3, 3), activation='relu', padding='same'))\n    model.add(layers.MaxPooling2D(pool_size=(2, 2), strides=(2, 2)))\n\n    # Fully connected part\n    model.add(layers.Flatten())\n    model.add(layers.Dense(4096, activation='relu'))\n    model.add(layers.Dense(4096, activation='relu'))\n    model.add(layers.Dense(num_classes, activation='softmax'))\n\n    return model\n\nif __name__ == '__main__':\n    vgg16_model = create_vgg16()\n    vgg16_model.compile(\n        optimizer=tf.keras.optimizers.Adam(learning_rate=0.0001),\n        loss='categorical_crossentropy',\n        metrics=['accuracy']\n    )\n    vgg16_model.summary()\n"}),"\n",i.createElement(t.p,null,"While this implementation captures the essence of VGG-16, in practice you'd likely use a pretrained version from a library (e.g., ",i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">tf.keras.applications.VGG16</code>'}}),") for transfer learning, and you might freeze certain layers or replace the final classifier layers according to your task."),"\n",i.createElement(t.hr),"\n",i.createElement(t.h2,{id:"mobilenet",style:{position:"relative"}},i.createElement(t.a,{href:"#mobilenet","aria-label":"mobilenet permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"MobileNet"),"\n",i.createElement(t.h3,{id:"details-and-architecture-of-mobilenet",style:{position:"relative"}},i.createElement(t.a,{href:"#details-and-architecture-of-mobilenet","aria-label":"details and architecture of mobilenet permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Details and architecture of mobilenet"),"\n",i.createElement(t.p,null,"Introduced by Howard and gang (arXiv:1704.04861, 2017), MobileNet is a CNN architecture designed for efficient computation on mobile and embedded devices. The main idea behind MobileNet is to drastically reduce the computational and memory requirements of typical CNNs while retaining a high level of accuracy. It uses ",i.createElement(t.strong,null,"depthwise separable convolutions")," as its core building block, replacing the standard convolution with two distinct operations:"),"\n",i.createElement(t.ol,null,"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Depthwise convolution"),": Applies a single convolution filter per input channel."),"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Pointwise convolution"),": Uses ",i.createElement(o.A,{text:"\\(1 \\times 1\\)"})," kernels to combine the outputs of the depthwise convolution into new feature maps."),"\n"),"\n",i.createElement(t.p,null,"By factorizing a standard convolution into these two separate stages, MobileNet achieves fewer parameters and faster inference on resource-constrained devices (e.g., smartphones)."),"\n",i.createElement(t.p,null,"Additionally, MobileNet introduces two hyperparameters to balance the trade-off between latency and accuracy:"),"\n",i.createElement(t.ul,null,"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Width multiplier ",i.createElement(o.A,{text:"\\(\\alpha\\)"})),": Scales the number of filters in each layer."),"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Resolution multiplier ",i.createElement(o.A,{text:"\\(\\rho\\)"})),": Scales the input resolution."),"\n"),"\n",i.createElement(t.h3,{id:"use-cases-3",style:{position:"relative"}},i.createElement(t.a,{href:"#use-cases-3","aria-label":"use cases 3 permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Use cases"),"\n",i.createElement(t.ul,null,"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Embedded devices"),": Ideal for applications where memory and compute resources are limited, such as mobile phones and edge devices."),"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Real-time inference"),": For tasks requiring minimal latency (like real-time camera processing)."),"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Transfer learning for small footprints"),": Pretrained MobileNet can be fine-tuned for specialized tasks while preserving efficiency."),"\n"),"\n",i.createElement(t.h3,{id:"advantages-and-disadvantages-of-mobilenet",style:{position:"relative"}},i.createElement(t.a,{href:"#advantages-and-disadvantages-of-mobilenet","aria-label":"advantages and disadvantages of mobilenet permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Advantages and disadvantages of mobilenet"),"\n",i.createElement(t.p,null,i.createElement(t.strong,null,"Advantages")),"\n",i.createElement(t.ul,null,"\n",i.createElement(t.li,null,"High efficiency: Greatly reduced parameter count and faster inference time."),"\n",i.createElement(t.li,null,"Flexible hyperparameters: Ability to trade off between model size and accuracy."),"\n",i.createElement(t.li,null,"Widely adopted on mobile frameworks: Commonly found in frameworks like TensorFlow Lite."),"\n"),"\n",i.createElement(t.p,null,i.createElement(t.strong,null,"Disadvantages")),"\n",i.createElement(t.ul,null,"\n",i.createElement(t.li,null,"Slight accuracy drop: Typically less accurate compared to heavier models (e.g., ResNet, VGG) on large-scale benchmarks, although the gap has shrunk with improvements like MobileNetV2, MobileNetV3."),"\n",i.createElement(t.li,null,"Less capacity: For highly complex tasks or high-resolution imagery, you might need more advanced or bigger architectures."),"\n"),"\n",i.createElement(t.h3,{id:"step-by-step-implementation-of-mobilenet-tensorflowkeras",style:{position:"relative"}},i.createElement(t.a,{href:"#step-by-step-implementation-of-mobilenet-tensorflowkeras","aria-label":"step by step implementation of mobilenet tensorflowkeras permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Step-by-step implementation of mobilenet (tensorflow/keras)"),"\n",i.createElement(t.p,null,"Below is a simplified example of implementing a MobileNet-like architecture in TensorFlow/Keras:"),"\n",i.createElement(r.A,{text:"\nimport tensorflow as tf\nfrom tensorflow.keras import layers, models\n\n# Depthwise + pointwise convolution block\ndef depthwise_separable_conv_block(inputs, pointwise_filters, stride=1):\n    x = layers.DepthwiseConv2D(kernel_size=(3,3), strides=stride, padding='same')(inputs)\n    x = layers.BatchNormalization()(x)\n    x = layers.ReLU(6.0)(x)  # typical ReLU6 used in MobileNet\n\n    x = layers.Conv2D(pointwise_filters, kernel_size=(1,1), padding='same')(x)\n    x = layers.BatchNormalization()(x)\n    x = layers.ReLU(6.0)(x)\n    return x\n\ndef create_mobilenet(input_shape=(224, 224, 3), alpha=1.0, num_classes=1000):\n    inputs = layers.Input(shape=input_shape)\n    \n    # Initial convolution layer\n    x = layers.Conv2D(int(32*alpha), kernel_size=(3,3), strides=(2,2), padding='same')(inputs)\n    x = layers.BatchNormalization()(x)\n    x = layers.ReLU(6.0)(x)\n\n    # Define the depthwise separable blocks\n    # Typical pattern for MobileNet: stride = 1 or 2 depending on layer\n    # This is a simplified sequence\n    layer_configs = [\n        (64, 1),\n        (128, 2),\n        (128, 1),\n        (256, 2),\n        (256, 1),\n        (512, 2),\n        # Then typically 5 blocks with 512 filters each with stride=1\n        (512, 1),\n        (512, 1),\n        (512, 1),\n        (512, 1),\n        (512, 1),\n        (1024, 2),\n        (1024, 1)\n    ]\n\n    for (filters, stride) in layer_configs:\n        x = depthwise_separable_conv_block(x, int(filters*alpha), stride=stride)\n\n    # Global average pooling\n    x = layers.GlobalAveragePooling2D()(x)\n    # Fully connected layer (classifier)\n    outputs = layers.Dense(num_classes, activation='softmax')(x)\n\n    model = models.Model(inputs, outputs)\n    return model\n\nif __name__ == '__main__':\n    mobilenet_model = create_mobilenet()\n    mobilenet_model.compile(\n        optimizer=tf.keras.optimizers.Adam(learning_rate=0.001),\n        loss='categorical_crossentropy',\n        metrics=['accuracy']\n    )\n    mobilenet_model.summary()\n"}),"\n",i.createElement(t.p,null,"This snippet captures the core principle of MobileNet: replacing standard convolutions with a depthwise separable convolution block. MobileNetV2 and MobileNetV3 build upon the same foundation but improve accuracy and reduce latency further via techniques such as inverted residuals and squeeze-and-excitation modules."),"\n",i.createElement(t.hr),"\n",i.createElement(t.h2,{id:"network-in-network-nin",style:{position:"relative"}},i.createElement(t.a,{href:"#network-in-network-nin","aria-label":"network in network nin permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Network in network (nin)"),"\n",i.createElement(t.p,null,"Network in Network (NiN) was introduced by Lin, Chen, and Yan (ICLR 2014). The NiN architecture proposes a novel approach: instead of using a single linear filter at each convolution layer to produce feature maps, NiN uses a ",i.createElement(t.strong,null,"micro-network")," (typically a multilayer perceptron) to generate more abstract representations within each local receptive field. This is often approximated or described as ",i.createElement(t.strong,null,"1<times1 convolutions")," combined with non-linear activations, which help the network learn more complex local feature transformations."),"\n",i.createElement(t.p,null,"In many CNN architectures (such as AlexNet and VGG), the ",i.createElement(o.A,{text:"\\(1 \\times 1\\)"}),' convolution is seen as a "bottleneck" or "pointwise" convolution. NiN extended this concept by stacking multiple ',i.createElement(o.A,{text:"\\(1 \\times 1\\)"})," filters with non-linear activations, effectively forming a tiny MLP that operates across the channels of each spatial position. The NiN modules are often described as:"),"\n",i.createElement(o.A,{text:"\\[\n\\text{NiN block}(X) = \\sigma\\bigl(W_1 * X\\bigr), \\quad \\sigma\\bigl(W_2 * X\\bigr), \\quad \\sigma\\bigl(W_3 * X\\bigr),\n\\]"}),"\n",i.createElement(t.p,null,"where each ",i.createElement(o.A,{text:"\\(W_i\\)"})," is a set of ",i.createElement(o.A,{text:"\\(1 \\times 1\\)"})," filters, and ",i.createElement(o.A,{text:"\\(\\sigma\\)"})," is a non-linear activation function."),"\n",i.createElement(t.p,null,i.createElement(t.strong,null,"Advantages"),":"),"\n",i.createElement(t.ul,null,"\n",i.createElement(t.li,null,"Allows for more complex transformations within each local receptive field."),"\n",i.createElement(t.li,null,"Reduces the number of parameters in some cases compared to using bigger convolution filters."),"\n"),"\n",i.createElement(t.p,null,i.createElement(t.strong,null,"Disadvantages"),":"),"\n",i.createElement(t.ul,null,"\n",i.createElement(t.li,null,"If not used carefully, can lead to overfitting, as these additional parameters can significantly increase the model capacity."),"\n",i.createElement(t.li,null,"Sometimes overshadowed by more advanced and widely adopted architectures (ResNet, Inception, etc.)."),"\n"),"\n",i.createElement(t.p,null,"Despite not being the most popular architecture in mainstream usage, NiN's concept of ",i.createElement(o.A,{text:"\\(1 \\times 1\\)"}),' "micro-networks" heavily inspired later designs (e.g., Inception modules that make extensive use of ',i.createElement(o.A,{text:"\\(1 \\times 1\\)"})," convolutions)."),"\n",i.createElement(t.hr),"\n",i.createElement(t.h2,{id:"residual-connections",style:{position:"relative"}},i.createElement(t.a,{href:"#residual-connections","aria-label":"residual connections permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Residual connections"),"\n",i.createElement(t.p,null,"Residual connections, popularized by He and gang (CVPR 2016) in the ",i.createElement(t.strong,null,"ResNet")," family of architectures, represent one of the most critical breakthroughs in deep CNN design. The driving motivation behind residual connections is to mitigate the ",i.createElement(t.strong,null,"vanishing gradient")," and ",i.createElement(t.strong,null,"degradation")," problems that arise when training very deep networks."),"\n",i.createElement(t.p,null,"A residual block typically looks like:"),"\n",i.createElement(n,{alt:"Basic ResNet residual block",path:"",caption:"A simplified depiction of a residual block. The input is added to the output of a series of convolutions and activations, forming a skip connection.",zoom:"false"}),"\n",i.createElement(t.p,null,"Mathematically, if we let ",i.createElement(o.A,{text:"\\(F(x)\\)"})," be the non-linear transformation (convolution, activation, etc.), then a residual block's output is:"),"\n",i.createElement(o.A,{text:"\\[\ny = F(x) + x.\n\\]"}),"\n",i.createElement(t.p,null,"The presence of the skip (or shortcut) connection that bypasses the non-linear transformations allows gradients to flow directly back to earlier layers, thus alleviating training difficulties. Empirically, ResNet architectures like ResNet-50, ResNet-101, and ResNet-152 achieve significantly better accuracy on tasks like ImageNet while also making it more feasible to train extremely deep networks."),"\n",i.createElement(t.p,null,i.createElement(t.strong,null,"Advantages"),":"),"\n",i.createElement(t.ul,null,"\n",i.createElement(t.li,null,"Eases training of deeper networks by mitigating gradient issues."),"\n",i.createElement(t.li,null,"Empirically shown to improve generalization."),"\n",i.createElement(t.li,null,"Architecture can be scaled to hundreds or even thousands of layers (e.g., ResNet variants)."),"\n"),"\n",i.createElement(t.p,null,i.createElement(t.strong,null,"Disadvantages"),":"),"\n",i.createElement(t.ul,null,"\n",i.createElement(t.li,null,"Introduces additional overhead in graph structure, though minimal."),"\n",i.createElement(t.li,null,"Residual networks can still suffer from other forms of overfitting or inefficiency if not designed carefully."),"\n"),"\n",i.createElement(t.p,null,"Residual connections are used not only in classical CNNs but also across various deep learning architectures, from segmentation networks to generative adversarial networks (GANs) and beyond."),"\n",i.createElement(t.hr),"\n",i.createElement(t.h2,{id:"inception-modules",style:{position:"relative"}},i.createElement(t.a,{href:"#inception-modules","aria-label":"inception modules permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Inception modules"),"\n",i.createElement(t.p,null,"Inception modules (Szegedy and gang, CVPR 2015), the backbone of ",i.createElement(t.strong,null,"GoogLeNet")," (Inception-V1) and subsequent Inception-V2, Inception-V3, Inception-V4, etc., aim to achieve a higher level of efficiency in networks by using multiple filter sizes in parallel and then concatenating their outputs. The guiding principle is that the optimal local architecture in CNNs can vary from layer to layer. Instead of committing to a single filter size (e.g., ",i.createElement(o.A,{text:"\\(3 \\times 3\\)"}),"), an Inception module tries filters of different sizes (",i.createElement(o.A,{text:"\\(1 \\times 1\\)"}),", ",i.createElement(o.A,{text:"\\(3 \\times 3\\)"}),", ",i.createElement(o.A,{text:"\\(5 \\times 5\\)"}),") plus pooling, and then merges these transformations."),"\n",i.createElement(t.p,null,"A simplified Inception module might look like:"),"\n",i.createElement(n,{alt:"Inception module block",path:"",caption:"A simplified Inception module showing parallel branches of different convolution/pooling operations, whose outputs are then concatenated.",zoom:"false"}),"\n",i.createElement(t.p,null,"The usage of ",i.createElement(o.A,{text:"\\(1 \\times 1\\)"})," convolutions before the larger convolutions helps reduce dimensionality and thus computational cost. More advanced versions (Inception-V2, Inception-V3) incorporate factorized convolutions (e.g., splitting ",i.createElement(o.A,{text:"\\(5 \\times 5\\)"})," into two ",i.createElement(o.A,{text:"\\(3 \\times 3\\)"})," convolutions), batch normalization, or additional techniques to improve accuracy and efficiency."),"\n",i.createElement(t.p,null,i.createElement(t.strong,null,"Advantages"),":"),"\n",i.createElement(t.ul,null,"\n",i.createElement(t.li,null,"Effectively captures features at multiple scales."),"\n",i.createElement(t.li,null,"Reduces parameter count by carefully factoring convolutions with ",i.createElement(o.A,{text:"\\(1 \\times 1\\)"})," bottlenecks."),"\n"),"\n",i.createElement(t.p,null,i.createElement(t.strong,null,"Disadvantages"),":"),"\n",i.createElement(t.ul,null,"\n",i.createElement(t.li,null,"The architecture is more complex to design and tune."),"\n",i.createElement(t.li,null,"Not as lightweight as architectures specifically optimized for mobile deployment (e.g., MobileNet)."),"\n"),"\n",i.createElement(t.hr),"\n",i.createElement(t.h2,{id:"depthwise-separable-convolutions",style:{position:"relative"}},i.createElement(t.a,{href:"#depthwise-separable-convolutions","aria-label":"depthwise separable convolutions permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Depthwise separable convolutions"),"\n",i.createElement(t.p,null,"As introduced earlier in the MobileNet discussion, depthwise separable convolutions decompose a standard convolution into two steps:"),"\n",i.createElement(t.ol,null,"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Depthwise convolution"),": A filter for each input channel that acts on the spatial dimension."),"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Pointwise convolution"),": A ",i.createElement(o.A,{text:"\\(1 \\times 1\\)"})," filter that projects the output of the depthwise convolution onto a new feature space."),"\n"),"\n",i.createElement(t.p,null,"Formally, if the standard convolution has a computational cost of ",i.createElement(o.A,{text:"\\(O(D_k \\times D_k \\times M \\times N \\times D_f \\times D_f)\\)"}),", where ",i.createElement(o.A,{text:"\\(D_k\\)"})," is kernel size, ",i.createElement(o.A,{text:"\\(M\\)"})," is the number of input channels, ",i.createElement(o.A,{text:"\\(N\\)"})," is the number of output channels, and ",i.createElement(o.A,{text:"\\(D_f\\)"})," is the spatial dimension of the feature map, a depthwise separable convolution has a cost of ",i.createElement(o.A,{text:"\\(O(D_k \\times D_k \\times M \\times D_f \\times D_f + M \\times N \\times D_f \\times D_f)\\)"}),". This factorization often yields fewer operations if ",i.createElement(o.A,{text:"\\(D_k\\)"})," is large relative to ",i.createElement(o.A,{text:"\\(M\\)"})," and ",i.createElement(o.A,{text:"\\(N\\)"}),"."),"\n",i.createElement(t.p,null,i.createElement(t.strong,null,"Advantages"),":"),"\n",i.createElement(t.ul,null,"\n",i.createElement(t.li,null,"Significant reduction in computational complexity."),"\n",i.createElement(t.li,null,"Applicable to many architectures (MobileNet, Xception, etc.) for improved efficiency."),"\n"),"\n",i.createElement(t.p,null,i.createElement(t.strong,null,"Disadvantages"),":"),"\n",i.createElement(t.ul,null,"\n",i.createElement(t.li,null,"May slightly reduce accuracy compared to standard convolutions if there's insufficient capacity or suboptimal hyperparameter tuning."),"\n"),"\n",i.createElement(t.hr),"\n",i.createElement(t.h2,{id:"dilated-convolutions",style:{position:"relative"}},i.createElement(t.a,{href:"#dilated-convolutions","aria-label":"dilated convolutions permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Dilated convolutions"),"\n",i.createElement(t.p,null,"Dilated (or atrous) convolutions introduce spacing between the kernel elements, effectively expanding the receptive field without increasing the number of parameters. Instead of sampling adjacent pixels, a dilated convolution samples pixels or feature map values at intervals. Formally, a dilated convolution for dilation rate ",i.createElement(o.A,{text:"\\(r\\)"})," is:"),"\n",i.createElement(o.A,{text:"\\[\n(\\text{DilatedConv}(I, K, r))(x, y) = \\sum_{a=-\\alpha}^{\\alpha} \\sum_{b=-\\beta}^{\\beta} I(x+ra, y+rb)\\,K(a, b).\n\\]"}),"\n",i.createElement(t.p,null,"When ",i.createElement(o.A,{text:"\\(r = 1\\)"}),", it's a standard convolution. Larger values of ",i.createElement(o.A,{text:"\\(r\\)"})," expand the receptive field exponentially, allowing the network to capture global context in fewer layers. This approach is popular in semantic segmentation networks, such as DeepLab, which rely on wide receptive fields to capture object contexts in images without resorting to large downsampling or large kernel sizes."),"\n",i.createElement(t.p,null,i.createElement(t.strong,null,"Advantages"),":"),"\n",i.createElement(t.ul,null,"\n",i.createElement(t.li,null,"Expands receptive field without extra parameters or pooling."),"\n",i.createElement(t.li,null,"Preserves spatial resolution better than large pooling."),"\n"),"\n",i.createElement(t.p,null,i.createElement(t.strong,null,"Disadvantages"),":"),"\n",i.createElement(t.ul,null,"\n",i.createElement(t.li,null,"Introduces grid artifacts if not carefully designed."),"\n",i.createElement(t.li,null,"May require careful combination with other components (like multi-scale features) for best results."),"\n"),"\n",i.createElement(t.hr),"\n",i.createElement(t.h2,{id:"grouped-convolutions",style:{position:"relative"}},i.createElement(t.a,{href:"#grouped-convolutions","aria-label":"grouped convolutions permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Grouped convolutions"),"\n",i.createElement(t.p,null,"Grouped convolutions, used notably in AlexNet (due to GPU memory constraints) and in ResNeXt (a variant of ResNet), split the input channels into groups and apply convolution within each group. Concretely, if you have ",i.createElement(o.A,{text:"\\(M\\)"})," input channels and want ",i.createElement(o.A,{text:"\\(g\\)"})," groups, each group would handle ",i.createElement(o.A,{text:"\\(M / g\\)"})," channels independently. The outputs of each group are concatenated along the channel dimension."),"\n",i.createElement(t.p,null,"In a standard convolution, the cost is ",i.createElement(o.A,{text:"\\(O(M \\times N \\times D_k^2 \\times D_f^2)\\)"}),". With grouped convolution:"),"\n",i.createElement(o.A,{text:"\\[\n\\text{Cost} = g \\times O\\left(\\frac{M}{g} \\times \\frac{N}{g} \\times D_k^2 \\times D_f^2\\right) = \\frac{MN}{g} D_k^2 D_f^2.\n\\]"}),"\n",i.createElement(t.p,null,"Hence, grouping can reduce computational complexity when ",i.createElement(o.A,{text:"\\(g\\)"})," > 1. However, if ",i.createElement(o.A,{text:"\\(g\\)"})," is too large relative to ",i.createElement(o.A,{text:"\\(M\\)"})," or ",i.createElement(o.A,{text:"\\(N\\)"}),', it might hamper feature fusion across different channel groups, potentially reducing accuracy unless carefully managed. ResNeXt (Xie and gang, CVPR 2017) used grouped convolutions with the idea of increasing the "cardinality" (the number of groups) as an additional dimension of network design, parallel to depth and width.'),"\n",i.createElement(t.p,null,i.createElement(t.strong,null,"Advantages"),":"),"\n",i.createElement(t.ul,null,"\n",i.createElement(t.li,null,"Reduced computational and memory cost compared to full convolutions if used appropriately."),"\n",i.createElement(t.li,null,"Allows a form of parallel feature extraction in separate channel groups."),"\n"),"\n",i.createElement(t.p,null,i.createElement(t.strong,null,"Disadvantages"),":"),"\n",i.createElement(t.ul,null,"\n",i.createElement(t.li,null,"Potentially reduces representational power if the grouping is not balanced."),"\n",i.createElement(t.li,null,"More complex design decisions: how many groups to use, interplay with the overall network architecture."),"\n"),"\n",i.createElement(t.hr),"\n",i.createElement(t.h2,{id:"deployment-and-optimization",style:{position:"relative"}},i.createElement(t.a,{href:"#deployment-and-optimization","aria-label":"deployment and optimization permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Deployment and optimization"),"\n",i.createElement(t.p,null,"After designing or choosing a CNN architecture — be it something classic like LeNet, AlexNet, or VGGNet, or more modern like MobileNet with depthwise separable convolutions — the next big challenge is ",i.createElement(t.strong,null,"deployment and optimization"),". This includes everything from compressing the model for faster inference to scaling training across multiple machines or specialized hardware."),"\n",i.createElement(t.h3,{id:"model-compression-pruning-quantization",style:{position:"relative"}},i.createElement(t.a,{href:"#model-compression-pruning-quantization","aria-label":"model compression pruning quantization permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Model compression (pruning, quantization)"),"\n",i.createElement(t.p,null,i.createElement(t.strong,null,"Model pruning"),": Involves removing weights that are deemed insignificant. Techniques like ",i.createElement(t.strong,null,"magnitude-based pruning")," remove weights below a certain threshold, while more advanced methods might consider the sensitivity of each layer or channel. Pruning can reduce model size and improve inference speed, especially if the pruning pattern is hardware-friendly (structured pruning)."),"\n",i.createElement(t.p,null,i.createElement(t.strong,null,"Quantization"),": Instead of using 32-bit floating-point weights, you can quantize parameters (and sometimes activations) to 16-bit, 8-bit, or even lower-precision formats. In an 8-bit quantized model, weights are stored and computed with 8 bits instead of 32 bits. This can yield a 4x reduction in model size and speed up inference on devices that support integer arithmetic acceleration. However, quantization sometimes introduces accuracy degradation if not carefully calibrated, and certain layers might be more sensitive to lower precision."),"\n",i.createElement(t.p,null,i.createElement(t.strong,null,"Knowledge distillation"),": Another relevant compression technique is ",i.createElement(t.strong,null,"knowledge distillation"),', where you train a smaller "student" model to mimic the outputs of a larger "teacher" model, encouraging the student to learn the teacher\'s softer distribution of outputs. This method can yield a more compact student model that approaches the accuracy of the teacher.'),"\n",i.createElement(t.h3,{id:"gputpu-acceleration",style:{position:"relative"}},i.createElement(t.a,{href:"#gputpu-acceleration","aria-label":"gputpu acceleration permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"GPU/TPU acceleration"),"\n",i.createElement(t.p,null,"Graphics Processing Units (GPUs) have become the mainstay of training deep neural networks due to their highly parallel architecture, which handles matrix and vector computations efficiently. When scaling beyond a single GPU, you might distribute computations across multiple GPUs in a single machine or across multiple machines."),"\n",i.createElement(t.p,null,"Tensor Processing Units (TPUs), developed by Google, are specialized ASICs designed to accelerate TensorFlow computations, particularly for large-scale matrix multiplications commonly found in neural networks. TPUs are integrated into cloud environments (like Google Cloud Platform), offering large-scale, distributed training resources."),"\n",i.createElement(t.h3,{id:"distributed-training",style:{position:"relative"}},i.createElement(t.a,{href:"#distributed-training","aria-label":"distributed training permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Distributed training"),"\n",i.createElement(t.p,null,"Distributed training can be done in multiple ways:"),"\n",i.createElement(t.ul,null,"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Data parallelism"),": Each worker holds a copy of the model, processes a different batch of data, and then gradients are averaged or reduced across workers."),"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Model parallelism"),": Different parts (layers) of the model are split across workers. This is sometimes used for extremely large models that cannot fit into a single worker's memory."),"\n",i.createElement(t.li,null,i.createElement(t.strong,null,"Pipeline parallelism"),": Splits the layers among multiple devices and processes different micro-batches in a pipeline."),"\n"),"\n",i.createElement(t.p,null,"Frameworks like TensorFlow's ",i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">tf.distribute.Strategy</code>'}}),", PyTorch's ",i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<code class="language-text">DistributedDataParallel</code>'}}),", and specialized libraries from HPC contexts can handle the complexities of synchronization, checkpointing, and fault tolerance."),"\n",i.createElement(t.h3,{id:"real-world-deployment-challenges",style:{position:"relative"}},i.createElement(t.a,{href:"#real-world-deployment-challenges","aria-label":"real world deployment challenges permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Real-world deployment challenges"),"\n",i.createElement(t.p,null,i.createElement(t.strong,null,"Latency constraints"),": Many real-time applications cannot tolerate slow inference. Models must be optimized, quantized, or pruned. Sometimes GPU or specialized hardware might be necessary."),"\n",i.createElement(t.p,null,i.createElement(t.strong,null,"Memory limitations"),": On embedded or mobile devices, memory is at a premium. Techniques like compression, partial offloading, or adopting architectures specifically designed for low memory usage (e.g., MobileNet, SqueezeNet) are crucial."),"\n",i.createElement(t.p,null,i.createElement(t.strong,null,"Scalability"),": If the application needs to handle millions of requests per day, the model might run on a cluster with load balancing."),"\n",i.createElement(t.p,null,i.createElement(t.strong,null,"Maintenance and versioning"),": Continual improvements or data updates can require re-training and re-deploying. Proper MLOps pipelines ensure seamless transitions, rollback mechanisms, and consistent performance monitoring."),"\n",i.createElement(t.p,null,i.createElement(t.strong,null,"Security"),": In adversarial ML contexts, CNNs deployed in production can be subjected to adversarial attacks. Proper security measures and robust defenses (like adversarial training or input sanitization) are relevant."),"\n",i.createElement(t.hr),"\n",i.createElement(t.h2,{id:"conclusion-for-the-article",style:{position:"relative"}},i.createElement(t.a,{href:"#conclusion-for-the-article","aria-label":"conclusion for the article permalink",className:"anchor before"},i.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg>'}})),"Conclusion for the article"),"\n",i.createElement(t.p,null,"In this article, I discussed a broad range of CNN architectures and design innovations, continuing the journey from the historical significance of LeNet, through the revolutionary advances in AlexNet and VGGNet, and arriving at more computationally efficient paradigms such as MobileNet. Along the way, we explored specialized techniques and building blocks like Network in Network, residual connections, Inception modules, depthwise separable convolutions, dilated convolutions, and grouped convolutions — each offering distinct advantages and trade-offs in terms of accuracy, parameter counts, computational cost, and architectural complexity."),"\n",i.createElement(t.p,null,"When selecting an architecture for a specific task, you'll want to consider the resource constraints of your deployment environment, the size and diversity of your dataset, and the performance metrics that matter most (e.g., accuracy, latency, memory usage). In many real-world scenarios, advanced optimization strategies like pruning, quantization, knowledge distillation, and distributed training can help you strike the right balance between model performance and practicality."),"\n",i.createElement(t.p,null,"These core CNN designs — from LeNet's simple but groundbreaking structure to MobileNet's cutting-edge efficiency — represent the foundations of modern computer vision. Mastering them can help you quickly grasp more advanced networks (e.g., ResNet, DenseNet, EfficientNet) and tackle a wide variety of tasks that extend beyond image classification, including segmentation, detection, and generative modeling. All these developments underscore a common theme: the synergy between architectural innovations, efficient implementation, and large-scale training can unlock powerful solutions that make computer vision accessible at scale."))}var c=function(e){void 0===e&&(e={});const{wrapper:t}=Object.assign({},(0,l.RP)(),e.components);return t?i.createElement(t,e,i.createElement(s,e)):s(e)};var m=n(36710),d=n(58481),u=n.n(d),h=n(36310),p=n(87245),g=n(27042),f=n(59849),v=n(5591),y=n(61122),E=n(9219),b=n(33203),w=n(95751),x=n(94328),k=n(80791),N=n(78137);const S=e=>{let{toc:t}=e;if(!t||!t.items)return null;return i.createElement("nav",{className:k.R},i.createElement("ul",null,t.items.map(((e,t)=>i.createElement("li",{key:t},i.createElement("a",{href:e.url,onClick:t=>((e,t)=>{e.preventDefault();const n=t.replace("#",""),a=document.getElementById(n);a&&a.scrollIntoView({behavior:"smooth",block:"start"})})(t,e.url)},e.title),e.items&&i.createElement(S,{toc:{items:e.items}}))))))};function _(e){let{data:{mdx:t,allMdx:r,allPostImages:o},children:s}=e;const{frontmatter:c,body:m,tableOfContents:d}=t,f=c.index,k=c.slug.split("/")[1],_=r.nodes.filter((e=>e.frontmatter.slug.includes(`/${k}/`))).sort(((e,t)=>e.frontmatter.index-t.frontmatter.index)),z=_.findIndex((e=>e.frontmatter.index===f)),A=_[z+1],C=_[z-1],H=c.slug.replace(/\/$/,""),M=/[^/]*$/.exec(H)[0],T=`posts/${k}/content/${M}/`,{0:I,1:V}=(0,i.useState)(c.flagWideLayoutByDefault),{0:L,1:D}=(0,i.useState)(!1);var G;(0,i.useEffect)((()=>{D(!0);const e=setTimeout((()=>D(!1)),340);return()=>clearTimeout(e)}),[I]),"adventures"===k?G=E.cb:"research"===k?G=E.Qh:"thoughts"===k&&(G=E.T6);const P=u()(m).replace(/import .*? from .*?;/g,"").replace(/<.*?>/g,"").replace(/\{\/\*[\s\S]*?\*\/\}/g,"").trim().split(/\s+/).length,B=function(e){if(e<=10)return"~10 min";if(e<=20)return"~20 min";if(e<=30)return"~30 min";if(e<=40)return"~40 min";if(e<=50)return"~50 min";if(e<=60)return"~1 h";const t=Math.floor(e/60),n=e%60;return n<=30?`~${t}${n>0?".5":""} h`:`~${t+1} h`}(Math.ceil(P/G)+(c.extraReadTimeMin||0)),R=[{flag:c.flagDraft,component:()=>Promise.all([n.e(3231),n.e(8809)]).then(n.bind(n,28809))},{flag:c.flagMindfuckery,component:()=>Promise.all([n.e(3231),n.e(2471)]).then(n.bind(n,67709))},{flag:c.flagRewrite,component:()=>Promise.all([n.e(3231),n.e(6764)]).then(n.bind(n,62002))},{flag:c.flagOffensive,component:()=>Promise.all([n.e(3231),n.e(2443)]).then(n.bind(n,17681))},{flag:c.flagProfane,component:()=>Promise.all([n.e(3231),n.e(8048)]).then(n.bind(n,53286))},{flag:c.flagMultilingual,component:()=>Promise.all([n.e(3231),n.e(4069)]).then(n.bind(n,78831))},{flag:c.flagUnreliably,component:()=>Promise.all([n.e(3231),n.e(3417)]).then(n.bind(n,8179))},{flag:c.flagPolitical,component:()=>Promise.all([n.e(3231),n.e(5195)]).then(n.bind(n,30433))},{flag:c.flagCognitohazard,component:()=>Promise.all([n.e(3231),n.e(3175)]).then(n.bind(n,8413))},{flag:c.flagHidden,component:()=>Promise.all([n.e(3231),n.e(9556)]).then(n.bind(n,14794))}],{0:U,1:q}=(0,i.useState)([]);return(0,i.useEffect)((()=>{R.forEach((e=>{let{flag:t,component:n}=e;t&&n().then((e=>{q((t=>[].concat((0,a.A)(t),[e.default])))}))}))}),[]),i.createElement(g.P.div,{initial:{opacity:0},animate:{opacity:1},exit:{opacity:0},transition:{duration:.15}},i.createElement(v.A,{postNumber:c.index,date:c.date,updated:c.updated,readTime:B,difficulty:c.difficultyLevel,title:c.title,desc:c.desc,banner:c.banner,section:k,postKey:M,isMindfuckery:c.flagMindfuckery,mainTag:c.mainTag}),i.createElement("div",{style:{display:"flex",justifyContent:"flex-end",flexWrap:"wrap",maxWidth:"75%",marginLeft:"auto",paddingRight:"1vw",marginTop:"-6vh",marginBottom:"4vh"}},c.otherTags.map(((e,t)=>i.createElement("span",{key:t,className:`noselect ${N.MW}`,style:{margin:"0 5px 5px 0"}},e)))),i.createElement("div",{class:"postBody"},i.createElement(S,{toc:d})),i.createElement("br"),i.createElement("div",{style:{margin:"0 10% -2vh 30%",textAlign:"right"}},i.createElement(g.P.button,{class:"noselect",className:x.pb,id:x.xG,onClick:()=>{V(!I)},whileTap:{scale:.93}},i.createElement(g.P.div,{className:w.DJ,key:I,initial:{opacity:0},animate:{opacity:1},exit:{opacity:0},transition:{duration:.3,ease:"easeInOut"}},I?"Switch to default layout":"Switch to wide layout"))),i.createElement("br"),i.createElement("div",{class:"postBody",style:{margin:I?"0 -14%":"",maxWidth:I?"200%":"",transition:"margin 1s ease, max-width 1s ease, padding 1s ease"}},i.createElement("div",{className:`${x.P_} ${L?x.Xn:x.qG}`},U.map(((e,t)=>i.createElement(e,{key:t}))),c.indexCourse?i.createElement(b.A,{index:c.indexCourse,category:c.courseCategoryName}):"",i.createElement(h.Z.Provider,{value:{images:o.nodes,basePath:T.replace(/\/$/,"")+"/"}},i.createElement(l.xA,{components:{Image:p.A}},s)))),i.createElement(y.A,{nextPost:A,lastPost:C,keyCurrent:M,section:k}))}function z(e){return i.createElement(_,e,i.createElement(c,e))}function A(e){var t,n,a,l,r;let{data:o}=e;const{frontmatter:s}=o.mdx,c=s.titleSEO||s.title,d=s.titleOG||c,u=s.titleTwitter||c,h=s.descSEO||s.desc,p=s.descOG||h,g=s.descTwitter||h,v=s.schemaType||"BlogPosting",y=s.keywordsSEO,E=s.date,b=s.updated||E,w=s.imageOG||(null===(t=s.banner)||void 0===t||null===(n=t.childImageSharp)||void 0===n||null===(a=n.gatsbyImageData)||void 0===a||null===(l=a.images)||void 0===l||null===(r=l.fallback)||void 0===r?void 0:r.src),x=s.imageAltOG||p,k=s.imageTwitter||w,N=s.imageAltTwitter||g,S=s.canonicalURL,_=s.flagHidden||!1,z=s.mainTag||"Posts",A=s.slug.split("/")[1]||"posts",{siteUrl:C}=(0,m.Q)(),H={"@context":"https://schema.org","@type":"BreadcrumbList",itemListElement:[{"@type":"ListItem",position:1,name:"Home",item:C},{"@type":"ListItem",position:2,name:z,item:`${C}/${s.slug.split("/")[1]}`},{"@type":"ListItem",position:3,name:c,item:`${C}${s.slug}`}]};return i.createElement(f.A,{title:c+" - avrtt.blog",titleOG:d,titleTwitter:u,description:h,descriptionOG:p,descriptionTwitter:g,schemaType:v,keywords:y,datePublished:E,dateModified:b,imageOG:w,imageAltOG:x,imageTwitter:k,imageAltTwitter:N,canonicalUrl:S,flagHidden:_,mainTag:z,section:A,type:"article"},i.createElement("script",{type:"application/ld+json"},JSON.stringify(H)))}},96098:function(e,t,n){var a=n(96540),l=n(7978);t.A=e=>{let{text:t}=e;return a.createElement(l.A,null,t)}}}]);
//# sourceMappingURL=component---src-templates-post-js-content-file-path-src-pages-posts-research-cnn-architecture-2-mdx-a325be1b9dc9ebec1e16.js.map